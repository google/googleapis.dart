/// Shared types to minimize the package size. Do not use directly.
@core.Deprecated(
  'Avoid importing this library. '
  'Use the members defined in the target API library instead.',
)
library;

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: doc_directive_unknown
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

import 'dart:convert' as convert;
import 'dart:core' as core;

/// Used by:
///
/// - speech:v1 : ABNFGrammar
/// - speech:v1p1beta1 : ABNFGrammar
class $ABNFGrammar {
  /// All declarations and rules of an ABNF grammar broken up into multiple
  /// strings that will end up concatenated.
  core.List<core.String>? abnfStrings;

  $ABNFGrammar({this.abnfStrings});

  $ABNFGrammar.fromJson(core.Map json_)
    : this(
        abnfStrings:
            (json_['abnfStrings'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (abnfStrings != null) 'abnfStrings': abnfStrings!,
  };
}

/// Used by:
///
/// - redis:v1 : AOFConfig
/// - redis:v1beta1 : AOFConfig
class $AOFConfig {
  /// fsync configuration.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "APPEND_FSYNC_UNSPECIFIED" : Not set. Default: EVERYSEC
  /// - "NO" : Never fsync. Normally Linux will flush data every 30 seconds with
  /// this configuration, but it's up to the kernel's exact tuning.
  /// - "EVERYSEC" : fsync every second. Fast enough, and you may lose 1 second
  /// of data if there is a disaster
  /// - "ALWAYS" : fsync every time new write commands are appended to the AOF.
  /// It has the best data loss protection at the cost of performance
  core.String? appendFsync;

  $AOFConfig({this.appendFsync});

  $AOFConfig.fromJson(core.Map json_)
    : this(appendFsync: json_['appendFsync'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (appendFsync != null) 'appendFsync': appendFsync!,
  };
}

/// Used by:
///
/// - compute:alpha : AWSV4Signature
/// - compute:beta : AWSV4Signature
/// - compute:v1 : AWSV4Signature
class $AWSV4Signature {
  /// The access key used for s3 bucket authentication.
  ///
  /// Required for updating or creating a backend that uses AWS v4 signature
  /// authentication, but will not be returned as part of the configuration when
  /// queried with a REST API GET request. @InputOnly
  core.String? accessKey;

  /// The identifier of an access key used for s3 bucket authentication.
  core.String? accessKeyId;

  /// The optional version identifier for the access key.
  ///
  /// You can use this to keep track of different iterations of your access key.
  core.String? accessKeyVersion;

  /// The name of the cloud region of your origin.
  ///
  /// This is a free-form field with the name of the region your cloud uses to
  /// host your origin. For example, "us-east-1" for AWS or "us-ashburn-1" for
  /// OCI.
  core.String? originRegion;

  $AWSV4Signature({
    this.accessKey,
    this.accessKeyId,
    this.accessKeyVersion,
    this.originRegion,
  });

  $AWSV4Signature.fromJson(core.Map json_)
    : this(
        accessKey: json_['accessKey'] as core.String?,
        accessKeyId: json_['accessKeyId'] as core.String?,
        accessKeyVersion: json_['accessKeyVersion'] as core.String?,
        originRegion: json_['originRegion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessKey != null) 'accessKey': accessKey!,
    if (accessKeyId != null) 'accessKeyId': accessKeyId!,
    if (accessKeyVersion != null) 'accessKeyVersion': accessKeyVersion!,
    if (originRegion != null) 'originRegion': originRegion!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : AbortInfo
/// - networkmanagement:v1beta1 : AbortInfo
class $AbortInfo {
  /// Causes that the analysis is aborted.
  /// Possible string values are:
  /// - "CAUSE_UNSPECIFIED" : Cause is unspecified.
  /// - "UNKNOWN_NETWORK" : Aborted due to unknown network. Deprecated, not used
  /// in the new tests.
  /// - "UNKNOWN_PROJECT" : Aborted because no project information can be
  /// derived from the test input. Deprecated, not used in the new tests.
  /// - "NO_EXTERNAL_IP" : Aborted because traffic is sent from a public IP to
  /// an instance without an external IP. Deprecated, not used in the new tests.
  /// - "UNINTENDED_DESTINATION" : Aborted because none of the traces matches
  /// destination information specified in the input test request. Deprecated,
  /// not used in the new tests.
  /// - "SOURCE_ENDPOINT_NOT_FOUND" : Aborted because the source endpoint could
  /// not be found. Deprecated, not used in the new tests.
  /// - "MISMATCHED_SOURCE_NETWORK" : Aborted because the source network does
  /// not match the source endpoint. Deprecated, not used in the new tests.
  /// - "DESTINATION_ENDPOINT_NOT_FOUND" : Aborted because the destination
  /// endpoint could not be found. Deprecated, not used in the new tests.
  /// - "MISMATCHED_DESTINATION_NETWORK" : Aborted because the destination
  /// network does not match the destination endpoint. Deprecated, not used in
  /// the new tests.
  /// - "UNKNOWN_IP" : Aborted because no endpoint with the packet's destination
  /// IP address is found.
  /// - "GOOGLE_MANAGED_SERVICE_UNKNOWN_IP" : Aborted because no endpoint with
  /// the packet's destination IP is found in the Google-managed project.
  /// - "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK" : Aborted because the source
  /// IP address doesn't belong to any of the subnets of the source VPC network.
  /// - "PERMISSION_DENIED" : Aborted because user lacks permission to access
  /// all or part of the network configurations required to run the test.
  /// - "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS" : Aborted because user lacks
  /// permission to access Cloud NAT configs required to run the test.
  /// - "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS" : Aborted because user lacks
  /// permission to access Network endpoint group endpoint configs required to
  /// run the test.
  /// - "PERMISSION_DENIED_NO_CLOUD_ROUTER_CONFIGS" : Aborted because user lacks
  /// permission to access Cloud Router configs required to run the test.
  /// - "NO_SOURCE_LOCATION" : Aborted because no valid source or destination
  /// endpoint is derived from the input test request.
  /// - "INVALID_ARGUMENT" : Aborted because the source or destination endpoint
  /// specified in the request is invalid. Some examples: - The request might
  /// contain malformed resource URI, project ID, or IP address. - The request
  /// might contain inconsistent information (for example, the request might
  /// include both the instance and the network, but the instance might not have
  /// a NIC in that network).
  /// - "TRACE_TOO_LONG" : Aborted because the number of steps in the trace
  /// exceeds a certain limit. It might be caused by a routing loop.
  /// - "INTERNAL_ERROR" : Aborted due to internal server error.
  /// - "UNSUPPORTED" : Aborted because the test scenario is not supported.
  /// - "MISMATCHED_IP_VERSION" : Aborted because the source and destination
  /// resources have no common IP version.
  /// - "GKE_KONNECTIVITY_PROXY_UNSUPPORTED" : Aborted because the connection
  /// between the control plane and the node of the source cluster is initiated
  /// by the node and managed by the Konnectivity proxy.
  /// - "RESOURCE_CONFIG_NOT_FOUND" : Aborted because expected resource
  /// configuration was missing.
  /// - "VM_INSTANCE_CONFIG_NOT_FOUND" : Aborted because expected VM instance
  /// configuration was missing.
  /// - "NETWORK_CONFIG_NOT_FOUND" : Aborted because expected network
  /// configuration was missing.
  /// - "FIREWALL_CONFIG_NOT_FOUND" : Aborted because expected firewall
  /// configuration was missing.
  /// - "ROUTE_CONFIG_NOT_FOUND" : Aborted because expected route configuration
  /// was missing.
  /// - "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT" : Aborted because PSC
  /// endpoint selection for the Google-managed service is ambiguous (several
  /// PSC endpoints satisfy test input).
  /// - "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_ENDPOINT" : Aborted because endpoint
  /// selection for the Google-managed service is ambiguous (several endpoints
  /// satisfy test input).
  /// - "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED" : Aborted because tests with a
  /// PSC-based Cloud SQL instance as a source are not supported.
  /// - "SOURCE_REDIS_CLUSTER_UNSUPPORTED" : Aborted because tests with a Redis
  /// Cluster as a source are not supported.
  /// - "SOURCE_REDIS_INSTANCE_UNSUPPORTED" : Aborted because tests with a Redis
  /// Instance as a source are not supported.
  /// - "SOURCE_FORWARDING_RULE_UNSUPPORTED" : Aborted because tests with a
  /// forwarding rule as a source are not supported.
  /// - "NON_ROUTABLE_IP_ADDRESS" : Aborted because one of the endpoints is a
  /// non-routable IP address (loopback, link-local, etc).
  /// - "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT" : Aborted due to an unknown
  /// issue in the Google-managed project.
  /// - "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG" : Aborted due to an
  /// unsupported configuration of the Google-managed project.
  /// - "NO_SERVERLESS_IP_RANGES" : Aborted because the source endpoint is a
  /// Cloud Run revision with direct VPC access enabled, but there are no
  /// reserved serverless IP ranges.
  /// - "IP_VERSION_PROTOCOL_MISMATCH" : Aborted because the used protocol is
  /// not supported for the used IP version.
  core.String? cause;

  /// IP address that caused the abort.
  core.String? ipAddress;

  /// List of project IDs the user specified in the request but lacks access to.
  ///
  /// In this case, analysis is aborted with the PERMISSION_DENIED cause.
  core.List<core.String>? projectsMissingPermission;

  /// URI of the resource that caused the abort.
  core.String? resourceUri;

  $AbortInfo({
    this.cause,
    this.ipAddress,
    this.projectsMissingPermission,
    this.resourceUri,
  });

  $AbortInfo.fromJson(core.Map json_)
    : this(
        cause: json_['cause'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        projectsMissingPermission:
            (json_['projectsMissingPermission'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        resourceUri: json_['resourceUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cause != null) 'cause': cause!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (projectsMissingPermission != null)
      'projectsMissingPermission': projectsMissingPermission!,
    if (resourceUri != null) 'resourceUri': resourceUri!,
  };
}

/// Used by:
///
/// - datafusion:v1 : Accelerator
/// - datafusion:v1beta1 : Accelerator
class $Accelerator00 {
  /// The type of an accelator for a Cloud Data Fusion instance.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ACCELERATOR_TYPE_UNSPECIFIED" : Default value, if unspecified.
  /// - "CDC" : Change Data Capture accelerator for Cloud Data Fusion.
  /// - "HEALTHCARE" : Reserved for internal use.
  /// - "CCAI_INSIGHTS" : Contact Center AI Insights This accelerator is used to
  /// enable import and export pipelines custom built to streamline CCAI
  /// Insights processing.
  /// - "CLOUDSEARCH" : Reserved for internal use.
  core.String? acceleratorType;

  /// The state of the accelerator.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value, do not use.
  /// - "ENABLED" : Indicates that the accelerator is enabled and available to
  /// use.
  /// - "DISABLED" : Indicates that the accelerator is disabled and not
  /// available to use.
  /// - "UNKNOWN" : Indicates that accelerator state is currently unknown.
  /// Requests for enable, disable could be retried while in this state.
  core.String? state;

  $Accelerator00({this.acceleratorType, this.state});

  $Accelerator00.fromJson(core.Map json_)
    : this(
        acceleratorType: json_['acceleratorType'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorType != null) 'acceleratorType': acceleratorType!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - workstations:v1 : Accelerator
/// - workstations:v1beta : Accelerator
class $Accelerator01 {
  /// Number of accelerator cards exposed to the instance.
  ///
  /// Optional.
  core.int? count;

  /// Type of accelerator resource to attach to the instance, for example,
  /// `"nvidia-tesla-p100"`.
  ///
  /// Optional.
  core.String? type;

  $Accelerator01({this.count, this.type});

  $Accelerator01.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.int?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : AcceleratorConfig
/// - compute:beta : AcceleratorConfig
/// - compute:v1 : AcceleratorConfig
class $AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int? acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance.
  ///
  /// For example:
  /// projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
  /// If you are creating an instance template, specify only the accelerator
  /// name. See GPUs on Compute Engine for a full list of accelerator types.
  core.String? acceleratorType;

  $AcceleratorConfig({this.acceleratorCount, this.acceleratorType});

  $AcceleratorConfig.fromJson(core.Map json_)
    : this(
        acceleratorCount: json_['acceleratorCount'] as core.int?,
        acceleratorType: json_['acceleratorType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
    if (acceleratorType != null) 'acceleratorType': acceleratorType!,
  };
}

/// Used by:
///
/// - tpu:v1 : AcceleratorType
/// - tpu:v1alpha1 : AcceleratorType
class $AcceleratorType {
  /// The resource name.
  core.String? name;

  /// the accelerator type.
  core.String? type;

  $AcceleratorType({this.name, this.type});

  $AcceleratorType.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : AcceptProposalRequest
/// - authorizedbuyersmarketplace:v1 : AcceptProposalRequest
/// - authorizedbuyersmarketplace:v1alpha : AcceptProposalRequest
class $AcceptProposalRequest {
  /// The last known client revision number of the proposal.
  core.String? proposalRevision;

  $AcceptProposalRequest({this.proposalRevision});

  $AcceptProposalRequest.fromJson(core.Map json_)
    : this(proposalRevision: json_['proposalRevision'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (proposalRevision != null) 'proposalRevision': proposalRevision!,
  };
}

/// Used by:
///
/// - compute:beta : AccessConfig
/// - compute:v1 : AccessConfig
class $AccessConfig00 {
  /// Applies to ipv6AccessConfigs only.
  ///
  /// The first IPv6 address of the external IPv6 range associated with this
  /// instance, prefix length is stored in externalIpv6PrefixLength in
  /// ipv6AccessConfig. To use a static external IP address, it must be unused
  /// and in the same region as the instance's zone. If not specified, Google
  /// Cloud will automatically assign an external IPv6 address from the
  /// instance's subnetwork.
  core.String? externalIpv6;

  /// Applies to ipv6AccessConfigs only.
  ///
  /// The prefix length of the external IPv6 range.
  core.int? externalIpv6PrefixLength;

  /// Type of the resource.
  ///
  /// Always compute#accessConfig for access configs.
  ///
  /// Output only.
  core.String? kind;

  /// The name of this access configuration.
  ///
  /// In accessConfigs (IPv4), the default and recommended name is External NAT,
  /// but you can use any arbitrary string, such as My external IP or Network
  /// Access. In ipv6AccessConfigs, the recommend name is External IPv6.
  core.String? name;

  /// Applies to accessConfigs (IPv4) only.
  ///
  /// An external IP address associated with this instance. Specify an unused
  /// static external IP address available to the project or leave this field
  /// undefined to use an IP from a shared ephemeral IP address pool. If you
  /// specify a static external IP address, it must live in the same region as
  /// the zone of the instance.
  core.String? natIP;

  /// This signifies the networking tier used for configuring this access
  /// configuration and can only take the following values: PREMIUM, STANDARD.
  ///
  /// If an AccessConfig is specified without a valid external IP address, an
  /// ephemeral IP will be created with this networkTier. If an AccessConfig
  /// with a valid external IP address is specified, it must match that of the
  /// networkTier associated with the Address resource owning that IP.
  /// Possible string values are:
  /// - "FIXED_STANDARD" : Public internet quality with fixed bandwidth.
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  /// - "STANDARD_OVERRIDES_FIXED_STANDARD" : (Output only) Temporary tier for
  /// FIXED_STANDARD when fixed standard tier is expired or not configured.
  core.String? networkTier;

  /// The DNS domain name for the public PTR record.
  ///
  /// You can set this field only if the `setPublicPtr` field is enabled in
  /// accessConfig. If this field is unspecified in ipv6AccessConfig, a default
  /// PTR record will be created for first IP in associated external IPv6 range.
  core.String? publicPtrDomainName;

  /// The resource URL for the security policy associated with this access
  /// config.
  core.String? securityPolicy;

  /// Specifies whether a public DNS 'PTR' record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  ///
  /// This field is not used in ipv6AccessConfig. A default PTR record will be
  /// created if the VM has external IPv6 range associated.
  core.bool? setPublicPtr;

  /// The type of configuration.
  ///
  /// In accessConfigs (IPv4), the default and only option is ONE_TO_ONE_NAT. In
  /// ipv6AccessConfigs, the default and only option is DIRECT_IPV6.
  /// Possible string values are:
  /// - "DIRECT_IPV6"
  /// - "ONE_TO_ONE_NAT"
  core.String? type;

  $AccessConfig00({
    this.externalIpv6,
    this.externalIpv6PrefixLength,
    this.kind,
    this.name,
    this.natIP,
    this.networkTier,
    this.publicPtrDomainName,
    this.securityPolicy,
    this.setPublicPtr,
    this.type,
  });

  $AccessConfig00.fromJson(core.Map json_)
    : this(
        externalIpv6: json_['externalIpv6'] as core.String?,
        externalIpv6PrefixLength:
            json_['externalIpv6PrefixLength'] as core.int?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        natIP: json_['natIP'] as core.String?,
        networkTier: json_['networkTier'] as core.String?,
        publicPtrDomainName: json_['publicPtrDomainName'] as core.String?,
        securityPolicy: json_['securityPolicy'] as core.String?,
        setPublicPtr: json_['setPublicPtr'] as core.bool?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalIpv6 != null) 'externalIpv6': externalIpv6!,
    if (externalIpv6PrefixLength != null)
      'externalIpv6PrefixLength': externalIpv6PrefixLength!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (natIP != null) 'natIP': natIP!,
    if (networkTier != null) 'networkTier': networkTier!,
    if (publicPtrDomainName != null)
      'publicPtrDomainName': publicPtrDomainName!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
    if (setPublicPtr != null) 'setPublicPtr': setPublicPtr!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - tpu:v2 : AccessConfig
/// - tpu:v2alpha1 : AccessConfig
class $AccessConfig01 {
  /// An external IP address associated with the TPU worker.
  ///
  /// Output only.
  core.String? externalIp;

  $AccessConfig01({this.externalIp});

  $AccessConfig01.fromJson(core.Map json_)
    : this(externalIp: json_['externalIp'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalIp != null) 'externalIp': externalIp!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessDateRange
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessDateRange
class $AccessDateRange {
  /// The inclusive end date for the query in the format `YYYY-MM-DD`.
  ///
  /// Cannot be before `startDate`. The format `NdaysAgo`, `yesterday`, or
  /// `today` is also accepted, and in that case, the date is inferred based on
  /// the current time in the request's time zone.
  core.String? endDate;

  /// The inclusive start date for the query in the format `YYYY-MM-DD`.
  ///
  /// Cannot be after `endDate`. The format `NdaysAgo`, `yesterday`, or `today`
  /// is also accepted, and in that case, the date is inferred based on the
  /// current time in the request's time zone.
  core.String? startDate;

  $AccessDateRange({this.endDate, this.startDate});

  $AccessDateRange.fromJson(core.Map json_)
    : this(
        endDate: json_['endDate'] as core.String?,
        startDate: json_['startDate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endDate != null) 'endDate': endDate!,
    if (startDate != null) 'startDate': startDate!,
  };
}

/// Used by:
///
/// - healthcare:v1 : AccessDeterminationLogConfig
/// - healthcare:v1beta1 : AccessDeterminationLogConfig
class $AccessDeterminationLogConfig {
  /// Controls the amount of detail to include as part of the audit logs.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LOG_LEVEL_UNSPECIFIED" : No log level specified. This value is unused.
  /// - "DISABLED" : No additional consent-related logging is added to audit
  /// logs.
  /// - "MINIMUM" : The following information is included: * One of the
  /// following
  /// \[`consentMode`\](https://cloud.google.com/healthcare-api/docs/fhir-consent#audit_logs)
  /// fields: (`off`|`emptyScope`|`enforced`|`btg`|`bypass`). * The accessor's
  /// request headers * The `log_level` of the AccessDeterminationLogConfig *
  /// The final consent evaluation (`PERMIT`, `DENY`, or `NO_CONSENT`) * A
  /// human-readable summary of the evaluation
  /// - "VERBOSE" : Includes `MINIMUM` and, for each resource owner, returns: *
  /// The resource owner's name * Most specific part of the `X-Consent-Scope`
  /// resulting in consensual determination * Timestamp of the applied
  /// enforcement leading to the decision * Enforcement version at the time the
  /// applicable consents were applied * The Consent resource name * The
  /// timestamp of the Consent resource used for enforcement * Policy type
  /// (`PATIENT` or `ADMIN`) Note that this mode adds some overhead to CRUD
  /// operations.
  core.String? logLevel;

  $AccessDeterminationLogConfig({this.logLevel});

  $AccessDeterminationLogConfig.fromJson(core.Map json_)
    : this(logLevel: json_['logLevel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (logLevel != null) 'logLevel': logLevel!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessDimension
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessDimension
class $AccessDimension {
  /// The API name of the dimension.
  ///
  /// See
  /// [Data Access Schema](https://developers.google.com/analytics/devguides/config/admin/v1/access-api-schema)
  /// for the list of dimensions supported in this API. Dimensions are
  /// referenced by name in `dimensionFilter` and `orderBys`.
  core.String? dimensionName;

  $AccessDimension({this.dimensionName});

  $AccessDimension.fromJson(core.Map json_)
    : this(dimensionName: json_['dimensionName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensionName != null) 'dimensionName': dimensionName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessDimensionHeader
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessDimensionHeader
class $AccessDimensionHeader {
  /// The dimension's name; for example 'userEmail'.
  core.String? dimensionName;

  $AccessDimensionHeader({this.dimensionName});

  $AccessDimensionHeader.fromJson(core.Map json_)
    : this(dimensionName: json_['dimensionName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensionName != null) 'dimensionName': dimensionName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessDimensionValue
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessDimensionValue
class $AccessDimensionValue {
  /// The dimension value.
  ///
  /// For example, this value may be 'France' for the 'country' dimension.
  core.String? value;

  $AccessDimensionValue({this.value});

  $AccessDimensionValue.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AccessKeyCredentials
/// - vmmigration:v1alpha1 : AccessKeyCredentials
class $AccessKeyCredentials {
  /// AWS access key ID.
  core.String? accessKeyId;

  /// Input only.
  ///
  /// AWS secret access key.
  core.String? secretAccessKey;

  /// Input only.
  ///
  /// AWS session token. Used only when AWS security token service (STS) is
  /// responsible for creating the temporary credentials.
  core.String? sessionToken;

  $AccessKeyCredentials({
    this.accessKeyId,
    this.secretAccessKey,
    this.sessionToken,
  });

  $AccessKeyCredentials.fromJson(core.Map json_)
    : this(
        accessKeyId: json_['accessKeyId'] as core.String?,
        secretAccessKey: json_['secretAccessKey'] as core.String?,
        sessionToken: json_['sessionToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessKeyId != null) 'accessKeyId': accessKeyId!,
    if (secretAccessKey != null) 'secretAccessKey': secretAccessKey!,
    if (sessionToken != null) 'sessionToken': sessionToken!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessMetric
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessMetric
class $AccessMetric {
  /// The API name of the metric.
  ///
  /// See
  /// [Data Access Schema](https://developers.google.com/analytics/devguides/config/admin/v1/access-api-schema)
  /// for the list of metrics supported in this API. Metrics are referenced by
  /// name in `metricFilter` & `orderBys`.
  core.String? metricName;

  $AccessMetric({this.metricName});

  $AccessMetric.fromJson(core.Map json_)
    : this(metricName: json_['metricName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricName != null) 'metricName': metricName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessMetricHeader
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessMetricHeader
class $AccessMetricHeader {
  /// The metric's name; for example 'accessCount'.
  core.String? metricName;

  $AccessMetricHeader({this.metricName});

  $AccessMetricHeader.fromJson(core.Map json_)
    : this(metricName: json_['metricName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricName != null) 'metricName': metricName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessMetricValue
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessMetricValue
class $AccessMetricValue {
  /// The measurement value.
  ///
  /// For example, this value may be '13'.
  core.String? value;

  $AccessMetricValue({this.value});

  $AccessMetricValue.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : AccessPolicy
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1AccessPolicy
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1AccessPolicy
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1AccessPolicy
class $AccessPolicy {
  /// An opaque identifier for the current version of the `AccessPolicy`.
  ///
  /// This will always be a strongly validated etag, meaning that two Access
  /// Policies will be identical if and only if their etags are identical.
  /// Clients should not expect this to be in any specific format.
  ///
  /// Output only.
  core.String? etag;

  /// Identifier.
  ///
  /// Resource name of the `AccessPolicy`. Format:
  /// `accessPolicies/{access_policy}`
  ///
  /// Output only.
  core.String? name;

  /// The parent of this `AccessPolicy` in the Cloud Resource Hierarchy.
  ///
  /// Currently immutable once created. Format:
  /// `organizations/{organization_id}`
  ///
  /// Required.
  core.String? parent;

  /// The scopes of the AccessPolicy.
  ///
  /// Scopes define which resources a policy can restrict and where its
  /// resources can be referenced. For example, policy A with
  /// `scopes=["folders/123"]` has the following behavior: - ServicePerimeter
  /// can only restrict projects within `folders/123`. - ServicePerimeter within
  /// policy A can only reference access levels defined within policy A. - Only
  /// one policy can include a given scope; thus, attempting to create a second
  /// policy which includes `folders/123` will result in an error. If no scopes
  /// are provided, then any resource within the organization can be restricted.
  /// Scopes cannot be modified after a policy is created. Policies can only
  /// have a single scope. Format: list of `folders/{folder_number}` or
  /// `projects/{project_number}`
  core.List<core.String>? scopes;

  /// Human readable title.
  ///
  /// Does not affect behavior.
  ///
  /// Required.
  core.String? title;

  $AccessPolicy({this.etag, this.name, this.parent, this.scopes, this.title});

  $AccessPolicy.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        name: json_['name'] as core.String?,
        parent: json_['parent'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (name != null) 'name': name!,
    if (parent != null) 'parent': parent!,
    if (scopes != null) 'scopes': scopes!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : AccessReason
/// - cloudcontrolspartner:v1beta : AccessReason
class $AccessReason {
  /// More detail about certain reason types.
  ///
  /// See comments for each type above.
  core.String? detail;

  /// Type of access justification.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value for proto, shouldn't be used.
  /// - "CUSTOMER_INITIATED_SUPPORT" : Customer made a request or raised an
  /// issue that required the principal to access customer data. `detail` is of
  /// the form ("#####" is the issue ID): - "Feedback Report: #####" - "Case
  /// Number: #####" - "Case ID: #####" - "E-PIN Reference: #####" -
  /// "Google-#####" - "T-#####"
  /// - "GOOGLE_INITIATED_SERVICE" : The principal accessed customer data in
  /// order to diagnose or resolve a suspected issue in services. Often this
  /// access is used to confirm that customers are not affected by a suspected
  /// service issue or to remediate a reversible system issue.
  /// - "GOOGLE_INITIATED_REVIEW" : Google initiated service for security,
  /// fraud, abuse, or compliance purposes.
  /// - "THIRD_PARTY_DATA_REQUEST" : The principal was compelled to access
  /// customer data in order to respond to a legal third party data request or
  /// process, including legal processes from customers themselves.
  /// - "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT" : The principal accessed customer
  /// data in order to diagnose or resolve a suspected issue in services or a
  /// known outage.
  /// - "CLOUD_INITIATED_ACCESS" : Similar to 'GOOGLE_INITIATED_SERVICE' or
  /// 'GOOGLE_INITIATED_REVIEW', but with universe agnostic naming. The
  /// principal accessed customer data in order to diagnose or resolve a
  /// suspected issue in services or a known outage, or for security, fraud,
  /// abuse, or compliance review purposes.
  core.String? type;

  $AccessReason({this.detail, this.type});

  $AccessReason.fromJson(core.Map json_)
    : this(
        detail: json_['detail'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (detail != null) 'detail': detail!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - policysimulator:v1 : GoogleCloudPolicysimulatorV1AccessTuple
/// - policysimulator:v1beta : GoogleCloudPolicysimulatorV1betaAccessTuple
/// - policytroubleshooter:v1 : GoogleCloudPolicytroubleshooterV1AccessTuple
class $AccessTuple {
  /// The full resource name that identifies the resource.
  ///
  /// For example,
  /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
  /// For examples of full resource names for Google Cloud services, see
  /// https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
  ///
  /// Required.
  core.String? fullResourceName;

  /// The IAM permission to check for the specified principal and resource.
  ///
  /// For a complete list of IAM permissions, see
  /// https://cloud.google.com/iam/help/permissions/reference. For a complete
  /// list of predefined IAM roles and the permissions in each role, see
  /// https://cloud.google.com/iam/help/roles/reference.
  ///
  /// Required.
  core.String? permission;

  /// The principal whose access you want to check, in the form of the email
  /// address that represents that principal.
  ///
  /// For example, `alice@example.com` or
  /// `my-service-account@my-project.iam.gserviceaccount.com`. The principal
  /// must be a Google Account or a service account. Other types of principals
  /// are not supported.
  ///
  /// Required.
  core.String? principal;

  $AccessTuple({this.fullResourceName, this.permission, this.principal});

  $AccessTuple.fromJson(core.Map json_)
    : this(
        fullResourceName: json_['fullResourceName'] as core.String?,
        permission: json_['permission'] as core.String?,
        principal: json_['principal'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fullResourceName != null) 'fullResourceName': fullResourceName!,
    if (permission != null) 'permission': permission!,
    if (principal != null) 'principal': principal!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccount
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccount
class $Account {
  /// Time when this account was originally created.
  ///
  /// Output only.
  core.String? createTime;

  /// Indicates whether this Account is soft-deleted or not.
  ///
  /// Deleted accounts are excluded from List results unless specifically
  /// requested.
  ///
  /// Output only.
  core.bool? deleted;

  /// Human-readable display name for this account.
  ///
  /// Required.
  core.String? displayName;

  /// The URI for a Google Marketing Platform organization resource.
  ///
  /// Only set when this account is connected to a GMP organization. Format:
  /// marketingplatformadmin.googleapis.com/organizations/{org_id}
  ///
  /// Output only.
  core.String? gmpOrganization;

  /// Resource name of this account.
  ///
  /// Format: accounts/{account} Example: "accounts/100"
  ///
  /// Output only.
  core.String? name;

  /// Country of business.
  ///
  /// Must be a Unicode CLDR region code.
  core.String? regionCode;

  /// Time when account payload fields were last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Account({
    this.createTime,
    this.deleted,
    this.displayName,
    this.gmpOrganization,
    this.name,
    this.regionCode,
    this.updateTime,
  });

  $Account.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        deleted: json_['deleted'] as core.bool?,
        displayName: json_['displayName'] as core.String?,
        gmpOrganization: json_['gmpOrganization'] as core.String?,
        name: json_['name'] as core.String?,
        regionCode: json_['regionCode'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (deleted != null) 'deleted': deleted!,
    if (displayName != null) 'displayName': displayName!,
    if (gmpOrganization != null) 'gmpOrganization': gmpOrganization!,
    if (name != null) 'name': name!,
    if (regionCode != null) 'regionCode': regionCode!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAcknowledgeUserDataCollectionRequest
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAcknowledgeUserDataCollectionRequest
class $AcknowledgeUserDataCollectionRequest {
  /// An acknowledgement that the caller of this method understands the terms of
  /// user data collection.
  ///
  /// This field must contain the exact value: "I acknowledge that I have the
  /// necessary privacy disclosures and rights from my end users for the
  /// collection and processing of their data, including the association of such
  /// data with the visitation information Google Analytics collects from my
  /// site and/or app property."
  ///
  /// Required.
  core.String? acknowledgement;

  $AcknowledgeUserDataCollectionRequest({this.acknowledgement});

  $AcknowledgeUserDataCollectionRequest.fromJson(core.Map json_)
    : this(acknowledgement: json_['acknowledgement'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (acknowledgement != null) 'acknowledgement': acknowledgement!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1AcknowledgeViolationRequest
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1AcknowledgeViolationRequest
class $AcknowledgeViolationRequest {
  /// Acknowledge type of specified violation.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ACKNOWLEDGE_TYPE_UNSPECIFIED" : Acknowledge type unspecified.
  /// - "SINGLE_VIOLATION" : Acknowledge only the specific violation.
  /// - "EXISTING_CHILD_RESOURCE_VIOLATIONS" : Acknowledge specified orgPolicy
  /// violation and also associated resource violations.
  core.String? acknowledgeType;

  /// Business justification explaining the need for violation acknowledgement
  ///
  /// Required.
  core.String? comment;

  /// This field is deprecated and will be removed in future version of the API.
  ///
  /// Name of the OrgPolicy which was modified with non-compliant change and
  /// resulted in this violation. Format:
  /// projects/{project_number}/policies/{constraint_name}
  /// folders/{folder_id}/policies/{constraint_name}
  /// organizations/{organization_id}/policies/{constraint_name}
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? nonCompliantOrgPolicy;

  $AcknowledgeViolationRequest({
    this.acknowledgeType,
    this.comment,
    this.nonCompliantOrgPolicy,
  });

  $AcknowledgeViolationRequest.fromJson(core.Map json_)
    : this(
        acknowledgeType: json_['acknowledgeType'] as core.String?,
        comment: json_['comment'] as core.String?,
        nonCompliantOrgPolicy: json_['nonCompliantOrgPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acknowledgeType != null) 'acknowledgeType': acknowledgeType!,
    if (comment != null) 'comment': comment!,
    if (nonCompliantOrgPolicy != null)
      'nonCompliantOrgPolicy': nonCompliantOrgPolicy!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : AclEntry
/// - sqladmin:v1beta4 : AclEntry
class $AclEntry {
  /// The time when this access control entry expires in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
  /// `2012-11-15T16:19:00.094Z`.
  core.String? expirationTime;

  /// This is always `sql#aclEntry`.
  core.String? kind;

  /// A label to identify this entry.
  ///
  /// Optional.
  core.String? name;

  /// The allowlisted value for the access control list.
  core.String? value;

  $AclEntry({this.expirationTime, this.kind, this.name, this.value});

  $AclEntry.fromJson(core.Map json_)
    : this(
        expirationTime: json_['expirationTime'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expirationTime != null) 'expirationTime': expirationTime!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - chat:v1 : ActionParameter
/// - chat:v1 : GoogleAppsCardV1ActionParameter
class $ActionParameter {
  /// The name of the parameter for the action script.
  core.String? key;

  /// The value of the parameter.
  core.String? value;

  $ActionParameter({this.key, this.value});

  $ActionParameter.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - healthcare:v1 : ActivateConsentRequest
/// - healthcare:v1beta1 : ActivateConsentRequest
class $ActivateConsentRequest {
  /// The resource name of the Consent artifact that contains documentation of
  /// the user's consent, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
  ///
  /// If the draft Consent had a Consent artifact, this Consent artifact
  /// overwrites it.
  ///
  /// Required.
  core.String? consentArtifact;

  /// Timestamp in UTC of when this Consent is considered expired.
  core.String? expireTime;

  /// The time to live for this Consent from when it is marked as active.
  core.String? ttl;

  $ActivateConsentRequest({this.consentArtifact, this.expireTime, this.ttl});

  $ActivateConsentRequest.fromJson(core.Map json_)
    : this(
        consentArtifact: json_['consentArtifact'] as core.String?,
        expireTime: json_['expireTime'] as core.String?,
        ttl: json_['ttl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consentArtifact != null) 'consentArtifact': consentArtifact!,
    if (expireTime != null) 'expireTime': expireTime!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - netapp:v1 : ActiveDirectory
/// - netapp:v1beta1 : ActiveDirectory
class $ActiveDirectory {
  /// Users to be added to the Built-in Admininstrators group.
  ///
  /// Optional.
  core.List<core.String>? administrators;

  /// If enabled, AES encryption will be enabled for SMB communication.
  core.bool? aesEncryption;

  /// Users to be added to the Built-in Backup Operator active directory group.
  ///
  /// Optional.
  core.List<core.String>? backupOperators;

  /// Create time of the active directory.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the active directory.
  core.String? description;

  /// Comma separated list of DNS server IP addresses for the Active Directory
  /// domain.
  ///
  /// Required.
  core.String? dns;

  /// Name of the Active Directory domain
  ///
  /// Required.
  core.String? domain;

  /// If enabled, traffic between the SMB server to Domain Controller (DC) will
  /// be encrypted.
  core.bool? encryptDcConnections;

  /// Name of the active directory machine.
  ///
  /// This optional parameter is used only while creating kerberos volume
  core.String? kdcHostname;

  /// KDC server IP address for the active directory machine.
  core.String? kdcIp;

  /// Labels for the active directory.
  core.Map<core.String, core.String>? labels;

  /// Specifies whether or not the LDAP traffic needs to be signed.
  core.bool? ldapSigning;

  /// Identifier.
  ///
  /// The resource name of the active directory. Format:
  /// `projects/{project_number}/locations/{location_id}/activeDirectories/{active_directory_id}`.
  core.String? name;

  /// NetBIOSPrefix is used as a prefix for SMB server name.
  ///
  /// Required.
  core.String? netBiosPrefix;

  /// If enabled, will allow access to local users and LDAP users.
  ///
  /// If access is needed for only LDAP users, it has to be disabled.
  core.bool? nfsUsersWithLdap;

  /// The Organizational Unit (OU) within the Windows Active Directory the user
  /// belongs to.
  core.String? organizationalUnit;

  /// Password of the Active Directory domain administrator.
  ///
  /// Required.
  core.String? password;

  /// Domain users to be given the SeSecurityPrivilege.
  ///
  /// Optional.
  core.List<core.String>? securityOperators;

  /// The Active Directory site the service will limit Domain Controller
  /// discovery too.
  core.String? site;

  /// The state of the AD.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Active Directory State
  /// - "CREATING" : Active Directory State is Creating
  /// - "READY" : Active Directory State is Ready
  /// - "UPDATING" : Active Directory State is Updating
  /// - "IN_USE" : Active Directory State is In use
  /// - "DELETING" : Active Directory State is Deleting
  /// - "ERROR" : Active Directory State is Error
  /// - "DIAGNOSING" : Active Directory State is Diagnosing.
  core.String? state;

  /// The state details of the Active Directory.
  ///
  /// Output only.
  core.String? stateDetails;

  /// Username of the Active Directory domain administrator.
  ///
  /// Required.
  core.String? username;

  $ActiveDirectory({
    this.administrators,
    this.aesEncryption,
    this.backupOperators,
    this.createTime,
    this.description,
    this.dns,
    this.domain,
    this.encryptDcConnections,
    this.kdcHostname,
    this.kdcIp,
    this.labels,
    this.ldapSigning,
    this.name,
    this.netBiosPrefix,
    this.nfsUsersWithLdap,
    this.organizationalUnit,
    this.password,
    this.securityOperators,
    this.site,
    this.state,
    this.stateDetails,
    this.username,
  });

  $ActiveDirectory.fromJson(core.Map json_)
    : this(
        administrators:
            (json_['administrators'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        aesEncryption: json_['aesEncryption'] as core.bool?,
        backupOperators:
            (json_['backupOperators'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        dns: json_['dns'] as core.String?,
        domain: json_['domain'] as core.String?,
        encryptDcConnections: json_['encryptDcConnections'] as core.bool?,
        kdcHostname: json_['kdcHostname'] as core.String?,
        kdcIp: json_['kdcIp'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        ldapSigning: json_['ldapSigning'] as core.bool?,
        name: json_['name'] as core.String?,
        netBiosPrefix: json_['netBiosPrefix'] as core.String?,
        nfsUsersWithLdap: json_['nfsUsersWithLdap'] as core.bool?,
        organizationalUnit: json_['organizationalUnit'] as core.String?,
        password: json_['password'] as core.String?,
        securityOperators:
            (json_['securityOperators'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        site: json_['site'] as core.String?,
        state: json_['state'] as core.String?,
        stateDetails: json_['stateDetails'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (administrators != null) 'administrators': administrators!,
    if (aesEncryption != null) 'aesEncryption': aesEncryption!,
    if (backupOperators != null) 'backupOperators': backupOperators!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (dns != null) 'dns': dns!,
    if (domain != null) 'domain': domain!,
    if (encryptDcConnections != null)
      'encryptDcConnections': encryptDcConnections!,
    if (kdcHostname != null) 'kdcHostname': kdcHostname!,
    if (kdcIp != null) 'kdcIp': kdcIp!,
    if (labels != null) 'labels': labels!,
    if (ldapSigning != null) 'ldapSigning': ldapSigning!,
    if (name != null) 'name': name!,
    if (netBiosPrefix != null) 'netBiosPrefix': netBiosPrefix!,
    if (nfsUsersWithLdap != null) 'nfsUsersWithLdap': nfsUsersWithLdap!,
    if (organizationalUnit != null) 'organizationalUnit': organizationalUnit!,
    if (password != null) 'password': password!,
    if (securityOperators != null) 'securityOperators': securityOperators!,
    if (site != null) 'site': site!,
    if (state != null) 'state': state!,
    if (stateDetails != null) 'stateDetails': stateDetails!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ActiveViewVideoViewabilityMetricConfig
/// - displayvideo:v3 : ActiveViewVideoViewabilityMetricConfig
/// - displayvideo:v4 : ActiveViewVideoViewabilityMetricConfig
class $ActiveViewVideoViewabilityMetricConfig {
  /// The display name of the custom metric.
  ///
  /// Required.
  core.String? displayName;

  /// The minimum visible video duration required (in seconds) in order for an
  /// impression to be recorded.
  ///
  /// You must specify minimum_duration, minimum_quartile or both. If both are
  /// specified, an impression meets the metric criteria if either requirement
  /// is met (whichever happens first).
  /// Possible string values are:
  /// - "VIDEO_DURATION_UNSPECIFIED" : Value is not specified or is unknown in
  /// this version.
  /// - "VIDEO_DURATION_SECONDS_NONE" : No duration value.
  /// - "VIDEO_DURATION_SECONDS_0" : 0 seconds.
  /// - "VIDEO_DURATION_SECONDS_1" : 1 second.
  /// - "VIDEO_DURATION_SECONDS_2" : 2 seconds.
  /// - "VIDEO_DURATION_SECONDS_3" : 3 seconds.
  /// - "VIDEO_DURATION_SECONDS_4" : 4 seconds.
  /// - "VIDEO_DURATION_SECONDS_5" : 5 seconds.
  /// - "VIDEO_DURATION_SECONDS_6" : 6 seconds.
  /// - "VIDEO_DURATION_SECONDS_7" : 7 seconds.
  /// - "VIDEO_DURATION_SECONDS_8" : 8 seconds.
  /// - "VIDEO_DURATION_SECONDS_9" : 9 seconds.
  /// - "VIDEO_DURATION_SECONDS_10" : 10 seconds.
  /// - "VIDEO_DURATION_SECONDS_11" : 11 seconds.
  /// - "VIDEO_DURATION_SECONDS_12" : 12 seconds.
  /// - "VIDEO_DURATION_SECONDS_13" : 13 seconds.
  /// - "VIDEO_DURATION_SECONDS_14" : 14 seconds.
  /// - "VIDEO_DURATION_SECONDS_15" : 15 seconds.
  /// - "VIDEO_DURATION_SECONDS_30" : 30 seconds.
  /// - "VIDEO_DURATION_SECONDS_45" : 45 seconds.
  /// - "VIDEO_DURATION_SECONDS_60" : 60 seconds.
  core.String? minimumDuration;

  /// The minimum visible video duration required, based on the video quartiles,
  /// in order for an impression to be recorded.
  ///
  /// You must specify minimum_duration, minimum_quartile or both. If both are
  /// specified, an impression meets the metric criteria if either requirement
  /// is met (whichever happens first).
  /// Possible string values are:
  /// - "VIDEO_DURATION_QUARTILE_UNSPECIFIED" : Value is not specified or is
  /// unknown in this version.
  /// - "VIDEO_DURATION_QUARTILE_NONE" : No quartile value.
  /// - "VIDEO_DURATION_QUARTILE_FIRST" : First quartile.
  /// - "VIDEO_DURATION_QUARTILE_SECOND" : Second quartile (midpoint).
  /// - "VIDEO_DURATION_QUARTILE_THIRD" : Third quartile.
  /// - "VIDEO_DURATION_QUARTILE_FOURTH" : Fourth quartile (completion).
  core.String? minimumQuartile;

  /// The minimum percentage of the video ad's pixels visible on the screen in
  /// order for an impression to be recorded.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VIEWABILITY_PERCENT_UNSPECIFIED" : Value is not specified or is unknown
  /// in this version.
  /// - "VIEWABILITY_PERCENT_0" : 0% viewable.
  /// - "VIEWABILITY_PERCENT_25" : 25% viewable.
  /// - "VIEWABILITY_PERCENT_50" : 50% viewable.
  /// - "VIEWABILITY_PERCENT_75" : 75% viewable.
  /// - "VIEWABILITY_PERCENT_100" : 100% viewable.
  core.String? minimumViewability;

  /// The minimum percentage of the video ad's volume required in order for an
  /// impression to be recorded.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VIDEO_VOLUME_PERCENT_UNSPECIFIED" : Value is not specified or is
  /// unknown in this version.
  /// - "VIDEO_VOLUME_PERCENT_0" : 0% volume.
  /// - "VIDEO_VOLUME_PERCENT_10" : 10% volume.
  core.String? minimumVolume;

  $ActiveViewVideoViewabilityMetricConfig({
    this.displayName,
    this.minimumDuration,
    this.minimumQuartile,
    this.minimumViewability,
    this.minimumVolume,
  });

  $ActiveViewVideoViewabilityMetricConfig.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        minimumDuration: json_['minimumDuration'] as core.String?,
        minimumQuartile: json_['minimumQuartile'] as core.String?,
        minimumViewability: json_['minimumViewability'] as core.String?,
        minimumVolume: json_['minimumVolume'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (minimumDuration != null) 'minimumDuration': minimumDuration!,
    if (minimumQuartile != null) 'minimumQuartile': minimumQuartile!,
    if (minimumViewability != null) 'minimumViewability': minimumViewability!,
    if (minimumVolume != null) 'minimumVolume': minimumVolume!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : Actor
/// - cloudsupport:v2beta : Actor
class $Actor {
  /// The name to display for the actor.
  ///
  /// If not provided, it is inferred from credentials supplied during case
  /// creation. When an email is provided, a display name must also be provided.
  /// This will be obfuscated if the user is a Google Support agent.
  core.String? displayName;

  /// The email address of the actor.
  ///
  /// If not provided, it is inferred from the credentials supplied during case
  /// creation. When a name is provided, an email must also be provided. If the
  /// user is a Google Support agent, this is obfuscated. This field is
  /// deprecated. Use `username` instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? email;

  /// Whether the actor is a Google support actor.
  ///
  /// Output only.
  core.bool? googleSupport;

  /// The username of the actor.
  ///
  /// It may look like an email or other format provided by the identity
  /// provider. If not provided, it is inferred from the credentials supplied.
  /// When a name is provided, a username must also be provided. If the user is
  /// a Google Support agent, this will not be set.
  ///
  /// Output only.
  core.String? username;

  $Actor({this.displayName, this.email, this.googleSupport, this.username});

  $Actor.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        email: json_['email'] as core.String?,
        googleSupport: json_['googleSupport'] as core.bool?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (email != null) 'email': email!,
    if (googleSupport != null) 'googleSupport': googleSupport!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : AdSize
/// - authorizedbuyersmarketplace:v1alpha : AdSize
class $AdSize {
  /// The height of the ad slot in pixels.
  ///
  /// This field will be present only when size type is `PIXEL`.
  core.String? height;

  /// The type of the ad slot size.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : A placeholder for an undefined size type.
  /// - "PIXEL" : Ad slot with size specified by height and width in pixels.
  /// - "INTERSTITIAL" : Special size to describe an interstitial ad slot.
  /// - "NATIVE" : Native (mobile) ads rendered by the publisher.
  /// - "FLUID" : Fluid size (responsive size) can be resized automatically with
  /// the change of outside environment.
  core.String? type;

  /// The width of the ad slot in pixels.
  ///
  /// This field will be present only when size type is `PIXEL`.
  core.String? width;

  $AdSize({this.height, this.type, this.width});

  $AdSize.fromJson(core.Map json_)
    : this(
        height: json_['height'] as core.String?,
        type: json_['type'] as core.String?,
        width: json_['width'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (height != null) 'height': height!,
    if (type != null) 'type': type!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AdUrl
/// - displayvideo:v3 : AdUrl
/// - displayvideo:v4 : AdUrl
class $AdUrl {
  /// The type of the Ad URL.
  /// Possible string values are:
  /// - "AD_URL_TYPE_UNSPECIFIED" : Unknown or unspecified.
  /// - "AD_URL_TYPE_BEACON_IMPRESSION" : A 1x1 tracking pixel to ping when an
  /// impression of a creative is delivered.
  /// - "AD_URL_TYPE_BEACON_EXPANDABLE_DCM_IMPRESSION" : Expandable DCM
  /// impression beacon. At serving time, it is expanded to several beacons.
  /// - "AD_URL_TYPE_BEACON_CLICK" : Tracking URL to ping when the click event
  /// is triggered.
  /// - "AD_URL_TYPE_BEACON_SKIP" : Tracking URL to ping when the skip event is
  /// triggered.
  core.String? type;

  /// The URL string value.
  core.String? url;

  $AdUrl({this.type, this.url});

  $AdUrl.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AddAddressGroupItemsRequest
/// - networksecurity:v1beta1 : AddAddressGroupItemsRequest
class $AddAddressGroupItemsRequest {
  /// List of items to add.
  ///
  /// Required.
  core.List<core.String>? items;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes since the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  $AddAddressGroupItemsRequest({this.items, this.requestId});

  $AddAddressGroupItemsRequest.fromJson(core.Map json_)
    : this(
        items:
            (json_['items'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        requestId: json_['requestId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (items != null) 'items': items!,
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsRequest
class $AddContextArtifactsAndExecutionsRequest {
  /// The resource names of the Artifacts to attribute to the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  core.List<core.String>? artifacts;

  /// The resource names of the Executions to associate with the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  core.List<core.String>? executions;

  $AddContextArtifactsAndExecutionsRequest({this.artifacts, this.executions});

  $AddContextArtifactsAndExecutionsRequest.fromJson(core.Map json_)
    : this(
        artifacts:
            (json_['artifacts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        executions:
            (json_['executions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
    if (executions != null) 'executions': executions!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2AddControlRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaAddControlRequest
/// - retail:v2beta : GoogleCloudRetailV2betaAddControlRequest
class $AddControlRequest {
  /// The id of the control to apply.
  ///
  /// Assumed to be in the same catalog as the serving config - if id is not
  /// found a NOT_FOUND error is returned.
  ///
  /// Required.
  core.String? controlId;

  $AddControlRequest({this.controlId});

  $AddControlRequest.fromJson(core.Map json_)
    : this(controlId: json_['controlId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (controlId != null) 'controlId': controlId!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : AddCreativeRequest
/// - authorizedbuyersmarketplace:v1alpha : AddCreativeRequest
class $AddCreativeRequest {
  /// Name of the creative to add to the finalized deal, in the format
  /// `buyers/{buyerAccountId}/creatives/{creativeId}`.
  ///
  /// See creative.name.
  core.String? creative;

  $AddCreativeRequest({this.creative});

  $AddCreativeRequest.fromJson(core.Map json_)
    : this(creative: json_['creative'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (creative != null) 'creative': creative!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2AddFulfillmentPlacesRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaAddFulfillmentPlacesRequest
/// - retail:v2beta : GoogleCloudRetailV2betaAddFulfillmentPlacesRequest
class $AddFulfillmentPlacesRequest {
  /// The time when the fulfillment updates are issued, used to prevent
  /// out-of-order updates on fulfillment information.
  ///
  /// If not provided, the internal system time will be used.
  core.String? addTime;

  /// If set to true, and the Product is not found, the fulfillment information
  /// will still be processed and retained for at most 1 day and processed once
  /// the Product is created.
  ///
  /// If set to false, a NOT_FOUND error is returned if the Product is not
  /// found.
  core.bool? allowMissing;

  /// The IDs for this type, such as the store IDs for "pickup-in-store" or the
  /// region IDs for "same-day-delivery" to be added for this type.
  ///
  /// Duplicate IDs will be automatically ignored. At least 1 value is required,
  /// and a maximum of 2000 values are allowed. Each value must be a string with
  /// a length limit of 10 characters, matching the pattern `[a-zA-Z0-9_-]+`,
  /// such as "store1" or "REGION-2". Otherwise, an INVALID_ARGUMENT error is
  /// returned. If the total number of place IDs exceeds 2000 for this type
  /// after adding, then the update will be rejected.
  ///
  /// Required.
  core.List<core.String>? placeIds;

  /// The fulfillment type, including commonly used types (such as pickup in
  /// store and same day delivery), and custom types.
  ///
  /// Supported values: * "pickup-in-store" * "ship-to-store" *
  /// "same-day-delivery" * "next-day-delivery" * "custom-type-1" *
  /// "custom-type-2" * "custom-type-3" * "custom-type-4" * "custom-type-5" If
  /// this field is set to an invalid value other than these, an
  /// INVALID_ARGUMENT error is returned. This field directly corresponds to
  /// Product.fulfillment_info.type.
  ///
  /// Required.
  core.String? type;

  $AddFulfillmentPlacesRequest({
    this.addTime,
    this.allowMissing,
    this.placeIds,
    this.type,
  });

  $AddFulfillmentPlacesRequest.fromJson(core.Map json_)
    : this(
        addTime: json_['addTime'] as core.String?,
        allowMissing: json_['allowMissing'] as core.bool?,
        placeIds:
            (json_['placeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addTime != null) 'addTime': addTime!,
    if (allowMissing != null) 'allowMissing': allowMissing!,
    if (placeIds != null) 'placeIds': placeIds!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AddGroupMigrationRequest
/// - vmmigration:v1alpha1 : AddGroupMigrationRequest
class $AddGroupMigrationRequest {
  /// The full path name of the MigratingVm to add.
  core.String? migratingVm;

  $AddGroupMigrationRequest({this.migratingVm});

  $AddGroupMigrationRequest.fromJson(core.Map json_)
    : this(migratingVm: json_['migratingVm'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (migratingVm != null) 'migratingVm': migratingVm!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : AddIdpCredentialRequest
/// - cloudidentity:v1beta1 : AddIdpCredentialRequest
class $AddIdpCredentialRequest {
  /// PEM encoded x509 certificate containing the public key for verifying IdP
  /// signatures.
  core.String? pemData;

  $AddIdpCredentialRequest({this.pemData});

  $AddIdpCredentialRequest.fromJson(core.Map json_)
    : this(pemData: json_['pemData'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pemData != null) 'pemData': pemData!,
  };
}

/// Used by:
///
/// - content:v2.1 : BuiltInSimpleActionAdditionalContent
/// - merchantapi:issueresolution_v1beta : AdditionalContent
class $AdditionalContent {
  /// Long text organized into paragraphs.
  core.List<core.String>? paragraphs;

  /// Title of the additional content;
  core.String? title;

  $AdditionalContent({this.paragraphs, this.title});

  $AdditionalContent.fromJson(core.Map json_)
    : this(
        paragraphs:
            (json_['paragraphs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (paragraphs != null) 'paragraphs': paragraphs!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - container:v1 : AdditionalIPRangesConfig
/// - container:v1beta1 : AdditionalIPRangesConfig
class $AdditionalIPRangesConfig {
  /// List of secondary ranges names within this subnetwork that can be used for
  /// pod IPs.
  ///
  /// Example1: gke-pod-range1 Example2: gke-pod-range1,gke-pod-range2
  core.List<core.String>? podIpv4RangeNames;

  /// Name of the subnetwork.
  ///
  /// This can be the full path of the subnetwork or just the name. Example1:
  /// my-subnet Example2:
  /// projects/gke-project/regions/us-central1/subnetworks/my-subnet
  core.String? subnetwork;

  $AdditionalIPRangesConfig({this.podIpv4RangeNames, this.subnetwork});

  $AdditionalIPRangesConfig.fromJson(core.Map json_)
    : this(
        podIpv4RangeNames:
            (json_['podIpv4RangeNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (podIpv4RangeNames != null) 'podIpv4RangeNames': podIpv4RangeNames!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - container:v1 : AdditionalNodeNetworkConfig
/// - container:v1beta1 : AdditionalNodeNetworkConfig
class $AdditionalNodeNetworkConfig {
  /// Name of the VPC where the additional interface belongs
  core.String? network;

  /// Name of the subnetwork where the additional interface belongs
  core.String? subnetwork;

  $AdditionalNodeNetworkConfig({this.network, this.subnetwork});

  $AdditionalNodeNetworkConfig.fromJson(core.Map json_)
    : this(
        network: json_['network'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (network != null) 'network': network!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - adsenseplatform:v1 : Address
/// - adsenseplatform:v1alpha : Address
class $Address00 {
  /// First line of address.
  ///
  /// Max length 64 bytes or 30 characters.
  core.String? address1;

  /// Second line of address.
  ///
  /// Max length 64 bytes or 30 characters.
  core.String? address2;

  /// City.
  ///
  /// Max length 60 bytes or 30 characters.
  core.String? city;

  /// Name of the company.
  ///
  /// Max length 255 bytes or 34 characters.
  core.String? company;

  /// Contact name of the company.
  ///
  /// Max length 128 bytes or 34 characters.
  core.String? contact;

  /// Fax number with international code (i.e. +441234567890).
  core.String? fax;

  /// Phone number with international code (i.e. +441234567890).
  core.String? phone;

  /// Country/Region code.
  ///
  /// The region is specified as a CLDR region code (e.g. "US", "FR").
  core.String? regionCode;

  /// State.
  ///
  /// Max length 60 bytes or 30 characters.
  core.String? state;

  /// Zip/post code.
  ///
  /// Max length 10 bytes or 10 characters.
  core.String? zip;

  $Address00({
    this.address1,
    this.address2,
    this.city,
    this.company,
    this.contact,
    this.fax,
    this.phone,
    this.regionCode,
    this.state,
    this.zip,
  });

  $Address00.fromJson(core.Map json_)
    : this(
        address1: json_['address1'] as core.String?,
        address2: json_['address2'] as core.String?,
        city: json_['city'] as core.String?,
        company: json_['company'] as core.String?,
        contact: json_['contact'] as core.String?,
        fax: json_['fax'] as core.String?,
        phone: json_['phone'] as core.String?,
        regionCode: json_['regionCode'] as core.String?,
        state: json_['state'] as core.String?,
        zip: json_['zip'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address1 != null) 'address1': address1!,
    if (address2 != null) 'address2': address2!,
    if (city != null) 'city': city!,
    if (company != null) 'company': company!,
    if (contact != null) 'contact': contact!,
    if (fax != null) 'fax': fax!,
    if (phone != null) 'phone': phone!,
    if (regionCode != null) 'regionCode': regionCode!,
    if (state != null) 'state': state!,
    if (zip != null) 'zip': zip!,
  };
}

/// Used by:
///
/// - compute:beta : Address
/// - compute:v1 : Address
class $Address01 {
  /// The static IP address represented by this resource.
  core.String? address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL.
  ///
  /// If unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL" : A publicly visible external IP address.
  /// - "INTERNAL" : A private network IP address, for use with an Instance or
  /// Internal Load Balancer forwarding rule.
  /// - "UNSPECIFIED_TYPE"
  core.String? addressType;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The IP version that will be used by this address.
  ///
  /// Valid options are IPV4 or IPV6.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String? ipVersion;

  /// The endpoint type of this address, which should be VM or NETLB.
  ///
  /// This is used for deciding which type of endpoint this address can be used
  /// after the external IPv6 address reservation.
  /// Possible string values are:
  /// - "NETLB" : Reserved IPv6 address can be used on network load balancer.
  /// - "VM" : Reserved IPv6 address can be used on VM.
  core.String? ipv6EndpointType;

  /// Type of the resource.
  ///
  /// Always compute#address for addresses.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this Address, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve an Address.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// The URL of the network in which to reserve the address.
  ///
  /// This field can only be used with INTERNAL type with the VPC_PEERING
  /// purpose.
  core.String? network;

  /// This signifies the networking tier used for configuring this address and
  /// can only take the following values: PREMIUM or STANDARD.
  ///
  /// Internal IP addresses are always Premium Tier; global external IP
  /// addresses are always Premium Tier; regional external IP addresses can be
  /// either Standard or Premium Tier. If this field is not specified, it is
  /// assumed to be PREMIUM.
  /// Possible string values are:
  /// - "FIXED_STANDARD" : Public internet quality with fixed bandwidth.
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  /// - "STANDARD_OVERRIDES_FIXED_STANDARD" : (Output only) Temporary tier for
  /// FIXED_STANDARD when fixed standard tier is expired or not configured.
  core.String? networkTier;

  /// The prefix length if the resource represents an IP range.
  core.int? prefixLength;

  /// The purpose of this resource, which can be one of the following values: -
  /// GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges,
  /// load balancers, and similar resources.
  ///
  /// - DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud DNS
  /// inbound forwarder IP addresses (regional internal IP address in a subnet
  /// of a VPC network) - VPC_PEERING for global internal IP addresses used for
  /// private services access allocated ranges. - NAT_AUTO for the regional
  /// external IP addresses used by Cloud NAT when allocating addresses using
  /// automatic NAT IP address allocation. - IPSEC_INTERCONNECT for addresses
  /// created from a private IP range that are reserved for a VLAN attachment in
  /// an *HA VPN over Cloud Interconnect* configuration. These addresses are
  /// regional resources. - `SHARED_LOADBALANCER_VIP` for an internal IP address
  /// that is assigned to multiple internal forwarding rules. -
  /// `PRIVATE_SERVICE_CONNECT` for a private network address that is used to
  /// configure Private Service Connect. Only global internal addresses can use
  /// this purpose.
  /// Possible string values are:
  /// - "DNS_RESOLVER" : DNS resolver address in the subnetwork.
  /// - "GCE_ENDPOINT" : VM internal/alias IP, Internal LB service IP, etc.
  /// - "IPSEC_INTERCONNECT" : A regional internal IP address range reserved for
  /// the VLAN attachment that is used in HA VPN over Cloud Interconnect. This
  /// regional internal IP address range must not overlap with any IP address
  /// range of subnet/route in the VPC network and its peering networks. After
  /// the VLAN attachment is created with the reserved IP address range, when
  /// creating a new VPN gateway, its interface IP address is allocated from the
  /// associated VLAN attachments IP address range.
  /// - "NAT_AUTO" : External IP automatically reserved for Cloud NAT.
  /// - "PRIVATE_SERVICE_CONNECT" : A private network IP address that can be
  /// used to configure Private Service Connect. This purpose can be specified
  /// only for GLOBAL addresses of Type INTERNAL
  /// - "SERVERLESS" : A regional internal IP address range reserved for
  /// Serverless.
  /// - "SHARED_LOADBALANCER_VIP" : A private network IP address that can be
  /// shared by multiple Internal Load Balancer forwarding rules.
  /// - "VPC_PEERING" : IP range for peer networks.
  core.String? purpose;

  /// The URL of the region where a regional address resides.
  ///
  /// For regional addresses, you must specify the region as a path parameter in
  /// the HTTP request URL. *This field is not applicable to global addresses.*
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the address, which can be one of RESERVING, RESERVED, or
  /// IN_USE.
  ///
  /// An address that is RESERVING is currently in the process of being
  /// reserved. A RESERVED address is currently reserved and available to use.
  /// An IN_USE address is currently being used by another resource and is not
  /// available.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "IN_USE" : Address is being used by another resource and is not
  /// available.
  /// - "RESERVED" : Address is reserved and available to use.
  /// - "RESERVING" : Address is being reserved.
  core.String? status;

  /// The URL of the subnetwork in which to reserve the address.
  ///
  /// If an IP address is specified, it must be within the subnetwork's IP
  /// range. This field can only be used with INTERNAL type with a GCE_ENDPOINT
  /// or DNS_RESOLVER purpose.
  core.String? subnetwork;

  /// The URLs of the resources that are using this address.
  ///
  /// Output only.
  core.List<core.String>? users;

  $Address01({
    this.address,
    this.addressType,
    this.creationTimestamp,
    this.description,
    this.id,
    this.ipVersion,
    this.ipv6EndpointType,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.name,
    this.network,
    this.networkTier,
    this.prefixLength,
    this.purpose,
    this.region,
    this.selfLink,
    this.status,
    this.subnetwork,
    this.users,
  });

  $Address01.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        addressType: json_['addressType'] as core.String?,
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        id: json_['id'] as core.String?,
        ipVersion: json_['ipVersion'] as core.String?,
        ipv6EndpointType: json_['ipv6EndpointType'] as core.String?,
        kind: json_['kind'] as core.String?,
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        networkTier: json_['networkTier'] as core.String?,
        prefixLength: json_['prefixLength'] as core.int?,
        purpose: json_['purpose'] as core.String?,
        region: json_['region'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
        users:
            (json_['users'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (addressType != null) 'addressType': addressType!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (id != null) 'id': id!,
    if (ipVersion != null) 'ipVersion': ipVersion!,
    if (ipv6EndpointType != null) 'ipv6EndpointType': ipv6EndpointType!,
    if (kind != null) 'kind': kind!,
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (networkTier != null) 'networkTier': networkTier!,
    if (prefixLength != null) 'prefixLength': prefixLength!,
    if (purpose != null) 'purpose': purpose!,
    if (region != null) 'region': region!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
    if (users != null) 'users': users!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AddressGroup
/// - networksecurity:v1beta1 : AddressGroup
class $AddressGroup {
  /// Capacity of the Address Group
  ///
  /// Required.
  core.int? capacity;

  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// List of items.
  ///
  /// Optional.
  core.List<core.String>? items;

  /// Set of label tags associated with the AddressGroup resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Name of the AddressGroup resource.
  ///
  /// It matches pattern `projects / * /locations/{location}/addressGroups/`.
  ///
  /// Required.
  core.String? name;

  /// List of supported purposes of the Address Group.
  ///
  /// Optional.
  core.List<core.String>? purpose;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The type of the Address Group.
  ///
  /// Possible values are "IPv4" or "IPV6".
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value.
  /// - "IPV4" : IP v4 ranges.
  /// - "IPV6" : IP v6 ranges.
  core.String? type;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $AddressGroup({
    this.capacity,
    this.createTime,
    this.description,
    this.items,
    this.labels,
    this.name,
    this.purpose,
    this.selfLink,
    this.type,
    this.updateTime,
  });

  $AddressGroup.fromJson(core.Map json_)
    : this(
        capacity: json_['capacity'] as core.int?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        items:
            (json_['items'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        purpose:
            (json_['purpose'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        selfLink: json_['selfLink'] as core.String?,
        type: json_['type'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (capacity != null) 'capacity': capacity!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (items != null) 'items': items!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (purpose != null) 'purpose': purpose!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (type != null) 'type': type!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalLoadBalancerAddressPool
/// - gkeonprem:v1 : VmwareAddressPool
class $AddressPool {
  /// The addresses that are part of this pool.
  ///
  /// Each address must be either in the CIDR form (1.2.3.0/24) or range form
  /// (1.2.3.1-1.2.3.5).
  ///
  /// Required.
  core.List<core.String>? addresses;

  /// If true, avoid using IPs ending in .0 or .255.
  ///
  /// This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
  /// those special IP addresses.
  core.bool? avoidBuggyIps;

  /// If true, prevent IP addresses from being automatically assigned.
  core.bool? manualAssign;

  /// The name of the address pool.
  ///
  /// Required.
  core.String? pool;

  $AddressPool({
    this.addresses,
    this.avoidBuggyIps,
    this.manualAssign,
    this.pool,
  });

  $AddressPool.fromJson(core.Map json_)
    : this(
        addresses:
            (json_['addresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        avoidBuggyIps: json_['avoidBuggyIps'] as core.bool?,
        manualAssign: json_['manualAssign'] as core.bool?,
        pool: json_['pool'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addresses != null) 'addresses': addresses!,
    if (avoidBuggyIps != null) 'avoidBuggyIps': avoidBuggyIps!,
    if (manualAssign != null) 'manualAssign': manualAssign!,
    if (pool != null) 'pool': pool!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : Adloox
/// - displayvideo:v4 : Adloox
class $Adloox {
  /// Adult and Explicit Sexual Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? adultExplicitSexualContent;

  /// Arms and Ammunition Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? armsAmmunitionContent;

  /// Crime and Harmful Acts Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent;

  /// Death, Injury, or Military Conflict Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? deathInjuryMilitaryConflictContent;

  /// Debated Sensitive Social Issue Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? debatedSensitiveSocialIssueContent;

  /// IAB viewability threshold for display ads.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DISPLAY_IAB_VIEWABILITY_UNSPECIFIED" : Default value when not specified
  /// or is unknown in this version.
  /// - "DISPLAY_IAB_VIEWABILITY_10" : 10%+ in view (IAB display viewability
  /// standard).
  /// - "DISPLAY_IAB_VIEWABILITY_20" : 20%+ in view (IAB display viewability
  /// standard).
  /// - "DISPLAY_IAB_VIEWABILITY_35" : 35%+ in view (IAB display viewability
  /// standard).
  /// - "DISPLAY_IAB_VIEWABILITY_50" : 50%+ in view (IAB display viewability
  /// standard).
  /// - "DISPLAY_IAB_VIEWABILITY_75" : 75%+ in view (IAB display viewability
  /// standard).
  core.String? displayIabViewability;

  /// Scope3 categories to exclude.
  core.List<core.String>? excludedAdlooxCategories;

  /// Scope3's fraud IVT MFA categories to exclude.
  ///
  /// Optional.
  core.List<core.String>? excludedFraudIvtMfaCategories;

  /// Hate Speech and Acts of Aggression Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? hateSpeechActsAggressionContent;

  /// Illegal Drugs/Alcohol Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? illegalDrugsTobaccoEcigarettesVapingAlcoholContent;

  /// Misinformation Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? misinformationContent;

  /// Obscenity and Profanity Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? obscenityProfanityContent;

  /// Online Piracy Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? onlinePiracyContent;

  /// Spam or Harmful Content
  /// [GARM](https://wfanet.org/leadership/garm/about-garm) risk ranges to
  /// exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? spamHarmfulContent;

  /// Terrorism Content [GARM](https://wfanet.org/leadership/garm/about-garm)
  /// risk ranges to exclude.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GARM_RISK_EXCLUSION_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any GARM risk exclusion option.
  /// - "GARM_RISK_EXCLUSION_FLOOR" : Exclude floor risk.
  /// - "GARM_RISK_EXCLUSION_HIGH" : Exclude high and floor risk.
  /// - "GARM_RISK_EXCLUSION_MEDIUM" : Exclude medium, high, and floor risk.
  /// - "GARM_RISK_EXCLUSION_LOW" : Exclude all levels of risk (low, medium,
  /// high and floor).
  core.String? terrorismContent;

  /// IAB viewability threshold for video ads.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "VIDEO_IAB_VIEWABILITY_UNSPECIFIED" : Default value when not specified
  /// or is unknown in this version.
  /// - "VIDEO_IAB_VIEWABILITY_10" : 10%+ in view (IAB video viewability
  /// standard).
  /// - "VIDEO_IAB_VIEWABILITY_20" : 20%+ in view (IAB video viewability
  /// standard).
  /// - "VIDEO_IAB_VIEWABILITY_35" : 35%+ in view (IAB video viewability
  /// standard).
  /// - "VIDEO_IAB_VIEWABILITY_50" : 50%+ in view (IAB video viewability
  /// standard).
  /// - "VIDEO_IAB_VIEWABILITY_75" : 75%+ in view (IAB video viewability
  /// standard).
  core.String? videoIabViewability;

  $Adloox({
    this.adultExplicitSexualContent,
    this.armsAmmunitionContent,
    this.crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent,
    this.deathInjuryMilitaryConflictContent,
    this.debatedSensitiveSocialIssueContent,
    this.displayIabViewability,
    this.excludedAdlooxCategories,
    this.excludedFraudIvtMfaCategories,
    this.hateSpeechActsAggressionContent,
    this.illegalDrugsTobaccoEcigarettesVapingAlcoholContent,
    this.misinformationContent,
    this.obscenityProfanityContent,
    this.onlinePiracyContent,
    this.spamHarmfulContent,
    this.terrorismContent,
    this.videoIabViewability,
  });

  $Adloox.fromJson(core.Map json_)
    : this(
        adultExplicitSexualContent:
            json_['adultExplicitSexualContent'] as core.String?,
        armsAmmunitionContent: json_['armsAmmunitionContent'] as core.String?,
        crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent:
            json_['crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent']
                as core.String?,
        deathInjuryMilitaryConflictContent:
            json_['deathInjuryMilitaryConflictContent'] as core.String?,
        debatedSensitiveSocialIssueContent:
            json_['debatedSensitiveSocialIssueContent'] as core.String?,
        displayIabViewability: json_['displayIabViewability'] as core.String?,
        excludedAdlooxCategories:
            (json_['excludedAdlooxCategories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludedFraudIvtMfaCategories:
            (json_['excludedFraudIvtMfaCategories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        hateSpeechActsAggressionContent:
            json_['hateSpeechActsAggressionContent'] as core.String?,
        illegalDrugsTobaccoEcigarettesVapingAlcoholContent:
            json_['illegalDrugsTobaccoEcigarettesVapingAlcoholContent']
                as core.String?,
        misinformationContent: json_['misinformationContent'] as core.String?,
        obscenityProfanityContent:
            json_['obscenityProfanityContent'] as core.String?,
        onlinePiracyContent: json_['onlinePiracyContent'] as core.String?,
        spamHarmfulContent: json_['spamHarmfulContent'] as core.String?,
        terrorismContent: json_['terrorismContent'] as core.String?,
        videoIabViewability: json_['videoIabViewability'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adultExplicitSexualContent != null)
      'adultExplicitSexualContent': adultExplicitSexualContent!,
    if (armsAmmunitionContent != null)
      'armsAmmunitionContent': armsAmmunitionContent!,
    if (crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent != null)
      'crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent':
          crimeHarmfulActsIndividualsSocietyHumanRightsViolationsContent!,
    if (deathInjuryMilitaryConflictContent != null)
      'deathInjuryMilitaryConflictContent': deathInjuryMilitaryConflictContent!,
    if (debatedSensitiveSocialIssueContent != null)
      'debatedSensitiveSocialIssueContent': debatedSensitiveSocialIssueContent!,
    if (displayIabViewability != null)
      'displayIabViewability': displayIabViewability!,
    if (excludedAdlooxCategories != null)
      'excludedAdlooxCategories': excludedAdlooxCategories!,
    if (excludedFraudIvtMfaCategories != null)
      'excludedFraudIvtMfaCategories': excludedFraudIvtMfaCategories!,
    if (hateSpeechActsAggressionContent != null)
      'hateSpeechActsAggressionContent': hateSpeechActsAggressionContent!,
    if (illegalDrugsTobaccoEcigarettesVapingAlcoholContent != null)
      'illegalDrugsTobaccoEcigarettesVapingAlcoholContent':
          illegalDrugsTobaccoEcigarettesVapingAlcoholContent!,
    if (misinformationContent != null)
      'misinformationContent': misinformationContent!,
    if (obscenityProfanityContent != null)
      'obscenityProfanityContent': obscenityProfanityContent!,
    if (onlinePiracyContent != null)
      'onlinePiracyContent': onlinePiracyContent!,
    if (spamHarmfulContent != null) 'spamHarmfulContent': spamHarmfulContent!,
    if (terrorismContent != null) 'terrorismContent': terrorismContent!,
    if (videoIabViewability != null)
      'videoIabViewability': videoIabViewability!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AdvancedCompleteQueryRequestBoostSpecConditionBoostSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpecConditionBoostSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAdvancedCompleteQueryRequestBoostSpecConditionBoostSpec
class $AdvancedCompleteQueryRequestBoostSpecConditionBoostSpec {
  /// Strength of the boost, which should be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the
  /// suggestions a big promotion. However, it does not necessarily mean that
  /// the top result will be a boosted suggestion. Setting to -1.0 gives the
  /// suggestions a big demotion. However, other suggestions that are relevant
  /// might still be shown. Setting to 0.0 means no boost applied. The boosting
  /// condition is ignored.
  core.double? boost;

  /// An expression which specifies a boost condition.
  ///
  /// The syntax is the same as
  /// [filter expression syntax](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax).
  /// Currently, the only supported condition is a list of BCP-47 lang codes.
  /// Example: * To boost suggestions in languages `en` or `fr`: `(lang_code:
  /// ANY("en", "fr"))`
  core.String? condition;

  $AdvancedCompleteQueryRequestBoostSpecConditionBoostSpec({
    this.boost,
    this.condition,
  });

  $AdvancedCompleteQueryRequestBoostSpecConditionBoostSpec.fromJson(
    core.Map json_,
  ) : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        condition: json_['condition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (condition != null) 'condition': condition!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AdvancedCompleteQueryRequestSuggestionTypeSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestSuggestionTypeSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAdvancedCompleteQueryRequestSuggestionTypeSpec
class $AdvancedCompleteQueryRequestSuggestionTypeSpec {
  /// Maximum number of suggestions to return for each suggestion type.
  ///
  /// Optional.
  core.int? maxSuggestions;

  /// Suggestion type.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SUGGESTION_TYPE_UNSPECIFIED" : Default value.
  /// - "QUERY" : Returns query suggestions.
  /// - "PEOPLE" : Returns people suggestions.
  /// - "CONTENT" : Returns content suggestions.
  /// - "RECENT_SEARCH" : Returns recent search suggestions.
  /// - "GOOGLE_WORKSPACE" : Returns Google Workspace suggestions.
  core.String? suggestionType;

  $AdvancedCompleteQueryRequestSuggestionTypeSpec({
    this.maxSuggestions,
    this.suggestionType,
  });

  $AdvancedCompleteQueryRequestSuggestionTypeSpec.fromJson(core.Map json_)
    : this(
        maxSuggestions: json_['maxSuggestions'] as core.int?,
        suggestionType: json_['suggestionType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxSuggestions != null) 'maxSuggestions': maxSuggestions!,
    if (suggestionType != null) 'suggestionType': suggestionType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AdvancedCompleteQueryResponseQuerySuggestion
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseQuerySuggestion
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAdvancedCompleteQueryResponseQuerySuggestion
class $AdvancedCompleteQueryResponseQuerySuggestion {
  /// The unique document field paths that serve as the source of this
  /// suggestion if it was generated from completable fields.
  ///
  /// This field is only populated for the document-completable model.
  core.List<core.String>? completableFieldPaths;

  /// The name of the dataStore that this suggestion belongs to.
  core.List<core.String>? dataStore;

  /// The score of each suggestion.
  ///
  /// The score is in the range of \[0, 1\].
  core.double? score;

  /// The suggestion for the query.
  core.String? suggestion;

  $AdvancedCompleteQueryResponseQuerySuggestion({
    this.completableFieldPaths,
    this.dataStore,
    this.score,
    this.suggestion,
  });

  $AdvancedCompleteQueryResponseQuerySuggestion.fromJson(core.Map json_)
    : this(
        completableFieldPaths:
            (json_['completableFieldPaths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        dataStore:
            (json_['dataStore'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        score: (json_['score'] as core.num?)?.toDouble(),
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completableFieldPaths != null)
      'completableFieldPaths': completableFieldPaths!,
    if (dataStore != null) 'dataStore': dataStore!,
    if (score != null) 'score': score!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AdvancedCompleteQueryResponseRecentSearchSuggestion
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseRecentSearchSuggestion
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAdvancedCompleteQueryResponseRecentSearchSuggestion
class $AdvancedCompleteQueryResponseRecentSearchSuggestion {
  /// The time when this recent rearch happened.
  core.String? recentSearchTime;

  /// The score of each suggestion.
  ///
  /// The score is in the range of \[0, 1\].
  core.double? score;

  /// The suggestion for the query.
  core.String? suggestion;

  $AdvancedCompleteQueryResponseRecentSearchSuggestion({
    this.recentSearchTime,
    this.score,
    this.suggestion,
  });

  $AdvancedCompleteQueryResponseRecentSearchSuggestion.fromJson(core.Map json_)
    : this(
        recentSearchTime: json_['recentSearchTime'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (recentSearchTime != null) 'recentSearchTime': recentSearchTime!,
    if (score != null) 'score': score!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Used by:
///
/// - container:v1 : AdvancedDatapathObservabilityConfig
/// - container:v1beta1 : AdvancedDatapathObservabilityConfig
class $AdvancedDatapathObservabilityConfig {
  /// Expose flow metrics on nodes
  core.bool? enableMetrics;

  /// Enable Relay component
  core.bool? enableRelay;

  /// Method used to make Relay available
  /// Possible string values are:
  /// - "RELAY_MODE_UNSPECIFIED" : Default value. This shouldn't be used.
  /// - "DISABLED" : disabled
  /// - "INTERNAL_VPC_LB" : exposed via internal load balancer
  /// - "EXTERNAL_LB" : exposed via external load balancer
  core.String? relayMode;

  $AdvancedDatapathObservabilityConfig({
    this.enableMetrics,
    this.enableRelay,
    this.relayMode,
  });

  $AdvancedDatapathObservabilityConfig.fromJson(core.Map json_)
    : this(
        enableMetrics: json_['enableMetrics'] as core.bool?,
        enableRelay: json_['enableRelay'] as core.bool?,
        relayMode: json_['relayMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableMetrics != null) 'enableMetrics': enableMetrics!,
    if (enableRelay != null) 'enableRelay': enableRelay!,
    if (relayMode != null) 'relayMode': relayMode!,
  };
}

/// Used by:
///
/// - compute:beta : AdvancedMachineFeatures
/// - compute:v1 : AdvancedMachineFeatures
class $AdvancedMachineFeatures00 {
  /// Whether to enable nested virtualization or not (default is false).
  core.bool? enableNestedVirtualization;

  /// Whether to enable UEFI networking for instance creation.
  core.bool? enableUefiNetworking;

  /// Type of Performance Monitoring Unit requested on instance.
  /// Possible string values are:
  /// - "ARCHITECTURAL" : Architecturally defined non-LLC events.
  /// - "ENHANCED" : Most documented core/L2 and LLC events.
  /// - "PERFORMANCE_MONITORING_UNIT_UNSPECIFIED"
  /// - "STANDARD" : Most documented core/L2 events.
  core.String? performanceMonitoringUnit;

  /// The number of threads per physical core.
  ///
  /// To disable simultaneous multithreading (SMT) set this to 1. If unset, the
  /// maximum number of threads supported per core by the underlying processor
  /// is assumed.
  core.int? threadsPerCore;

  /// Turbo frequency mode to use for the instance.
  ///
  /// Supported modes include: * ALL_CORE_MAX Using empty string or not setting
  /// this field will use the platform-specific default turbo mode.
  core.String? turboMode;

  /// The number of physical cores to expose to an instance.
  ///
  /// Multiply by the number of threads per core to compute the total number of
  /// virtual CPUs to expose to the instance. If unset, the number of cores is
  /// inferred from the instance's nominal CPU count and the underlying
  /// platform's SMT width.
  core.int? visibleCoreCount;

  $AdvancedMachineFeatures00({
    this.enableNestedVirtualization,
    this.enableUefiNetworking,
    this.performanceMonitoringUnit,
    this.threadsPerCore,
    this.turboMode,
    this.visibleCoreCount,
  });

  $AdvancedMachineFeatures00.fromJson(core.Map json_)
    : this(
        enableNestedVirtualization:
            json_['enableNestedVirtualization'] as core.bool?,
        enableUefiNetworking: json_['enableUefiNetworking'] as core.bool?,
        performanceMonitoringUnit:
            json_['performanceMonitoringUnit'] as core.String?,
        threadsPerCore: json_['threadsPerCore'] as core.int?,
        turboMode: json_['turboMode'] as core.String?,
        visibleCoreCount: json_['visibleCoreCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableNestedVirtualization != null)
      'enableNestedVirtualization': enableNestedVirtualization!,
    if (enableUefiNetworking != null)
      'enableUefiNetworking': enableUefiNetworking!,
    if (performanceMonitoringUnit != null)
      'performanceMonitoringUnit': performanceMonitoringUnit!,
    if (threadsPerCore != null) 'threadsPerCore': threadsPerCore!,
    if (turboMode != null) 'turboMode': turboMode!,
    if (visibleCoreCount != null) 'visibleCoreCount': visibleCoreCount!,
  };
}

/// Used by:
///
/// - container:v1 : AdvancedMachineFeatures
/// - container:v1beta1 : AdvancedMachineFeatures
class $AdvancedMachineFeatures01 {
  /// Whether or not to enable nested virtualization (defaults to false).
  core.bool? enableNestedVirtualization;

  /// Type of Performance Monitoring Unit (PMU) requested on node pool
  /// instances.
  ///
  /// If unset, PMU will not be available to the node.
  /// Possible string values are:
  /// - "PERFORMANCE_MONITORING_UNIT_UNSPECIFIED" : PMU not enabled.
  /// - "ARCHITECTURAL" : Architecturally defined non-LLC events.
  /// - "STANDARD" : Most documented core/L2 events.
  /// - "ENHANCED" : Most documented core/L2 and LLC events.
  core.String? performanceMonitoringUnit;

  /// The number of threads per physical core.
  ///
  /// To disable simultaneous multithreading (SMT) set this to 1. If unset, the
  /// maximum number of threads supported per core by the underlying processor
  /// is assumed.
  core.String? threadsPerCore;

  $AdvancedMachineFeatures01({
    this.enableNestedVirtualization,
    this.performanceMonitoringUnit,
    this.threadsPerCore,
  });

  $AdvancedMachineFeatures01.fromJson(core.Map json_)
    : this(
        enableNestedVirtualization:
            json_['enableNestedVirtualization'] as core.bool?,
        performanceMonitoringUnit:
            json_['performanceMonitoringUnit'] as core.String?,
        threadsPerCore: json_['threadsPerCore'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableNestedVirtualization != null)
      'enableNestedVirtualization': enableNestedVirtualization!,
    if (performanceMonitoringUnit != null)
      'performanceMonitoringUnit': performanceMonitoringUnit!,
    if (threadsPerCore != null) 'threadsPerCore': threadsPerCore!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : AdvancedMachineFeatures
/// - sqladmin:v1beta4 : AdvancedMachineFeatures
class $AdvancedMachineFeatures02 {
  /// The number of threads per physical core.
  core.int? threadsPerCore;

  $AdvancedMachineFeatures02({this.threadsPerCore});

  $AdvancedMachineFeatures02.fromJson(core.Map json_)
    : this(threadsPerCore: json_['threadsPerCore'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (threadsPerCore != null) 'threadsPerCore': threadsPerCore!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AdvancedSettingsDtmfSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AdvancedSettingsDtmfSettings
class $AdvancedSettingsDtmfSettings {
  /// If true, incoming audio is processed for DTMF (dual tone multi frequency)
  /// events.
  ///
  /// For example, if the caller presses a button on their telephone keypad and
  /// DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3"
  /// was pressed) in the incoming audio and pass the event to the bot to drive
  /// business logic (e.g. when 3 is pressed, return the account balance).
  core.bool? enabled;

  /// Endpoint timeout setting for matching dtmf input to regex.
  core.String? endpointingTimeoutDuration;

  /// The digit that terminates a DTMF digit sequence.
  core.String? finishDigit;

  /// Interdigit timeout setting for matching dtmf input to regex.
  core.String? interdigitTimeoutDuration;

  /// Max length of DTMF digits.
  core.int? maxDigits;

  $AdvancedSettingsDtmfSettings({
    this.enabled,
    this.endpointingTimeoutDuration,
    this.finishDigit,
    this.interdigitTimeoutDuration,
    this.maxDigits,
  });

  $AdvancedSettingsDtmfSettings.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        endpointingTimeoutDuration:
            json_['endpointingTimeoutDuration'] as core.String?,
        finishDigit: json_['finishDigit'] as core.String?,
        interdigitTimeoutDuration:
            json_['interdigitTimeoutDuration'] as core.String?,
        maxDigits: json_['maxDigits'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (endpointingTimeoutDuration != null)
      'endpointingTimeoutDuration': endpointingTimeoutDuration!,
    if (finishDigit != null) 'finishDigit': finishDigit!,
    if (interdigitTimeoutDuration != null)
      'interdigitTimeoutDuration': interdigitTimeoutDuration!,
    if (maxDigits != null) 'maxDigits': maxDigits!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AdvancedSettingsLoggingSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AdvancedSettingsLoggingSettings
class $AdvancedSettingsLoggingSettings {
  /// Enables consent-based end-user input redaction, if true, a pre-defined
  /// session parameter `$session.params.conversation-redaction` will be used to
  /// determine if the utterance should be redacted.
  core.bool? enableConsentBasedRedaction;

  /// Enables DF Interaction logging.
  core.bool? enableInteractionLogging;

  /// Enables Google Cloud Logging.
  core.bool? enableStackdriverLogging;

  $AdvancedSettingsLoggingSettings({
    this.enableConsentBasedRedaction,
    this.enableInteractionLogging,
    this.enableStackdriverLogging,
  });

  $AdvancedSettingsLoggingSettings.fromJson(core.Map json_)
    : this(
        enableConsentBasedRedaction:
            json_['enableConsentBasedRedaction'] as core.bool?,
        enableInteractionLogging:
            json_['enableInteractionLogging'] as core.bool?,
        enableStackdriverLogging:
            json_['enableStackdriverLogging'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableConsentBasedRedaction != null)
      'enableConsentBasedRedaction': enableConsentBasedRedaction!,
    if (enableInteractionLogging != null)
      'enableInteractionLogging': enableInteractionLogging!,
    if (enableStackdriverLogging != null)
      'enableStackdriverLogging': enableStackdriverLogging!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AdvancedSettingsSpeechSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AdvancedSettingsSpeechSettings
class $AdvancedSettingsSpeechSettings {
  /// Sensitivity of the speech model that detects the end of speech.
  ///
  /// Scale from 0 to 100.
  core.int? endpointerSensitivity;

  /// Mapping from language to Speech-to-Text model.
  ///
  /// The mapped Speech-to-Text model will be selected for requests from its
  /// corresponding language. For more information, see
  /// [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
  core.Map<core.String, core.String>? models;

  /// Timeout before detecting no speech.
  core.String? noSpeechTimeout;

  /// Use timeout based endpointing, interpreting endpointer sensitivity as
  /// seconds of timeout value.
  core.bool? useTimeoutBasedEndpointing;

  $AdvancedSettingsSpeechSettings({
    this.endpointerSensitivity,
    this.models,
    this.noSpeechTimeout,
    this.useTimeoutBasedEndpointing,
  });

  $AdvancedSettingsSpeechSettings.fromJson(core.Map json_)
    : this(
        endpointerSensitivity: json_['endpointerSensitivity'] as core.int?,
        models: (json_['models'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        noSpeechTimeout: json_['noSpeechTimeout'] as core.String?,
        useTimeoutBasedEndpointing:
            json_['useTimeoutBasedEndpointing'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpointerSensitivity != null)
      'endpointerSensitivity': endpointerSensitivity!,
    if (models != null) 'models': models!,
    if (noSpeechTimeout != null) 'noSpeechTimeout': noSpeechTimeout!,
    if (useTimeoutBasedEndpointing != null)
      'useTimeoutBasedEndpointing': useTimeoutBasedEndpointing!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AdvancedSiteSearchConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAdvancedSiteSearchConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAdvancedSiteSearchConfig
class $AdvancedSiteSearchConfig {
  /// If set true, automatic refresh is disabled for the DataStore.
  core.bool? disableAutomaticRefresh;

  /// If set true, initial indexing is disabled for the DataStore.
  core.bool? disableInitialIndex;

  $AdvancedSiteSearchConfig({
    this.disableAutomaticRefresh,
    this.disableInitialIndex,
  });

  $AdvancedSiteSearchConfig.fromJson(core.Map json_)
    : this(
        disableAutomaticRefresh: json_['disableAutomaticRefresh'] as core.bool?,
        disableInitialIndex: json_['disableInitialIndex'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableAutomaticRefresh != null)
      'disableAutomaticRefresh': disableAutomaticRefresh!,
    if (disableInitialIndex != null)
      'disableInitialIndex': disableInitialIndex!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : AdvancedVoiceOptions
/// - texttospeech:v1beta1 : AdvancedVoiceOptions
class $AdvancedVoiceOptions {
  /// Only for Journey voices.
  ///
  /// If false, the synthesis is context aware and has a higher latency.
  core.bool? lowLatencyJourneySynthesis;

  $AdvancedVoiceOptions({this.lowLatencyJourneySynthesis});

  $AdvancedVoiceOptions.fromJson(core.Map json_)
    : this(
        lowLatencyJourneySynthesis:
            json_['lowLatencyJourneySynthesis'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lowLatencyJourneySynthesis != null)
      'lowLatencyJourneySynthesis': lowLatencyJourneySynthesis!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : AdvertiserBillingConfig
/// - displayvideo:v4 : AdvertiserBillingConfig
class $AdvertiserBillingConfig {
  /// The ID of a billing profile assigned to the advertiser.
  ///
  /// Required.
  core.String? billingProfileId;

  $AdvertiserBillingConfig({this.billingProfileId});

  $AdvertiserBillingConfig.fromJson(core.Map json_)
    : this(billingProfileId: json_['billingProfileId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (billingProfileId != null) 'billingProfileId': billingProfileId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AdvertiserCreativeConfig
/// - displayvideo:v3 : AdvertiserCreativeConfig
/// - displayvideo:v4 : AdvertiserCreativeConfig
class $AdvertiserCreativeConfig {
  /// Whether or not the advertiser is enabled for dynamic creatives.
  core.bool? dynamicCreativeEnabled;

  /// An ID for configuring campaign monitoring provided by Integral Ad Service
  /// (IAS).
  ///
  /// The DV360 system will append an IAS "Campaign Monitor" tag containing this
  /// ID to the creative tag.
  core.String? iasClientId;

  /// Whether or not to disable Google's About this Ad feature that adds badging
  /// (to identify the content as an ad) and transparency information (on
  /// interaction with About this Ad) to your ads for Online Behavioral
  /// Advertising (OBA) and regulatory requirements.
  ///
  /// About this Ad gives users greater control over the ads they see and helps
  /// you explain why they're seeing your ad. \[Learn
  /// more\](//support.google.com/displayvideo/answer/14315795). If you choose
  /// to set this field to `true`, note that ads served through Display & Video
  /// 360 must comply to the following: * Be Online Behavioral Advertising (OBA)
  /// compliant, as per your contract with Google Marketing Platform. * In the
  /// European Economic Area (EEA), include transparency information and a
  /// mechanism for users to report illegal content in ads. If using an
  /// alternative ad badging, transparency, and reporting solution, you must
  /// ensure it includes the required transparency information and illegal
  /// content flagging mechanism and that you notify Google of any illegal
  /// content reports using the appropriate
  /// \[form\](//support.google.com/legal/troubleshooter/1114905?sjid=6787484030557261960-EU#ts=2981967%2C2982031%2C12980091).
  core.bool? obaComplianceDisabled;

  /// By setting this field to `true`, you, on behalf of your company, authorize
  /// Google to use video creatives associated with this Display & Video 360
  /// advertiser to provide reporting and features related to the advertiser's
  /// television campaigns.
  ///
  /// Applicable only when the advertiser has a CM360 hybrid ad server
  /// configuration.
  core.bool? videoCreativeDataSharingAuthorized;

  $AdvertiserCreativeConfig({
    this.dynamicCreativeEnabled,
    this.iasClientId,
    this.obaComplianceDisabled,
    this.videoCreativeDataSharingAuthorized,
  });

  $AdvertiserCreativeConfig.fromJson(core.Map json_)
    : this(
        dynamicCreativeEnabled: json_['dynamicCreativeEnabled'] as core.bool?,
        iasClientId: json_['iasClientId'] as core.String?,
        obaComplianceDisabled: json_['obaComplianceDisabled'] as core.bool?,
        videoCreativeDataSharingAuthorized:
            json_['videoCreativeDataSharingAuthorized'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dynamicCreativeEnabled != null)
      'dynamicCreativeEnabled': dynamicCreativeEnabled!,
    if (iasClientId != null) 'iasClientId': iasClientId!,
    if (obaComplianceDisabled != null)
      'obaComplianceDisabled': obaComplianceDisabled!,
    if (videoCreativeDataSharingAuthorized != null)
      'videoCreativeDataSharingAuthorized': videoCreativeDataSharingAuthorized!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AdvertiserGeneralConfig
/// - displayvideo:v3 : AdvertiserGeneralConfig
/// - displayvideo:v4 : AdvertiserGeneralConfig
class $AdvertiserGeneralConfig {
  /// Advertiser's currency in ISO 4217 format.
  ///
  /// Accepted codes and the currencies they represent are: Currency Code :
  /// Currency Name * `ARS` : Argentine Peso * `AUD` : Australian Dollar * `BRL`
  /// : Brazilian Real * `CAD` : Canadian Dollar * `CHF` : Swiss Franc * `CLP` :
  /// Chilean Peso * `CNY` : Chinese Yuan * `COP` : Colombian Peso * `CZK` :
  /// Czech Koruna * `DKK` : Danish Krone * `EGP` : Egyption Pound * `EUR` :
  /// Euro * `GBP` : British Pound * `HKD` : Hong Kong Dollar * `HUF` :
  /// Hungarian Forint * `IDR` : Indonesian Rupiah * `ILS` : Israeli Shekel *
  /// `INR` : Indian Rupee * `JPY` : Japanese Yen * `KRW` : South Korean Won *
  /// `MXN` : Mexican Pesos * `MYR` : Malaysian Ringgit * `NGN` : Nigerian Naira
  /// * `NOK` : Norwegian Krone * `NZD` : New Zealand Dollar * `PEN` : Peruvian
  /// Nuevo Sol * `PLN` : Polish Zloty * `RON` : New Romanian Leu * `RUB` :
  /// Russian Ruble * `SEK` : Swedish Krona * `TRY` : Turkish Lira * `TWD` : New
  /// Taiwan Dollar * `USD` : US Dollar * `ZAR` : South African Rand
  ///
  /// Required. Immutable.
  core.String? currencyCode;

  /// The domain URL of the advertiser's primary website.
  ///
  /// The system will send this information to publishers that require website
  /// URL to associate a campaign with an advertiser. Provide a URL with no path
  /// or query string, beginning with `http:` or `https:`. For example,
  /// http://www.example.com
  ///
  /// Required.
  core.String? domainUrl;

  /// The standard TZ database name of the advertiser's time zone.
  ///
  /// For example, `America/New_York`. See more at:
  /// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones For CM360
  /// hybrid advertisers, the time zone is the same as that of the associated
  /// CM360 account; for third-party only advertisers, the time zone is the same
  /// as that of the parent partner.
  ///
  /// Output only.
  core.String? timeZone;

  $AdvertiserGeneralConfig({this.currencyCode, this.domainUrl, this.timeZone});

  $AdvertiserGeneralConfig.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        domainUrl: json_['domainUrl'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (domainUrl != null) 'domainUrl': domainUrl!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AdvertiserTargetingConfig
/// - displayvideo:v3 : AdvertiserTargetingConfig
/// - displayvideo:v4 : AdvertiserTargetingConfig
class $AdvertiserTargetingConfig {
  /// Whether or not connected TV devices are exempt from viewability targeting
  /// for all video line items under the advertiser.
  core.bool? exemptTvFromViewabilityTargeting;

  $AdvertiserTargetingConfig({this.exemptTvFromViewabilityTargeting});

  $AdvertiserTargetingConfig.fromJson(core.Map json_)
    : this(
        exemptTvFromViewabilityTargeting:
            json_['exemptTvFromViewabilityTargeting'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exemptTvFromViewabilityTargeting != null)
      'exemptTvFromViewabilityTargeting': exemptTvFromViewabilityTargeting!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AgeRangeAssignedTargetingOptionDetails
/// - displayvideo:v3 : AgeRangeAssignedTargetingOptionDetails
/// - displayvideo:v4 : AgeRangeAssignedTargetingOptionDetails
class $AgeRangeAssignedTargetingOptionDetails {
  /// The age range of an audience.
  ///
  /// We only support targeting a continuous age range of an audience. Thus, the
  /// age range represented in this field can be 1) targeted solely, or, 2) part
  /// of a larger continuous age range. The reach of a continuous age range
  /// targeting can be expanded by also targeting an audience of an unknown age.
  ///
  /// Required.
  /// Possible string values are:
  /// - "AGE_RANGE_UNSPECIFIED" : Default value when age range is not specified
  /// in this version. This enum is a placeholder for default value and does not
  /// represent a real age range option.
  /// - "AGE_RANGE_18_24" : The age range of the audience is 18 to 24.
  /// - "AGE_RANGE_25_34" : The age range of the audience is 25 to 34.
  /// - "AGE_RANGE_35_44" : The age range of the audience is 35 to 44.
  /// - "AGE_RANGE_45_54" : The age range of the audience is 45 to 54.
  /// - "AGE_RANGE_55_64" : The age range of the audience is 55 to 64.
  /// - "AGE_RANGE_65_PLUS" : The age range of the audience is 65 and up.
  /// - "AGE_RANGE_UNKNOWN" : The age range of the audience is unknown.
  /// - "AGE_RANGE_18_20" : The age range of the audience is 18 to 20, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_21_24" : The age range of the audience is 21 to 24, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_25_29" : The age range of the audience is 25 to 29, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_30_34" : The age range of the audience is 30 to 34, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_35_39" : The age range of the audience is 35 to 39, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_40_44" : The age range of the audience is 40 to 44, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_45_49" : The age range of the audience is 45 to 49, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_50_54" : The age range of the audience is 50 to 54, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_55_59" : The age range of the audience is 55 to 59, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_60_64" : The age range of the audience is 60 to 64, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  core.String? ageRange;

  $AgeRangeAssignedTargetingOptionDetails({this.ageRange});

  $AgeRangeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(ageRange: json_['ageRange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ageRange != null) 'ageRange': ageRange!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AgeRangeTargetingOptionDetails
/// - displayvideo:v3 : AgeRangeTargetingOptionDetails
/// - displayvideo:v4 : AgeRangeTargetingOptionDetails
class $AgeRangeTargetingOptionDetails {
  /// The age range of an audience.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AGE_RANGE_UNSPECIFIED" : Default value when age range is not specified
  /// in this version. This enum is a placeholder for default value and does not
  /// represent a real age range option.
  /// - "AGE_RANGE_18_24" : The age range of the audience is 18 to 24.
  /// - "AGE_RANGE_25_34" : The age range of the audience is 25 to 34.
  /// - "AGE_RANGE_35_44" : The age range of the audience is 35 to 44.
  /// - "AGE_RANGE_45_54" : The age range of the audience is 45 to 54.
  /// - "AGE_RANGE_55_64" : The age range of the audience is 55 to 64.
  /// - "AGE_RANGE_65_PLUS" : The age range of the audience is 65 and up.
  /// - "AGE_RANGE_UNKNOWN" : The age range of the audience is unknown.
  /// - "AGE_RANGE_18_20" : The age range of the audience is 18 to 20, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_21_24" : The age range of the audience is 21 to 24, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_25_29" : The age range of the audience is 25 to 29, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_30_34" : The age range of the audience is 30 to 34, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_35_39" : The age range of the audience is 35 to 39, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_40_44" : The age range of the audience is 40 to 44, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_45_49" : The age range of the audience is 45 to 49, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_50_54" : The age range of the audience is 50 to 54, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_55_59" : The age range of the audience is 55 to 59, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  /// - "AGE_RANGE_60_64" : The age range of the audience is 60 to 64, only
  /// supported for the AdGroup of YouTube Programmatic Reservation line item.
  core.String? ageRange;

  $AgeRangeTargetingOptionDetails({this.ageRange});

  $AgeRangeTargetingOptionDetails.fromJson(core.Map json_)
    : this(ageRange: json_['ageRange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ageRange != null) 'ageRange': ageRange!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentAnswerFeedbackSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AgentAnswerFeedbackSettings
class $AgentAnswerFeedbackSettings {
  /// If enabled, end users will be able to provide answer feedback to
  /// Dialogflow responses.
  ///
  /// Feature works only if interaction logging is enabled in the Dialogflow
  /// agent.
  ///
  /// Optional.
  core.bool? enableAnswerFeedback;

  $AgentAnswerFeedbackSettings({this.enableAnswerFeedback});

  $AgentAnswerFeedbackSettings.fromJson(core.Map json_)
    : this(enableAnswerFeedback: json_['enableAnswerFeedback'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableAnswerFeedback != null)
      'enableAnswerFeedback': enableAnswerFeedback!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2AgentAssistantFeedbackKnowledgeAssistFeedback
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1AgentAssistantFeedbackKnowledgeAssistFeedback
class $AgentAssistantFeedbackKnowledgeAssistFeedback {
  /// Whether the suggested answer was copied by the human agent.
  ///
  /// If the value is set to be true, AnswerFeedback.clicked will be updated to
  /// be true.
  core.bool? answerCopied;

  /// The URIs clicked by the human agent.
  ///
  /// The value is appended for each UpdateAnswerRecordRequest. If the value is
  /// not empty, AnswerFeedback.clicked will be updated to be true.
  core.List<core.String>? clickedUris;

  $AgentAssistantFeedbackKnowledgeAssistFeedback({
    this.answerCopied,
    this.clickedUris,
  });

  $AgentAssistantFeedbackKnowledgeAssistFeedback.fromJson(core.Map json_)
    : this(
        answerCopied: json_['answerCopied'] as core.bool?,
        clickedUris:
            (json_['clickedUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerCopied != null) 'answerCopied': answerCopied!,
    if (clickedUris != null) 'clickedUris': clickedUris!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2AgentAssistantFeedbackKnowledgeSearchFeedback
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1AgentAssistantFeedbackKnowledgeSearchFeedback
class $AgentAssistantFeedbackKnowledgeSearchFeedback {
  /// Whether the answer was copied by the human agent or not.
  ///
  /// If the value is set to be true, AnswerFeedback.clicked will be updated to
  /// be true.
  core.bool? answerCopied;

  /// The URIs clicked by the human agent.
  ///
  /// The value is appended for each UpdateAnswerRecordRequest. If the value is
  /// not empty, AnswerFeedback.clicked will be updated to be true.
  core.List<core.String>? clickedUris;

  $AgentAssistantFeedbackKnowledgeSearchFeedback({
    this.answerCopied,
    this.clickedUris,
  });

  $AgentAssistantFeedbackKnowledgeSearchFeedback.fromJson(core.Map json_)
    : this(
        answerCopied: json_['answerCopied'] as core.bool?,
        clickedUris:
            (json_['clickedUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerCopied != null) 'answerCopied': answerCopied!,
    if (clickedUris != null) 'clickedUris': clickedUris!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentClientCertificateSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AgentClientCertificateSettings
class $AgentClientCertificateSettings {
  /// The name of the SecretManager secret version resource storing the
  /// passphrase.
  ///
  /// 'passphrase' should be left unset if the private key is not encrypted.
  /// Format: `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Optional.
  core.String? passphrase;

  /// The name of the SecretManager secret version resource storing the private
  /// key encoded in PEM format.
  ///
  /// Format: `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Required.
  core.String? privateKey;

  /// The ssl certificate encoded in PEM format.
  ///
  /// This string must include the begin header and end footer lines.
  ///
  /// Required.
  core.String? sslCertificate;

  $AgentClientCertificateSettings({
    this.passphrase,
    this.privateKey,
    this.sslCertificate,
  });

  $AgentClientCertificateSettings.fromJson(core.Map json_)
    : this(
        passphrase: json_['passphrase'] as core.String?,
        privateKey: json_['privateKey'] as core.String?,
        sslCertificate: json_['sslCertificate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (passphrase != null) 'passphrase': passphrase!,
    if (privateKey != null) 'privateKey': privateKey!,
    if (sslCertificate != null) 'sslCertificate': sslCertificate!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentGenAppBuilderSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AgentGenAppBuilderSettings
class $AgentGenAppBuilderSettings {
  /// The full name of the Gen App Builder engine related to this agent if there
  /// is one.
  ///
  /// Format: `projects/{Project ID}/locations/{Location
  /// ID}/collections/{Collection ID}/engines/{Engine ID}`
  ///
  /// Required.
  core.String? engine;

  $AgentGenAppBuilderSettings({this.engine});

  $AgentGenAppBuilderSettings.fromJson(core.Map json_)
    : this(engine: json_['engine'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (engine != null) 'engine': engine!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentGitIntegrationSettingsGithubSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AgentGitIntegrationSettingsGithubSettings
class $AgentGitIntegrationSettingsGithubSettings {
  /// The access token used to authenticate the access to the GitHub repository.
  core.String? accessToken;

  /// A list of branches configured to be used from Dialogflow.
  core.List<core.String>? branches;

  /// The unique repository display name for the GitHub repository.
  core.String? displayName;

  /// The GitHub repository URI related to the agent.
  core.String? repositoryUri;

  /// The branch of the GitHub repository tracked for this agent.
  core.String? trackingBranch;

  $AgentGitIntegrationSettingsGithubSettings({
    this.accessToken,
    this.branches,
    this.displayName,
    this.repositoryUri,
    this.trackingBranch,
  });

  $AgentGitIntegrationSettingsGithubSettings.fromJson(core.Map json_)
    : this(
        accessToken: json_['accessToken'] as core.String?,
        branches:
            (json_['branches'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        displayName: json_['displayName'] as core.String?,
        repositoryUri: json_['repositoryUri'] as core.String?,
        trackingBranch: json_['trackingBranch'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'accessToken': accessToken!,
    if (branches != null) 'branches': branches!,
    if (displayName != null) 'displayName': displayName!,
    if (repositoryUri != null) 'repositoryUri': repositoryUri!,
    if (trackingBranch != null) 'trackingBranch': trackingBranch!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentPersonalizationSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AgentPersonalizationSettings
class $AgentPersonalizationSettings {
  /// Default end user metadata, used when processing DetectIntent requests.
  ///
  /// Recommended to be filled as a template instead of hard-coded value, for
  /// example { "age": "$session.params.age" }. The data will be merged with the
  /// QueryParameters.end_user_metadata in DetectIntentRequest.query_params
  /// during query processing.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? defaultEndUserMetadata;

  $AgentPersonalizationSettings({this.defaultEndUserMetadata});

  $AgentPersonalizationSettings.fromJson(core.Map json_)
    : this(
        defaultEndUserMetadata:
            json_.containsKey('defaultEndUserMetadata')
                ? json_['defaultEndUserMetadata']
                    as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultEndUserMetadata != null)
      'defaultEndUserMetadata': defaultEndUserMetadata!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AggregationHistogram
/// - migrationcenter:v1alpha1 : AggregationHistogram
class $AggregationHistogram {
  /// Lower bounds of buckets.
  ///
  /// The response will contain `n+1` buckets for `n` bounds. The first bucket
  /// will count all assets for which the field value is smaller than the first
  /// bound. Subsequent buckets will count assets for which the field value is
  /// greater or equal to a lower bound and smaller than the next one. The last
  /// bucket will count assets for which the field value is greater or equal to
  /// the final lower bound. You can define up to 20 lower bounds.
  core.List<core.double>? lowerBounds;

  $AggregationHistogram({this.lowerBounds});

  $AggregationHistogram.fromJson(core.Map json_)
    : this(
        lowerBounds:
            (json_['lowerBounds'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lowerBounds != null) 'lowerBounds': lowerBounds!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AggregationResultCount
/// - migrationcenter:v1alpha1 : AggregationResultCount
class $AggregationResultCount {
  core.String? value;

  $AggregationResultCount({this.value});

  $AggregationResultCount.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AggregationResultFrequency
/// - migrationcenter:v1alpha1 : AggregationResultFrequency
class $AggregationResultFrequency {
  core.Map<core.String, core.String>? values;

  $AggregationResultFrequency({this.values});

  $AggregationResultFrequency.fromJson(core.Map json_)
    : this(
        values: (json_['values'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AggregationResultHistogramBucket
/// - migrationcenter:v1alpha1 : AggregationResultHistogramBucket
class $AggregationResultHistogramBucket {
  /// Count of items in the bucket.
  core.String? count;

  /// Lower bound - inclusive.
  core.double? lowerBound;

  /// Upper bound - exclusive.
  core.double? upperBound;

  $AggregationResultHistogramBucket({
    this.count,
    this.lowerBound,
    this.upperBound,
  });

  $AggregationResultHistogramBucket.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        lowerBound: (json_['lowerBound'] as core.num?)?.toDouble(),
        upperBound: (json_['upperBound'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (lowerBound != null) 'lowerBound': lowerBound!,
    if (upperBound != null) 'upperBound': upperBound!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AggregationResultSum
/// - migrationcenter:v1alpha1 : AggregationResultSum
class $AggregationResultSum {
  core.double? value;

  $AggregationResultSum({this.value});

  $AggregationResultSum.fromJson(core.Map json_)
    : this(value: (json_['value'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - composer:v1 : AirflowMetadataRetentionPolicyConfig
/// - composer:v1beta1 : AirflowMetadataRetentionPolicyConfig
class $AirflowMetadataRetentionPolicyConfig {
  /// How many days data should be retained for.
  ///
  /// Optional.
  core.int? retentionDays;

  /// Retention can be either enabled or disabled.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "RETENTION_MODE_UNSPECIFIED" : Default mode doesn't change environment
  /// parameters.
  /// - "RETENTION_MODE_ENABLED" : Retention policy is enabled.
  /// - "RETENTION_MODE_DISABLED" : Retention policy is disabled.
  core.String? retentionMode;

  $AirflowMetadataRetentionPolicyConfig({
    this.retentionDays,
    this.retentionMode,
  });

  $AirflowMetadataRetentionPolicyConfig.fromJson(core.Map json_)
    : this(
        retentionDays: json_['retentionDays'] as core.int?,
        retentionMode: json_['retentionMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (retentionDays != null) 'retentionDays': retentionDays!,
    if (retentionMode != null) 'retentionMode': retentionMode!,
  };
}

/// Used by:
///
/// - retail:v2alpha : GoogleCloudRetailV2alphaAlertConfigAlertPolicyRecipient
/// - retail:v2beta : GoogleCloudRetailV2betaAlertConfigAlertPolicyRecipient
class $AlertConfigAlertPolicyRecipient {
  /// Email address of the recipient.
  core.String? emailAddress;

  $AlertConfigAlertPolicyRecipient({this.emailAddress});

  $AlertConfigAlertPolicyRecipient.fromJson(core.Map json_)
    : this(emailAddress: json_['emailAddress'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (emailAddress != null) 'emailAddress': emailAddress!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : AliasContext
/// - containeranalysis:v1alpha1 : GoogleDevtoolsContaineranalysisV1alpha1AliasContext
/// - containeranalysis:v1beta1 : AliasContext
/// - ondemandscanning:v1 : AliasContext
/// - ondemandscanning:v1beta1 : AliasContext
class $AliasContext {
  /// The alias kind.
  /// Possible string values are:
  /// - "KIND_UNSPECIFIED" : Unknown.
  /// - "FIXED" : Git tag.
  /// - "MOVABLE" : Git branch.
  /// - "OTHER" : Used to specify non-standard aliases. For example, if a Git
  /// repo has a ref named "refs/foo/bar".
  core.String? kind;

  /// The alias name.
  core.String? name;

  $AliasContext({this.kind, this.name});

  $AliasContext.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : AliasIpRange
/// - compute:beta : AliasIpRange
/// - compute:v1 : AliasIpRange
class $AliasIpRange {
  /// The IP alias ranges to allocate for this interface.
  ///
  /// This IP CIDR range must belong to the specified subnetwork and cannot
  /// contain IP addresses reserved by system or used by other network
  /// interfaces. This range may be a single IP address (such as 10.2.3.4), a
  /// netmask (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
  core.String? ipCidrRange;

  /// The name of a subnetwork secondary IP range from which to allocate an IP
  /// alias range.
  ///
  /// If not specified, the primary range of the subnetwork is used.
  core.String? subnetworkRangeName;

  $AliasIpRange({this.ipCidrRange, this.subnetworkRangeName});

  $AliasIpRange.fromJson(core.Map json_)
    : this(
        ipCidrRange: json_['ipCidrRange'] as core.String?,
        subnetworkRangeName: json_['subnetworkRangeName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
    if (subnetworkRangeName != null)
      'subnetworkRangeName': subnetworkRangeName!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : AllocatedConnection
/// - beyondcorp:v1alpha : AllocatedConnection
class $AllocatedConnection {
  /// The ingress port of an allocated connection
  ///
  /// Required.
  core.int? ingressPort;

  /// The PSC uri of an allocated connection
  ///
  /// Required.
  core.String? pscUri;

  $AllocatedConnection({this.ingressPort, this.pscUri});

  $AllocatedConnection.fromJson(core.Map json_)
    : this(
        ingressPort: json_['ingressPort'] as core.int?,
        pscUri: json_['pscUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ingressPort != null) 'ingressPort': ingressPort!,
    if (pscUri != null) 'pscUri': pscUri!,
  };
}

/// Used by:
///
/// - compute:alpha : AllocationAggregateReservationReservedResourceInfoAccelerator
/// - compute:beta : AllocationAggregateReservationReservedResourceInfoAccelerator
/// - compute:v1 : AllocationAggregateReservationReservedResourceInfoAccelerator
class $AllocationAggregateReservationReservedResourceInfoAccelerator {
  /// Number of accelerators of specified type.
  core.int? acceleratorCount;

  /// Full or partial URL to accelerator type.
  ///
  /// e.g. "projects/{PROJECT}/zones/{ZONE}/acceleratorTypes/ct4l"
  core.String? acceleratorType;

  $AllocationAggregateReservationReservedResourceInfoAccelerator({
    this.acceleratorCount,
    this.acceleratorType,
  });

  $AllocationAggregateReservationReservedResourceInfoAccelerator.fromJson(
    core.Map json_,
  ) : this(
        acceleratorCount: json_['acceleratorCount'] as core.int?,
        acceleratorType: json_['acceleratorType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
    if (acceleratorType != null) 'acceleratorType': acceleratorType!,
  };
}

/// Used by:
///
/// - compute:alpha : AllocationReservationSharingPolicy
/// - compute:beta : AllocationReservationSharingPolicy
/// - compute:v1 : AllocationReservationSharingPolicy
class $AllocationReservationSharingPolicy {
  /// Sharing config for all Google Cloud services.
  /// Possible string values are:
  /// - "ALLOW_ALL" : Allow all Google Cloud managed services to share
  /// reservations.
  /// - "DISALLOW_ALL" : \[Default\] Disallow sharing with all Google Cloud
  /// services.
  /// - "SERVICE_SHARE_TYPE_UNSPECIFIED"
  core.String? serviceShareType;

  $AllocationReservationSharingPolicy({this.serviceShareType});

  $AllocationReservationSharingPolicy.fromJson(core.Map json_)
    : this(serviceShareType: json_['serviceShareType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceShareType != null) 'serviceShareType': serviceShareType!,
  };
}

/// Used by:
///
/// - compute:alpha : AllocationResourceStatusHealthInfo
/// - compute:beta : AllocationResourceStatusHealthInfo
/// - compute:v1 : AllocationResourceStatusHealthInfo
class $AllocationResourceStatusHealthInfo {
  /// The number of reservation blocks that are degraded.
  core.int? degradedBlockCount;

  /// The health status of the reservation.
  /// Possible string values are:
  /// - "DEGRADED" : The reservation is degraded.
  /// - "HEALTHY" : The reservation is healthy.
  /// - "HEALTH_STATUS_UNSPECIFIED" : The health status of the reservation is
  /// unspecified.
  core.String? healthStatus;

  /// The number of reservation blocks that are healthy.
  core.int? healthyBlockCount;

  $AllocationResourceStatusHealthInfo({
    this.degradedBlockCount,
    this.healthStatus,
    this.healthyBlockCount,
  });

  $AllocationResourceStatusHealthInfo.fromJson(core.Map json_)
    : this(
        degradedBlockCount: json_['degradedBlockCount'] as core.int?,
        healthStatus: json_['healthStatus'] as core.String?,
        healthyBlockCount: json_['healthyBlockCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (degradedBlockCount != null) 'degradedBlockCount': degradedBlockCount!,
    if (healthStatus != null) 'healthStatus': healthStatus!,
    if (healthyBlockCount != null) 'healthyBlockCount': healthyBlockCount!,
  };
}

/// Used by:
///
/// - compute:alpha : AllocationResourceStatusSpecificSKUAllocation
/// - compute:beta : AllocationResourceStatusSpecificSKUAllocation
/// - compute:v1 : AllocationResourceStatusSpecificSKUAllocation
class $AllocationResourceStatusSpecificSKUAllocation {
  /// ID of the instance template used to populate reservation properties.
  core.String? sourceInstanceTemplateId;

  /// Per service utilization breakdown.
  ///
  /// The Key is the Google Cloud managed service name.
  core.Map<core.String, core.String>? utilizations;

  $AllocationResourceStatusSpecificSKUAllocation({
    this.sourceInstanceTemplateId,
    this.utilizations,
  });

  $AllocationResourceStatusSpecificSKUAllocation.fromJson(core.Map json_)
    : this(
        sourceInstanceTemplateId:
            json_['sourceInstanceTemplateId'] as core.String?,
        utilizations: (json_['utilizations']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceInstanceTemplateId != null)
      'sourceInstanceTemplateId': sourceInstanceTemplateId!,
    if (utilizations != null) 'utilizations': utilizations!,
  };
}

/// Used by:
///
/// - compute:beta : AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
/// - compute:v1 : AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
class $AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /// Specifies the size of the disk in base-2 GB.
  core.String? diskSizeGb;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME.
  ///
  /// The default is SCSI. For performance characteristics of SCSI over NVMe,
  /// see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String? interface;

  $AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk({
    this.diskSizeGb,
    this.interface,
  });

  $AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk.fromJson(
    core.Map json_,
  ) : this(
        diskSizeGb: json_['diskSizeGb'] as core.String?,
        interface: json_['interface'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
    if (interface != null) 'interface': interface!,
  };
}

/// Used by:
///
/// - composer:v1 : AllowedIpRange
/// - composer:v1beta1 : AllowedIpRange
class $AllowedIpRange {
  /// User-provided description.
  ///
  /// It must contain at most 300 characters.
  ///
  /// Optional.
  core.String? description;

  /// IP address or range, defined using CIDR notation, of requests that this
  /// rule applies to.
  ///
  /// Examples: `192.168.1.1` or `192.168.0.0/16` or `2001:db8::/32` or
  /// `2001:0db8:0000:0042:0000:8a2e:0370:7334`. IP range prefixes should be
  /// properly truncated. For example, `1.2.3.4/24` should be truncated to
  /// `1.2.3.0/24`. Similarly, for IPv6, `2001:db8::1/32` should be truncated to
  /// `2001:db8::/32`.
  core.String? value;

  $AllowedIpRange({this.description, this.value});

  $AllowedIpRange.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - iamcredentials:v1 : ServiceAccountAllowedLocations
/// - iamcredentials:v1 : WorkforcePoolAllowedLocations
/// - iamcredentials:v1 : WorkloadIdentityPoolAllowedLocations
class $AllowedLocations {
  /// The hex encoded bitmap of the trust boundary locations
  ///
  /// Output only.
  core.String? encodedLocations;

  /// The human readable trust boundary locations.
  ///
  /// For example, \["us-central1", "europe-west1"\]
  ///
  /// Output only.
  core.List<core.String>? locations;

  $AllowedLocations({this.encodedLocations, this.locations});

  $AllowedLocations.fromJson(core.Map json_)
    : this(
        encodedLocations: json_['encodedLocations'] as core.String?,
        locations:
            (json_['locations'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encodedLocations != null) 'encodedLocations': encodedLocations!,
    if (locations != null) 'locations': locations!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AlloyDbSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAlloyDbSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAlloyDbSource
class $AlloyDbSource {
  /// The AlloyDB cluster to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? clusterId;

  /// The AlloyDB database to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? databaseId;

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters.
  ///
  /// Can be specified if one wants to have the AlloyDB export to a specific
  /// Cloud Storage directory. Ensure that the AlloyDB service account has the
  /// necessary Cloud Storage Admin permissions to access the specified Cloud
  /// Storage directory.
  core.String? gcsStagingDir;

  /// The AlloyDB location to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? locationId;

  /// The project ID that contains the AlloyDB source.
  ///
  /// Has a length limit of 128 characters. If not specified, inherits the
  /// project ID from the parent request.
  core.String? projectId;

  /// The AlloyDB table to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? tableId;

  $AlloyDbSource({
    this.clusterId,
    this.databaseId,
    this.gcsStagingDir,
    this.locationId,
    this.projectId,
    this.tableId,
  });

  $AlloyDbSource.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        databaseId: json_['databaseId'] as core.String?,
        gcsStagingDir: json_['gcsStagingDir'] as core.String?,
        locationId: json_['locationId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (databaseId != null) 'databaseId': databaseId!,
    if (gcsStagingDir != null) 'gcsStagingDir': gcsStagingDir!,
    if (locationId != null) 'locationId': locationId!,
    if (projectId != null) 'projectId': projectId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// Used by:
///
/// - metastore:v1 : AlterMetadataResourceLocationRequest
/// - metastore:v1alpha : AlterMetadataResourceLocationRequest
/// - metastore:v1beta : AlterMetadataResourceLocationRequest
class $AlterMetadataResourceLocationRequest {
  /// The new location URI for the metadata resource.
  ///
  /// Required.
  core.String? locationUri;

  /// The relative metadata resource name in the following
  /// format.databases/{database_id} or
  /// databases/{database_id}/tables/{table_id} or
  /// databases/{database_id}/tables/{table_id}/partitions/{partition_id}
  ///
  /// Required.
  core.String? resourceName;

  $AlterMetadataResourceLocationRequest({this.locationUri, this.resourceName});

  $AlterMetadataResourceLocationRequest.fromJson(core.Map json_)
    : this(
        locationUri: json_['locationUri'] as core.String?,
        resourceName: json_['resourceName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (locationUri != null) 'locationUri': locationUri!,
    if (resourceName != null) 'resourceName': resourceName!,
  };
}

/// Used by:
///
/// - metastore:v1 : AlterTablePropertiesRequest
/// - metastore:v1alpha : AlterTablePropertiesRequest
/// - metastore:v1beta : AlterTablePropertiesRequest
class $AlterTablePropertiesRequest {
  /// A map that describes the desired values to mutate.
  ///
  /// If update_mask is empty, the properties will not update. Otherwise, the
  /// properties only alters the value whose associated paths exist in the
  /// update mask
  core.Map<core.String, core.String>? properties;

  /// The name of the table containing the properties you're altering in the
  /// following format.databases/{database_id}/tables/{table_id}
  ///
  /// Required.
  core.String? tableName;

  /// A field mask that specifies the metadata table properties that are
  /// overwritten by the update.
  ///
  /// Fields specified in the update_mask are relative to the resource (not to
  /// the full request). A field is overwritten if it is in the mask.For
  /// example, given the target properties: properties { a: 1 b: 2 } And an
  /// update properties: properties { a: 2 b: 3 c: 4 } then if the field mask
  /// is:paths: "properties.b", "properties.c"then the result will be:
  /// properties { a: 1 b: 3 c: 4 }
  core.String? updateMask;

  $AlterTablePropertiesRequest({
    this.properties,
    this.tableName,
    this.updateMask,
  });

  $AlterTablePropertiesRequest.fromJson(core.Map json_)
    : this(
        properties: (json_['properties']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        tableName: json_['tableName'] as core.String?,
        updateMask: json_['updateMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (properties != null) 'properties': properties!,
    if (tableName != null) 'tableName': tableName!,
    if (updateMask != null) 'updateMask': updateMask!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : AnalysisCompleted
/// - containeranalysis:v1beta1 : AnalysisCompleted
/// - ondemandscanning:v1 : AnalysisCompleted
/// - ondemandscanning:v1beta1 : AnalysisCompleted
class $AnalysisCompleted {
  core.List<core.String>? analysisType;

  $AnalysisCompleted({this.analysisType});

  $AnalysisCompleted.fromJson(core.Map json_)
    : this(
        analysisType:
            (json_['analysisType'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (analysisType != null) 'analysisType': analysisType!,
  };
}

/// Used by:
///
/// - healthcare:v1 : AnalyzeEntitiesRequest
/// - healthcare:v1beta1 : AnalyzeEntitiesRequest
class $AnalyzeEntitiesRequest {
  /// Alternative output format to be generated based on the results of
  /// analysis.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ALTERNATIVE_OUTPUT_FORMAT_UNSPECIFIED" : No alternative output format
  /// is specified.
  /// - "FHIR_BUNDLE" : FHIR bundle output.
  core.String? alternativeOutputFormat;

  /// document_content is a document to be annotated.
  core.String? documentContent;

  /// A list of licensed vocabularies to use in the request, in addition to the
  /// default unlicensed vocabularies.
  core.List<core.String>? licensedVocabularies;

  $AnalyzeEntitiesRequest({
    this.alternativeOutputFormat,
    this.documentContent,
    this.licensedVocabularies,
  });

  $AnalyzeEntitiesRequest.fromJson(core.Map json_)
    : this(
        alternativeOutputFormat:
            json_['alternativeOutputFormat'] as core.String?,
        documentContent: json_['documentContent'] as core.String?,
        licensedVocabularies:
            (json_['licensedVocabularies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alternativeOutputFormat != null)
      'alternativeOutputFormat': alternativeOutputFormat!,
    if (documentContent != null) 'documentContent': documentContent!,
    if (licensedVocabularies != null)
      'licensedVocabularies': licensedVocabularies!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1AndroidAttributes
/// - cloudidentity:v1beta1 : AndroidAttributes
class $AndroidAttributes {
  /// Whether the device passes Android CTS compliance.
  core.bool? ctsProfileMatch;

  /// Whether applications from unknown sources can be installed on device.
  core.bool? enabledUnknownSources;

  /// Whether any potentially harmful apps were detected on the device.
  core.bool? hasPotentiallyHarmfulApps;

  /// Whether this account is on an owner/primary profile.
  ///
  /// For phones, only true for owner profiles. Android 4+ devices can have
  /// secondary or restricted user profiles.
  core.bool? ownerProfileAccount;

  /// Ownership privileges on device.
  /// Possible string values are:
  /// - "OWNERSHIP_PRIVILEGE_UNSPECIFIED" : Ownership privilege is not set.
  /// - "DEVICE_ADMINISTRATOR" : Active device administrator privileges on the
  /// device.
  /// - "PROFILE_OWNER" : Profile Owner privileges. The account is in a managed
  /// corporate profile.
  /// - "DEVICE_OWNER" : Device Owner privileges on the device.
  core.String? ownershipPrivilege;

  /// Whether device supports Android work profiles.
  ///
  /// If false, this service will not block access to corp data even if an
  /// administrator turns on the "Enforce Work Profile" policy.
  core.bool? supportsWorkProfile;

  /// Whether Android verified boot status is GREEN.
  core.bool? verifiedBoot;

  /// Whether Google Play Protect Verify Apps is enabled.
  core.bool? verifyAppsEnabled;

  $AndroidAttributes({
    this.ctsProfileMatch,
    this.enabledUnknownSources,
    this.hasPotentiallyHarmfulApps,
    this.ownerProfileAccount,
    this.ownershipPrivilege,
    this.supportsWorkProfile,
    this.verifiedBoot,
    this.verifyAppsEnabled,
  });

  $AndroidAttributes.fromJson(core.Map json_)
    : this(
        ctsProfileMatch: json_['ctsProfileMatch'] as core.bool?,
        enabledUnknownSources: json_['enabledUnknownSources'] as core.bool?,
        hasPotentiallyHarmfulApps:
            json_['hasPotentiallyHarmfulApps'] as core.bool?,
        ownerProfileAccount: json_['ownerProfileAccount'] as core.bool?,
        ownershipPrivilege: json_['ownershipPrivilege'] as core.String?,
        supportsWorkProfile: json_['supportsWorkProfile'] as core.bool?,
        verifiedBoot: json_['verifiedBoot'] as core.bool?,
        verifyAppsEnabled: json_['verifyAppsEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ctsProfileMatch != null) 'ctsProfileMatch': ctsProfileMatch!,
    if (enabledUnknownSources != null)
      'enabledUnknownSources': enabledUnknownSources!,
    if (hasPotentiallyHarmfulApps != null)
      'hasPotentiallyHarmfulApps': hasPotentiallyHarmfulApps!,
    if (ownerProfileAccount != null)
      'ownerProfileAccount': ownerProfileAccount!,
    if (ownershipPrivilege != null) 'ownershipPrivilege': ownershipPrivilege!,
    if (supportsWorkProfile != null)
      'supportsWorkProfile': supportsWorkProfile!,
    if (verifiedBoot != null) 'verifiedBoot': verifiedBoot!,
    if (verifyAppsEnabled != null) 'verifyAppsEnabled': verifyAppsEnabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AnnotationSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AnnotationSpec
class $AnnotationSpec {
  /// Timestamp when this AnnotationSpec was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the AnnotationSpec.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Resource name of the AnnotationSpec.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when AnnotationSpec was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $AnnotationSpec({
    this.createTime,
    this.displayName,
    this.etag,
    this.name,
    this.updateTime,
  });

  $AnnotationSpec.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - container:v1 : AnonymousAuthenticationConfig
/// - container:v1beta1 : AnonymousAuthenticationConfig
class $AnonymousAuthenticationConfig {
  /// Defines the mode of limiting anonymous access in the cluster.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value not specified.
  /// - "ENABLED" : Anonymous authentication is allowed for all endpoints.
  /// - "LIMITED" : Anonymous authentication is allowed for only health check
  /// endpoints.
  core.String? mode;

  $AnonymousAuthenticationConfig({this.mode});

  $AnonymousAuthenticationConfig.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachmentBlob
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerBlobAttachmentBlob
class $AnswerBlobAttachmentBlob {
  /// Raw bytes.
  ///
  /// Output only.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The media type (MIME type) of the generated or retrieved data.
  ///
  /// Output only.
  core.String? mimeType;

  $AnswerBlobAttachmentBlob({this.data, this.mimeType});

  $AnswerBlobAttachmentBlob.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerCitationSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerCitationSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerCitationSource
class $AnswerCitationSource {
  /// ID of the citation source.
  core.String? referenceId;

  $AnswerCitationSource({this.referenceId});

  $AnswerCitationSource.fromJson(core.Map json_)
    : this(referenceId: json_['referenceId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (referenceId != null) 'referenceId': referenceId!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AnswerFeedbackRatingReason
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1AnswerFeedbackRatingReason
class $AnswerFeedbackRatingReason {
  /// Additional feedback about the rating.
  ///
  /// This field can be populated without choosing a predefined `reason`.
  ///
  /// Optional.
  core.String? feedback;

  /// Custom reason labels for thumbs down rating provided by the user.
  ///
  /// The maximum number of labels allowed is 10 and the maximum length of a
  /// single label is 128 characters.
  ///
  /// Optional.
  core.List<core.String>? reasonLabels;

  $AnswerFeedbackRatingReason({this.feedback, this.reasonLabels});

  $AnswerFeedbackRatingReason.fromJson(core.Map json_)
    : this(
        feedback: json_['feedback'] as core.String?,
        reasonLabels:
            (json_['reasonLabels'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (feedback != null) 'feedback': feedback!,
    if (reasonLabels != null) 'reasonLabels': reasonLabels!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerGenerationSpecUserDefinedClassifierSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpecUserDefinedClassifierSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerGenerationSpecUserDefinedClassifierSpec
class $AnswerGenerationSpecUserDefinedClassifierSpec {
  /// Whether or not to enable and include user defined classifier.
  ///
  /// Optional.
  core.bool? enableUserDefinedClassifier;

  /// The model id to be used for the user defined classifier.
  ///
  /// Optional.
  core.String? modelId;

  /// The preamble to be used for the user defined classifier.
  ///
  /// Optional.
  core.String? preamble;

  /// The seed value to be used for the user defined classifier.
  ///
  /// Optional.
  core.int? seed;

  /// The task marker to be used for the user defined classifier.
  ///
  /// Optional.
  core.String? taskMarker;

  /// The temperature value to be used for the user defined classifier.
  ///
  /// Optional.
  core.double? temperature;

  /// The top-k value to be used for the user defined classifier.
  ///
  /// Optional.
  core.String? topK;

  /// The top-p value to be used for the user defined classifier.
  ///
  /// Optional.
  core.double? topP;

  $AnswerGenerationSpecUserDefinedClassifierSpec({
    this.enableUserDefinedClassifier,
    this.modelId,
    this.preamble,
    this.seed,
    this.taskMarker,
    this.temperature,
    this.topK,
    this.topP,
  });

  $AnswerGenerationSpecUserDefinedClassifierSpec.fromJson(core.Map json_)
    : this(
        enableUserDefinedClassifier:
            json_['enableUserDefinedClassifier'] as core.bool?,
        modelId: json_['modelId'] as core.String?,
        preamble: json_['preamble'] as core.String?,
        seed: json_['seed'] as core.int?,
        taskMarker: json_['taskMarker'] as core.String?,
        temperature: (json_['temperature'] as core.num?)?.toDouble(),
        topK: json_['topK'] as core.String?,
        topP: (json_['topP'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableUserDefinedClassifier != null)
      'enableUserDefinedClassifier': enableUserDefinedClassifier!,
    if (modelId != null) 'modelId': modelId!,
    if (preamble != null) 'preamble': preamble!,
    if (seed != null) 'seed': seed!,
    if (taskMarker != null) 'taskMarker': taskMarker!,
    if (temperature != null) 'temperature': temperature!,
    if (topK != null) 'topK': topK!,
    if (topP != null) 'topP': topP!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestAnswerGenerationSpecModelSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecModelSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestAnswerGenerationSpecModelSpec
class $AnswerQueryRequestAnswerGenerationSpecModelSpec {
  /// Model version.
  ///
  /// If not set, it will use the default stable model. Allowed values are:
  /// stable, preview.
  core.String? modelVersion;

  $AnswerQueryRequestAnswerGenerationSpecModelSpec({this.modelVersion});

  $AnswerQueryRequestAnswerGenerationSpecModelSpec.fromJson(core.Map json_)
    : this(modelVersion: json_['modelVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelVersion != null) 'modelVersion': modelVersion!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestAnswerGenerationSpecPromptSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecPromptSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestAnswerGenerationSpecPromptSpec
class $AnswerQueryRequestAnswerGenerationSpecPromptSpec {
  /// Customized preamble.
  core.String? preamble;

  $AnswerQueryRequestAnswerGenerationSpecPromptSpec({this.preamble});

  $AnswerQueryRequestAnswerGenerationSpecPromptSpec.fromJson(core.Map json_)
    : this(preamble: json_['preamble'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (preamble != null) 'preamble': preamble!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata
class $AnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata {
  /// Title of the document.
  core.String? title;

  $AnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata({
    this.title,
  });

  $AnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata.fromJson(
    core.Map json_,
  ) : this(title: json_['title'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestGroundingSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestGroundingSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestGroundingSpec
class $AnswerQueryRequestGroundingSpec {
  /// Specifies whether to enable the filtering based on grounding score and at
  /// what level.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "FILTERING_LEVEL_UNSPECIFIED" : Default is no filter
  /// - "FILTERING_LEVEL_LOW" : Filter answers based on a low threshold.
  /// - "FILTERING_LEVEL_HIGH" : Filter answers based on a high threshold.
  core.String? filteringLevel;

  /// Specifies whether to include grounding_supports in the answer.
  ///
  /// The default value is `false`. When this field is set to `true`, returned
  /// answer will have `grounding_score` and will contain GroundingSupports for
  /// each claim.
  ///
  /// Optional.
  core.bool? includeGroundingSupports;

  $AnswerQueryRequestGroundingSpec({
    this.filteringLevel,
    this.includeGroundingSupports,
  });

  $AnswerQueryRequestGroundingSpec.fromJson(core.Map json_)
    : this(
        filteringLevel: json_['filteringLevel'] as core.String?,
        includeGroundingSupports:
            json_['includeGroundingSupports'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filteringLevel != null) 'filteringLevel': filteringLevel!,
    if (includeGroundingSupports != null)
      'includeGroundingSupports': includeGroundingSupports!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec
class $AnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec {
  /// Enabled query classification types.
  core.List<core.String>? types;

  $AnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec({
    this.types,
  });

  $AnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec.fromJson(
    core.Map json_,
  ) : this(
        types:
            (json_['types'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (types != null) 'types': types!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec
class $AnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec {
  /// Enabled query rephraser model type.
  ///
  /// If not set, it will use LARGE by default.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MODEL_TYPE_UNSPECIFIED" : Unspecified model type.
  /// - "SMALL" : Small query rephraser model. Gemini 1.0 XS model.
  /// - "LARGE" : Large query rephraser model. Gemini 1.0 Pro model.
  core.String? modelType;

  $AnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec({
    this.modelType,
  });

  $AnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec.fromJson(
    core.Map json_,
  ) : this(modelType: json_['modelType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelType != null) 'modelType': modelType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestRelatedQuestionsSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestRelatedQuestionsSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestRelatedQuestionsSpec
class $AnswerQueryRequestRelatedQuestionsSpec {
  /// Enable related questions feature if true.
  core.bool? enable;

  $AnswerQueryRequestRelatedQuestionsSpec({this.enable});

  $AnswerQueryRequestRelatedQuestionsSpec.fromJson(core.Map json_)
    : this(enable: json_['enable'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestSafetySpecSafetySetting
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpecSafetySetting
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestSafetySpecSafetySetting
class $AnswerQueryRequestSafetySpecSafetySetting {
  /// Harm category.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : The harm category is civic integrity.
  core.String? category;

  /// The harm block threshold.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_BLOCK_THRESHOLD_UNSPECIFIED" : Unspecified harm block threshold.
  /// - "BLOCK_LOW_AND_ABOVE" : Block low threshold and above (i.e. block more).
  /// - "BLOCK_MEDIUM_AND_ABOVE" : Block medium threshold and above.
  /// - "BLOCK_ONLY_HIGH" : Block only high threshold (i.e. block less).
  /// - "BLOCK_NONE" : Block none.
  /// - "OFF" : Turn off the safety filter.
  core.String? threshold;

  $AnswerQueryRequestSafetySpecSafetySetting({this.category, this.threshold});

  $AnswerQueryRequestSafetySpecSafetySetting.fromJson(core.Map json_)
    : this(
        category: json_['category'] as core.String?,
        threshold: json_['threshold'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (threshold != null) 'threshold': threshold!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata
class $AnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata {
  /// Title of the document.
  core.String? title;

  /// Uri of the document.
  core.String? uri;

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata({
    this.title,
    this.uri,
  });

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata.fromJson(
    core.Map json_,
  ) : this(
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext
class $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext {
  /// Document content to be used for answer generation.
  core.String? content;

  /// Page identifier.
  core.String? pageIdentifier;

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext({
    this.content,
    this.pageIdentifier,
  });

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext.fromJson(
    core.Map json_,
  ) : this(
        content: json_['content'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer
class $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer {
  /// Extractive answer content.
  core.String? content;

  /// Page identifier.
  core.String? pageIdentifier;

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer({
    this.content,
    this.pageIdentifier,
  });

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer.fromJson(
    core.Map json_,
  ) : this(
        content: json_['content'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment
class $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment {
  /// Extractive segment content.
  core.String? content;

  /// Page identifier.
  core.String? pageIdentifier;

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment({
    this.content,
    this.pageIdentifier,
  });

  $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment.fromJson(
    core.Map json_,
  ) : this(
        content: json_['content'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerQueryUnderstandingInfoQueryClassificationInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfoQueryClassificationInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryUnderstandingInfoQueryClassificationInfo
class $AnswerQueryUnderstandingInfoQueryClassificationInfo {
  /// Classification output.
  core.bool? positive;

  /// Query classification type.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified query classification type.
  /// - "ADVERSARIAL_QUERY" : Adversarial query classification type.
  /// - "NON_ANSWER_SEEKING_QUERY" : Non-answer-seeking query classification
  /// type, for chit chat.
  /// - "JAIL_BREAKING_QUERY" : Jail-breaking query classification type.
  /// - "NON_ANSWER_SEEKING_QUERY_V2" : Non-answer-seeking query classification
  /// type, for no clear intent.
  /// - "USER_DEFINED_CLASSIFICATION_QUERY" : User defined query classification
  /// type.
  core.String? type;

  $AnswerQueryUnderstandingInfoQueryClassificationInfo({
    this.positive,
    this.type,
  });

  $AnswerQueryUnderstandingInfoQueryClassificationInfo.fromJson(core.Map json_)
    : this(
        positive: json_['positive'] as core.bool?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (positive != null) 'positive': positive!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerReferenceChunkInfoDocumentMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfoDocumentMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerReferenceChunkInfoDocumentMetadata
class $AnswerReferenceChunkInfoDocumentMetadata {
  /// Document resource name.
  core.String? document;

  /// Page identifier.
  core.String? pageIdentifier;

  /// The structured JSON metadata for the document.
  ///
  /// It is populated from the struct data from the Chunk in search result.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  /// Title.
  core.String? title;

  /// URI for the document.
  core.String? uri;

  $AnswerReferenceChunkInfoDocumentMetadata({
    this.document,
    this.pageIdentifier,
    this.structData,
    this.title,
    this.uri,
  });

  $AnswerReferenceChunkInfoDocumentMetadata.fromJson(core.Map json_)
    : this(
        document: json_['document'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
    if (structData != null) 'structData': structData!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerReferenceStructuredDocumentInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerReferenceStructuredDocumentInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerReferenceStructuredDocumentInfo
class $AnswerReferenceStructuredDocumentInfo {
  /// Document resource name.
  core.String? document;

  /// Structured search data.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  /// The title of the document.
  ///
  /// Output only.
  core.String? title;

  /// The URI of the document.
  ///
  /// Output only.
  core.String? uri;

  $AnswerReferenceStructuredDocumentInfo({
    this.document,
    this.structData,
    this.title,
    this.uri,
  });

  $AnswerReferenceStructuredDocumentInfo.fromJson(core.Map json_)
    : this(
        document: json_['document'] as core.String?,
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (structData != null) 'structData': structData!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfoChunkContent
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerReferenceUnstructuredDocumentInfoChunkContent
class $AnswerReferenceUnstructuredDocumentInfoChunkContent {
  /// Stores indexes of blobattachments linked to this chunk.
  ///
  /// Output only.
  core.List<core.String>? blobAttachmentIndexes;

  /// Chunk textual content.
  core.String? content;

  /// Page identifier.
  core.String? pageIdentifier;

  /// The relevance of the chunk for a given query.
  ///
  /// Values range from 0.0 (completely irrelevant) to 1.0 (completely
  /// relevant). This value is for informational purpose only. It may change for
  /// the same query and chunk at any time due to a model retraining or change
  /// in implementation.
  core.double? relevanceScore;

  $AnswerReferenceUnstructuredDocumentInfoChunkContent({
    this.blobAttachmentIndexes,
    this.content,
    this.pageIdentifier,
    this.relevanceScore,
  });

  $AnswerReferenceUnstructuredDocumentInfoChunkContent.fromJson(core.Map json_)
    : this(
        blobAttachmentIndexes:
            (json_['blobAttachmentIndexes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        content: json_['content'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
        relevanceScore: (json_['relevanceScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobAttachmentIndexes != null)
      'blobAttachmentIndexes': blobAttachmentIndexes!,
    if (content != null) 'content': content!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
    if (relevanceScore != null) 'relevanceScore': relevanceScore!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerStepActionObservationSearchResultChunkInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultChunkInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerStepActionObservationSearchResultChunkInfo
class $AnswerStepActionObservationSearchResultChunkInfo {
  /// Chunk resource name.
  core.String? chunk;

  /// Chunk textual content.
  core.String? content;

  /// The relevance of the chunk for a given query.
  ///
  /// Values range from 0.0 (completely irrelevant) to 1.0 (completely
  /// relevant). This value is for informational purpose only. It may change for
  /// the same query and chunk at any time due to a model retraining or change
  /// in implementation.
  core.double? relevanceScore;

  $AnswerStepActionObservationSearchResultChunkInfo({
    this.chunk,
    this.content,
    this.relevanceScore,
  });

  $AnswerStepActionObservationSearchResultChunkInfo.fromJson(core.Map json_)
    : this(
        chunk: json_['chunk'] as core.String?,
        content: json_['content'] as core.String?,
        relevanceScore: (json_['relevanceScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunk != null) 'chunk': chunk!,
    if (content != null) 'content': content!,
    if (relevanceScore != null) 'relevanceScore': relevanceScore!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerStepActionObservationSearchResultSnippetInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultSnippetInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerStepActionObservationSearchResultSnippetInfo
class $AnswerStepActionObservationSearchResultSnippetInfo {
  /// Snippet content.
  core.String? snippet;

  /// Status of the snippet defined by the search team.
  core.String? snippetStatus;

  $AnswerStepActionObservationSearchResultSnippetInfo({
    this.snippet,
    this.snippetStatus,
  });

  $AnswerStepActionObservationSearchResultSnippetInfo.fromJson(core.Map json_)
    : this(
        snippet: json_['snippet'] as core.String?,
        snippetStatus: json_['snippetStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (snippet != null) 'snippet': snippet!,
    if (snippetStatus != null) 'snippetStatus': snippetStatus!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AnswerStepActionSearchAction
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerStepActionSearchAction
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerStepActionSearchAction
class $AnswerStepActionSearchAction {
  /// The query to search.
  core.String? query;

  $AnswerStepActionSearchAction({this.query});

  $AnswerStepActionSearchAction.fromJson(core.Map json_)
    : this(query: json_['query'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AntivirusOverride
/// - networksecurity:v1beta1 : AntivirusOverride
class $AntivirusOverride {
  /// Threat action override.
  ///
  /// For some threat types, only a subset of actions applies.
  ///
  /// Required.
  /// Possible string values are:
  /// - "THREAT_ACTION_UNSPECIFIED" : Threat action not specified.
  /// - "DEFAULT_ACTION" : The default action (as specified by the vendor) is
  /// taken.
  /// - "ALLOW" : The packet matching this rule will be allowed to transmit.
  /// - "ALERT" : The packet matching this rule will be allowed to transmit, but
  /// a threat_log entry will be sent to the consumer project.
  /// - "DENY" : The packet matching this rule will be dropped, and a threat_log
  /// entry will be sent to the consumer project.
  core.String? action;

  /// Protocol to match.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PROTOCOL_UNSPECIFIED" : Protocol not specified.
  /// - "SMTP" : SMTP protocol
  /// - "SMB" : SMB protocol
  /// - "POP3" : POP3 protocol
  /// - "IMAP" : IMAP protocol
  /// - "HTTP2" : HTTP2 protocol
  /// - "HTTP" : HTTP protocol
  /// - "FTP" : FTP protocol
  core.String? protocol;

  $AntivirusOverride({this.action, this.protocol});

  $AntivirusOverride.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        protocol: json_['protocol'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (protocol != null) 'protocol': protocol!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ApiAuthApiKeyConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig
class $ApiAuthApiKeyConfig {
  /// The SecretManager secret version resource name storing API key.
  ///
  /// e.g. projects/{project}/secrets/{secret}/versions/{version}
  ///
  /// Required.
  core.String? apiKeySecretVersion;

  /// The API key string.
  ///
  /// Either this or `api_key_secret_version` must be set.
  core.String? apiKeyString;

  $ApiAuthApiKeyConfig({this.apiKeySecretVersion, this.apiKeyString});

  $ApiAuthApiKeyConfig.fromJson(core.Map json_)
    : this(
        apiKeySecretVersion: json_['apiKeySecretVersion'] as core.String?,
        apiKeyString: json_['apiKeyString'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeySecretVersion != null)
      'apiKeySecretVersion': apiKeySecretVersion!,
    if (apiKeyString != null) 'apiKeyString': apiKeyString!,
  };
}

/// Used by:
///
/// - appengine:v1 : ApiConfigHandler
/// - appengine:v1beta : ApiConfigHandler
class $ApiConfigHandler {
  /// Action to take when users access resources that require authentication.
  ///
  /// Defaults to redirect.
  /// Possible string values are:
  /// - "AUTH_FAIL_ACTION_UNSPECIFIED" : Not specified.
  /// AUTH_FAIL_ACTION_REDIRECT is assumed.
  /// - "AUTH_FAIL_ACTION_REDIRECT" : Redirects user to "accounts.google.com".
  /// The user is redirected back to the application URL after signing in or
  /// creating an account.
  /// - "AUTH_FAIL_ACTION_UNAUTHORIZED" : Rejects request with a 401 HTTP status
  /// code and an error message.
  core.String? authFailAction;

  /// Level of login required to access this resource.
  ///
  /// Defaults to optional.
  /// Possible string values are:
  /// - "LOGIN_UNSPECIFIED" : Not specified. LOGIN_OPTIONAL is assumed.
  /// - "LOGIN_OPTIONAL" : Does not require that the user is signed in.
  /// - "LOGIN_ADMIN" : If the user is not signed in, the auth_fail_action is
  /// taken. In addition, if the user is not an administrator for the
  /// application, they are given an error message regardless of
  /// auth_fail_action. If the user is an administrator, the handler proceeds.
  /// - "LOGIN_REQUIRED" : If the user has signed in, the handler proceeds
  /// normally. Otherwise, the auth_fail_action is taken.
  core.String? login;

  /// Path to the script from the application root directory.
  core.String? script;

  /// Security (HTTPS) enforcement for this URL.
  /// Possible string values are:
  /// - "SECURE_UNSPECIFIED" : Not specified.
  /// - "SECURE_DEFAULT" : Both HTTP and HTTPS requests with URLs that match the
  /// handler succeed without redirects. The application can examine the request
  /// to determine which protocol was used, and respond accordingly.
  /// - "SECURE_NEVER" : Requests for a URL that match this handler that use
  /// HTTPS are automatically redirected to the HTTP equivalent URL.
  /// - "SECURE_OPTIONAL" : Both HTTP and HTTPS requests with URLs that match
  /// the handler succeed without redirects. The application can examine the
  /// request to determine which protocol was used and respond accordingly.
  /// - "SECURE_ALWAYS" : Requests for a URL that match this handler that do not
  /// use HTTPS are automatically redirected to the HTTPS URL with the same
  /// path. Query parameters are reserved for the redirect.
  core.String? securityLevel;

  /// URL to serve the endpoint at.
  core.String? url;

  $ApiConfigHandler({
    this.authFailAction,
    this.login,
    this.script,
    this.securityLevel,
    this.url,
  });

  $ApiConfigHandler.fromJson(core.Map json_)
    : this(
        authFailAction: json_['authFailAction'] as core.String?,
        login: json_['login'] as core.String?,
        script: json_['script'] as core.String?,
        securityLevel: json_['securityLevel'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authFailAction != null) 'authFailAction': authFailAction!,
    if (login != null) 'login': login!,
    if (script != null) 'script': script!,
    if (securityLevel != null) 'securityLevel': securityLevel!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : ApiWarning
/// - sqladmin:v1beta4 : ApiWarning
class $ApiWarning {
  /// Code to uniquely identify the warning type.
  /// Possible string values are:
  /// - "SQL_API_WARNING_CODE_UNSPECIFIED" : An unknown or unset warning type
  /// from Cloud SQL API.
  /// - "REGION_UNREACHABLE" : Warning when one or more regions are not
  /// reachable. The returned result set may be incomplete.
  /// - "MAX_RESULTS_EXCEEDS_LIMIT" : Warning when user provided maxResults
  /// parameter exceeds the limit. The returned result set may be incomplete.
  /// - "COMPROMISED_CREDENTIALS" : Warning when user tries to create/update a
  /// user with credentials that have previously been compromised by a public
  /// data breach.
  /// - "INTERNAL_STATE_FAILURE" : Warning when the operation succeeds but some
  /// non-critical workflow state failed.
  core.String? code;

  /// The warning message.
  core.String? message;

  /// The region name for REGION_UNREACHABLE warning.
  core.String? region;

  $ApiWarning({this.code, this.message, this.region});

  $ApiWarning.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        message: json_['message'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (message != null) 'message': message!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - apigateway:v1 : ApigatewayApi
/// - apigateway:v1beta : ApigatewayApi
class $ApigatewayApi {
  /// Created time.
  ///
  /// Output only.
  core.String? createTime;

  /// Display name.
  ///
  /// Optional.
  core.String? displayName;

  /// Resource labels to represent user-provided metadata.
  ///
  /// Refer to cloud documentation on labels for more details.
  /// https://cloud.google.com/compute/docs/labeling-resources
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The name of a Google Managed Service (
  /// https://cloud.google.com/service-infrastructure/docs/glossary#managed).
  ///
  /// If not specified, a new Service will automatically be created in the same
  /// project as this API.
  ///
  /// Optional. Immutable.
  core.String? managedService;

  /// Resource name of the API.
  ///
  /// Format: projects/{project}/locations/global/apis/{api}
  ///
  /// Output only.
  core.String? name;

  /// State of the API.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : API does not have a state yet.
  /// - "CREATING" : API is being created.
  /// - "ACTIVE" : API is active.
  /// - "FAILED" : API creation failed.
  /// - "DELETING" : API is being deleted.
  /// - "UPDATING" : API is being updated.
  core.String? state;

  /// Updated time.
  ///
  /// Output only.
  core.String? updateTime;

  $ApigatewayApi({
    this.createTime,
    this.displayName,
    this.labels,
    this.managedService,
    this.name,
    this.state,
    this.updateTime,
  });

  $ApigatewayApi.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        managedService: json_['managedService'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (managedService != null) 'managedService': managedService!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - apigateway:v1 : ApigatewayApiConfigFile
/// - apigateway:v1beta : ApigatewayApiConfigFile
class $ApigatewayApiConfigFile {
  /// The bytes that constitute the file.
  core.String? contents;
  core.List<core.int> get contentsAsBytes => convert.base64.decode(contents!);

  set contentsAsBytes(core.List<core.int> bytes_) {
    contents = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The file path (full or relative path).
  ///
  /// This is typically the path of the file when it is uploaded.
  core.String? path;

  $ApigatewayApiConfigFile({this.contents, this.path});

  $ApigatewayApiConfigFile.fromJson(core.Map json_)
    : this(
        contents: json_['contents'] as core.String?,
        path: json_['path'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - apigateway:v1 : ApigatewayGateway
/// - apigateway:v1beta : ApigatewayGateway
class $ApigatewayGateway {
  /// Resource name of the API Config for this Gateway.
  ///
  /// Format: projects/{project}/locations/global/apis/{api}/configs/{apiConfig}
  ///
  /// Required.
  core.String? apiConfig;

  /// Created time.
  ///
  /// Output only.
  core.String? createTime;

  /// The default API Gateway host name of the form
  /// `{gateway_id}-{hash}.{region_code}.gateway.dev`.
  ///
  /// Output only.
  core.String? defaultHostname;

  /// Display name.
  ///
  /// Optional.
  core.String? displayName;

  /// Resource labels to represent user-provided metadata.
  ///
  /// Refer to cloud documentation on labels for more details.
  /// https://cloud.google.com/compute/docs/labeling-resources
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Gateway.
  ///
  /// Format: projects/{project}/locations/{location}/gateways/{gateway}
  ///
  /// Output only.
  core.String? name;

  /// The current state of the Gateway.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Gateway does not have a state yet.
  /// - "CREATING" : Gateway is being created.
  /// - "ACTIVE" : Gateway is running and ready for requests.
  /// - "FAILED" : Gateway creation failed.
  /// - "DELETING" : Gateway is being deleted.
  /// - "UPDATING" : Gateway is being updated.
  core.String? state;

  /// Updated time.
  ///
  /// Output only.
  core.String? updateTime;

  $ApigatewayGateway({
    this.apiConfig,
    this.createTime,
    this.defaultHostname,
    this.displayName,
    this.labels,
    this.name,
    this.state,
    this.updateTime,
  });

  $ApigatewayGateway.fromJson(core.Map json_)
    : this(
        apiConfig: json_['apiConfig'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        defaultHostname: json_['defaultHostname'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiConfig != null) 'apiConfig': apiConfig!,
    if (createTime != null) 'createTime': createTime!,
    if (defaultHostname != null) 'defaultHostname': defaultHostname!,
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1App
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1App
class $App {
  /// Title of the app.
  ///
  /// This is the latest title as set in the Play Console and may not yet have
  /// been reviewed, so might not match the Play Store. Example: `Google Maps`.
  core.String? displayName;

  /// Identifier.
  ///
  /// The resource name. Format: apps/{app}
  core.String? name;

  /// Package name of the app.
  ///
  /// Example: `com.example.app123`.
  core.String? packageName;

  $App({this.displayName, this.name, this.packageName});

  $App.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        packageName: json_['packageName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (packageName != null) 'packageName': packageName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AppAssignedTargetingOptionDetails
/// - displayvideo:v3 : AppAssignedTargetingOptionDetails
/// - displayvideo:v4 : AppAssignedTargetingOptionDetails
class $AppAssignedTargetingOptionDetails {
  /// The ID of the app.
  ///
  /// Android's Play store app uses bundle ID, for example
  /// `com.google.android.gm`. Apple's App store app ID uses 9 digit string, for
  /// example `422689480`.
  ///
  /// Required.
  core.String? appId;

  /// Indicates the platform of the targeted app.
  ///
  /// If this field is not specified, the app platform will be assumed to be
  /// mobile (i.e., Android or iOS), and we will derive the appropriate mobile
  /// platform from the app ID.
  /// Possible string values are:
  /// - "APP_PLATFORM_UNSPECIFIED" : Default value when app platform is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real platform option.
  /// - "APP_PLATFORM_IOS" : The app platform is iOS.
  /// - "APP_PLATFORM_ANDROID" : The app platform is Android.
  /// - "APP_PLATFORM_ROKU" : The app platform is Roku.
  /// - "APP_PLATFORM_AMAZON_FIRETV" : The app platform is Amazon FireTV.
  /// - "APP_PLATFORM_PLAYSTATION" : The app platform is Playstation.
  /// - "APP_PLATFORM_APPLE_TV" : The app platform is Apple TV.
  /// - "APP_PLATFORM_XBOX" : The app platform is Xbox.
  /// - "APP_PLATFORM_SAMSUNG_TV" : The app platform is Samsung TV.
  /// - "APP_PLATFORM_ANDROID_TV" : The app platform is Android TV.
  /// - "APP_PLATFORM_GENERIC_CTV" : The app platform is a CTV platform that is
  /// not explicitly listed elsewhere.
  /// - "APP_PLATFORM_LG_TV" : The app platform is LG TV.
  /// - "APP_PLATFORM_VIZIO_TV" : The app platform is VIZIO TV.
  core.String? appPlatform;

  /// The display name of the app.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  $AppAssignedTargetingOptionDetails({
    this.appId,
    this.appPlatform,
    this.displayName,
    this.negative,
  });

  $AppAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        appId: json_['appId'] as core.String?,
        appPlatform: json_['appPlatform'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appId != null) 'appId': appId!,
    if (appPlatform != null) 'appPlatform': appPlatform!,
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1AppAttestConfig
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaAppAttestConfig
class $AppAttestConfig {
  /// The relative resource name of the App Attest configuration object, in the
  /// format: ``` projects/{project_number}/apps/{app_id}/appAttestConfig ```
  ///
  /// Required.
  core.String? name;

  /// Specifies the duration for which App Check tokens exchanged from App
  /// Attest artifacts will be valid.
  ///
  /// If unset, a default value of 1 hour is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $AppAttestConfig({this.name, this.tokenTtl});

  $AppAttestConfig.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AppCategoryAssignedTargetingOptionDetails
/// - displayvideo:v3 : AppCategoryAssignedTargetingOptionDetails
/// - displayvideo:v4 : AppCategoryAssignedTargetingOptionDetails
class $AppCategoryAssignedTargetingOptionDetails {
  /// The display name of the app category.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_APP_CATEGORY`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $AppCategoryAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $AppCategoryAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AppCategoryTargetingOptionDetails
/// - displayvideo:v3 : AppCategoryTargetingOptionDetails
/// - displayvideo:v4 : AppCategoryTargetingOptionDetails
class $AppCategoryTargetingOptionDetails {
  /// The name of the app collection.
  ///
  /// Output only.
  core.String? displayName;

  $AppCategoryTargetingOptionDetails({this.displayName});

  $AppCategoryTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpAppconnectionsV1AppConnectionGateway
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpAppconnectionsV1alphaAppConnectionGateway
class $AppConnectionGateway {
  /// AppGateway name in following format:
  /// `projects/{project_id}/locations/{location_id}/appgateways/{gateway_id}`
  ///
  /// Required.
  core.String? appGateway;

  /// Ingress port reserved on the gateways for this AppConnection, if not
  /// specified or zero, the default port is 19443.
  ///
  /// Output only.
  core.int? ingressPort;

  /// L7 private service connection for this resource.
  ///
  /// Output only.
  core.String? l7psc;

  /// The type of hosting used by the gateway.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value. This value is unused.
  /// - "GCP_REGIONAL_MIG" : Gateway hosted in a GCP regional managed instance
  /// group.
  core.String? type;

  /// Server-defined URI for this resource.
  ///
  /// Output only.
  core.String? uri;

  $AppConnectionGateway({
    this.appGateway,
    this.ingressPort,
    this.l7psc,
    this.type,
    this.uri,
  });

  $AppConnectionGateway.fromJson(core.Map json_)
    : this(
        appGateway: json_['appGateway'] as core.String?,
        ingressPort: json_['ingressPort'] as core.int?,
        l7psc: json_['l7psc'] as core.String?,
        type: json_['type'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appGateway != null) 'appGateway': appGateway!,
    if (ingressPort != null) 'ingressPort': ingressPort!,
    if (l7psc != null) 'l7psc': l7psc!,
    if (type != null) 'type': type!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - cloudscheduler:v1 : AppEngineRouting
/// - cloudscheduler:v1beta1 : AppEngineRouting
class $AppEngineRouting00 {
  /// The host that the job is sent to.
  ///
  /// For more information about how App Engine requests are routed, see
  /// [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
  /// The host is constructed as: * `host = [application_domain_name]` `|
  /// [service] + '.' + [application_domain_name]` `| [version] + '.' +
  /// [application_domain_name]` `| [version_dot_service]+ '.' +
  /// [application_domain_name]` `| [instance] + '.' +
  /// [application_domain_name]` `| [instance_dot_service] + '.' +
  /// [application_domain_name]` `| [instance_dot_version] + '.' +
  /// [application_domain_name]` `| [instance_dot_version_dot_service] + '.' +
  /// [application_domain_name]` * `application_domain_name` = The domain name
  /// of the app, for example .appspot.com, which is associated with the job's
  /// project ID. * `service =` service * `version =` version *
  /// `version_dot_service =` version `+ '.' +` service * `instance =` instance
  /// * `instance_dot_service =` instance `+ '.' +` service *
  /// `instance_dot_version =` instance `+ '.' +` version *
  /// `instance_dot_version_dot_service =` instance `+ '.' +` version `+ '.' +`
  /// service If service is empty, then the job will be sent to the service
  /// which is the default service when the job is attempted. If version is
  /// empty, then the job will be sent to the version which is the default
  /// version when the job is attempted. If instance is empty, then the job will
  /// be sent to an instance which is available when the job is attempted. If
  /// service, version, or instance is invalid, then the job will be sent to the
  /// default version of the default service when the job is attempted.
  ///
  /// Output only.
  core.String? host;

  /// App instance.
  ///
  /// By default, the job is sent to an instance which is available when the job
  /// is attempted. Requests can only be sent to a specific instance if
  /// [manual scaling is used in App Engine Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?#scaling_types_and_instance_classes).
  /// App Engine Flex does not support instances. For more information, see
  /// [App Engine Standard request routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
  /// and
  /// [App Engine Flex request routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
  core.String? instance;

  /// App service.
  ///
  /// By default, the job is sent to the service which is the default service
  /// when the job is attempted.
  core.String? service;

  /// App version.
  ///
  /// By default, the job is sent to the version which is the default version
  /// when the job is attempted.
  core.String? version;

  $AppEngineRouting00({this.host, this.instance, this.service, this.version});

  $AppEngineRouting00.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        instance: json_['instance'] as core.String?,
        service: json_['service'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (instance != null) 'instance': instance!,
    if (service != null) 'service': service!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : AppEngineRouting
/// - cloudtasks:v2beta3 : AppEngineRouting
class $AppEngineRouting01 {
  /// The host that the task is sent to.
  ///
  /// The host is constructed from the domain name of the app associated with
  /// the queue's project ID (for example .appspot.com), and the service,
  /// version, and instance. Tasks which were created using the App Engine SDK
  /// might have a custom domain name. For more information, see
  /// [How Requests are Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
  ///
  /// Output only.
  core.String? host;

  /// App instance.
  ///
  /// By default, the task is sent to an instance which is available when the
  /// task is attempted. Requests can only be sent to a specific instance if
  /// [manual scaling is used in App Engine Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
  /// App Engine Flex does not support instances. For more information, see
  /// [App Engine Standard request routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
  /// and
  /// [App Engine Flex request routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
  core.String? instance;

  /// App service.
  ///
  /// By default, the task is sent to the service which is the default service
  /// when the task is attempted. For some queues or tasks which were created
  /// using the App Engine Task Queue API, host is not parsable into service,
  /// version, and instance. For example, some tasks which were created using
  /// the App Engine SDK use a custom domain name; custom domains are not parsed
  /// by Cloud Tasks. If host is not parsable, then service, version, and
  /// instance are the empty string.
  core.String? service;

  /// App version.
  ///
  /// By default, the task is sent to the version which is the default version
  /// when the task is attempted. For some queues or tasks which were created
  /// using the App Engine Task Queue API, host is not parsable into service,
  /// version, and instance. For example, some tasks which were created using
  /// the App Engine SDK use a custom domain name; custom domains are not parsed
  /// by Cloud Tasks. If host is not parsable, then service, version, and
  /// instance are the empty string.
  core.String? version;

  $AppEngineRouting01({this.host, this.instance, this.service, this.version});

  $AppEngineRouting01.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        instance: json_['instance'] as core.String?,
        service: json_['service'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (instance != null) 'instance': instance!,
    if (service != null) 'service': service!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : AppEngineVersionEndpoint
/// - networkmanagement:v1beta1 : AppEngineVersionEndpoint
class $AppEngineVersionEndpoint {
  /// An [App Engine](https://cloud.google.com/appengine)
  /// [service version](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1/apps.services.versions)
  /// name.
  core.String? uri;

  $AppEngineVersionEndpoint({this.uri});

  $AppEngineVersionEndpoint.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : AppEngineVersionInfo
/// - networkmanagement:v1beta1 : AppEngineVersionInfo
class $AppEngineVersionInfo {
  /// Name of an App Engine version.
  core.String? displayName;

  /// App Engine execution environment for a version.
  core.String? environment;

  /// Runtime of the App Engine version.
  core.String? runtime;

  /// URI of an App Engine version.
  core.String? uri;

  $AppEngineVersionInfo({
    this.displayName,
    this.environment,
    this.runtime,
    this.uri,
  });

  $AppEngineVersionInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        environment: json_['environment'] as core.String?,
        runtime: json_['runtime'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (environment != null) 'environment': environment!,
    if (runtime != null) 'runtime': runtime!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - admob:v1 : AppManualAppInfo
/// - admob:v1beta : AppManualAppInfo
class $AppManualAppInfo {
  /// The display name of the app as shown in the AdMob UI, which is provided by
  /// the user.
  ///
  /// The maximum length allowed is 80 characters.
  core.String? displayName;

  $AppManualAppInfo({this.displayName});

  $AppManualAppInfo.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1AppVersion
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1AppVersion
class $AppVersion {
  /// Numeric version code of the app version (set by the app's developer).
  core.String? versionCode;

  $AppVersion({this.versionCode});

  $AppVersion.fromJson(core.Map json_)
    : this(versionCode: json_['versionCode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (versionCode != null) 'versionCode': versionCode!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ApplianceCluster
/// - gkehub:v1alpha : ApplianceCluster
/// - gkehub:v1beta : ApplianceCluster
class $ApplianceCluster {
  /// Self-link of the Google Cloud resource for the Appliance Cluster.
  ///
  /// For example:
  /// //transferappliance.googleapis.com/projects/my-project/locations/us-west1-a/appliances/my-appliance
  ///
  /// Immutable.
  core.String? resourceLink;

  $ApplianceCluster({this.resourceLink});

  $ApplianceCluster.fromJson(core.Map json_)
    : this(resourceLink: json_['resourceLink'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceLink != null) 'resourceLink': resourceLink!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ApplianceVersion
/// - vmmigration:v1alpha1 : ApplianceVersion
class $ApplianceVersion {
  /// Determine whether it's critical to upgrade the appliance to this version.
  core.bool? critical;

  /// Link to a page that contains the version release notes.
  core.String? releaseNotesUri;

  /// A link for downloading the version.
  core.String? uri;

  /// The appliance version.
  core.String? version;

  $ApplianceVersion({
    this.critical,
    this.releaseNotesUri,
    this.uri,
    this.version,
  });

  $ApplianceVersion.fromJson(core.Map json_)
    : this(
        critical: json_['critical'] as core.bool?,
        releaseNotesUri: json_['releaseNotesUri'] as core.String?,
        uri: json_['uri'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (critical != null) 'critical': critical!,
    if (releaseNotesUri != null) 'releaseNotesUri': releaseNotesUri!,
    if (uri != null) 'uri': uri!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpAppconnectionsV1AppConnectionApplicationEndpoint
/// - beyondcorp:v1alpha : ApplicationEndpoint
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpAppconnectionsV1alphaAppConnectionApplicationEndpoint
class $ApplicationEndpoint {
  /// Hostname or IP address of the remote application endpoint.
  ///
  /// Required.
  core.String? host;

  /// Port of the remote application endpoint.
  ///
  /// Required.
  core.int? port;

  $ApplicationEndpoint({this.host, this.port});

  $ApplicationEndpoint.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - jobs:v3 : ApplicationInfo
/// - jobs:v3p1beta1 : ApplicationInfo
class $ApplicationInfo {
  /// Optional but at least one of uris, emails or instruction must be
  /// specified.
  ///
  /// Use this field to specify email address(es) to which resumes or
  /// applications can be sent. The maximum number of allowed characters for
  /// each entry is 255.
  core.List<core.String>? emails;

  /// Optional but at least one of uris, emails or instruction must be
  /// specified.
  ///
  /// Use this field to provide instructions, such as "Mail your application to
  /// ...", that a candidate can follow to apply for the job. This field accepts
  /// and sanitizes HTML input, and also accepts bold, italic, ordered list, and
  /// unordered list markup tags. The maximum number of allowed characters is
  /// 3,000.
  core.String? instruction;

  /// Optional but at least one of uris, emails or instruction must be
  /// specified.
  ///
  /// Use this URI field to direct an applicant to a website, for example to
  /// link to an online application form. The maximum number of allowed
  /// characters for each entry is 2,000.
  core.List<core.String>? uris;

  $ApplicationInfo({this.emails, this.instruction, this.uris});

  $ApplicationInfo.fromJson(core.Map json_)
    : this(
        emails:
            (json_['emails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        instruction: json_['instruction'] as core.String?,
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (emails != null) 'emails': emails!,
    if (instruction != null) 'instruction': instruction!,
    if (uris != null) 'uris': uris!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpSecuritygatewaysV1ApplicationUpstreamNetwork
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpSecuritygatewaysV1alphaApplicationUpstreamNetwork
class $ApplicationUpstreamNetwork {
  /// Network name is of the format:
  /// \`projects/{project}/global/networks/{network}
  ///
  /// Required.
  core.String? name;

  $ApplicationUpstreamNetwork({this.name});

  $ApplicationUpstreamNetwork.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AppliedLicense
/// - vmmigration:v1alpha1 : AppliedLicense
class $AppliedLicense {
  /// The OS license returned from the adaptation module's report.
  core.String? osLicense;

  /// The license type that was used in OS adaptation.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified license for the OS.
  /// - "NONE" : No license available for the OS.
  /// - "PAYG" : The license type is Pay As You Go license type.
  /// - "BYOL" : The license type is Bring Your Own License type.
  core.String? type;

  $AppliedLicense({this.osLicense, this.type});

  $AppliedLicense.fromJson(core.Map json_)
    : this(
        osLicense: json_['osLicense'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (osLicense != null) 'osLicense': osLicense!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - memcache:v1 : ApplyParametersRequest
/// - memcache:v1beta2 : ApplyParametersRequest
class $ApplyParametersRequest {
  /// Whether to apply instance-level parameter group to all nodes.
  ///
  /// If set to true, users are restricted from specifying individual nodes, and
  /// `ApplyParameters` updates all nodes within the instance.
  core.bool? applyAll;

  /// Nodes to which the instance-level parameter group is applied.
  core.List<core.String>? nodeIds;

  $ApplyParametersRequest({this.applyAll, this.nodeIds});

  $ApplyParametersRequest.fromJson(core.Map json_)
    : this(
        applyAll: json_['applyAll'] as core.bool?,
        nodeIds:
            (json_['nodeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (applyAll != null) 'applyAll': applyAll!,
    if (nodeIds != null) 'nodeIds': nodeIds!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1ApplyWorkloadUpdateRequest
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1ApplyWorkloadUpdateRequest
class $ApplyWorkloadUpdateRequest {
  /// The action to be performed on the update.
  /// Possible string values are:
  /// - "WORKLOAD_UPDATE_ACTION_UNSPECIFIED" : Unspecified value.
  /// - "APPLY" : The update is applied.
  core.String? action;

  $ApplyWorkloadUpdateRequest({this.action});

  $ApplyWorkloadUpdateRequest.fromJson(core.Map json_)
    : this(action: json_['action'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
  };
}

/// Used by:
///
/// - osconfig:v1 : AptSettings
/// - osconfig:v1beta : AptSettings
class $AptSettings {
  /// List of packages to exclude from update.
  ///
  /// These packages will be excluded
  core.List<core.String>? excludes;

  /// An exclusive list of packages to be updated.
  ///
  /// These are the only packages that will be updated. If these packages are
  /// not installed, they will be ignored. This field cannot be specified with
  /// any other patch configuration fields.
  core.List<core.String>? exclusivePackages;

  /// By changing the type to DIST, the patching is performed using `apt-get
  /// dist-upgrade` instead.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : By default, upgrade will be performed.
  /// - "DIST" : Runs `apt-get dist-upgrade`.
  /// - "UPGRADE" : Runs `apt-get upgrade`.
  core.String? type;

  $AptSettings({this.excludes, this.exclusivePackages, this.type});

  $AptSettings.fromJson(core.Map json_)
    : this(
        excludes:
            (json_['excludes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        exclusivePackages:
            (json_['exclusivePackages'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludes != null) 'excludes': excludes!,
    if (exclusivePackages != null) 'exclusivePackages': exclusivePackages!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Artifact
/// - containeranalysis:v1beta1 : Artifact
/// - ondemandscanning:v1 : Artifact
/// - ondemandscanning:v1beta1 : Artifact
class $Artifact00 {
  /// Hash or checksum value of a binary, or Docker Registry 2.0 digest of a
  /// container.
  core.String? checksum;

  /// Artifact ID, if any; for container images, this will be a URL by digest
  /// like `gcr.io/projectID/imagename@sha256:123456`.
  core.String? id;

  /// Related artifact names.
  ///
  /// This may be the path to a binary or jar file, or in the case of a
  /// container build, the name used to push the container image to Google
  /// Container Registry, as presented to `docker push`. Note that a single
  /// Artifact ID can have multiple names, for example if two tags are applied
  /// to one image.
  core.List<core.String>? names;

  $Artifact00({this.checksum, this.id, this.names});

  $Artifact00.fromJson(core.Map json_)
    : this(
        checksum: json_['checksum'] as core.String?,
        id: json_['id'] as core.String?,
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checksum != null) 'checksum': checksum!,
    if (id != null) 'id': id!,
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Artifact
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Artifact
class $Artifact01 {
  /// Timestamp when this Artifact was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Artifact
  core.String? description;

  /// User provided display name of the Artifact.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Artifacts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Artifact (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Artifact.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Artifact.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Artifact.
  ///
  /// This is a property of the Artifact, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines), and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state for the Artifact.
  /// - "PENDING" : A state used by systems like Vertex AI Pipelines to indicate
  /// that the underlying data item represented by this Artifact is being
  /// created.
  /// - "LIVE" : A state indicating that the Artifact should exist, unless
  /// something external to the system deletes it.
  core.String? state;

  /// Timestamp when this Artifact was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The uniform resource identifier of the artifact file.
  ///
  /// May be empty if there is no actual artifact file.
  core.String? uri;

  $Artifact01({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
    this.uri,
  });

  $Artifact01.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        schemaTitle: json_['schemaTitle'] as core.String?,
        schemaVersion: json_['schemaVersion'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (schemaTitle != null) 'schemaTitle': schemaTitle!,
    if (schemaVersion != null) 'schemaVersion': schemaVersion!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : ImportAptArtifactsGcsSource
/// - artifactregistry:v1 : ImportYumArtifactsGcsSource
/// - artifactregistry:v1beta2 : ImportAptArtifactsGcsSource
/// - artifactregistry:v1beta2 : ImportYumArtifactsGcsSource
class $ArtifactsGcsSource {
  /// Cloud Storage paths URI (e.g., gs://my_bucket//my_object).
  core.List<core.String>? uris;

  /// Supports URI wildcards for matching multiple objects from a single URI.
  core.bool? useWildcards;

  $ArtifactsGcsSource({this.uris, this.useWildcards});

  $ArtifactsGcsSource.fromJson(core.Map json_)
    : this(
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        useWildcards: json_['useWildcards'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (uris != null) 'uris': uris!,
    if (useWildcards != null) 'useWildcards': useWildcards!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionResourceUsageAssessmentConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionValidationAssessmentConfig
class $AssessmentConfig {
  /// The name of the model used for batch prediction.
  ///
  /// Required.
  core.String? modelName;

  $AssessmentConfig({this.modelName});

  $AssessmentConfig.fromJson(core.Map json_)
    : this(modelName: json_['modelName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : Asset
/// - displayvideo:v3 : Asset
/// - displayvideo:v4 : Asset
class $Asset {
  /// The asset content.
  ///
  /// For uploaded assets, the content is the serving path.
  core.String? content;

  /// Media ID of the uploaded asset.
  ///
  /// This is a unique identifier for the asset. This ID can be passed to other
  /// API calls, e.g. CreateCreative to associate the asset with a creative. The
  /// Media ID space updated on **April 5, 2023**. Update media IDs cached
  /// before **April 5, 2023** by retrieving the new media ID from associated
  /// creative resources or re-uploading the asset.
  core.String? mediaId;

  $Asset({this.content, this.mediaId});

  $Asset.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        mediaId: json_['mediaId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (mediaId != null) 'mediaId': mediaId!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AssetList
/// - migrationcenter:v1alpha1 : AssetList
class $AssetList {
  /// A list of asset IDs
  ///
  /// Required.
  core.List<core.String>? assetIds;

  $AssetList({this.assetIds});

  $AssetList.fromJson(core.Map json_)
    : this(
        assetIds:
            (json_['assetIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assetIds != null) 'assetIds': assetIds!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AssignedInventorySource
/// - displayvideo:v3 : AssignedInventorySource
/// - displayvideo:v4 : AssignedInventorySource
class $AssignedInventorySource {
  /// The unique ID of the assigned inventory source.
  ///
  /// The ID is only unique within a given inventory source group. It may be
  /// reused in other contexts.
  ///
  /// Output only.
  core.String? assignedInventorySourceId;

  /// The ID of the inventory source entity being targeted.
  ///
  /// Required.
  core.String? inventorySourceId;

  /// The resource name of the assigned inventory source.
  ///
  /// Output only.
  core.String? name;

  $AssignedInventorySource({
    this.assignedInventorySourceId,
    this.inventorySourceId,
    this.name,
  });

  $AssignedInventorySource.fromJson(core.Map json_)
    : this(
        assignedInventorySourceId:
            json_['assignedInventorySourceId'] as core.String?,
        inventorySourceId: json_['inventorySourceId'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignedInventorySourceId != null)
      'assignedInventorySourceId': assignedInventorySourceId!,
    if (inventorySourceId != null) 'inventorySourceId': inventorySourceId!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AssignedLocation
/// - displayvideo:v3 : AssignedLocation
/// - displayvideo:v4 : AssignedLocation
class $AssignedLocation {
  /// The unique ID of the assigned location.
  ///
  /// The ID is only unique within a location list. It may be reused in other
  /// contexts.
  ///
  /// Output only.
  core.String? assignedLocationId;

  /// The resource name of the assigned location.
  ///
  /// Output only.
  core.String? name;

  /// The ID of the targeting option assigned to the location list.
  ///
  /// Required.
  core.String? targetingOptionId;

  $AssignedLocation({
    this.assignedLocationId,
    this.name,
    this.targetingOptionId,
  });

  $AssignedLocation.fromJson(core.Map json_)
    : this(
        assignedLocationId: json_['assignedLocationId'] as core.String?,
        name: json_['name'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignedLocationId != null) 'assignedLocationId': assignedLocationId!,
    if (name != null) 'name': name!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AssignedUserRole
/// - displayvideo:v3 : AssignedUserRole
/// - displayvideo:v4 : AssignedUserRole
class $AssignedUserRole {
  /// The ID of the advertiser that the assigend user role applies to.
  core.String? advertiserId;

  /// The ID of the assigned user role.
  ///
  /// Output only.
  core.String? assignedUserRoleId;

  /// The ID of the partner that the assigned user role applies to.
  core.String? partnerId;

  /// The user role to assign to a user for the entity.
  ///
  /// Required.
  /// Possible string values are:
  /// - "USER_ROLE_UNSPECIFIED" : Default value when the user role is not
  /// specified or is unknown in this version.
  /// - "ADMIN" : The user can manage campaigns, creatives, insertion orders,
  /// line items, and reports for the entity. They can view and edit billing
  /// information, create or modify users, and enable or disable exchanges. This
  /// role can only be assigned for a partner entity.
  /// - "ADMIN_PARTNER_CLIENT" : The user can manage campaigns, creatives,
  /// insertion orders, line items, and reports for the entity. They can create
  /// and modify other `ADMIN_PARTNER_CLIENT` users and view billing
  /// information. They cannot view revenue models, markups, or any other
  /// reseller-sensitive fields. This role can only be assigned for a partner
  /// entity.
  /// - "STANDARD" : The user can manage campaigns, creatives, insertion orders,
  /// line items, and reports for the entity. They cannot create and modify
  /// users or view billing information.
  /// - "STANDARD_PLANNER" : The user can view all campaigns, creatives,
  /// insertion orders, line items, and reports for the entity, including all
  /// cost data. They can create and modify planning-related features, including
  /// plans and inventory.
  /// - "STANDARD_PLANNER_LIMITED" : The user can view all campaigns, creatives,
  /// insertion orders, line items, and reports for the entity. They can create
  /// or modify planning-related features, including plans and inventory. They
  /// have no access to cost data and cannot start, accept, or negotiate deals.
  /// - "STANDARD_PARTNER_CLIENT" : The user can manage campaigns, creatives,
  /// insertion orders, line items, and reports for the entity. They cannot
  /// create or modify other users or view billing information. They cannot view
  /// revenue models, markups, or any other reseller-sensitive fields. This role
  /// can only be assigned for an advertiser entity.
  /// - "READ_ONLY" : The user can only build reports and view data for the
  /// entity.
  /// - "REPORTING_ONLY" : The user can only create and manage reports.
  /// - "LIMITED_REPORTING_ONLY" : The user can only create and manage the
  /// following client-safe reports: General, Audience Performance,
  /// Cross-Partner, Keyword, Order ID, Category, and Third-Party Data Provider.
  /// - "CREATIVE" : The user can view media plan information they need to
  /// collaborate, but can't view cost-related data or Marketplace.
  /// - "CREATIVE_ADMIN" : The user can view media plan information they need to
  /// collaborate, but can't view cost-related data or Marketplace. In addition,
  /// they can add other creative admins or creative users to the entity.
  core.String? userRole;

  $AssignedUserRole({
    this.advertiserId,
    this.assignedUserRoleId,
    this.partnerId,
    this.userRole,
  });

  $AssignedUserRole.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        assignedUserRoleId: json_['assignedUserRoleId'] as core.String?,
        partnerId: json_['partnerId'] as core.String?,
        userRole: json_['userRole'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (assignedUserRoleId != null) 'assignedUserRoleId': assignedUserRoleId!,
    if (partnerId != null) 'partnerId': partnerId!,
    if (userRole != null) 'userRole': userRole!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2AssistQueryParameters
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1AssistQueryParameters
class $AssistQueryParameters {
  /// Key-value filters on the metadata of documents returned by article
  /// suggestion.
  ///
  /// If specified, article suggestion only returns suggested documents that
  /// match all filters in their Document.metadata. Multiple values for a
  /// metadata key should be concatenated by comma. For example, filters to
  /// match all documents that have 'US' or 'CA' in their market metadata values
  /// and 'agent' in their user metadata values will be ```
  /// documents_metadata_filters { key: "market" value: "US,CA" }
  /// documents_metadata_filters { key: "user" value: "agent" } ```
  core.Map<core.String, core.String>? documentsMetadataFilters;

  $AssistQueryParameters({this.documentsMetadataFilters});

  $AssistQueryParameters.fromJson(core.Map json_)
    : this(
        documentsMetadataFilters: (json_['documentsMetadataFilters']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentsMetadataFilters != null)
      'documentsMetadataFilters': documentsMetadataFilters!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistUserMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistUserMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistUserMetadata
class $AssistUserMetadata {
  /// Preferred language to be used for answering if language detection fails.
  ///
  /// Also used as the language of error messages created by actions, regardless
  /// of language detection results.
  ///
  /// Optional.
  core.String? preferredLanguageCode;

  /// IANA time zone, e.g. Europe/Budapest.
  ///
  /// Optional.
  core.String? timeZone;

  $AssistUserMetadata({this.preferredLanguageCode, this.timeZone});

  $AssistUserMetadata.fromJson(core.Map json_)
    : this(
        preferredLanguageCode: json_['preferredLanguageCode'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (preferredLanguageCode != null)
      'preferredLanguageCode': preferredLanguageCode!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Assistant
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistant
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistant
class $Assistant {
  /// Resource name of the assistant.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
  /// It must be a UTF-8 encoded string with a length limit of 1024 characters.
  ///
  /// Immutable.
  core.String? name;

  $Assistant({this.name});

  $Assistant.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantContentBlob
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantContentBlob
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantContentBlob
class $AssistantContentBlob {
  /// Raw bytes.
  ///
  /// Required.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The media type (MIME type) of the generated data.
  ///
  /// Required.
  core.String? mimeType;

  $AssistantContentBlob({this.data, this.mimeType});

  $AssistantContentBlob.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantContentExecutableCode
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantContentExecutableCode
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantContentExecutableCode
class $AssistantContentExecutableCode {
  /// The code content.
  ///
  /// Currently only supports Python.
  ///
  /// Required.
  core.String? code;

  $AssistantContentExecutableCode({this.code});

  $AssistantContentExecutableCode.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantContentFile
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantContentFile
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantContentFile
class $AssistantContentFile {
  /// The file ID.
  ///
  /// Required.
  core.String? fileId;

  /// The media type (MIME type) of the file.
  ///
  /// Required.
  core.String? mimeType;

  $AssistantContentFile({this.fileId, this.mimeType});

  $AssistantContentFile.fromJson(core.Map json_)
    : this(
        fileId: json_['fileId'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fileId != null) 'fileId': fileId!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata
class $AssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata {
  /// Document resource name.
  core.String? document;

  /// Domain name from the document URI.
  ///
  /// Note that the `uri` field may contain a URL that redirects to the actual
  /// website, in which case this will contain the domain name of the target
  /// site.
  core.String? domain;

  /// Page identifier.
  core.String? pageIdentifier;

  /// Title.
  core.String? title;

  /// URI for the document.
  ///
  /// It may contain a URL that redirects to the actual website.
  core.String? uri;

  $AssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata({
    this.document,
    this.domain,
    this.pageIdentifier,
    this.title,
    this.uri,
  });

  $AssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata.fromJson(
    core.Map json_,
  ) : this(
        document: json_['document'] as core.String?,
        domain: json_['domain'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (domain != null) 'domain': domain!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantGroundedContentTextGroundingMetadataSegment
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataSegment
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantGroundedContentTextGroundingMetadataSegment
class $AssistantGroundedContentTextGroundingMetadataSegment {
  /// End of the segment, exclusive.
  core.String? endIndex;

  /// Score for the segment.
  core.double? groundingScore;

  /// References for the segment.
  core.List<core.int>? referenceIndices;

  /// Zero-based index indicating the start of the segment, measured in bytes of
  /// a UTF-8 string (i.e. characters encoded on multiple bytes have a length of
  /// more than one).
  core.String? startIndex;

  /// The text segment itself.
  core.String? text;

  $AssistantGroundedContentTextGroundingMetadataSegment({
    this.endIndex,
    this.groundingScore,
    this.referenceIndices,
    this.startIndex,
    this.text,
  });

  $AssistantGroundedContentTextGroundingMetadataSegment.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.String?,
        groundingScore: (json_['groundingScore'] as core.num?)?.toDouble(),
        referenceIndices:
            (json_['referenceIndices'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        startIndex: json_['startIndex'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (groundingScore != null) 'groundingScore': groundingScore!,
    if (referenceIndices != null) 'referenceIndices': referenceIndices!,
    if (startIndex != null) 'startIndex': startIndex!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - healthcare:v1 : AttributeDefinition
/// - healthcare:v1beta1 : AttributeDefinition
class $AttributeDefinition {
  /// Possible values for the attribute.
  ///
  /// The number of allowed values must not exceed 500. An empty list is
  /// invalid. The list can only be expanded after creation.
  ///
  /// Required.
  core.List<core.String>? allowedValues;

  /// The category of the attribute.
  ///
  /// The value of this field cannot be changed after creation.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CATEGORY_UNSPECIFIED" : No category specified. This option is invalid.
  /// - "RESOURCE" : Specify this category when this attribute describes the
  /// properties of resources. For example, data anonymity or data type.
  /// - "REQUEST" : Specify this category when this attribute describes the
  /// properties of requests. For example, requester's role or requester's
  /// organization.
  core.String? category;

  /// Default values of the attribute in Consents.
  ///
  /// If no default values are specified, it defaults to an empty value.
  ///
  /// Optional.
  core.List<core.String>? consentDefaultValues;

  /// Default value of the attribute in User data mappings.
  ///
  /// If no default value is specified, it defaults to an empty value. This
  /// field is only applicable to attributes of the category `RESOURCE`.
  ///
  /// Optional.
  core.String? dataMappingDefaultValue;

  /// A description of the attribute.
  ///
  /// Optional.
  core.String? description;

  /// Identifier.
  ///
  /// Resource name of the Attribute definition, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/attributeDefinitions/{attribute_definition_id}`.
  /// Cannot be changed after creation.
  core.String? name;

  $AttributeDefinition({
    this.allowedValues,
    this.category,
    this.consentDefaultValues,
    this.dataMappingDefaultValue,
    this.description,
    this.name,
  });

  $AttributeDefinition.fromJson(core.Map json_)
    : this(
        allowedValues:
            (json_['allowedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        category: json_['category'] as core.String?,
        consentDefaultValues:
            (json_['consentDefaultValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        dataMappingDefaultValue:
            json_['dataMappingDefaultValue'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedValues != null) 'allowedValues': allowedValues!,
    if (category != null) 'category': category!,
    if (consentDefaultValues != null)
      'consentDefaultValues': consentDefaultValues!,
    if (dataMappingDefaultValue != null)
      'dataMappingDefaultValue': dataMappingDefaultValue!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Attribution
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Attribution
class $Attribution00 {
  /// Error of feature_attributions caused by approximation used in the
  /// explanation method.
  ///
  /// Lower value means more precise attributions. * For Sampled Shapley
  /// attribution, increasing path_count might reduce the error. * For
  /// Integrated Gradients attribution, increasing step_count might reduce the
  /// error. * For XRAI attribution, increasing step_count might reduce the
  /// error. See \[this introduction\](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  ///
  /// Output only.
  core.double? approximationError;

  /// Model predicted output if the input instance is constructed from the
  /// baselines of all the features defined in ExplanationMetadata.inputs.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model's predicted output has multiple
  /// dimensions (rank \> 1), this is the value in the output located by
  /// output_index. If there are multiple baselines, their output values are
  /// averaged.
  ///
  /// Output only.
  core.double? baselineOutputValue;

  /// Attributions of each explained feature.
  ///
  /// Features are extracted from the prediction instances according to
  /// explanation metadata for inputs. The value is a struct, whose keys are the
  /// name of the feature. The values are how much the feature in the instance
  /// contributed to the predicted result. The format of the value is determined
  /// by the feature's input format: * If the feature is a scalar value, the
  /// attribution value is a floating number. * If the feature is an array of
  /// scalar values, the attribution value is an array. * If the feature is a
  /// struct, the attribution value is a struct. The keys in the attribution
  /// value struct are the same as the keys in the feature struct. The formats
  /// of the values in the attribution struct are determined by the formats of
  /// the values in the feature struct. The
  /// ExplanationMetadata.feature_attributions_schema_uri field, pointed to by
  /// the ExplanationSpec field of the Endpoint.deployed_models object, points
  /// to the schema file that describes the features and their attribution
  /// values (if it is populated).
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? featureAttributions;

  /// Model predicted output on the corresponding explanation instance.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model predicted output has multiple
  /// dimensions, this is the value in the output located by output_index.
  ///
  /// Output only.
  core.double? instanceOutputValue;

  /// The display name of the output identified by output_index.
  ///
  /// For example, the predicted class name by a multi-classification Model.
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  ///
  /// Output only.
  core.String? outputDisplayName;

  /// The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th
  /// dimension of the output vector. Indices start from 0.
  ///
  /// Output only.
  core.List<core.int>? outputIndex;

  /// Name of the explain output.
  ///
  /// Specified as the key in ExplanationMetadata.outputs.
  ///
  /// Output only.
  core.String? outputName;

  $Attribution00({
    this.approximationError,
    this.baselineOutputValue,
    this.featureAttributions,
    this.instanceOutputValue,
    this.outputDisplayName,
    this.outputIndex,
    this.outputName,
  });

  $Attribution00.fromJson(core.Map json_)
    : this(
        approximationError:
            (json_['approximationError'] as core.num?)?.toDouble(),
        baselineOutputValue:
            (json_['baselineOutputValue'] as core.num?)?.toDouble(),
        featureAttributions: json_['featureAttributions'],
        instanceOutputValue:
            (json_['instanceOutputValue'] as core.num?)?.toDouble(),
        outputDisplayName: json_['outputDisplayName'] as core.String?,
        outputIndex:
            (json_['outputIndex'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        outputName: json_['outputName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (approximationError != null) 'approximationError': approximationError!,
    if (baselineOutputValue != null)
      'baselineOutputValue': baselineOutputValue!,
    if (featureAttributions != null)
      'featureAttributions': featureAttributions!,
    if (instanceOutputValue != null)
      'instanceOutputValue': instanceOutputValue!,
    if (outputDisplayName != null) 'outputDisplayName': outputDisplayName!,
    if (outputIndex != null) 'outputIndex': outputIndex!,
    if (outputName != null) 'outputName': outputName!,
  };
}

/// Used by:
///
/// - ml:v1 : GoogleCloudMlV1__IntegratedGradientsAttribution
/// - ml:v1 : GoogleCloudMlV1__XraiAttribution
class $Attribution01 {
  /// Number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is met within the desired error range.
  core.int? numIntegralSteps;

  $Attribution01({this.numIntegralSteps});

  $Attribution01.fromJson(core.Map json_)
    : this(numIntegralSteps: json_['numIntegralSteps'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (numIntegralSteps != null) 'numIntegralSteps': numIntegralSteps!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2Audience
/// - retail:v2alpha : GoogleCloudRetailV2alphaAudience
/// - retail:v2beta : GoogleCloudRetailV2betaAudience
class $Audience {
  /// The age groups of the audience.
  ///
  /// Strongly encouraged to use the standard values: "newborn" (up to 3 months
  /// old), "infant" (312 months old), "toddler" (15 years old), "kids" (513
  /// years old), "adult" (typically teens or older). At most 5 values are
  /// allowed. Each value must be a UTF-8 encoded string with a length limit of
  /// 128 characters. Otherwise, an INVALID_ARGUMENT error is returned. Google
  /// Merchant Center property
  /// [age_group](https://support.google.com/merchants/answer/6324463).
  /// Schema.org property
  /// [Product.audience.suggestedMinAge](https://schema.org/suggestedMinAge) and
  /// [Product.audience.suggestedMaxAge](https://schema.org/suggestedMaxAge).
  core.List<core.String>? ageGroups;

  /// The genders of the audience.
  ///
  /// Strongly encouraged to use the standard values: "male", "female",
  /// "unisex". At most 5 values are allowed. Each value must be a UTF-8 encoded
  /// string with a length limit of 128 characters. Otherwise, an
  /// INVALID_ARGUMENT error is returned. Google Merchant Center property
  /// [gender](https://support.google.com/merchants/answer/6324479). Schema.org
  /// property
  /// [Product.audience.suggestedGender](https://schema.org/suggestedGender).
  core.List<core.String>? genders;

  $Audience({this.ageGroups, this.genders});

  $Audience.fromJson(core.Map json_)
    : this(
        ageGroups:
            (json_['ageGroups'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        genders:
            (json_['genders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ageGroups != null) 'ageGroups': ageGroups!,
    if (genders != null) 'genders': genders!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AudioContentTypeAssignedTargetingOptionDetails
/// - displayvideo:v3 : AudioContentTypeAssignedTargetingOptionDetails
/// - displayvideo:v4 : AudioContentTypeAssignedTargetingOptionDetails
class $AudioContentTypeAssignedTargetingOptionDetails {
  /// The audio content type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "AUDIO_CONTENT_TYPE_UNSPECIFIED" : Audio content type is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real content stream type.
  /// - "AUDIO_CONTENT_TYPE_UNKNOWN" : The audio content type is unknown.
  /// - "AUDIO_CONTENT_TYPE_MUSIC" : The audio content type is music.
  /// - "AUDIO_CONTENT_TYPE_BROADCAST" : The audio content type is broadcast.
  /// - "AUDIO_CONTENT_TYPE_PODCAST" : The audio content type is podcast.
  core.String? audioContentType;

  $AudioContentTypeAssignedTargetingOptionDetails({this.audioContentType});

  $AudioContentTypeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(audioContentType: json_['audioContentType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioContentType != null) 'audioContentType': audioContentType!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AudioContentTypeTargetingOptionDetails
/// - displayvideo:v3 : AudioContentTypeTargetingOptionDetails
/// - displayvideo:v4 : AudioContentTypeTargetingOptionDetails
class $AudioContentTypeTargetingOptionDetails {
  /// The audio content type.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AUDIO_CONTENT_TYPE_UNSPECIFIED" : Audio content type is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real content stream type.
  /// - "AUDIO_CONTENT_TYPE_UNKNOWN" : The audio content type is unknown.
  /// - "AUDIO_CONTENT_TYPE_MUSIC" : The audio content type is music.
  /// - "AUDIO_CONTENT_TYPE_BROADCAST" : The audio content type is broadcast.
  /// - "AUDIO_CONTENT_TYPE_PODCAST" : The audio content type is podcast.
  core.String? audioContentType;

  $AudioContentTypeTargetingOptionDetails({this.audioContentType});

  $AudioContentTypeTargetingOptionDetails.fromJson(core.Map json_)
    : this(audioContentType: json_['audioContentType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioContentType != null) 'audioContentType': audioContentType!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AudioVideoOffset
/// - displayvideo:v3 : AudioVideoOffset
/// - displayvideo:v4 : AudioVideoOffset
class $AudioVideoOffset {
  /// The offset in percentage of the audio or video duration.
  ///
  /// Optional.
  core.String? percentage;

  /// The offset in seconds from the start of the audio or video.
  ///
  /// Optional.
  core.String? seconds;

  $AudioVideoOffset({this.percentage, this.seconds});

  $AudioVideoOffset.fromJson(core.Map json_)
    : this(
        percentage: json_['percentage'] as core.String?,
        seconds: json_['seconds'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (percentage != null) 'percentage': percentage!,
    if (seconds != null) 'seconds': seconds!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AuditAdvertiserResponse
/// - displayvideo:v3 : AuditAdvertiserResponse
/// - displayvideo:v4 : AuditAdvertiserResponse
class $AuditAdvertiserResponse {
  /// The number of individual targeting options from the following targeting
  /// types that are assigned to a line item under this advertiser.
  ///
  /// These individual targeting options count towards the limit of 4500000 ad
  /// group targeting options per advertiser. Qualifying Targeting types: *
  /// Channels, URLs, apps, and collections * Demographic * Google Audiences,
  /// including Affinity, Custom Affinity, and In-market audiences * Inventory
  /// source * Keyword * Mobile app category * User lists * Video targeting *
  /// Viewability
  core.String? adGroupCriteriaCount;

  /// The number of individual targeting options from the following targeting
  /// types that are assigned to a line item under this advertiser.
  ///
  /// These individual targeting options count towards the limit of 900000
  /// campaign targeting options per advertiser. Qualifying Targeting types: *
  /// Position * Browser * Connection speed * Day and time * Device and
  /// operating system * Digital content label * Sensitive categories *
  /// Environment * Geography, including business chains and proximity * ISP *
  /// Language * Third-party verification
  core.String? campaignCriteriaCount;

  /// The number of channels created under this advertiser.
  ///
  /// These channels count towards the limit of 1000 channels per advertiser.
  core.String? channelsCount;

  /// The number of negative keyword lists created under this advertiser.
  ///
  /// These negative keyword lists count towards the limit of 20 negative
  /// keyword lists per advertiser.
  core.String? negativeKeywordListsCount;

  /// The number of negatively targeted channels created under this advertiser.
  ///
  /// These negatively targeted channels count towards the limit of 5 negatively
  /// targeted channels per advertiser.
  core.String? negativelyTargetedChannelsCount;

  /// The number of ACTIVE and PAUSED campaigns under this advertiser.
  ///
  /// These campaigns count towards the limit of 9999 campaigns per advertiser.
  core.String? usedCampaignsCount;

  /// The number of ACTIVE, PAUSED and DRAFT insertion orders under this
  /// advertiser.
  ///
  /// These insertion orders count towards the limit of 9999 insertion orders
  /// per advertiser.
  core.String? usedInsertionOrdersCount;

  /// The number of ACTIVE, PAUSED, and DRAFT line items under this advertiser.
  ///
  /// These line items count towards the limit of 9999 line items per
  /// advertiser.
  core.String? usedLineItemsCount;

  $AuditAdvertiserResponse({
    this.adGroupCriteriaCount,
    this.campaignCriteriaCount,
    this.channelsCount,
    this.negativeKeywordListsCount,
    this.negativelyTargetedChannelsCount,
    this.usedCampaignsCount,
    this.usedInsertionOrdersCount,
    this.usedLineItemsCount,
  });

  $AuditAdvertiserResponse.fromJson(core.Map json_)
    : this(
        adGroupCriteriaCount: json_['adGroupCriteriaCount'] as core.String?,
        campaignCriteriaCount: json_['campaignCriteriaCount'] as core.String?,
        channelsCount: json_['channelsCount'] as core.String?,
        negativeKeywordListsCount:
            json_['negativeKeywordListsCount'] as core.String?,
        negativelyTargetedChannelsCount:
            json_['negativelyTargetedChannelsCount'] as core.String?,
        usedCampaignsCount: json_['usedCampaignsCount'] as core.String?,
        usedInsertionOrdersCount:
            json_['usedInsertionOrdersCount'] as core.String?,
        usedLineItemsCount: json_['usedLineItemsCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adGroupCriteriaCount != null)
      'adGroupCriteriaCount': adGroupCriteriaCount!,
    if (campaignCriteriaCount != null)
      'campaignCriteriaCount': campaignCriteriaCount!,
    if (channelsCount != null) 'channelsCount': channelsCount!,
    if (negativeKeywordListsCount != null)
      'negativeKeywordListsCount': negativeKeywordListsCount!,
    if (negativelyTargetedChannelsCount != null)
      'negativelyTargetedChannelsCount': negativelyTargetedChannelsCount!,
    if (usedCampaignsCount != null) 'usedCampaignsCount': usedCampaignsCount!,
    if (usedInsertionOrdersCount != null)
      'usedInsertionOrdersCount': usedInsertionOrdersCount!,
    if (usedLineItemsCount != null) 'usedLineItemsCount': usedLineItemsCount!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : AuditLogConfig
/// - analyticshub:v1 : AuditLogConfig
/// - analyticshub:v1beta1 : AuditLogConfig
/// - apigateway:v1 : ApigatewayAuditLogConfig
/// - apigateway:v1beta : ApigatewayAuditLogConfig
/// - apigee:v1 : GoogleIamV1AuditLogConfig
/// - apphub:v1 : AuditLogConfig
/// - apphub:v1alpha : AuditLogConfig
/// - backupdr:v1 : AuditLogConfig
/// - beyondcorp:v1 : GoogleIamV1AuditLogConfig
/// - beyondcorp:v1alpha : GoogleIamV1AuditLogConfig
/// - bigquery:v2 : AuditLogConfig
/// - bigqueryconnection:v1 : AuditLogConfig
/// - bigqueryconnection:v1beta1 : AuditLogConfig
/// - bigquerydatapolicy:v1 : AuditLogConfig
/// - bigqueryreservation:v1 : AuditLogConfig
/// - bigtableadmin:v2 : AuditLogConfig
/// - cloudasset:v1 : AuditLogConfig
/// - cloudasset:v1beta1 : AuditLogConfig
/// - cloudasset:v1p1beta1 : AuditLogConfig
/// - cloudasset:v1p5beta1 : AuditLogConfig
/// - cloudbilling:v1 : AuditLogConfig
/// - cloudbuild:v2 : AuditLogConfig
/// - clouddeploy:v1 : AuditLogConfig
/// - cloudfunctions:v1 : AuditLogConfig
/// - cloudfunctions:v2 : AuditLogConfig
/// - cloudfunctions:v2alpha : AuditLogConfig
/// - cloudfunctions:v2beta : AuditLogConfig
/// - cloudkms:v1 : AuditLogConfig
/// - cloudresourcemanager:v1 : AuditLogConfig
/// - cloudresourcemanager:v1beta1 : AuditLogConfig
/// - cloudresourcemanager:v2 : AuditLogConfig
/// - cloudresourcemanager:v2beta1 : AuditLogConfig
/// - cloudresourcemanager:v3 : AuditLogConfig
/// - config:v1 : AuditLogConfig
/// - connectors:v1 : AuditLogConfig
/// - contentwarehouse:v1 : GoogleIamV1AuditLogConfig
/// - datafusion:v1 : AuditLogConfig
/// - datafusion:v1beta1 : AuditLogConfig
/// - datamigration:v1 : AuditLogConfig
/// - datamigration:v1beta1 : AuditLogConfig
/// - dataplex:v1 : GoogleIamV1AuditLogConfig
/// - deploymentmanager:alpha : AuditLogConfig
/// - deploymentmanager:v2 : AuditLogConfig
/// - deploymentmanager:v2beta : AuditLogConfig
/// - dns:v1 : GoogleIamV1AuditLogConfig
/// - dns:v1beta2 : GoogleIamV1AuditLogConfig
/// - domains:v1 : AuditLogConfig
/// - domains:v1alpha2 : AuditLogConfig
/// - domains:v1beta1 : AuditLogConfig
/// - eventarc:v1 : AuditLogConfig
/// - gkebackup:v1 : AuditLogConfig
/// - gkehub:v1 : AuditLogConfig
/// - gkehub:v1alpha : AuditLogConfig
/// - gkehub:v1beta : AuditLogConfig
/// - gkehub:v1beta1 : AuditLogConfig
/// - healthcare:v1 : AuditLogConfig
/// - healthcare:v1beta1 : AuditLogConfig
/// - iam:v1 : AuditLogConfig
/// - identitytoolkit:v2 : GoogleIamV1AuditLogConfig
/// - metastore:v1 : AuditLogConfig
/// - metastore:v1alpha : AuditLogConfig
/// - metastore:v1beta : AuditLogConfig
/// - ml:v1 : GoogleIamV1__AuditLogConfig
/// - networkconnectivity:v1 : AuditLogConfig
/// - networkconnectivity:v1alpha1 : AuditLogConfig
/// - networkmanagement:v1 : AuditLogConfig
/// - networkmanagement:v1beta1 : AuditLogConfig
/// - networksecurity:v1 : GoogleIamV1AuditLogConfig
/// - networksecurity:v1beta1 : GoogleIamV1AuditLogConfig
/// - networkservices:v1 : AuditLogConfig
/// - policysimulator:v1 : GoogleIamV1AuditLogConfig
/// - policysimulator:v1beta : GoogleIamV1AuditLogConfig
/// - policytroubleshooter:v1 : GoogleIamV1AuditLogConfig
/// - policytroubleshooter:v1beta : GoogleIamV1AuditLogConfig
/// - privateca:v1 : AuditLogConfig
/// - privateca:v1beta1 : AuditLogConfig
/// - run:v1 : AuditLogConfig
/// - run:v2 : GoogleIamV1AuditLogConfig
/// - secretmanager:v1 : AuditLogConfig
/// - secretmanager:v1beta1 : AuditLogConfig
/// - secretmanager:v1beta2 : AuditLogConfig
/// - securesourcemanager:v1 : AuditLogConfig
/// - securitycenter:v1 : AuditLogConfig
/// - securitycenter:v1beta1 : AuditLogConfig
/// - servicemanagement:v1 : AuditLogConfig
/// - vmwareengine:v1 : AuditLogConfig
/// - workstations:v1 : AuditLogConfig
/// - workstations:v1beta : AuditLogConfig
class $AuditLogConfig00 {
  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  ///
  /// Follows the same format of Binding.members.
  core.List<core.String>? exemptedMembers;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "LOG_TYPE_UNSPECIFIED" : Default case. Should never be this.
  /// - "ADMIN_READ" : Admin reads. Example: CloudIAM getIamPolicy
  /// - "DATA_WRITE" : Data writes. Example: CloudSQL Users create
  /// - "DATA_READ" : Data reads. Example: CloudSQL Users list
  core.String? logType;

  $AuditLogConfig00({this.exemptedMembers, this.logType});

  $AuditLogConfig00.fromJson(core.Map json_)
    : this(
        exemptedMembers:
            (json_['exemptedMembers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        logType: json_['logType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
    if (logType != null) 'logType': logType!,
  };
}

/// Used by:
///
/// - compute:alpha : AuditLogConfig
/// - compute:beta : AuditLogConfig
/// - compute:v1 : AuditLogConfig
class $AuditLogConfig01 {
  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  ///
  /// Follows the same format of Binding.members.
  core.List<core.String>? exemptedMembers;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "ADMIN_READ" : Admin reads. Example: CloudIAM getIamPolicy
  /// - "DATA_READ" : Data reads. Example: CloudSQL Users list
  /// - "DATA_WRITE" : Data writes. Example: CloudSQL Users create
  /// - "LOG_TYPE_UNSPECIFIED" : Default case. Should never be this.
  core.String? logType;

  $AuditLogConfig01({this.exemptedMembers, this.logType});

  $AuditLogConfig01.fromJson(core.Map json_)
    : this(
        exemptedMembers:
            (json_['exemptedMembers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        logType: json_['logType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
    if (logType != null) 'logType': logType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AugmentPromptRequestModel
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AugmentPromptRequestModel
class $AugmentPromptRequestModel {
  /// The model that the user will send the augmented prompt for content
  /// generation.
  ///
  /// Optional.
  core.String? model;

  /// The model version of the backend deployed model.
  ///
  /// Optional.
  core.String? modelVersion;

  $AugmentPromptRequestModel({this.model, this.modelVersion});

  $AugmentPromptRequestModel.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        modelVersion: json_['modelVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelVersion != null) 'modelVersion': modelVersion!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AuthConfigApiKeyConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AuthConfigApiKeyConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1AuthConfigApiKeyConfig
class $AuthConfigApiKeyConfig {
  /// The name of the SecretManager secret version resource storing the API key.
  ///
  /// Format: `projects/{project}/secrets/{secrete}/versions/{version}` - If
  /// both `api_key_secret` and `api_key_string` are specified, this field takes
  /// precedence over `api_key_string`. - If specified, the
  /// `secretmanager.versions.access` permission should be granted to Vertex AI
  /// Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  ///
  /// Optional.
  core.String? apiKeySecret;

  /// The API key to be used in the request directly.
  ///
  /// Optional.
  core.String? apiKeyString;

  /// The location of the API key.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HTTP_IN_UNSPECIFIED"
  /// - "HTTP_IN_QUERY" : Element is in the HTTP request query.
  /// - "HTTP_IN_HEADER" : Element is in the HTTP request header.
  /// - "HTTP_IN_PATH" : Element is in the HTTP request path.
  /// - "HTTP_IN_BODY" : Element is in the HTTP request body.
  /// - "HTTP_IN_COOKIE" : Element is in the HTTP request cookie.
  core.String? httpElementLocation;

  /// The parameter name of the API key.
  ///
  /// E.g. If the API request is "https://example.com/act?api_key=", "api_key"
  /// would be the parameter name.
  ///
  /// Optional.
  core.String? name;

  $AuthConfigApiKeyConfig({
    this.apiKeySecret,
    this.apiKeyString,
    this.httpElementLocation,
    this.name,
  });

  $AuthConfigApiKeyConfig.fromJson(core.Map json_)
    : this(
        apiKeySecret: json_['apiKeySecret'] as core.String?,
        apiKeyString: json_['apiKeyString'] as core.String?,
        httpElementLocation: json_['httpElementLocation'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeySecret != null) 'apiKeySecret': apiKeySecret!,
    if (apiKeyString != null) 'apiKeyString': apiKeyString!,
    if (httpElementLocation != null)
      'httpElementLocation': httpElementLocation!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AuthConfigGoogleServiceAccountConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AuthConfigGoogleServiceAccountConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1AuthConfigGoogleServiceAccountConfig
class $AuthConfigGoogleServiceAccountConfig {
  /// The service account that the extension execution service runs as.
  ///
  /// - If the service account is specified, the
  /// `iam.serviceAccounts.getAccessToken` permission should be granted to
  /// Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified service account. - If not specified, the Vertex AI
  /// Extension Service Agent will be used to execute the Extension.
  ///
  /// Optional.
  core.String? serviceAccount;

  $AuthConfigGoogleServiceAccountConfig({this.serviceAccount});

  $AuthConfigGoogleServiceAccountConfig.fromJson(core.Map json_)
    : this(serviceAccount: json_['serviceAccount'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AuthConfigHttpBasicAuthConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AuthConfigHttpBasicAuthConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1AuthConfigHttpBasicAuthConfig
class $AuthConfigHttpBasicAuthConfig {
  /// The name of the SecretManager secret version resource storing the base64
  /// encoded credentials.
  ///
  /// Format: `projects/{project}/secrets/{secrete}/versions/{version}` - If
  /// specified, the `secretmanager.versions.access` permission should be
  /// granted to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  ///
  /// Required.
  core.String? credentialSecret;

  $AuthConfigHttpBasicAuthConfig({this.credentialSecret});

  $AuthConfigHttpBasicAuthConfig.fromJson(core.Map json_)
    : this(credentialSecret: json_['credentialSecret'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (credentialSecret != null) 'credentialSecret': credentialSecret!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AuthConfigOauthConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AuthConfigOauthConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1AuthConfigOauthConfig
class $AuthConfigOauthConfig {
  /// Access token for extension endpoint.
  ///
  /// Only used to propagate token from
  /// \[\[ExecuteExtensionRequest.runtime_auth_config\]\] at request time.
  core.String? accessToken;

  /// The service account used to generate access tokens for executing the
  /// Extension.
  ///
  /// - If the service account is specified, the
  /// `iam.serviceAccounts.getAccessToken` permission should be granted to
  /// Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the provided service account.
  core.String? serviceAccount;

  $AuthConfigOauthConfig({this.accessToken, this.serviceAccount});

  $AuthConfigOauthConfig.fromJson(core.Map json_)
    : this(
        accessToken: json_['accessToken'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'accessToken': accessToken!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AuthConfigOidcConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AuthConfigOidcConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1AuthConfigOidcConfig
class $AuthConfigOidcConfig {
  /// OpenID Connect formatted ID token for extension endpoint.
  ///
  /// Only used to propagate token from
  /// \[\[ExecuteExtensionRequest.runtime_auth_config\]\] at request time.
  core.String? idToken;

  /// The service account used to generate an OpenID Connect (OIDC)-compatible
  /// JWT token signed by the Google OIDC Provider (accounts.google.com) for
  /// extension endpoint
  /// (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-oidc).
  ///
  /// - The audience for the token will be set to the URL in the server url
  /// defined in the OpenApi spec. - If the service account is provided, the
  /// service account should grant `iam.serviceAccounts.getOpenIdToken`
  /// permission to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  core.String? serviceAccount;

  $AuthConfigOidcConfig({this.idToken, this.serviceAccount});

  $AuthConfigOidcConfig.fromJson(core.Map json_)
    : this(
        idToken: json_['idToken'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idToken != null) 'idToken': idToken!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : AuthRequirement
/// - serviceusage:v1 : AuthRequirement
/// - serviceusage:v1beta1 : AuthRequirement
class $AuthRequirement {
  /// NOTE: This will be deprecated soon, once AuthProvider.audiences is
  /// implemented and accepted in all the runtime components.
  ///
  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted. When this setting is absent, only JWTs with audience
  /// "https://Service_name/API_name" will be accepted. For example, if no
  /// audiences are in the setting, LibraryService API will only accept JWTs
  /// with the following audience
  /// "https://library-example.googleapis.com/google.example.library.v1.LibraryService".
  /// Example: audiences: bookstore_android.apps.googleusercontent.com,
  /// bookstore_web.apps.googleusercontent.com
  core.String? audiences;

  /// id from authentication provider.
  ///
  /// Example: provider_id: bookstore_auth
  core.String? providerId;

  $AuthRequirement({this.audiences, this.providerId});

  $AuthRequirement.fromJson(core.Map json_)
    : this(
        audiences: json_['audiences'] as core.String?,
        providerId: json_['providerId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audiences != null) 'audiences': audiences!,
    if (providerId != null) 'providerId': providerId!,
  };
}

/// Used by:
///
/// - container:v1 : AuthenticatorGroupsConfig
/// - container:v1beta1 : AuthenticatorGroupsConfig
class $AuthenticatorGroupsConfig {
  /// Whether this cluster should return group membership lookups during
  /// authentication using a group of security groups.
  core.bool? enabled;

  /// The name of the security group-of-groups to be used.
  ///
  /// Only relevant if enabled = true.
  core.String? securityGroup;

  $AuthenticatorGroupsConfig({this.enabled, this.securityGroup});

  $AuthenticatorGroupsConfig.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        securityGroup: json_['securityGroup'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (securityGroup != null) 'securityGroup': securityGroup!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution
/// - places:v1 : GoogleMapsPlacesV1AuthorAttribution
class $AuthorAttribution {
  /// Name of the author of the Photo or Review.
  core.String? displayName;

  /// Profile photo URI of the author of the Photo or Review.
  core.String? photoUri;

  /// URI of the author of the Photo or Review.
  core.String? uri;

  $AuthorAttribution({this.displayName, this.photoUri, this.uri});

  $AuthorAttribution.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        photoUri: json_['photoUri'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (photoUri != null) 'photoUri': photoUri!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - gkehub:v1 : Authority
/// - gkehub:v1alpha : Authority
/// - gkehub:v1beta : Authority
class $Authority {
  /// An identity provider that reflects the `issuer` in the workload identity
  /// pool.
  ///
  /// Output only.
  core.String? identityProvider;

  /// A JSON Web Token (JWT) issuer URI.
  ///
  /// `issuer` must start with `https://` and be a valid URL with length \<2000
  /// characters, it must use `location` rather than `zone` for GKE clusters. If
  /// set, then Google will allow valid OIDC tokens from this issuer to
  /// authenticate within the workload_identity_pool. OIDC discovery will be
  /// performed on this URI to validate tokens from the issuer. Clearing
  /// `issuer` disables Workload Identity. `issuer` cannot be directly modified;
  /// it must be cleared (and Workload Identity disabled) before using a new
  /// issuer (and re-enabling Workload Identity).
  ///
  /// Optional.
  core.String? issuer;

  /// OIDC verification keys for this Membership in JWKS format (RFC 7517).
  ///
  /// When this field is set, OIDC discovery will NOT be performed on `issuer`,
  /// and instead OIDC tokens will be validated using this field.
  ///
  /// Optional.
  core.String? oidcJwks;
  core.List<core.int> get oidcJwksAsBytes => convert.base64.decode(oidcJwks!);

  set oidcJwksAsBytes(core.List<core.int> bytes_) {
    oidcJwks = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The identity provider for the scope-tenancy workload identity pool.
  ///
  /// Optional. Output only.
  core.String? scopeTenancyIdentityProvider;

  /// The name of the scope-tenancy workload identity pool.
  ///
  /// This pool is set in the fleet-level feature.
  ///
  /// Optional. Output only.
  core.String? scopeTenancyWorkloadIdentityPool;

  /// The name of the workload identity pool in which `issuer` will be
  /// recognized.
  ///
  /// There is a single Workload Identity Pool per Hub that is shared between
  /// all Memberships that belong to that Hub. For a Hub hosted in {PROJECT_ID},
  /// the workload pool format is `{PROJECT_ID}.hub.id.goog`, although this is
  /// subject to change in newer versions of this API.
  ///
  /// Output only.
  core.String? workloadIdentityPool;

  $Authority({
    this.identityProvider,
    this.issuer,
    this.oidcJwks,
    this.scopeTenancyIdentityProvider,
    this.scopeTenancyWorkloadIdentityPool,
    this.workloadIdentityPool,
  });

  $Authority.fromJson(core.Map json_)
    : this(
        identityProvider: json_['identityProvider'] as core.String?,
        issuer: json_['issuer'] as core.String?,
        oidcJwks: json_['oidcJwks'] as core.String?,
        scopeTenancyIdentityProvider:
            json_['scopeTenancyIdentityProvider'] as core.String?,
        scopeTenancyWorkloadIdentityPool:
            json_['scopeTenancyWorkloadIdentityPool'] as core.String?,
        workloadIdentityPool: json_['workloadIdentityPool'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identityProvider != null) 'identityProvider': identityProvider!,
    if (issuer != null) 'issuer': issuer!,
    if (oidcJwks != null) 'oidcJwks': oidcJwks!,
    if (scopeTenancyIdentityProvider != null)
      'scopeTenancyIdentityProvider': scopeTenancyIdentityProvider!,
    if (scopeTenancyWorkloadIdentityPool != null)
      'scopeTenancyWorkloadIdentityPool': scopeTenancyWorkloadIdentityPool!,
    if (workloadIdentityPool != null)
      'workloadIdentityPool': workloadIdentityPool!,
  };
}

/// Used by:
///
/// - domains:v1 : AuthorizationCode
/// - domains:v1alpha2 : AuthorizationCode
/// - domains:v1beta1 : AuthorizationCode
class $AuthorizationCode {
  /// The Authorization Code in ASCII.
  ///
  /// It can be used to transfer the domain to or from another registrar.
  core.String? code;

  $AuthorizationCode({this.code});

  $AuthorizationCode.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - appengine:v1 : AuthorizedDomain
/// - appengine:v1alpha : AuthorizedDomain
/// - appengine:v1beta : AuthorizedDomain
class $AuthorizedDomain {
  /// Fully qualified domain name of the domain authorized for use.
  ///
  /// Example: example.com.
  core.String? id;

  /// Full path to the AuthorizedDomain resource in the API.
  ///
  /// Example: apps/myapp/authorizedDomains/example.com.@OutputOnly
  core.String? name;

  $AuthorizedDomain({this.id, this.name});

  $AuthorizedDomain.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - alloydb:v1 : AuthorizedNetwork
/// - alloydb:v1alpha : AuthorizedNetwork
/// - alloydb:v1beta : AuthorizedNetwork
class $AuthorizedNetwork {
  /// CIDR range for one authorzied network of the instance.
  core.String? cidrRange;

  $AuthorizedNetwork({this.cidrRange});

  $AuthorizedNetwork.fromJson(core.Map json_)
    : this(cidrRange: json_['cidrRange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cidrRange != null) 'cidrRange': cidrRange!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AuthorizedSellerStatusAssignedTargetingOptionDetails
/// - displayvideo:v3 : AuthorizedSellerStatusAssignedTargetingOptionDetails
/// - displayvideo:v4 : AuthorizedSellerStatusAssignedTargetingOptionDetails
class $AuthorizedSellerStatusAssignedTargetingOptionDetails {
  /// The authorized seller status to target.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AUTHORIZED_SELLER_STATUS_UNSPECIFIED" : Default value when authorized
  /// seller status is not specified in this version. This enum is a placeholder
  /// for the default value, or "Authorized Direct Sellers and Resellers" in the
  /// UI.
  /// - "AUTHORIZED_SELLER_STATUS_AUTHORIZED_DIRECT_SELLERS_ONLY" : Only
  /// authorized sellers that directly own the inventory being monetized, as
  /// indicated by a DIRECT declaration in the ads.txt file. This value is
  /// equivalent to "Authorized Direct Sellers" in the UI.
  /// - "AUTHORIZED_SELLER_STATUS_AUTHORIZED_AND_NON_PARTICIPATING_PUBLISHERS" :
  /// All authorized sellers, including publishers that have not posted an
  /// ads.txt file. Display & Video 360 automatically disallows unauthorized
  /// sellers. This value is equivalent to "Authorized and Non-Participating
  /// Publishers" in the UI.
  core.String? authorizedSellerStatus;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_AUTHORIZED_SELLER_STATUS`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $AuthorizedSellerStatusAssignedTargetingOptionDetails({
    this.authorizedSellerStatus,
    this.targetingOptionId,
  });

  $AuthorizedSellerStatusAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        authorizedSellerStatus: json_['authorizedSellerStatus'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authorizedSellerStatus != null)
      'authorizedSellerStatus': authorizedSellerStatus!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : AuthorizedSellerStatusTargetingOptionDetails
/// - displayvideo:v3 : AuthorizedSellerStatusTargetingOptionDetails
/// - displayvideo:v4 : AuthorizedSellerStatusTargetingOptionDetails
class $AuthorizedSellerStatusTargetingOptionDetails {
  /// The authorized seller status.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AUTHORIZED_SELLER_STATUS_UNSPECIFIED" : Default value when authorized
  /// seller status is not specified in this version. This enum is a placeholder
  /// for the default value, or "Authorized Direct Sellers and Resellers" in the
  /// UI.
  /// - "AUTHORIZED_SELLER_STATUS_AUTHORIZED_DIRECT_SELLERS_ONLY" : Only
  /// authorized sellers that directly own the inventory being monetized, as
  /// indicated by a DIRECT declaration in the ads.txt file. This value is
  /// equivalent to "Authorized Direct Sellers" in the UI.
  /// - "AUTHORIZED_SELLER_STATUS_AUTHORIZED_AND_NON_PARTICIPATING_PUBLISHERS" :
  /// All authorized sellers, including publishers that have not posted an
  /// ads.txt file. Display & Video 360 automatically disallows unauthorized
  /// sellers. This value is equivalent to "Authorized and Non-Participating
  /// Publishers" in the UI.
  core.String? authorizedSellerStatus;

  $AuthorizedSellerStatusTargetingOptionDetails({this.authorizedSellerStatus});

  $AuthorizedSellerStatusTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        authorizedSellerStatus: json_['authorizedSellerStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authorizedSellerStatus != null)
      'authorizedSellerStatus': authorizedSellerStatus!,
  };
}

/// Used by:
///
/// - networkservices:v1 : AuthzExtension
/// - networkservices:v1beta1 : AuthzExtension
class $AuthzExtension {
  /// The `:authority` header in the gRPC request sent from Envoy to the
  /// extension service.
  ///
  /// Required.
  core.String? authority;

  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A human-readable description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// Determines how the proxy behaves if the call to the extension fails or
  /// times out.
  ///
  /// When set to `TRUE`, request or response processing continues without
  /// error. Any subsequent extensions in the extension chain are also executed.
  /// When set to `FALSE` or the default setting of `FALSE` is used, one of the
  /// following happens: * If response headers have not been delivered to the
  /// downstream client, a generic 500 error is returned to the client. The
  /// error response can be tailored by configuring a custom error response in
  /// the load balancer. * If response headers have been delivered, then the
  /// HTTP stream to the downstream client is reset.
  ///
  /// Optional.
  core.bool? failOpen;

  /// List of the HTTP headers to forward to the extension (from the client).
  ///
  /// If omitted, all headers are sent. Each element is a string indicating the
  /// header name.
  ///
  /// Optional.
  core.List<core.String>? forwardHeaders;

  /// Set of labels associated with the `AuthzExtension` resource.
  ///
  /// The format must comply with \[the requirements for
  /// labels\](/compute/docs/labeling-resources#requirements) for Google Cloud
  /// resources.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// All backend services and forwarding rules referenced by this extension
  /// must share the same load balancing scheme.
  ///
  /// Supported values: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`. For more
  /// information, refer to
  /// [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
  ///
  /// Required.
  /// Possible string values are:
  /// - "LOAD_BALANCING_SCHEME_UNSPECIFIED" : Default value. Do not use.
  /// - "INTERNAL_MANAGED" : Signifies that this is used for Internal HTTP(S)
  /// Load Balancing.
  /// - "EXTERNAL_MANAGED" : Signifies that this is used for External Managed
  /// HTTP(S) Load Balancing.
  core.String? loadBalancingScheme;

  /// The metadata provided here is included as part of the `metadata_context`
  /// (of type `google.protobuf.Struct`) in the `ProcessingRequest` message sent
  /// to the extension server.
  ///
  /// The metadata is available under the namespace
  /// `com.google.authz_extension.`. The following variables are supported in
  /// the metadata Struct: `{forwarding_rule_id}` - substituted with the
  /// forwarding rule's fully qualified resource name.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Identifier.
  ///
  /// Name of the `AuthzExtension` resource in the following format:
  /// `projects/{project}/locations/{location}/authzExtensions/{authz_extension}`.
  ///
  /// Required.
  core.String? name;

  /// The reference to the service that runs the extension.
  ///
  /// To configure a callout extension, `service` must be a fully-qualified
  /// reference to a
  /// [backend service](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices)
  /// in the format:
  /// `https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/backendServices/{backendService}`
  /// or
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices/{backendService}`.
  ///
  /// Required.
  core.String? service;

  /// Specifies the timeout for each individual message on the stream.
  ///
  /// The timeout must be between 10-10000 milliseconds.
  ///
  /// Required.
  core.String? timeout;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The format of communication supported by the callout extension.
  ///
  /// If not specified, the default value `EXT_PROC_GRPC` is used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "WIRE_FORMAT_UNSPECIFIED" : Not specified.
  /// - "EXT_PROC_GRPC" : The extension service uses ext_proc gRPC API over a
  /// gRPC stream. This is the default value if the wire format is not
  /// specified. The backend service for the extension must use HTTP2 or H2C as
  /// the protocol. All `supported_events` for a client request are sent as part
  /// of the same gRPC stream.
  /// - "EXT_AUTHZ_GRPC" : The extension service uses Envoy's `ext_authz` gRPC
  /// API. The backend service for the extension must use HTTP2, or H2C as the
  /// protocol. `EXT_AUTHZ_GRPC` is only supported for `AuthzExtension`
  /// resources.
  core.String? wireFormat;

  $AuthzExtension({
    this.authority,
    this.createTime,
    this.description,
    this.failOpen,
    this.forwardHeaders,
    this.labels,
    this.loadBalancingScheme,
    this.metadata,
    this.name,
    this.service,
    this.timeout,
    this.updateTime,
    this.wireFormat,
  });

  $AuthzExtension.fromJson(core.Map json_)
    : this(
        authority: json_['authority'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        failOpen: json_['failOpen'] as core.bool?,
        forwardHeaders:
            (json_['forwardHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        loadBalancingScheme: json_['loadBalancingScheme'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        service: json_['service'] as core.String?,
        timeout: json_['timeout'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        wireFormat: json_['wireFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authority != null) 'authority': authority!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (failOpen != null) 'failOpen': failOpen!,
    if (forwardHeaders != null) 'forwardHeaders': forwardHeaders!,
    if (labels != null) 'labels': labels!,
    if (loadBalancingScheme != null)
      'loadBalancingScheme': loadBalancingScheme!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (service != null) 'service': service!,
    if (timeout != null) 'timeout': timeout!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (wireFormat != null) 'wireFormat': wireFormat!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AuthzPolicyAuthzRuleIpBlock
/// - networksecurity:v1beta1 : AuthzPolicyAuthzRuleIpBlock
class $AuthzPolicyAuthzRuleIpBlock {
  /// The length of the address range.
  ///
  /// Required.
  core.int? length;

  /// The address prefix.
  ///
  /// Required.
  core.String? prefix;

  $AuthzPolicyAuthzRuleIpBlock({this.length, this.prefix});

  $AuthzPolicyAuthzRuleIpBlock.fromJson(core.Map json_)
    : this(
        length: json_['length'] as core.int?,
        prefix: json_['prefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (length != null) 'length': length!,
    if (prefix != null) 'prefix': prefix!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AuthzPolicyAuthzRuleRequestResourceTagValueIdSet
/// - networksecurity:v1beta1 : AuthzPolicyAuthzRuleRequestResourceTagValueIdSet
class $AuthzPolicyAuthzRuleRequestResourceTagValueIdSet {
  /// A list of resource tag value permanent IDs to match against the resource
  /// manager tags value associated with the source VM of a request.
  ///
  /// The match follows AND semantics which means all the ids must match.
  /// Limited to 5 matches.
  ///
  /// Required.
  core.List<core.String>? ids;

  $AuthzPolicyAuthzRuleRequestResourceTagValueIdSet({this.ids});

  $AuthzPolicyAuthzRuleRequestResourceTagValueIdSet.fromJson(core.Map json_)
    : this(
        ids:
            (json_['ids'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ids != null) 'ids': ids!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AuthzPolicyAuthzRuleStringMatch
/// - networksecurity:v1beta1 : AuthzPolicyAuthzRuleStringMatch
class $AuthzPolicyAuthzRuleStringMatch {
  /// The input string must have the substring specified here.
  ///
  /// Note: empty contains match is not allowed, please use regex instead.
  /// Examples: * ``abc`` matches the value ``xyz.abc.def``
  core.String? contains;

  /// The input string must match exactly the string specified here.
  ///
  /// Examples: * ``abc`` only matches the value ``abc``.
  core.String? exact;

  /// If true, indicates the exact/prefix/suffix/contains matching should be
  /// case insensitive.
  ///
  /// For example, the matcher ``data`` will match both input string ``Data``
  /// and ``data`` if set to true.
  core.bool? ignoreCase;

  /// The input string must have the prefix specified here.
  ///
  /// Note: empty prefix is not allowed, please use regex instead. Examples: *
  /// ``abc`` matches the value ``abc.xyz``
  core.String? prefix;

  /// The input string must have the suffix specified here.
  ///
  /// Note: empty prefix is not allowed, please use regex instead. Examples: *
  /// ``abc`` matches the value ``xyz.abc``
  core.String? suffix;

  $AuthzPolicyAuthzRuleStringMatch({
    this.contains,
    this.exact,
    this.ignoreCase,
    this.prefix,
    this.suffix,
  });

  $AuthzPolicyAuthzRuleStringMatch.fromJson(core.Map json_)
    : this(
        contains: json_['contains'] as core.String?,
        exact: json_['exact'] as core.String?,
        ignoreCase: json_['ignoreCase'] as core.bool?,
        prefix: json_['prefix'] as core.String?,
        suffix: json_['suffix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contains != null) 'contains': contains!,
    if (exact != null) 'exact': exact!,
    if (ignoreCase != null) 'ignoreCase': ignoreCase!,
    if (prefix != null) 'prefix': prefix!,
    if (suffix != null) 'suffix': suffix!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AuthzPolicyCustomProviderAuthzExtension
/// - networksecurity:v1beta1 : AuthzPolicyCustomProviderAuthzExtension
class $AuthzPolicyCustomProviderAuthzExtension {
  /// A list of references to authorization extensions that will be invoked for
  /// requests matching this policy.
  ///
  /// Limited to 1 custom provider.
  ///
  /// Required.
  core.List<core.String>? resources;

  $AuthzPolicyCustomProviderAuthzExtension({this.resources});

  $AuthzPolicyCustomProviderAuthzExtension.fromJson(core.Map json_)
    : this(
        resources:
            (json_['resources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resources != null) 'resources': resources!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : AuthzPolicyTarget
/// - networksecurity:v1beta1 : AuthzPolicyTarget
class $AuthzPolicyTarget {
  /// All gateways and forwarding rules referenced by this policy and extensions
  /// must share the same load balancing scheme.
  ///
  /// Supported values: `INTERNAL_MANAGED` and `EXTERNAL_MANAGED`. For more
  /// information, refer to
  /// [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
  ///
  /// Required.
  /// Possible string values are:
  /// - "LOAD_BALANCING_SCHEME_UNSPECIFIED" : Default value. Do not use.
  /// - "INTERNAL_MANAGED" : Signifies that this is used for Regional internal
  /// or Cross-region internal Application Load Balancing.
  /// - "EXTERNAL_MANAGED" : Signifies that this is used for Global external or
  /// Regional external Application Load Balancing.
  /// - "INTERNAL_SELF_MANAGED" : Signifies that this is used for Cloud Service
  /// Mesh. Meant for use by CSM GKE controller only.
  core.String? loadBalancingScheme;

  /// A list of references to the Forwarding Rules on which this policy will be
  /// applied.
  ///
  /// Required.
  core.List<core.String>? resources;

  $AuthzPolicyTarget({this.loadBalancingScheme, this.resources});

  $AuthzPolicyTarget.fromJson(core.Map json_)
    : this(
        loadBalancingScheme: json_['loadBalancingScheme'] as core.String?,
        resources:
            (json_['resources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (loadBalancingScheme != null)
      'loadBalancingScheme': loadBalancingScheme!,
    if (resources != null) 'resources': resources!,
  };
}

/// Used by:
///
/// - container:v1 : AutoIpamConfig
/// - container:v1beta1 : AutoIpamConfig
class $AutoIpamConfig {
  /// The flag that enables Auto IPAM on this cluster
  core.bool? enabled;

  $AutoIpamConfig({this.enabled});

  $AutoIpamConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - container:v1 : AutoMonitoringConfig
/// - container:v1beta1 : AutoMonitoringConfig
class $AutoMonitoringConfig {
  /// Scope for GKE Workload Auto-Monitoring.
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED" : Not set.
  /// - "ALL" : Auto-Monitoring is enabled for all supported applications.
  /// - "NONE" : Disable Auto-Monitoring.
  core.String? scope;

  $AutoMonitoringConfig({this.scope});

  $AutoMonitoringConfig.fromJson(core.Map json_)
    : this(scope: json_['scope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - identitytoolkit:v1 : GoogleCloudIdentitytoolkitV1AutoRetrievalInfo
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitV2AutoRetrievalInfo
class $AutoRetrievalInfo {
  /// The Android app's signature hash for Google Play Service's SMS Retriever
  /// API.
  core.String? appSignatureHash;

  $AutoRetrievalInfo({this.appSignatureHash});

  $AutoRetrievalInfo.fromJson(core.Map json_)
    : this(appSignatureHash: json_['appSignatureHash'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (appSignatureHash != null) 'appSignatureHash': appSignatureHash!,
  };
}

/// Used by:
///
/// - container:v1 : AutoUpgradeOptions
/// - container:v1beta1 : AutoUpgradeOptions
class $AutoUpgradeOptions {
  /// This field is set when upgrades are about to commence with the approximate
  /// start time for the upgrades, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  ///
  /// Output only.
  core.String? autoUpgradeStartTime;

  /// This field is set when upgrades are about to commence with the description
  /// of the upgrade.
  ///
  /// Output only.
  core.String? description;

  $AutoUpgradeOptions({this.autoUpgradeStartTime, this.description});

  $AutoUpgradeOptions.fromJson(core.Map json_)
    : this(
        autoUpgradeStartTime: json_['autoUpgradeStartTime'] as core.String?,
        description: json_['description'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoUpgradeStartTime != null)
      'autoUpgradeStartTime': autoUpgradeStartTime!,
    if (description != null) 'description': description!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AutomaticResources
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AutomaticResources
class $AutomaticResources {
  /// The maximum number of replicas that may be deployed on when the traffic
  /// against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale to that many replicas is
  /// guaranteed (barring service outages). If traffic increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, a no upper bound for scaling under heavy
  /// traffic will be assume, though Vertex AI may be unable to scale beyond
  /// certain replica number.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of replicas that will be always deployed on.
  ///
  /// If traffic against it increases, it may dynamically be deployed onto more
  /// replicas up to max_replica_count, and as traffic decreases, some of these
  /// extra replicas may be freed. If the requested value is too large, the
  /// deployment will error.
  ///
  /// Immutable.
  core.int? minReplicaCount;

  $AutomaticResources({this.maxReplicaCount, this.minReplicaCount});

  $AutomaticResources.fromJson(core.Map json_)
    : this(
        maxReplicaCount: json_['maxReplicaCount'] as core.int?,
        minReplicaCount: json_['minReplicaCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
    if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
  };
}

/// Used by:
///
/// - container:v1 : AutopilotCompatibilityIssue
/// - container:v1beta1 : AutopilotCompatibilityIssue
class $AutopilotCompatibilityIssue {
  /// The constraint type of the issue.
  core.String? constraintType;

  /// The description of the issue.
  core.String? description;

  /// A URL to a public documentation, which addresses resolving this issue.
  core.String? documentationUrl;

  /// The incompatibility type of this issue.
  /// Possible string values are:
  /// - "UNSPECIFIED" : Default value, should not be used.
  /// - "INCOMPATIBILITY" : Indicates that the issue is a known incompatibility
  /// between the cluster and Autopilot mode.
  /// - "ADDITIONAL_CONFIG_REQUIRED" : Indicates the issue is an incompatibility
  /// if customers take no further action to resolve.
  /// - "PASSED_WITH_OPTIONAL_CONFIG" : Indicates the issue is not an
  /// incompatibility, but depending on the workloads business logic, there is a
  /// potential that they won't work on Autopilot.
  core.String? incompatibilityType;

  /// The last time when this issue was observed.
  core.String? lastObservation;

  /// The name of the resources which are subject to this issue.
  core.List<core.String>? subjects;

  $AutopilotCompatibilityIssue({
    this.constraintType,
    this.description,
    this.documentationUrl,
    this.incompatibilityType,
    this.lastObservation,
    this.subjects,
  });

  $AutopilotCompatibilityIssue.fromJson(core.Map json_)
    : this(
        constraintType: json_['constraintType'] as core.String?,
        description: json_['description'] as core.String?,
        documentationUrl: json_['documentationUrl'] as core.String?,
        incompatibilityType: json_['incompatibilityType'] as core.String?,
        lastObservation: json_['lastObservation'] as core.String?,
        subjects:
            (json_['subjects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (constraintType != null) 'constraintType': constraintType!,
    if (description != null) 'description': description!,
    if (documentationUrl != null) 'documentationUrl': documentationUrl!,
    if (incompatibilityType != null)
      'incompatibilityType': incompatibilityType!,
    if (lastObservation != null) 'lastObservation': lastObservation!,
    if (subjects != null) 'subjects': subjects!,
  };
}

/// Used by:
///
/// - container:v1 : AutopilotConfig
/// - container:v1beta1 : AutopilotConfig
class $AutopilotConfig {
  /// Denotes that nodes belonging to this node pool are Autopilot nodes.
  core.bool? enabled;

  $AutopilotConfig({this.enabled});

  $AutopilotConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AutoraterConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AutoraterConfig
class $AutoraterConfig {
  /// The fully qualified name of the publisher model or tuned autorater
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Optional.
  core.String? autoraterModel;

  /// Default is true.
  ///
  /// Whether to flip the candidate and baseline responses. This is only
  /// applicable to the pairwise metric. If enabled, also provide
  /// PairwiseMetricSpec.candidate_response_field_name and
  /// PairwiseMetricSpec.baseline_response_field_name. When rendering
  /// PairwiseMetricSpec.metric_prompt_template, the candidate and baseline
  /// fields will be flipped for half of the samples to reduce bias.
  ///
  /// Optional.
  core.bool? flipEnabled;

  /// Number of samples for each instance in the dataset.
  ///
  /// If not specified, the default is 4. Minimum value is 1, maximum value is
  /// 32.
  ///
  /// Optional.
  core.int? samplingCount;

  $AutoraterConfig({this.autoraterModel, this.flipEnabled, this.samplingCount});

  $AutoraterConfig.fromJson(core.Map json_)
    : this(
        autoraterModel: json_['autoraterModel'] as core.String?,
        flipEnabled: json_['flipEnabled'] as core.bool?,
        samplingCount: json_['samplingCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoraterModel != null) 'autoraterModel': autoraterModel!,
    if (flipEnabled != null) 'flipEnabled': flipEnabled!,
    if (samplingCount != null) 'samplingCount': samplingCount!,
  };
}

/// Used by:
///
/// - compute:alpha : AutoscalerStatusDetails
/// - compute:beta : AutoscalerStatusDetails
/// - compute:v1 : AutoscalerStatusDetails
class $AutoscalerStatusDetails {
  /// The status message.
  core.String? message;

  /// The type of error, warning, or notice returned.
  ///
  /// Current set of possible values: - ALL_INSTANCES_UNHEALTHY (WARNING): All
  /// instances in the instance group are unhealthy (not in RUNNING state). -
  /// BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  /// attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING):
  /// Autoscaler recommends a size greater than maxNumReplicas. -
  /// CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples
  /// are not exported often enough to be a credible base for autoscaling. -
  /// CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  /// not exist or does not have the necessary labels. - MIN_EQUALS_MAX
  /// (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the
  /// autoscaler cannot add or remove instances from the instance group. -
  /// MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not
  /// receive any data from the custom metric configured for autoscaling. -
  /// MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured
  /// to scale based on a load balancing signal but the instance group has not
  /// received any requests from the load balancer. - MODE_OFF (WARNING):
  /// Autoscaling is turned off. The number of instances in the group won't
  /// change automatically. The autoscaling configuration is preserved. -
  /// MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode.
  /// The autoscaler can add instances but not remove any. -
  /// MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it. -
  /// NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances. -
  /// REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  /// there is a resource stockout in the chosen region. -
  /// SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  /// exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR):
  /// Autoscaling does not work with an HTTP/S load balancer that has been
  /// configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal
  /// autoscalers: there is a resource stockout in the chosen zone. For regional
  /// autoscalers: in at least one of the zones you're using there is a resource
  /// stockout. New values might be added in the future. Some of the values
  /// might not be available in all API versions.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY" : All instances in the instance group are
  /// unhealthy (not in RUNNING state).
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST" : There is no backend service attached
  /// to the instance group.
  /// - "CAPPED_AT_MAX_NUM_REPLICAS" : Autoscaler recommends a size greater than
  /// maxNumReplicas.
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE" : The custom metric samples are
  /// not exported often enough to be a credible base for autoscaling.
  /// - "CUSTOM_METRIC_INVALID" : The custom metric that was specified does not
  /// exist or does not have the necessary labels.
  /// - "MIN_EQUALS_MAX" : The minNumReplicas is equal to maxNumReplicas. This
  /// means the autoscaler cannot add or remove instances from the instance
  /// group.
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS" : The autoscaler did not receive any
  /// data from the custom metric configured for autoscaling.
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS" : The autoscaler is configured to
  /// scale based on a load balancing signal but the instance group has not
  /// received any requests from the load balancer.
  /// - "MODE_OFF" : Autoscaling is turned off. The number of instances in the
  /// group won't change automatically. The autoscaling configuration is
  /// preserved.
  /// - "MODE_ONLY_SCALE_OUT" : Autoscaling is in the "Autoscale only scale out"
  /// mode. Instances in the group will be only added.
  /// - "MODE_ONLY_UP" : Autoscaling is in the "Autoscale only out" mode.
  /// Instances in the group will be only added.
  /// - "MORE_THAN_ONE_BACKEND_SERVICE" : The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it.
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE" : There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances.
  /// - "REGION_RESOURCE_STOCKOUT" : Showed only for regional autoscalers: there
  /// is a resource stockout in the chosen region.
  /// - "SCALING_TARGET_DOES_NOT_EXIST" : The target to be scaled does not
  /// exist.
  /// - "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX" : For some scaling
  /// schedules minRequiredReplicas is greater than maxNumReplicas. Autoscaler
  /// always recommends at most maxNumReplicas instances.
  /// - "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN" : For some scaling
  /// schedules minRequiredReplicas is less than minNumReplicas. Autoscaler
  /// always recommends at least minNumReplicas instances.
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION" : Autoscaling does
  /// not work with an HTTP/S load balancer that has been configured for
  /// maxRate.
  /// - "ZONE_RESOURCE_STOCKOUT" : For zonal autoscalers: there is a resource
  /// stockout in the chosen zone. For regional autoscalers: in at least one of
  /// the zones you're using there is a resource stockout.
  core.String? type;

  $AutoscalerStatusDetails({this.message, this.type});

  $AutoscalerStatusDetails.fromJson(core.Map json_)
    : this(
        message: json_['message'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (message != null) 'message': message!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AutoscalingMetricSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AutoscalingMetricSpec
class $AutoscalingMetricSpec {
  /// The resource metric name.
  ///
  /// Supported metrics: * For Online Prediction: *
  /// `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` *
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization` *
  /// `aiplatform.googleapis.com/prediction/online/request_count`
  ///
  /// Required.
  core.String? metricName;

  /// The target resource utilization in percentage (1% - 100%) for the given
  /// metric; once the real usage deviates from the target by a certain
  /// percentage, the machine replicas change.
  ///
  /// The default value is 60 (representing 60%) if not provided.
  core.int? target;

  $AutoscalingMetricSpec({this.metricName, this.target});

  $AutoscalingMetricSpec.fromJson(core.Map json_)
    : this(
        metricName: json_['metricName'] as core.String?,
        target: json_['target'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricName != null) 'metricName': metricName!,
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - compute:alpha : AutoscalingPolicyCustomMetricUtilization
/// - compute:beta : AutoscalingPolicyCustomMetricUtilization
/// - compute:v1 : AutoscalingPolicyCustomMetricUtilization
class $AutoscalingPolicyCustomMetricUtilization {
  /// A filter string, compatible with a Stackdriver Monitoring filter string
  /// for TimeSeries.list API call.
  ///
  /// This filter is used to select a specific TimeSeries for the purpose of
  /// autoscaling and to determine whether the metric is exporting per-instance
  /// or per-group data. For the filter to be valid for autoscaling purposes,
  /// the following rules apply: - You can only use the AND operator for joining
  /// selectors. - You can only use direct equality comparison operator (=)
  /// without any functions for each selector. - You can specify the metric in
  /// both the filter string and in the metric field. However, if specified in
  /// both places, the metric must be identical. - The monitored resource type
  /// determines what kind of values are expected for the metric. If it is a
  /// gce_instance, the autoscaler expects the metric to include a separate
  /// TimeSeries for each instance in a group. In such a case, you cannot filter
  /// on resource labels. If the resource type is any other value, the
  /// autoscaler expects this metric to contain values that apply to the entire
  /// autoscaled instance group and resource label filtering can be performed to
  /// point autoscaler at the correct TimeSeries to scale upon. This is called a
  /// *per-group metric* for the purpose of autoscaling. If not specified, the
  /// type defaults to gce_instance. Try to provide a filter that is selective
  /// enough to pick just one TimeSeries for the autoscaled group or for each of
  /// the instances (if you are using gce_instance resource type). If multiple
  /// TimeSeries are returned upon the query execution, the autoscaler will sum
  /// their respective values to obtain its scaling value.
  core.String? filter;

  /// The identifier (type) of the Stackdriver Monitoring metric.
  ///
  /// The metric cannot have negative values. The metric must have a value type
  /// of INT64 or DOUBLE.
  core.String? metric;

  /// If scaling is based on a per-group metric value that represents the total
  /// amount of work to be done or resource usage, set this value to an amount
  /// assigned for a single instance of the scaled group.
  ///
  /// Autoscaler keeps the number of instances proportional to the value of this
  /// metric. The metric itself does not change value due to group resizing. A
  /// good metric to use with the target is for example
  /// pubsub.googleapis.com/subscription/num_undelivered_messages or a custom
  /// metric exporting the total number of requests coming to your instances. A
  /// bad example would be a metric exporting an average or median latency,
  /// since this value can't include a chunk assignable to a single instance, it
  /// could be better used with utilization_target instead.
  core.double? singleInstanceAssignment;

  /// The target value of the metric that autoscaler maintains.
  ///
  /// This must be a positive value. A utilization metric scales number of
  /// virtual machines handling requests to increase or decrease proportionally
  /// to the metric. For example, a good metric to use as a utilization_target
  /// is
  /// https://www.googleapis.com/compute/v1/instance/network/received_bytes_count.
  /// The autoscaler works to keep this value constant for each of the
  /// instances.
  core.double? utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric.
  ///
  /// Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE" : Sets the utilization target value for a cumulative
  /// or delta metric, expressed as the rate of growth per minute.
  /// - "DELTA_PER_SECOND" : Sets the utilization target value for a cumulative
  /// or delta metric, expressed as the rate of growth per second.
  /// - "GAUGE" : Sets the utilization target value for a gauge metric. The
  /// autoscaler will collect the average utilization of the virtual machines
  /// from the last couple of minutes, and compare the value to the utilization
  /// target value to perform autoscaling.
  core.String? utilizationTargetType;

  $AutoscalingPolicyCustomMetricUtilization({
    this.filter,
    this.metric,
    this.singleInstanceAssignment,
    this.utilizationTarget,
    this.utilizationTargetType,
  });

  $AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        metric: json_['metric'] as core.String?,
        singleInstanceAssignment:
            (json_['singleInstanceAssignment'] as core.num?)?.toDouble(),
        utilizationTarget:
            (json_['utilizationTarget'] as core.num?)?.toDouble(),
        utilizationTargetType: json_['utilizationTargetType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (metric != null) 'metric': metric!,
    if (singleInstanceAssignment != null)
      'singleInstanceAssignment': singleInstanceAssignment!,
    if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
    if (utilizationTargetType != null)
      'utilizationTargetType': utilizationTargetType!,
  };
}

/// Used by:
///
/// - compute:alpha : AutoscalingPolicyLoadBalancingUtilization
/// - compute:beta : AutoscalingPolicyLoadBalancingUtilization
/// - compute:v1 : AutoscalingPolicyLoadBalancingUtilization
class $AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(S) load balancing
  /// configuration) that the autoscaler maintains.
  ///
  /// Must be a positive float value. If not defined, the default is 0.8.
  core.double? utilizationTarget;

  $AutoscalingPolicyLoadBalancingUtilization({this.utilizationTarget});

  $AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map json_)
    : this(
        utilizationTarget:
            (json_['utilizationTarget'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
  };
}

/// Used by:
///
/// - compute:alpha : AutoscalingPolicyScalingSchedule
/// - compute:beta : AutoscalingPolicyScalingSchedule
/// - compute:v1 : AutoscalingPolicyScalingSchedule
class $AutoscalingPolicyScalingSchedule {
  /// A description of a scaling schedule.
  core.String? description;

  /// A boolean value that specifies whether a scaling schedule can influence
  /// autoscaler recommendations.
  ///
  /// If set to true, then a scaling schedule has no effect. This field is
  /// optional, and its value is false by default.
  core.bool? disabled;

  /// The duration of time intervals, in seconds, for which this scaling
  /// schedule is to run.
  ///
  /// The minimum allowed value is 300. This field is required.
  core.int? durationSec;

  /// The minimum number of VM instances that the autoscaler will recommend in
  /// time intervals starting according to schedule.
  ///
  /// This field is required.
  core.int? minRequiredReplicas;

  /// The start timestamps of time intervals when this scaling schedule is to
  /// provide a scaling signal.
  ///
  /// This field uses the extended cron format (with an optional year field).
  /// The expression can describe a single timestamp if the optional year is
  /// set, in which case the scaling schedule runs once. The schedule is
  /// interpreted with respect to time_zone. This field is required. Note: These
  /// timestamps only describe when autoscaler starts providing the scaling
  /// signal. The VMs need additional time to become serving.
  core.String? schedule;

  /// The time zone to use when interpreting the schedule.
  ///
  /// The value of this field must be a time zone name from the tz database:
  /// https://en.wikipedia.org/wiki/Tz_database. This field is assigned a
  /// default value of "UTC" if left empty.
  core.String? timeZone;

  $AutoscalingPolicyScalingSchedule({
    this.description,
    this.disabled,
    this.durationSec,
    this.minRequiredReplicas,
    this.schedule,
    this.timeZone,
  });

  $AutoscalingPolicyScalingSchedule.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        disabled: json_['disabled'] as core.bool?,
        durationSec: json_['durationSec'] as core.int?,
        minRequiredReplicas: json_['minRequiredReplicas'] as core.int?,
        schedule: json_['schedule'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (disabled != null) 'disabled': disabled!,
    if (durationSec != null) 'durationSec': durationSec!,
    if (minRequiredReplicas != null)
      'minRequiredReplicas': minRequiredReplicas!,
    if (schedule != null) 'schedule': schedule!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : AvailableDatabaseVersion
/// - sqladmin:v1beta4 : AvailableDatabaseVersion
class $AvailableDatabaseVersion {
  /// The database version's display name.
  core.String? displayName;

  /// The version's major version name.
  core.String? majorVersion;

  /// The database version name.
  ///
  /// For MySQL 8.0, this string provides the database major and minor version.
  core.String? name;

  $AvailableDatabaseVersion({this.displayName, this.majorVersion, this.name});

  $AvailableDatabaseVersion.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        majorVersion: json_['majorVersion'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (majorVersion != null) 'majorVersion': majorVersion!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : AvroConfig
/// - pubsub:v1 : AvroConfig
class $AvroConfig {
  /// When true, the output Cloud Storage file will be serialized using the
  /// topic schema, if it exists.
  ///
  /// Optional.
  core.bool? useTopicSchema;

  /// When true, write the subscription name, message_id, publish_time,
  /// attributes, and ordering_key as additional fields in the output.
  ///
  /// The subscription name, message_id, and publish_time fields are put in
  /// their own fields while all other message properties other than data (for
  /// example, an ordering_key, if present) are added as entries in the
  /// attributes map.
  ///
  /// Optional.
  core.bool? writeMetadata;

  $AvroConfig({this.useTopicSchema, this.writeMetadata});

  $AvroConfig.fromJson(core.Map json_)
    : this(
        useTopicSchema: json_['useTopicSchema'] as core.bool?,
        writeMetadata: json_['writeMetadata'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useTopicSchema != null) 'useTopicSchema': useTopicSchema!,
    if (writeMetadata != null) 'writeMetadata': writeMetadata!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AwsDiskDetails
/// - vmmigration:v1alpha1 : AwsDiskDetails
class $AwsDiskDetails {
  /// The ordinal number of the disk.
  ///
  /// Output only.
  core.int? diskNumber;

  /// Size in GB.
  ///
  /// Output only.
  core.String? sizeGb;

  /// AWS volume ID.
  ///
  /// Output only.
  core.String? volumeId;

  $AwsDiskDetails({this.diskNumber, this.sizeGb, this.volumeId});

  $AwsDiskDetails.fromJson(core.Map json_)
    : this(
        diskNumber: json_['diskNumber'] as core.int?,
        sizeGb: json_['sizeGb'] as core.String?,
        volumeId: json_['volumeId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskNumber != null) 'diskNumber': diskNumber!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
    if (volumeId != null) 'volumeId': volumeId!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AwsEc2PlatformDetails
/// - migrationcenter:v1alpha1 : AwsEc2PlatformDetails
class $AwsEc2PlatformDetails {
  /// Whether the machine is hyperthreaded.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HYPERTHREADING_STATUS_UNSPECIFIED" : Simultaneous Multithreading status
  /// unknown.
  /// - "HYPERTHREADING_STATUS_DISABLED" : Simultaneous Multithreading is
  /// disabled or unavailable.
  /// - "HYPERTHREADING_STATUS_ENABLED" : Simultaneous Multithreading is
  /// enabled.
  core.String? hyperthreading;

  /// The location of the machine in the AWS format.
  core.String? location;

  /// AWS platform's machine type label.
  core.String? machineTypeLabel;

  $AwsEc2PlatformDetails({
    this.hyperthreading,
    this.location,
    this.machineTypeLabel,
  });

  $AwsEc2PlatformDetails.fromJson(core.Map json_)
    : this(
        hyperthreading: json_['hyperthreading'] as core.String?,
        location: json_['location'] as core.String?,
        machineTypeLabel: json_['machineTypeLabel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperthreading != null) 'hyperthreading': hyperthreading!,
    if (location != null) 'location': location!,
    if (machineTypeLabel != null) 'machineTypeLabel': machineTypeLabel!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AwsSecurityGroup
/// - vmmigration:v1alpha1 : AwsSecurityGroup
class $AwsSecurityGroup {
  /// The AWS security group id.
  core.String? id;

  /// The AWS security group name.
  core.String? name;

  $AwsSecurityGroup({this.id, this.name});

  $AwsSecurityGroup.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : AzureDiskDetails
/// - vmmigration:v1alpha1 : AzureDiskDetails
class $AzureDiskDetails {
  /// Azure disk ID.
  ///
  /// Output only.
  core.String? diskId;

  /// The ordinal number of the disk.
  ///
  /// Output only.
  core.int? diskNumber;

  /// Size in GB.
  ///
  /// Output only.
  core.String? sizeGb;

  $AzureDiskDetails({this.diskId, this.diskNumber, this.sizeGb});

  $AzureDiskDetails.fromJson(core.Map json_)
    : this(
        diskId: json_['diskId'] as core.String?,
        diskNumber: json_['diskNumber'] as core.int?,
        sizeGb: json_['sizeGb'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskId != null) 'diskId': diskId!,
    if (diskNumber != null) 'diskNumber': diskNumber!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : AzureVmPlatformDetails
/// - migrationcenter:v1alpha1 : AzureVmPlatformDetails
class $AzureVmPlatformDetails {
  /// Whether the machine is hyperthreaded.
  /// Possible string values are:
  /// - "HYPERTHREADING_STATUS_UNSPECIFIED" : Simultaneous Multithreading status
  /// unknown.
  /// - "HYPERTHREADING_STATUS_DISABLED" : Simultaneous Multithreading is
  /// disabled or unavailable.
  /// - "HYPERTHREADING_STATUS_ENABLED" : Simultaneous Multithreading is
  /// enabled.
  core.String? hyperthreading;

  /// The location of the machine in the Azure format.
  core.String? location;

  /// Azure platform's machine type label.
  core.String? machineTypeLabel;

  /// Azure platform's provisioning state.
  core.String? provisioningState;

  $AzureVmPlatformDetails({
    this.hyperthreading,
    this.location,
    this.machineTypeLabel,
    this.provisioningState,
  });

  $AzureVmPlatformDetails.fromJson(core.Map json_)
    : this(
        hyperthreading: json_['hyperthreading'] as core.String?,
        location: json_['location'] as core.String?,
        machineTypeLabel: json_['machineTypeLabel'] as core.String?,
        provisioningState: json_['provisioningState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperthreading != null) 'hyperthreading': hyperthreading!,
    if (location != null) 'location': location!,
    if (machineTypeLabel != null) 'machineTypeLabel': machineTypeLabel!,
    if (provisioningState != null) 'provisioningState': provisioningState!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : BackendAuthenticationConfig
/// - networksecurity:v1beta1 : BackendAuthenticationConfig
class $BackendAuthenticationConfig {
  /// A reference to a certificatemanager.googleapis.com.Certificate resource.
  ///
  /// This is a relative resource path following the form
  /// "projects/{project}/locations/{location}/certificates/{certificate}". Used
  /// by a BackendService to negotiate mTLS when the backend connection uses TLS
  /// and the backend requests a client certificate. Must have a CLIENT_AUTH
  /// scope.
  ///
  /// Optional.
  core.String? clientCertificate;

  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// Etag of the resource.
  ///
  /// Output only.
  core.String? etag;

  /// Set of label tags associated with the resource.
  core.Map<core.String, core.String>? labels;

  /// Name of the BackendAuthenticationConfig resource.
  ///
  /// It matches the pattern `projects / *
  /// /locations/{location}/backendAuthenticationConfigs/{backend_authentication_config}`
  ///
  /// Required.
  core.String? name;

  /// A reference to a TrustConfig resource from the
  /// certificatemanager.googleapis.com namespace.
  ///
  /// This is a relative resource path following the form
  /// "projects/{project}/locations/{location}/trustConfigs/{trust_config}". A
  /// BackendService uses the chain of trust represented by this TrustConfig, if
  /// specified, to validate the server certificates presented by the backend.
  /// Required unless wellKnownRoots is set to PUBLIC_ROOTS.
  ///
  /// Optional.
  core.String? trustConfig;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Well known roots to use for server certificate validation.
  /// Possible string values are:
  /// - "WELL_KNOWN_ROOTS_UNSPECIFIED" : Equivalent to NONE.
  /// - "NONE" : The BackendService will only validate server certificates
  /// against roots specified in TrustConfig.
  /// - "PUBLIC_ROOTS" : The BackendService uses a set of well-known public
  /// roots, in addition to any roots specified in the trustConfig field, when
  /// validating the server certificates presented by the backend. Validation
  /// with these roots is only considered when the TlsSettings.sni field in the
  /// BackendService is set. The well-known roots are a set of root CAs managed
  /// by Google. CAs in this set can be added or removed without notice.
  core.String? wellKnownRoots;

  $BackendAuthenticationConfig({
    this.clientCertificate,
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.name,
    this.trustConfig,
    this.updateTime,
    this.wellKnownRoots,
  });

  $BackendAuthenticationConfig.fromJson(core.Map json_)
    : this(
        clientCertificate: json_['clientCertificate'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        trustConfig: json_['trustConfig'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        wellKnownRoots: json_['wellKnownRoots'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientCertificate != null) 'clientCertificate': clientCertificate!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (trustConfig != null) 'trustConfig': trustConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (wellKnownRoots != null) 'wellKnownRoots': wellKnownRoots!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendBucketCdnPolicyCacheKeyPolicy
/// - compute:beta : BackendBucketCdnPolicyCacheKeyPolicy
/// - compute:v1 : BackendBucketCdnPolicyCacheKeyPolicy
class $BackendBucketCdnPolicyCacheKeyPolicy {
  /// Allows HTTP request headers (by name) to be used in the cache key.
  core.List<core.String>? includeHttpHeaders;

  /// Names of query string parameters to include in cache keys.
  ///
  /// Default parameters are always included. '&' and '=' will be percent
  /// encoded and not treated as delimiters.
  core.List<core.String>? queryStringWhitelist;

  $BackendBucketCdnPolicyCacheKeyPolicy({
    this.includeHttpHeaders,
    this.queryStringWhitelist,
  });

  $BackendBucketCdnPolicyCacheKeyPolicy.fromJson(core.Map json_)
    : this(
        includeHttpHeaders:
            (json_['includeHttpHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        queryStringWhitelist:
            (json_['queryStringWhitelist'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeHttpHeaders != null) 'includeHttpHeaders': includeHttpHeaders!,
    if (queryStringWhitelist != null)
      'queryStringWhitelist': queryStringWhitelist!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendBucketUsedBy
/// - compute:beta : BackendBucketUsedBy
/// - compute:v1 : BackendBucketUsedBy
class $BackendBucketUsedBy {
  /// Server-defined URL for UrlMaps referencing that BackendBucket.
  ///
  /// Output only.
  core.String? reference;

  $BackendBucketUsedBy({this.reference});

  $BackendBucketUsedBy.fromJson(core.Map json_)
    : this(reference: json_['reference'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendCustomMetric
/// - compute:beta : BackendCustomMetric
/// - compute:v1 : BackendCustomMetric
class $BackendCustomMetric {
  /// If true, the metric data is collected and reported to Cloud Monitoring,
  /// but is not used for load balancing.
  core.bool? dryRun;

  /// Optional parameter to define a target utilization for the Custom Metrics
  /// balancing mode.
  ///
  /// The valid range is \[0.0, 1.0\].
  core.double? maxUtilization;

  /// Name of a custom utilization signal.
  ///
  /// The name must be 1-64 characters long and match the regular expression
  /// \[a-z\](\[-_.a-z0-9\]*\[a-z0-9\])? which means that the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// period, underscore, lowercase letter, or digit, except the last character,
  /// which cannot be a dash, period, or underscore. For usage guidelines, see
  /// Custom Metrics balancing mode. This field can only be used for a global or
  /// regional backend service with the loadBalancingScheme set to
  /// EXTERNAL_MANAGED, INTERNAL_MANAGED INTERNAL_SELF_MANAGED.
  core.String? name;

  $BackendCustomMetric({this.dryRun, this.maxUtilization, this.name});

  $BackendCustomMetric.fromJson(core.Map json_)
    : this(
        dryRun: json_['dryRun'] as core.bool?,
        maxUtilization: (json_['maxUtilization'] as core.num?)?.toDouble(),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dryRun != null) 'dryRun': dryRun!,
    if (maxUtilization != null) 'maxUtilization': maxUtilization!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : BackendMetastore
/// - metastore:v1beta : BackendMetastore
class $BackendMetastore {
  /// The type of the backend metastore.
  /// Possible string values are:
  /// - "METASTORE_TYPE_UNSPECIFIED" : The metastore type is not set.
  /// - "DATAPLEX" : The backend metastore is Dataplex.
  /// - "BIGQUERY" : The backend metastore is BigQuery.
  /// - "DATAPROC_METASTORE" : The backend metastore is Dataproc Metastore.
  core.String? metastoreType;

  /// The relative resource name of the metastore that is being federated.
  ///
  /// The formats of the relative resource names for the currently supported
  /// metastores are listed below: BigQuery projects/{project_id} Dataproc
  /// Metastore projects/{project_id}/locations/{location}/services/{service_id}
  core.String? name;

  $BackendMetastore({this.metastoreType, this.name});

  $BackendMetastore.fromJson(core.Map json_)
    : this(
        metastoreType: json_['metastoreType'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metastoreType != null) 'metastoreType': metastoreType!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceConnectionTrackingPolicy
/// - compute:beta : BackendServiceConnectionTrackingPolicy
/// - compute:v1 : BackendServiceConnectionTrackingPolicy
class $BackendServiceConnectionTrackingPolicy {
  /// Specifies connection persistence when backends are unhealthy.
  ///
  /// The default value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL,
  /// the existing connections persist on unhealthy backends only for
  /// connection-oriented protocols (TCP and SCTP) and only if the Tracking Mode
  /// is PER_CONNECTION (default tracking mode) or the Session Affinity is
  /// configured for 5-tuple. They do not persist for UDP. If set to
  /// NEVER_PERSIST, after a backend becomes unhealthy, the existing connections
  /// on the unhealthy backend are never persisted on the unhealthy backend.
  /// They are always diverted to newly selected healthy backends (unless all
  /// backends are unhealthy). If set to ALWAYS_PERSIST, existing connections
  /// always persist on unhealthy backends regardless of protocol and session
  /// affinity. It is generally not recommended to use this mode overriding the
  /// default. For more details, see
  /// [Connection Persistence for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#connection-persistence)
  /// and
  /// [Connection Persistence for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#connection-persistence).
  /// Possible string values are:
  /// - "ALWAYS_PERSIST"
  /// - "DEFAULT_FOR_PROTOCOL"
  /// - "NEVER_PERSIST"
  core.String? connectionPersistenceOnUnhealthyBackends;

  /// Enable Strong Session Affinity for external passthrough Network Load
  /// Balancers.
  ///
  /// This option is not available publicly.
  core.bool? enableStrongAffinity;

  /// Specifies how long to keep a Connection Tracking entry while there is no
  /// matching traffic (in seconds).
  ///
  /// For internal passthrough Network Load Balancers: - The minimum (default)
  /// is 10 minutes and the maximum is 16 hours. - It can be set only if
  /// Connection Tracking is less than 5-tuple (i.e. Session Affinity is
  /// CLIENT_IP_NO_DESTINATION, CLIENT_IP or CLIENT_IP_PROTO, and Tracking Mode
  /// is PER_SESSION). For external passthrough Network Load Balancers the
  /// default is 60 seconds. This option is not available publicly.
  core.int? idleTimeoutSec;

  /// Specifies the key used for connection tracking.
  ///
  /// There are two options: - PER_CONNECTION: This is the default mode. The
  /// Connection Tracking is performed as per the Connection Key (default Hash
  /// Method) for the specific protocol. - PER_SESSION: The Connection Tracking
  /// is performed as per the configured Session Affinity. It matches the
  /// configured Session Affinity. For more details, see
  /// [Tracking Mode for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#tracking-mode)
  /// and
  /// [Tracking Mode for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#tracking-mode).
  /// Possible string values are:
  /// - "INVALID_TRACKING_MODE"
  /// - "PER_CONNECTION"
  /// - "PER_SESSION"
  core.String? trackingMode;

  $BackendServiceConnectionTrackingPolicy({
    this.connectionPersistenceOnUnhealthyBackends,
    this.enableStrongAffinity,
    this.idleTimeoutSec,
    this.trackingMode,
  });

  $BackendServiceConnectionTrackingPolicy.fromJson(core.Map json_)
    : this(
        connectionPersistenceOnUnhealthyBackends:
            json_['connectionPersistenceOnUnhealthyBackends'] as core.String?,
        enableStrongAffinity: json_['enableStrongAffinity'] as core.bool?,
        idleTimeoutSec: json_['idleTimeoutSec'] as core.int?,
        trackingMode: json_['trackingMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectionPersistenceOnUnhealthyBackends != null)
      'connectionPersistenceOnUnhealthyBackends':
          connectionPersistenceOnUnhealthyBackends!,
    if (enableStrongAffinity != null)
      'enableStrongAffinity': enableStrongAffinity!,
    if (idleTimeoutSec != null) 'idleTimeoutSec': idleTimeoutSec!,
    if (trackingMode != null) 'trackingMode': trackingMode!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceCustomMetric
/// - compute:beta : BackendServiceCustomMetric
/// - compute:v1 : BackendServiceCustomMetric
class $BackendServiceCustomMetric {
  /// If true, the metric data is not used for load balancing.
  core.bool? dryRun;

  /// Name of a custom utilization signal.
  ///
  /// The name must be 1-64 characters long and match the regular expression
  /// \[a-z\](\[-_.a-z0-9\]*\[a-z0-9\])? which means that the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// period, underscore, lowercase letter, or digit, except the last character,
  /// which cannot be a dash, period, or underscore. For usage guidelines, see
  /// Custom Metrics balancing mode. This field can only be used for a global or
  /// regional backend service with the loadBalancingScheme set to
  /// EXTERNAL_MANAGED, INTERNAL_MANAGED INTERNAL_SELF_MANAGED.
  core.String? name;

  $BackendServiceCustomMetric({this.dryRun, this.name});

  $BackendServiceCustomMetric.fromJson(core.Map json_)
    : this(
        dryRun: json_['dryRun'] as core.bool?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dryRun != null) 'dryRun': dryRun!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceDynamicForwardingIpPortSelection
/// - compute:beta : BackendServiceDynamicForwardingIpPortSelection
class $BackendServiceDynamicForwardingIpPortSelection {
  /// A boolean flag enabling IP:PORT based dynamic forwarding.
  core.bool? enabled;

  $BackendServiceDynamicForwardingIpPortSelection({this.enabled});

  $BackendServiceDynamicForwardingIpPortSelection.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceFailoverPolicy
/// - compute:beta : BackendServiceFailoverPolicy
/// - compute:v1 : BackendServiceFailoverPolicy
class $BackendServiceFailoverPolicy {
  /// This can be set to true only if the protocol is TCP.
  ///
  /// The default is false.
  core.bool? disableConnectionDrainOnFailover;

  /// If set to true, connections to the load balancer are dropped when all
  /// primary and all backup backend VMs are unhealthy.If set to false,
  /// connections are distributed among all primary VMs when all primary and all
  /// backup backend VMs are unhealthy.
  ///
  /// For load balancers that have configurable failover:
  /// [Internal passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  /// and
  /// [external passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
  /// The default is false.
  core.bool? dropTrafficIfUnhealthy;

  /// The value of the field must be in the range \[0, 1\].
  ///
  /// If the value is 0, the load balancer performs a failover when the number
  /// of healthy primary VMs equals zero. For all other values, the load
  /// balancer performs a failover when the total number of healthy primary VMs
  /// is less than this ratio. For load balancers that have configurable
  /// failover:
  /// [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview)
  /// and
  /// [external TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
  core.double? failoverRatio;

  $BackendServiceFailoverPolicy({
    this.disableConnectionDrainOnFailover,
    this.dropTrafficIfUnhealthy,
    this.failoverRatio,
  });

  $BackendServiceFailoverPolicy.fromJson(core.Map json_)
    : this(
        disableConnectionDrainOnFailover:
            json_['disableConnectionDrainOnFailover'] as core.bool?,
        dropTrafficIfUnhealthy: json_['dropTrafficIfUnhealthy'] as core.bool?,
        failoverRatio: (json_['failoverRatio'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableConnectionDrainOnFailover != null)
      'disableConnectionDrainOnFailover': disableConnectionDrainOnFailover!,
    if (dropTrafficIfUnhealthy != null)
      'dropTrafficIfUnhealthy': dropTrafficIfUnhealthy!,
    if (failoverRatio != null) 'failoverRatio': failoverRatio!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceHAPolicyLeaderNetworkEndpoint
/// - compute:beta : BackendServiceHAPolicyLeaderNetworkEndpoint
/// - compute:v1 : BackendServiceHAPolicyLeaderNetworkEndpoint
class $BackendServiceHAPolicyLeaderNetworkEndpoint {
  /// The name of the VM instance of the leader network endpoint.
  ///
  /// The instance must already be attached to the NEG specified in the
  /// haPolicy.leader.backendGroup. The name must be 1-63 characters long, and
  /// comply with RFC1035. Authorization requires the following IAM permission
  /// on the specified resource instance: compute.instances.use
  core.String? instance;

  $BackendServiceHAPolicyLeaderNetworkEndpoint({this.instance});

  $BackendServiceHAPolicyLeaderNetworkEndpoint.fromJson(core.Map json_)
    : this(instance: json_['instance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
  };
}

/// Used by:
///
/// - compute:beta : BackendServiceIAP
/// - compute:v1 : BackendServiceIAP
class $BackendServiceIAP {
  /// Whether the serving infrastructure will authenticate and authorize all
  /// incoming requests.
  core.bool? enabled;

  /// OAuth2 client ID to use for the authentication flow.
  core.String? oauth2ClientId;

  /// OAuth2 client secret to use for the authentication flow.
  ///
  /// For security reasons, this value cannot be retrieved via the API. Instead,
  /// the SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
  /// field. @InputOnly
  core.String? oauth2ClientSecret;

  /// SHA256 hash value for the field oauth2_client_secret above.
  ///
  /// Output only.
  core.String? oauth2ClientSecretSha256;

  $BackendServiceIAP({
    this.enabled,
    this.oauth2ClientId,
    this.oauth2ClientSecret,
    this.oauth2ClientSecretSha256,
  });

  $BackendServiceIAP.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        oauth2ClientId: json_['oauth2ClientId'] as core.String?,
        oauth2ClientSecret: json_['oauth2ClientSecret'] as core.String?,
        oauth2ClientSecretSha256:
            json_['oauth2ClientSecretSha256'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (oauth2ClientId != null) 'oauth2ClientId': oauth2ClientId!,
    if (oauth2ClientSecret != null) 'oauth2ClientSecret': oauth2ClientSecret!,
    if (oauth2ClientSecretSha256 != null)
      'oauth2ClientSecretSha256': oauth2ClientSecretSha256!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy
/// - compute:beta : BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy
/// - compute:v1 : BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy
class $BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy {
  /// An optional, arbitrary JSON object with configuration data, understood by
  /// a locally installed custom policy implementation.
  core.String? data;

  /// Identifies the custom policy.
  ///
  /// The value should match the name of a custom implementation registered on
  /// the gRPC clients. It should follow protocol buffer message naming
  /// conventions and include the full path (for example, myorg.CustomLbPolicy).
  /// The maximum length is 256 characters. Do not specify the same custom
  /// policy more than once for a backend. If you do, the configuration is
  /// rejected. For an example of how to use this field, see Use a custom
  /// policy.
  core.String? name;

  $BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy({
    this.data,
    this.name,
  });

  $BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy.fromJson(
    core.Map json_,
  ) : this(
        data: json_['data'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceLocalityLoadBalancingPolicyConfigPolicy
/// - compute:beta : BackendServiceLocalityLoadBalancingPolicyConfigPolicy
/// - compute:v1 : BackendServiceLocalityLoadBalancingPolicyConfigPolicy
class $BackendServiceLocalityLoadBalancingPolicyConfigPolicy {
  /// The name of a locality load-balancing policy.
  ///
  /// Valid values include ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For
  /// information about these values, see the description of localityLbPolicy.
  /// Do not specify the same policy more than once for a backend. If you do,
  /// the configuration is rejected.
  /// Possible string values are:
  /// - "INVALID_LB_POLICY"
  /// - "LEAST_REQUEST" : An O(1) algorithm which selects two random healthy
  /// hosts and picks the host which has fewer active requests.
  /// - "MAGLEV" : This algorithm implements consistent hashing to backends.
  /// Maglev can be used as a drop in replacement for the ring hash load
  /// balancer. Maglev is not as stable as ring hash but has faster table lookup
  /// build times and host selection times. For more information about Maglev,
  /// see https://ai.google/research/pubs/pub44824
  /// - "ORIGINAL_DESTINATION" : Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer.
  /// - "RANDOM" : The load balancer selects a random healthy host.
  /// - "RING_HASH" : The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests.
  /// - "ROUND_ROBIN" : This is a simple policy in which each healthy backend is
  /// selected in round robin order. This is the default.
  /// - "WEIGHTED_MAGLEV" : Per-instance weighted Load Balancing via health
  /// check reported weights. If set, the Backend Service must configure a non
  /// legacy HTTP-based Health Check, and health check replies are expected to
  /// contain non-standard HTTP response header field
  /// X-Load-Balancing-Endpoint-Weight to specify the per-instance weights. If
  /// set, Load Balancing is weighted based on the per-instance weights reported
  /// in the last processed health check replies, as long as every instance
  /// either reported a valid weight or had UNAVAILABLE_WEIGHT. Otherwise, Load
  /// Balancing remains equal-weight. This option is only supported in Network
  /// Load Balancing.
  /// - "WEIGHTED_ROUND_ROBIN" : Per-endpoint weighted round-robin Load
  /// Balancing using weights computed from Backend reported Custom Metrics. If
  /// set, the Backend Service responses are expected to contain non-standard
  /// HTTP response header field Endpoint-Load-Metrics. The reported metrics to
  /// use for computing the weights are specified via the customMetrics fields.
  core.String? name;

  $BackendServiceLocalityLoadBalancingPolicyConfigPolicy({this.name});

  $BackendServiceLocalityLoadBalancingPolicyConfigPolicy.fromJson(
    core.Map json_,
  ) : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:beta : BackendServiceLogConfig
/// - compute:v1 : BackendServiceLogConfig
class $BackendServiceLogConfig {
  /// Denotes whether to enable logging for the load balancer traffic served by
  /// this backend service.
  ///
  /// The default value is false.
  core.bool? enable;

  /// This field can only be specified if logging is enabled for this backend
  /// service and "logConfig.optionalMode" was set to CUSTOM.
  ///
  /// Contains a list of optional fields you want to include in the logs. For
  /// example: serverInstance, serverGkeDetails.cluster,
  /// serverGkeDetails.pod.podNamespace
  core.List<core.String>? optionalFields;

  /// This field can only be specified if logging is enabled for this backend
  /// service.
  ///
  /// Configures whether all, none or a subset of optional fields should be
  /// added to the reported logs. One of \[INCLUDE_ALL_OPTIONAL,
  /// EXCLUDE_ALL_OPTIONAL, CUSTOM\]. Default is EXCLUDE_ALL_OPTIONAL.
  /// Possible string values are:
  /// - "CUSTOM" : A subset of optional fields.
  /// - "EXCLUDE_ALL_OPTIONAL" : None optional fields.
  /// - "INCLUDE_ALL_OPTIONAL" : All optional fields.
  core.String? optionalMode;

  /// This field can only be specified if logging is enabled for this backend
  /// service.
  ///
  /// The value of the field must be in \[0, 1\]. This configures the sampling
  /// rate of requests to the load balancer where 1.0 means all logged requests
  /// are reported and 0.0 means no logged requests are reported. The default
  /// value is 1.0.
  core.double? sampleRate;

  $BackendServiceLogConfig({
    this.enable,
    this.optionalFields,
    this.optionalMode,
    this.sampleRate,
  });

  $BackendServiceLogConfig.fromJson(core.Map json_)
    : this(
        enable: json_['enable'] as core.bool?,
        optionalFields:
            (json_['optionalFields'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        optionalMode: json_['optionalMode'] as core.String?,
        sampleRate: (json_['sampleRate'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
    if (optionalFields != null) 'optionalFields': optionalFields!,
    if (optionalMode != null) 'optionalMode': optionalMode!,
    if (sampleRate != null) 'sampleRate': sampleRate!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity
/// - compute:beta : BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity
class $BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity {
  /// This field indicates whether zonal affinity is enabled or not.
  ///
  /// The possible values are: - ZONAL_AFFINITY_DISABLED: Default Value. Zonal
  /// Affinity is disabled. The load balancer distributes new connections to all
  /// healthy backend endpoints across all zones. -
  /// ZONAL_AFFINITY_STAY_WITHIN_ZONE: Zonal Affinity is enabled. The load
  /// balancer distributes new connections to all healthy backend endpoints in
  /// the local zone only. If there are no healthy backend endpoints in the
  /// local zone, the load balancer distributes new connections to all backend
  /// endpoints in the local zone. - ZONAL_AFFINITY_SPILL_CROSS_ZONE: Zonal
  /// Affinity is enabled. The load balancer distributes new connections to all
  /// healthy backend endpoints in the local zone only. If there aren't enough
  /// healthy backend endpoints in the local zone, the load balancer distributes
  /// new connections to all healthy backend endpoints across all zones.
  /// Possible string values are:
  /// - "ZONAL_AFFINITY_DISABLED"
  /// - "ZONAL_AFFINITY_SPILL_CROSS_ZONE"
  /// - "ZONAL_AFFINITY_STAY_WITHIN_ZONE"
  core.String? spillover;

  /// The value of the field must be in \[0, 1\].
  ///
  /// When the ratio of the count of healthy backend endpoints in a zone to the
  /// count of backend endpoints in that same zone is equal to or above this
  /// threshold, the load balancer distributes new connections to all healthy
  /// endpoints in the local zone only. When the ratio of the count of healthy
  /// backend endpoints in a zone to the count of backend endpoints in that same
  /// zone is below this threshold, the load balancer distributes all new
  /// connections to all healthy endpoints across all zones.
  core.double? spilloverRatio;

  $BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity({
    this.spillover,
    this.spilloverRatio,
  });

  $BackendServiceNetworkPassThroughLbTrafficPolicyZonalAffinity.fromJson(
    core.Map json_,
  ) : this(
        spillover: json_['spillover'] as core.String?,
        spilloverRatio: (json_['spilloverRatio'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (spillover != null) 'spillover': spillover!,
    if (spilloverRatio != null) 'spilloverRatio': spilloverRatio!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceReference
/// - compute:beta : BackendServiceReference
/// - compute:v1 : BackendServiceReference
class $BackendServiceReference {
  core.String? backendService;

  $BackendServiceReference({this.backendService});

  $BackendServiceReference.fromJson(core.Map json_)
    : this(backendService: json_['backendService'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (backendService != null) 'backendService': backendService!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceTlsSettingsSubjectAltName
/// - compute:beta : BackendServiceTlsSettingsSubjectAltName
/// - compute:v1 : BackendServiceTlsSettingsSubjectAltName
class $BackendServiceTlsSettingsSubjectAltName {
  /// The SAN specified as a DNS Name.
  core.String? dnsName;

  /// The SAN specified as a URI.
  core.String? uniformResourceIdentifier;

  $BackendServiceTlsSettingsSubjectAltName({
    this.dnsName,
    this.uniformResourceIdentifier,
  });

  $BackendServiceTlsSettingsSubjectAltName.fromJson(core.Map json_)
    : this(
        dnsName: json_['dnsName'] as core.String?,
        uniformResourceIdentifier:
            json_['uniformResourceIdentifier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dnsName != null) 'dnsName': dnsName!,
    if (uniformResourceIdentifier != null)
      'uniformResourceIdentifier': uniformResourceIdentifier!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendServiceUsedBy
/// - compute:beta : BackendServiceUsedBy
/// - compute:v1 : BackendServiceUsedBy
class $BackendServiceUsedBy {
  /// Server-defined URL for resources referencing given BackendService like
  /// UrlMaps, TargetTcpProxies, TargetSslProxies and ForwardingRule.
  ///
  /// Output only.
  core.String? reference;

  $BackendServiceUsedBy({this.reference});

  $BackendServiceUsedBy.fromJson(core.Map json_)
    : this(reference: json_['reference'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - managedidentities:v1alpha1 : Backup
/// - managedidentities:v1beta1 : Backup
class $Backup00 {
  /// The time the backups was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A short description of the backup.
  ///
  /// Optional.
  core.String? description;

  /// Resource labels to represent user provided metadata.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The unique name of the Backup in the form of
  /// projects/{project_id}/locations/global/domains/{domain_name}/backups/{name}
  ///
  /// Output only.
  core.String? name;

  /// The current state of the backup.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "CREATING" : Backup is being created.
  /// - "ACTIVE" : Backup has been created and validated.
  /// - "FAILED" : Backup has been created but failed validation.
  /// - "DELETING" : Backup is being deleted.
  core.String? state;

  /// Additional information about the current status of this backup, if
  /// available.
  ///
  /// Output only.
  core.String? statusMessage;

  /// Indicates whether its an on-demand backup or scheduled.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Backup type not specified.
  /// - "ON_DEMAND" : Backup was manually created.
  /// - "SCHEDULED" : Backup was automatically created.
  /// - "SCHEMA_EXTENSION" : Backup was taken as part of Schema Extension
  /// request.
  core.String? type;

  /// Last update time.
  ///
  /// Output only.
  core.String? updateTime;

  $Backup00({
    this.createTime,
    this.description,
    this.labels,
    this.name,
    this.state,
    this.statusMessage,
    this.type,
    this.updateTime,
  });

  $Backup00.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        statusMessage: json_['statusMessage'] as core.String?,
        type: json_['type'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (statusMessage != null) 'statusMessage': statusMessage!,
    if (type != null) 'type': type!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - netapp:v1 : Backup
/// - netapp:v1beta1 : Backup
class $Backup01 {
  /// Region in which backup is stored.
  ///
  /// Format: `projects/{project_id}/locations/{location}`
  ///
  /// Output only.
  core.String? backupRegion;

  /// Type of backup, manually created or created by a backup policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified backup type.
  /// - "MANUAL" : Manual backup type.
  /// - "SCHEDULED" : Scheduled backup type.
  core.String? backupType;

  /// Total size of all backups in a chain in bytes = baseline backup size +
  /// sum(incremental backup size)
  ///
  /// Output only.
  core.String? chainStorageBytes;

  /// The time when the backup was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of the backup with 2048 characters or less.
  ///
  /// Requests with longer descriptions will be rejected.
  core.String? description;

  /// The time until which the backup is not deletable.
  ///
  /// Output only.
  core.String? enforcedRetentionEndTime;

  /// Resource labels to represent user provided metadata.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The resource name of the backup. Format:
  /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}`.
  core.String? name;

  /// Reserved for future use
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// If specified, backup will be created from the given snapshot.
  ///
  /// If not specified, there will be a new snapshot taken to initiate the
  /// backup creation. Format:
  /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`
  core.String? sourceSnapshot;

  /// Volume full name of this backup belongs to.
  ///
  /// Format: `projects/{projects_id}/locations/{location}/volumes/{volume_id}`
  core.String? sourceVolume;

  /// The backup state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set.
  /// - "CREATING" : Backup is being created. While in this state, the snapshot
  /// for the backup point-in-time may not have been created yet, and so the
  /// point-in-time may not have been fixed.
  /// - "UPLOADING" : Backup is being uploaded. While in this state, none of the
  /// writes to the volume will be included in the backup.
  /// - "READY" : Backup is available for use.
  /// - "DELETING" : Backup is being deleted.
  /// - "ERROR" : Backup is not valid and cannot be used for creating new
  /// volumes or restoring existing volumes.
  /// - "UPDATING" : Backup is being updated.
  core.String? state;

  /// Region of the volume from which the backup was created.
  ///
  /// Format: `projects/{project_id}/locations/{location}`
  ///
  /// Output only.
  core.String? volumeRegion;

  /// Size of the file system when the backup was created.
  ///
  /// When creating a new volume from the backup, the volume capacity will have
  /// to be at least as big.
  ///
  /// Output only.
  core.String? volumeUsageBytes;

  $Backup01({
    this.backupRegion,
    this.backupType,
    this.chainStorageBytes,
    this.createTime,
    this.description,
    this.enforcedRetentionEndTime,
    this.labels,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.sourceSnapshot,
    this.sourceVolume,
    this.state,
    this.volumeRegion,
    this.volumeUsageBytes,
  });

  $Backup01.fromJson(core.Map json_)
    : this(
        backupRegion: json_['backupRegion'] as core.String?,
        backupType: json_['backupType'] as core.String?,
        chainStorageBytes: json_['chainStorageBytes'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        enforcedRetentionEndTime:
            json_['enforcedRetentionEndTime'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        sourceSnapshot: json_['sourceSnapshot'] as core.String?,
        sourceVolume: json_['sourceVolume'] as core.String?,
        state: json_['state'] as core.String?,
        volumeRegion: json_['volumeRegion'] as core.String?,
        volumeUsageBytes: json_['volumeUsageBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupRegion != null) 'backupRegion': backupRegion!,
    if (backupType != null) 'backupType': backupType!,
    if (chainStorageBytes != null) 'chainStorageBytes': chainStorageBytes!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (enforcedRetentionEndTime != null)
      'enforcedRetentionEndTime': enforcedRetentionEndTime!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
    if (sourceVolume != null) 'sourceVolume': sourceVolume!,
    if (state != null) 'state': state!,
    if (volumeRegion != null) 'volumeRegion': volumeRegion!,
    if (volumeUsageBytes != null) 'volumeUsageBytes': volumeUsageBytes!,
  };
}

/// Used by:
///
/// - redis:v1 : BackupClusterRequest
/// - redis:v1beta1 : BackupClusterRequest
class $BackupClusterRequest {
  /// The id of the backup to be created.
  ///
  /// If not specified, the default value (\[YYYYMMDDHHMMSS\]_\[Shortened
  /// Cluster UID\] is used.
  ///
  /// Optional.
  core.String? backupId;

  /// TTL for the backup to expire.
  ///
  /// Value range is 1 day to 100 years. If not specified, the default value is
  /// 100 years.
  ///
  /// Optional.
  core.String? ttl;

  $BackupClusterRequest({this.backupId, this.ttl});

  $BackupClusterRequest.fromJson(core.Map json_)
    : this(
        backupId: json_['backupId'] as core.String?,
        ttl: json_['ttl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupId != null) 'backupId': backupId!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - redis:v1 : BackupCollection
/// - redis:v1beta1 : BackupCollection
class $BackupCollection {
  /// The full resource path of the cluster the backup collection belongs to.
  ///
  /// Example: projects/{project}/locations/{location}/clusters/{cluster}
  ///
  /// Output only.
  core.String? cluster;

  /// The cluster uid of the backup collection.
  ///
  /// Output only.
  core.String? clusterUid;

  /// The time when the backup collection was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The KMS key used to encrypt the backups under this backup collection.
  ///
  /// Output only.
  core.String? kmsKey;

  /// Identifier.
  ///
  /// Full resource path of the backup collection.
  core.String? name;

  /// System assigned unique identifier of the backup collection.
  ///
  /// Output only.
  core.String? uid;

  $BackupCollection({
    this.cluster,
    this.clusterUid,
    this.createTime,
    this.kmsKey,
    this.name,
    this.uid,
  });

  $BackupCollection.fromJson(core.Map json_)
    : this(
        cluster: json_['cluster'] as core.String?,
        clusterUid: json_['clusterUid'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        kmsKey: json_['kmsKey'] as core.String?,
        name: json_['name'] as core.String?,
        uid: json_['uid'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cluster != null) 'cluster': cluster!,
    if (clusterUid != null) 'clusterUid': clusterUid!,
    if (createTime != null) 'createTime': createTime!,
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (name != null) 'name': name!,
    if (uid != null) 'uid': uid!,
  };
}

/// Used by:
///
/// - netapp:v1 : BackupConfig
/// - netapp:v1beta1 : BackupConfig
class $BackupConfig {
  /// Total size of all backups in a chain in bytes = baseline backup size +
  /// sum(incremental backup size).
  ///
  /// Output only.
  core.String? backupChainBytes;

  /// When specified, schedule backups will be created based on the policy
  /// configuration.
  ///
  /// Optional.
  core.List<core.String>? backupPolicies;

  /// Name of backup vault.
  ///
  /// Format:
  /// projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}
  ///
  /// Optional.
  core.String? backupVault;

  /// When set to true, scheduled backup is enabled on the volume.
  ///
  /// This field should be nil when there's no backup policy attached.
  ///
  /// Optional.
  core.bool? scheduledBackupEnabled;

  $BackupConfig({
    this.backupChainBytes,
    this.backupPolicies,
    this.backupVault,
    this.scheduledBackupEnabled,
  });

  $BackupConfig.fromJson(core.Map json_)
    : this(
        backupChainBytes: json_['backupChainBytes'] as core.String?,
        backupPolicies:
            (json_['backupPolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        backupVault: json_['backupVault'] as core.String?,
        scheduledBackupEnabled: json_['scheduledBackupEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupChainBytes != null) 'backupChainBytes': backupChainBytes!,
    if (backupPolicies != null) 'backupPolicies': backupPolicies!,
    if (backupVault != null) 'backupVault': backupVault!,
    if (scheduledBackupEnabled != null)
      'scheduledBackupEnabled': scheduledBackupEnabled!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : BackupContext
/// - sqladmin:v1beta4 : BackupContext
class $BackupContext {
  /// The identifier of the backup.
  core.String? backupId;

  /// This is always `sql#backupContext`.
  core.String? kind;

  /// The name of the backup.
  ///
  /// Format: projects/{project}/backups/{backup}
  core.String? name;

  $BackupContext({this.backupId, this.kind, this.name});

  $BackupContext.fromJson(core.Map json_)
    : this(
        backupId: json_['backupId'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupId != null) 'backupId': backupId!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - redis:v1 : BackupFile
/// - redis:v1beta1 : BackupFile
class $BackupFile {
  /// The time when the backup file was created.
  ///
  /// Output only.
  core.String? createTime;

  /// e.g: .rdb
  ///
  /// Output only.
  core.String? fileName;

  /// Size of the backup file in bytes.
  ///
  /// Output only.
  core.String? sizeBytes;

  $BackupFile({this.createTime, this.fileName, this.sizeBytes});

  $BackupFile.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        fileName: json_['fileName'] as core.String?,
        sizeBytes: json_['sizeBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (fileName != null) 'fileName': fileName!,
    if (sizeBytes != null) 'sizeBytes': sizeBytes!,
  };
}

/// Used by:
///
/// - netapp:v1 : BackupPolicy
/// - netapp:v1beta1 : BackupPolicy
class $BackupPolicy {
  /// The total number of volumes assigned by this backup policy.
  ///
  /// Output only.
  core.int? assignedVolumeCount;

  /// The time when the backup policy was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Number of daily backups to keep.
  ///
  /// Note that the minimum daily backup limit is 2.
  core.int? dailyBackupLimit;

  /// Description of the backup policy.
  core.String? description;

  /// If enabled, make backups automatically according to the schedules.
  ///
  /// This will be applied to all volumes that have this policy attached and
  /// enforced on volume level. If not specified, default is true.
  core.bool? enabled;

  /// Resource labels to represent user provided metadata.
  core.Map<core.String, core.String>? labels;

  /// Number of monthly backups to keep.
  ///
  /// Note that the sum of daily, weekly and monthly backups should be greater
  /// than 1.
  core.int? monthlyBackupLimit;

  /// Identifier.
  ///
  /// The resource name of the backup policy. Format:
  /// `projects/{project_id}/locations/{location}/backupPolicies/{backup_policy_id}`.
  core.String? name;

  /// The backup policy state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set.
  /// - "CREATING" : BackupPolicy is being created.
  /// - "READY" : BackupPolicy is available for use.
  /// - "DELETING" : BackupPolicy is being deleted.
  /// - "ERROR" : BackupPolicy is not valid and cannot be used.
  /// - "UPDATING" : BackupPolicy is being updated.
  core.String? state;

  /// Number of weekly backups to keep.
  ///
  /// Note that the sum of daily, weekly and monthly backups should be greater
  /// than 1.
  core.int? weeklyBackupLimit;

  $BackupPolicy({
    this.assignedVolumeCount,
    this.createTime,
    this.dailyBackupLimit,
    this.description,
    this.enabled,
    this.labels,
    this.monthlyBackupLimit,
    this.name,
    this.state,
    this.weeklyBackupLimit,
  });

  $BackupPolicy.fromJson(core.Map json_)
    : this(
        assignedVolumeCount: json_['assignedVolumeCount'] as core.int?,
        createTime: json_['createTime'] as core.String?,
        dailyBackupLimit: json_['dailyBackupLimit'] as core.int?,
        description: json_['description'] as core.String?,
        enabled: json_['enabled'] as core.bool?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        monthlyBackupLimit: json_['monthlyBackupLimit'] as core.int?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        weeklyBackupLimit: json_['weeklyBackupLimit'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignedVolumeCount != null)
      'assignedVolumeCount': assignedVolumeCount!,
    if (createTime != null) 'createTime': createTime!,
    if (dailyBackupLimit != null) 'dailyBackupLimit': dailyBackupLimit!,
    if (description != null) 'description': description!,
    if (enabled != null) 'enabled': enabled!,
    if (labels != null) 'labels': labels!,
    if (monthlyBackupLimit != null) 'monthlyBackupLimit': monthlyBackupLimit!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (weeklyBackupLimit != null) 'weeklyBackupLimit': weeklyBackupLimit!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : BackupReencryptionConfig
/// - sqladmin:v1beta4 : BackupReencryptionConfig
class $BackupReencryptionConfig {
  /// Backup re-encryption limit
  core.int? backupLimit;

  /// Type of backups users want to re-encrypt.
  /// Possible string values are:
  /// - "BACKUP_TYPE_UNSPECIFIED" : Unknown backup type, will be defaulted to
  /// AUTOMATIC backup type
  /// - "AUTOMATED" : Reencrypt automatic backups
  /// - "ON_DEMAND" : Reencrypt on-demand backups
  core.String? backupType;

  $BackupReencryptionConfig({this.backupLimit, this.backupType});

  $BackupReencryptionConfig.fromJson(core.Map json_)
    : this(
        backupLimit: json_['backupLimit'] as core.int?,
        backupType: json_['backupType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupLimit != null) 'backupLimit': backupLimit!,
    if (backupType != null) 'backupType': backupType!,
  };
}

/// Used by:
///
/// - netapp:v1 : BackupRetentionPolicy
/// - netapp:v1beta1 : BackupRetentionPolicy
class $BackupRetentionPolicy {
  /// Minimum retention duration in days for backups in the backup vault.
  ///
  /// Required.
  core.int? backupMinimumEnforcedRetentionDays;

  /// Indicates if the daily backups are immutable.
  ///
  /// At least one of daily_backup_immutable, weekly_backup_immutable,
  /// monthly_backup_immutable and manual_backup_immutable must be true.
  ///
  /// Optional.
  core.bool? dailyBackupImmutable;

  /// Indicates if the manual backups are immutable.
  ///
  /// At least one of daily_backup_immutable, weekly_backup_immutable,
  /// monthly_backup_immutable and manual_backup_immutable must be true.
  ///
  /// Optional.
  core.bool? manualBackupImmutable;

  /// Indicates if the monthly backups are immutable.
  ///
  /// At least one of daily_backup_immutable, weekly_backup_immutable,
  /// monthly_backup_immutable and manual_backup_immutable must be true.
  ///
  /// Optional.
  core.bool? monthlyBackupImmutable;

  /// Indicates if the weekly backups are immutable.
  ///
  /// At least one of daily_backup_immutable, weekly_backup_immutable,
  /// monthly_backup_immutable and manual_backup_immutable must be true.
  ///
  /// Optional.
  core.bool? weeklyBackupImmutable;

  $BackupRetentionPolicy({
    this.backupMinimumEnforcedRetentionDays,
    this.dailyBackupImmutable,
    this.manualBackupImmutable,
    this.monthlyBackupImmutable,
    this.weeklyBackupImmutable,
  });

  $BackupRetentionPolicy.fromJson(core.Map json_)
    : this(
        backupMinimumEnforcedRetentionDays:
            json_['backupMinimumEnforcedRetentionDays'] as core.int?,
        dailyBackupImmutable: json_['dailyBackupImmutable'] as core.bool?,
        manualBackupImmutable: json_['manualBackupImmutable'] as core.bool?,
        monthlyBackupImmutable: json_['monthlyBackupImmutable'] as core.bool?,
        weeklyBackupImmutable: json_['weeklyBackupImmutable'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupMinimumEnforcedRetentionDays != null)
      'backupMinimumEnforcedRetentionDays': backupMinimumEnforcedRetentionDays!,
    if (dailyBackupImmutable != null)
      'dailyBackupImmutable': dailyBackupImmutable!,
    if (manualBackupImmutable != null)
      'manualBackupImmutable': manualBackupImmutable!,
    if (monthlyBackupImmutable != null)
      'monthlyBackupImmutable': monthlyBackupImmutable!,
    if (weeklyBackupImmutable != null)
      'weeklyBackupImmutable': weeklyBackupImmutable!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : BackupRetentionSettings
/// - sqladmin:v1beta4 : BackupRetentionSettings
class $BackupRetentionSettings {
  /// Depending on the value of retention_unit, this is used to determine if a
  /// backup needs to be deleted.
  ///
  /// If retention_unit is 'COUNT', we will retain this many backups.
  core.int? retainedBackups;

  /// The unit that 'retained_backups' represents.
  /// Possible string values are:
  /// - "RETENTION_UNIT_UNSPECIFIED" : Backup retention unit is unspecified,
  /// will be treated as COUNT.
  /// - "COUNT" : Retention will be by count, eg. "retain the most recent 7
  /// backups".
  core.String? retentionUnit;

  $BackupRetentionSettings({this.retainedBackups, this.retentionUnit});

  $BackupRetentionSettings.fromJson(core.Map json_)
    : this(
        retainedBackups: json_['retainedBackups'] as core.int?,
        retentionUnit: json_['retentionUnit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (retainedBackups != null) 'retainedBackups': retainedBackups!,
    if (retentionUnit != null) 'retentionUnit': retentionUnit!,
  };
}

/// Used by:
///
/// - alloydb:v1 : BackupSource
/// - alloydb:v1alpha : BackupSource
/// - alloydb:v1beta : BackupSource
class $BackupSource {
  /// The name of the backup resource with the format: *
  /// projects/{project}/locations/{region}/backups/{backup_id}
  ///
  /// Required.
  core.String? backupName;

  /// The system-generated UID of the backup which was used to create this
  /// resource.
  ///
  /// The UID is generated when the backup is created, and it is retained until
  /// the backup is deleted.
  ///
  /// Output only.
  core.String? backupUid;

  $BackupSource({this.backupName, this.backupUid});

  $BackupSource.fromJson(core.Map json_)
    : this(
        backupName: json_['backupName'] as core.String?,
        backupUid: json_['backupUid'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupName != null) 'backupName': backupName!,
    if (backupUid != null) 'backupUid': backupUid!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1Barcode
/// - documentai:v1 : GoogleCloudDocumentaiV1Barcode
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3Barcode
class $Barcode {
  /// Format of a barcode.
  ///
  /// The supported formats are: - `CODE_128`: Code 128 type. - `CODE_39`: Code
  /// 39 type. - `CODE_93`: Code 93 type. - `CODABAR`: Codabar type. -
  /// `DATA_MATRIX`: 2D Data Matrix type. - `ITF`: ITF type. - `EAN_13`: EAN-13
  /// type. - `EAN_8`: EAN-8 type. - `QR_CODE`: 2D QR code type. - `UPC_A`:
  /// UPC-A type. - `UPC_E`: UPC-E type. - `PDF417`: PDF417 type. - `AZTEC`: 2D
  /// Aztec code type. - `DATABAR`: GS1 DataBar code type.
  core.String? format;

  /// Raw value encoded in the barcode.
  ///
  /// For example: `'MEBKM:TITLE:Google;URL:https://www.google.com;;'`.
  core.String? rawValue;

  /// Value format describes the format of the value that a barcode encodes.
  ///
  /// The supported formats are: - `CONTACT_INFO`: Contact information. -
  /// `EMAIL`: Email address. - `ISBN`: ISBN identifier. - `PHONE`: Phone
  /// number. - `PRODUCT`: Product. - `SMS`: SMS message. - `TEXT`: Text string.
  /// - `URL`: URL address. - `WIFI`: Wifi information. - `GEO`:
  /// Geo-localization. - `CALENDAR_EVENT`: Calendar event. - `DRIVER_LICENSE`:
  /// Driver's license.
  core.String? valueFormat;

  $Barcode({this.format, this.rawValue, this.valueFormat});

  $Barcode.fromJson(core.Map json_)
    : this(
        format: json_['format'] as core.String?,
        rawValue: json_['rawValue'] as core.String?,
        valueFormat: json_['valueFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (format != null) 'format': format!,
    if (rawValue != null) 'rawValue': rawValue!,
    if (valueFormat != null) 'valueFormat': valueFormat!,
  };
}

/// Used by:
///
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1BargeInConfig
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3BargeInConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1BargeInConfig
class $BargeInConfig {
  /// Duration that is not eligible for barge-in at the beginning of the input
  /// audio.
  core.String? noBargeInDuration;

  /// Total duration for the playback at the beginning of the input audio.
  core.String? totalDuration;

  $BargeInConfig({this.noBargeInDuration, this.totalDuration});

  $BargeInConfig.fromJson(core.Map json_)
    : this(
        noBargeInDuration: json_['noBargeInDuration'] as core.String?,
        totalDuration: json_['totalDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (noBargeInDuration != null) 'noBargeInDuration': noBargeInDuration!,
    if (totalDuration != null) 'totalDuration': totalDuration!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : BaseImage
/// - containeranalysis:v1alpha1 : BaseImage
/// - ondemandscanning:v1 : BaseImage
/// - ondemandscanning:v1 : GrafeasV1BaseImage
/// - ondemandscanning:v1beta1 : BaseImage
/// - ondemandscanning:v1beta1 : GrafeasV1BaseImage
class $BaseImage {
  /// The number of layers that the base image is composed of.
  core.int? layerCount;

  /// The name of the base image.
  core.String? name;

  /// The repository name in which the base image is from.
  core.String? repository;

  $BaseImage({this.layerCount, this.name, this.repository});

  $BaseImage.fromJson(core.Map json_)
    : this(
        layerCount: json_['layerCount'] as core.int?,
        name: json_['name'] as core.String?,
        repository: json_['repository'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (layerCount != null) 'layerCount': layerCount!,
    if (name != null) 'name': name!,
    if (repository != null) 'repository': repository!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : BasicAuth
/// - deploymentmanager:v2beta : BasicAuth
class $BasicAuth {
  core.String? password;
  core.String? user;

  $BasicAuth({this.password, this.user});

  $BasicAuth.fromJson(core.Map json_)
    : this(
        password: json_['password'] as core.String?,
        user: json_['user'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
    if (user != null) 'user': user!,
  };
}

/// Used by:
///
/// - appengine:v1 : BasicScaling
/// - appengine:v1beta : BasicScaling
class $BasicScaling {
  /// Duration of time after the last request that an instance must wait before
  /// the instance is shut down.
  core.String? idleTimeout;

  /// Maximum number of instances to create for this version.
  core.int? maxInstances;

  $BasicScaling({this.idleTimeout, this.maxInstances});

  $BasicScaling.fromJson(core.Map json_)
    : this(
        idleTimeout: json_['idleTimeout'] as core.String?,
        maxInstances: json_['maxInstances'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idleTimeout != null) 'idleTimeout': idleTimeout!,
    if (maxInstances != null) 'maxInstances': maxInstances!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchCancelPipelineJobsRequest
class $BatchCancelPipelineJobsRequest {
  /// The names of the PipelineJobs to cancel.
  ///
  /// A maximum of 32 PipelineJobs can be cancelled in a batch. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  ///
  /// Required.
  core.List<core.String>? names;

  $BatchCancelPipelineJobsRequest({this.names});

  $BatchCancelPipelineJobsRequest.fromJson(core.Map json_)
    : this(
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2BatchDeleteEntitiesRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1BatchDeleteEntitiesRequest
class $BatchDeleteEntitiesRequest {
  /// The reference `values` of the entities to delete.
  ///
  /// Note that these are not fully-qualified names, i.e. they don't start with
  /// `projects/`.
  ///
  /// Required.
  core.List<core.String>? entityValues;

  /// The language used to access language-specific data.
  ///
  /// If not specified, the agent's default language is used. For more
  /// information, see
  /// [Multilingual intent and entity data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
  ///
  /// Optional.
  core.String? languageCode;

  $BatchDeleteEntitiesRequest({this.entityValues, this.languageCode});

  $BatchDeleteEntitiesRequest.fromJson(core.Map json_)
    : this(
        entityValues:
            (json_['entityValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityValues != null) 'entityValues': entityValues!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2BatchDeleteEntityTypesRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1BatchDeleteEntityTypesRequest
class $BatchDeleteEntityTypesRequest {
  /// The names entity types to delete.
  ///
  /// All names must point to the same agent as `parent`.
  ///
  /// Required.
  core.List<core.String>? entityTypeNames;

  $BatchDeleteEntityTypesRequest({this.entityTypeNames});

  $BatchDeleteEntityTypesRequest.fromJson(core.Map json_)
    : this(
        entityTypeNames:
            (json_['entityTypeNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityTypeNames != null) 'entityTypeNames': entityTypeNames!,
  };
}

/// Used by:
///
/// - jobs:v3 : BatchDeleteJobsRequest
/// - jobs:v3p1beta1 : BatchDeleteJobsRequest
class $BatchDeleteJobsRequest {
  /// The filter string specifies the jobs to be deleted.
  ///
  /// Supported operator: =, AND The fields eligible for filtering are: *
  /// `companyName` (Required) * `requisitionId` (Required) Sample Query:
  /// companyName = "projects/api-test-project/companies/123" AND requisitionId
  /// = "req-1"
  ///
  /// Required.
  core.String? filter;

  $BatchDeleteJobsRequest({this.filter});

  $BatchDeleteJobsRequest.fromJson(core.Map json_)
    : this(filter: json_['filter'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchDeletePipelineJobsRequest
class $BatchDeletePipelineJobsRequest {
  /// The names of the PipelineJobs to delete.
  ///
  /// A maximum of 32 PipelineJobs can be deleted in a batch. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  ///
  /// Required.
  core.List<core.String>? names;

  $BatchDeletePipelineJobsRequest({this.names});

  $BatchDeletePipelineJobsRequest.fromJson(core.Map json_)
    : this(
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3BatchDeleteTestCasesRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1BatchDeleteTestCasesRequest
class $BatchDeleteTestCasesRequest {
  /// Format of test case names: `projects//locations//agents//testCases/`.
  ///
  /// Required.
  core.List<core.String>? names;

  $BatchDeleteTestCasesRequest({this.names});

  $BatchDeleteTestCasesRequest.fromJson(core.Map json_)
    : this(
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1BatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaBatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue
class $BatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue {
  /// Format:
  /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
  core.String? fhirResource;

  /// If match by URI, the URI of the Document.
  core.String? uri;

  $BatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue({
    this.fhirResource,
    this.uri,
  });

  $BatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue.fromJson(
    core.Map json_,
  ) : this(
        fhirResource: json_['fhirResource'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fhirResource != null) 'fhirResource': fhirResource!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsResponse
class $BatchImportEvaluatedAnnotationsResponse {
  /// Number of EvaluatedAnnotations imported.
  ///
  /// Output only.
  core.int? importedEvaluatedAnnotationsCount;

  $BatchImportEvaluatedAnnotationsResponse({
    this.importedEvaluatedAnnotationsCount,
  });

  $BatchImportEvaluatedAnnotationsResponse.fromJson(core.Map json_)
    : this(
        importedEvaluatedAnnotationsCount:
            json_['importedEvaluatedAnnotationsCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (importedEvaluatedAnnotationsCount != null)
      'importedEvaluatedAnnotationsCount': importedEvaluatedAnnotationsCount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchPredictionJobInstanceConfig
class $BatchPredictionJobInstanceConfig {
  /// Fields that will be excluded in the prediction instance that is sent to
  /// the Model.
  ///
  /// Excluded will be attached to the batch prediction output if key_field is
  /// not specified. When excluded_fields is populated, included_fields must be
  /// empty. The input must be JSONL with objects at each line, BigQuery or
  /// TfRecord.
  core.List<core.String>? excludedFields;

  /// Fields that will be included in the prediction instance that is sent to
  /// the Model.
  ///
  /// If instance_type is `array`, the order of field names in included_fields
  /// also determines the order of the values in the array. When included_fields
  /// is populated, excluded_fields must be empty. The input must be JSONL with
  /// objects at each line, BigQuery or TfRecord.
  core.List<core.String>? includedFields;

  /// The format of the instance that the Model accepts.
  ///
  /// Vertex AI will convert compatible batch prediction input instance formats
  /// to the specified format. Supported values are: * `object`: Each input is
  /// converted to JSON object format. * For `bigquery`, each row is converted
  /// to an object. * For `jsonl`, each line of the JSONL input must be an
  /// object. * Does not apply to `csv`, `file-list`, `tf-record`, or
  /// `tf-record-gzip`. * `array`: Each input is converted to JSON array format.
  /// * For `bigquery`, each row is converted to an array. The order of columns
  /// is determined by the BigQuery column order, unless included_fields is
  /// populated. included_fields must be populated for specifying field orders.
  /// * For `jsonl`, if each line of the JSONL input is an object,
  /// included_fields must be populated for specifying field orders. * Does not
  /// apply to `csv`, `file-list`, `tf-record`, or `tf-record-gzip`. If not
  /// specified, Vertex AI converts the batch prediction input as follows: * For
  /// `bigquery` and `csv`, the behavior is the same as `array`. The order of
  /// columns is the same as defined in the file or table, unless
  /// included_fields is populated. * For `jsonl`, the prediction instance
  /// format is determined by each line of the input. * For
  /// `tf-record`/`tf-record-gzip`, each record will be converted to an object
  /// in the format of `{"b64": }`, where `` is the Base64-encoded string of the
  /// content of the record. * For `file-list`, each file in the list will be
  /// converted to an object in the format of `{"b64": }`, where `` is the
  /// Base64-encoded string of the content of the file.
  core.String? instanceType;

  /// The name of the field that is considered as a key.
  ///
  /// The values identified by the key field is not included in the transformed
  /// instances that is sent to the Model. This is similar to specifying this
  /// name of the field in excluded_fields. In addition, the batch prediction
  /// output will not include the instances. Instead the output will only
  /// include the value of the key field, in a field named `key` in the output:
  /// * For `jsonl` output format, the output will have a `key` field instead of
  /// the `instance` field. * For `csv`/`bigquery` output format, the output
  /// will have have a `key` column instead of the instance feature columns. The
  /// input must be JSONL with objects at each line, CSV, BigQuery or TfRecord.
  core.String? keyField;

  $BatchPredictionJobInstanceConfig({
    this.excludedFields,
    this.includedFields,
    this.instanceType,
    this.keyField,
  });

  $BatchPredictionJobInstanceConfig.fromJson(core.Map json_)
    : this(
        excludedFields:
            (json_['excludedFields'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        includedFields:
            (json_['includedFields'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        instanceType: json_['instanceType'] as core.String?,
        keyField: json_['keyField'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedFields != null) 'excludedFields': excludedFields!,
    if (includedFields != null) 'includedFields': includedFields!,
    if (instanceType != null) 'instanceType': instanceType!,
    if (keyField != null) 'keyField': keyField!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchPredictionJobOutputInfo
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchPredictionJobOutputInfo
class $BatchPredictionJobOutputInfo {
  /// The path of the BigQuery dataset created, in `bq://projectId.bqDatasetId`
  /// format, into which the prediction output is written.
  ///
  /// Output only.
  core.String? bigqueryOutputDataset;

  /// The name of the BigQuery table created, in `predictions_` format, into
  /// which the prediction output is written.
  ///
  /// Can be used by UI to generate the BigQuery output path, for example.
  ///
  /// Output only.
  core.String? bigqueryOutputTable;

  /// The full path of the Cloud Storage directory created, into which the
  /// prediction output is written.
  ///
  /// Output only.
  core.String? gcsOutputDirectory;

  $BatchPredictionJobOutputInfo({
    this.bigqueryOutputDataset,
    this.bigqueryOutputTable,
    this.gcsOutputDirectory,
  });

  $BatchPredictionJobOutputInfo.fromJson(core.Map json_)
    : this(
        bigqueryOutputDataset: json_['bigqueryOutputDataset'] as core.String?,
        bigqueryOutputTable: json_['bigqueryOutputTable'] as core.String?,
        gcsOutputDirectory: json_['gcsOutputDirectory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryOutputDataset != null)
      'bigqueryOutputDataset': bigqueryOutputDataset!,
    if (bigqueryOutputTable != null)
      'bigqueryOutputTable': bigqueryOutputTable!,
    if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestPassThroughField
class $BatchReadFeatureValuesRequestPassThroughField {
  /// The name of the field in the CSV header or the name of the column in
  /// BigQuery table.
  ///
  /// The naming restriction is the same as Feature.name.
  ///
  /// Required.
  core.String? fieldName;

  $BatchReadFeatureValuesRequestPassThroughField({this.fieldName});

  $BatchReadFeatureValuesRequestPassThroughField.fromJson(core.Map json_)
    : this(fieldName: json_['fieldName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldName != null) 'fieldName': fieldName!,
  };
}

/// Used by:
///
/// - retail:v2alpha : GoogleCloudRetailV2alphaBatchRemoveCatalogAttributesRequest
/// - retail:v2beta : GoogleCloudRetailV2betaBatchRemoveCatalogAttributesRequest
class $BatchRemoveCatalogAttributesRequest {
  /// The attribute name keys of the CatalogAttributes to delete.
  ///
  /// A maximum of 1000 catalog attributes can be deleted in a batch.
  ///
  /// Required.
  core.List<core.String>? attributeKeys;

  $BatchRemoveCatalogAttributesRequest({this.attributeKeys});

  $BatchRemoveCatalogAttributesRequest.fromJson(core.Map json_)
    : this(
        attributeKeys:
            (json_['attributeKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeKeys != null) 'attributeKeys': attributeKeys!,
  };
}

/// Used by:
///
/// - retail:v2alpha : GoogleCloudRetailV2alphaBatchRemoveCatalogAttributesResponse
/// - retail:v2beta : GoogleCloudRetailV2betaBatchRemoveCatalogAttributesResponse
class $BatchRemoveCatalogAttributesResponse {
  /// Catalog attributes that were deleted.
  ///
  /// Only pre-loaded catalog attributes that are neither in use by products nor
  /// predefined can be deleted.
  core.List<core.String>? deletedCatalogAttributes;

  /// Catalog attributes that were reset.
  ///
  /// Catalog attributes that are either in use by products or are predefined
  /// attributes cannot be deleted; however, their configuration properties will
  /// reset to default values upon removal request.
  core.List<core.String>? resetCatalogAttributes;

  $BatchRemoveCatalogAttributesResponse({
    this.deletedCatalogAttributes,
    this.resetCatalogAttributes,
  });

  $BatchRemoveCatalogAttributesResponse.fromJson(core.Map json_)
    : this(
        deletedCatalogAttributes:
            (json_['deletedCatalogAttributes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        resetCatalogAttributes:
            (json_['resetCatalogAttributes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deletedCatalogAttributes != null)
      'deletedCatalogAttributes': deletedCatalogAttributes!,
    if (resetCatalogAttributes != null)
      'resetCatalogAttributes': resetCatalogAttributes!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3BatchRunTestCasesRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1BatchRunTestCasesRequest
class $BatchRunTestCasesRequest {
  /// If not set, draft environment is assumed.
  ///
  /// Format: `projects//locations//agents//environments/`.
  ///
  /// Optional.
  core.String? environment;

  /// Format: `projects//locations//agents//testCases/`.
  ///
  /// Required.
  core.List<core.String>? testCases;

  $BatchRunTestCasesRequest({this.environment, this.testCases});

  $BatchRunTestCasesRequest.fromJson(core.Map json_)
    : this(
        environment: json_['environment'] as core.String?,
        testCases:
            (json_['testCases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
    if (testCases != null) 'testCases': testCases!,
  };
}

/// Used by:
///
/// - datastore:v1 : BeginTransactionResponse
/// - datastore:v1beta3 : BeginTransactionResponse
class $BeginTransactionResponse00 {
  /// The transaction identifier (always present).
  core.String? transaction;
  core.List<core.int> get transactionAsBytes =>
      convert.base64.decode(transaction!);

  set transactionAsBytes(core.List<core.int> bytes_) {
    transaction = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $BeginTransactionResponse00({this.transaction});

  $BeginTransactionResponse00.fromJson(core.Map json_)
    : this(transaction: json_['transaction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (transaction != null) 'transaction': transaction!,
  };
}

/// Used by:
///
/// - firestore:v1 : BeginTransactionResponse
/// - firestore:v1beta1 : BeginTransactionResponse
class $BeginTransactionResponse01 {
  /// The transaction that was started.
  core.String? transaction;
  core.List<core.int> get transactionAsBytes =>
      convert.base64.decode(transaction!);

  set transactionAsBytes(core.List<core.int> bytes_) {
    transaction = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $BeginTransactionResponse01({this.transaction});

  $BeginTransactionResponse01.fromJson(core.Map json_)
    : this(transaction: json_['transaction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (transaction != null) 'transaction': transaction!,
  };
}

/// Used by:
///
/// - container:v1 : BestEffortProvisioning
/// - container:v1beta1 : BestEffortProvisioning
class $BestEffortProvisioning {
  /// When this is enabled, cluster/node pool creations will ignore non-fatal
  /// errors like stockout to best provision as many nodes as possible right now
  /// and eventually bring up all target number of nodes
  core.bool? enabled;

  /// Minimum number of nodes to be provisioned to be considered as succeeded,
  /// and the rest of nodes will be provisioned gradually and eventually when
  /// stockout issue has been resolved.
  core.int? minProvisionNodes;

  $BestEffortProvisioning({this.enabled, this.minProvisionNodes});

  $BestEffortProvisioning.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        minProvisionNodes: json_['minProvisionNodes'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (minProvisionNodes != null) 'minProvisionNodes': minProvisionNodes!,
  };
}

/// Used by:
///
/// - compute:alpha : BfdPacket
/// - compute:beta : BfdPacket
/// - compute:v1 : BfdPacket
class $BfdPacket {
  /// The Authentication Present bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? authenticationPresent;

  /// The Control Plane Independent bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? controlPlaneIndependent;

  /// The demand bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? demand;

  /// The diagnostic code specifies the local system's reason for the last
  /// change in session state.
  ///
  /// This allows remote systems to determine the reason that the previous
  /// session failed, for example. These diagnostic codes are specified in
  /// section 4.1 of RFC5880
  /// Possible string values are:
  /// - "ADMINISTRATIVELY_DOWN"
  /// - "CONCATENATED_PATH_DOWN"
  /// - "CONTROL_DETECTION_TIME_EXPIRED"
  /// - "DIAGNOSTIC_UNSPECIFIED"
  /// - "ECHO_FUNCTION_FAILED"
  /// - "FORWARDING_PLANE_RESET"
  /// - "NEIGHBOR_SIGNALED_SESSION_DOWN"
  /// - "NO_DIAGNOSTIC"
  /// - "PATH_DOWN"
  /// - "REVERSE_CONCATENATED_PATH_DOWN"
  core.String? diagnostic;

  /// The Final bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? final_;

  /// The length of the BFD Control packet in bytes.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? length;

  /// The Required Min Echo RX Interval value in the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? minEchoRxIntervalMs;

  /// The Required Min RX Interval value in the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? minRxIntervalMs;

  /// The Desired Min TX Interval value in the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? minTxIntervalMs;

  /// The detection time multiplier of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? multiplier;

  /// The multipoint bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? multipoint;

  /// The My Discriminator value in the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? myDiscriminator;

  /// The Poll bit of the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.bool? poll;

  /// The current BFD session state as seen by the transmitting system.
  ///
  /// These states are specified in section 4.1 of RFC5880
  /// Possible string values are:
  /// - "ADMIN_DOWN"
  /// - "DOWN"
  /// - "INIT"
  /// - "STATE_UNSPECIFIED"
  /// - "UP"
  core.String? state;

  /// The version number of the BFD protocol, as specified in section 4.1 of
  /// RFC5880.
  core.int? version;

  /// The Your Discriminator value in the BFD packet.
  ///
  /// This is specified in section 4.1 of RFC5880
  core.int? yourDiscriminator;

  $BfdPacket({
    this.authenticationPresent,
    this.controlPlaneIndependent,
    this.demand,
    this.diagnostic,
    this.final_,
    this.length,
    this.minEchoRxIntervalMs,
    this.minRxIntervalMs,
    this.minTxIntervalMs,
    this.multiplier,
    this.multipoint,
    this.myDiscriminator,
    this.poll,
    this.state,
    this.version,
    this.yourDiscriminator,
  });

  $BfdPacket.fromJson(core.Map json_)
    : this(
        authenticationPresent: json_['authenticationPresent'] as core.bool?,
        controlPlaneIndependent: json_['controlPlaneIndependent'] as core.bool?,
        demand: json_['demand'] as core.bool?,
        diagnostic: json_['diagnostic'] as core.String?,
        final_: json_['final'] as core.bool?,
        length: json_['length'] as core.int?,
        minEchoRxIntervalMs: json_['minEchoRxIntervalMs'] as core.int?,
        minRxIntervalMs: json_['minRxIntervalMs'] as core.int?,
        minTxIntervalMs: json_['minTxIntervalMs'] as core.int?,
        multiplier: json_['multiplier'] as core.int?,
        multipoint: json_['multipoint'] as core.bool?,
        myDiscriminator: json_['myDiscriminator'] as core.int?,
        poll: json_['poll'] as core.bool?,
        state: json_['state'] as core.String?,
        version: json_['version'] as core.int?,
        yourDiscriminator: json_['yourDiscriminator'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authenticationPresent != null)
      'authenticationPresent': authenticationPresent!,
    if (controlPlaneIndependent != null)
      'controlPlaneIndependent': controlPlaneIndependent!,
    if (demand != null) 'demand': demand!,
    if (diagnostic != null) 'diagnostic': diagnostic!,
    if (final_ != null) 'final': final_!,
    if (length != null) 'length': length!,
    if (minEchoRxIntervalMs != null)
      'minEchoRxIntervalMs': minEchoRxIntervalMs!,
    if (minRxIntervalMs != null) 'minRxIntervalMs': minRxIntervalMs!,
    if (minTxIntervalMs != null) 'minTxIntervalMs': minTxIntervalMs!,
    if (multiplier != null) 'multiplier': multiplier!,
    if (multipoint != null) 'multipoint': multipoint!,
    if (myDiscriminator != null) 'myDiscriminator': myDiscriminator!,
    if (poll != null) 'poll': poll!,
    if (state != null) 'state': state!,
    if (version != null) 'version': version!,
    if (yourDiscriminator != null) 'yourDiscriminator': yourDiscriminator!,
  };
}

/// Used by:
///
/// - compute:alpha : BfdStatusPacketCounts
/// - compute:beta : BfdStatusPacketCounts
/// - compute:v1 : BfdStatusPacketCounts
class $BfdStatusPacketCounts {
  /// Number of packets received since the beginning of the current BFD session.
  core.int? numRx;

  /// Number of packets received that were rejected because of errors since the
  /// beginning of the current BFD session.
  core.int? numRxRejected;

  /// Number of packets received that were successfully processed since the
  /// beginning of the current BFD session.
  core.int? numRxSuccessful;

  /// Number of packets transmitted since the beginning of the current BFD
  /// session.
  core.int? numTx;

  $BfdStatusPacketCounts({
    this.numRx,
    this.numRxRejected,
    this.numRxSuccessful,
    this.numTx,
  });

  $BfdStatusPacketCounts.fromJson(core.Map json_)
    : this(
        numRx: json_['numRx'] as core.int?,
        numRxRejected: json_['numRxRejected'] as core.int?,
        numRxSuccessful: json_['numRxSuccessful'] as core.int?,
        numTx: json_['numTx'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numRx != null) 'numRx': numRx!,
    if (numRxRejected != null) 'numRxRejected': numRxRejected!,
    if (numRxSuccessful != null) 'numRxSuccessful': numRxSuccessful!,
    if (numTx != null) 'numTx': numTx!,
  };
}

/// Used by:
///
/// - compute:beta : BgpRouteAsPath
/// - compute:v1 : BgpRouteAsPath
class $BgpRouteAsPath {
  /// ASNs in the path segment.
  ///
  /// When type is SEQUENCE, these are ordered.
  ///
  /// Output only.
  core.List<core.int>? asns;

  /// Type of AS-PATH segment (SEQUENCE or SET)
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AS_PATH_TYPE_SEQUENCE"
  /// - "AS_PATH_TYPE_SET"
  core.String? type;

  $BgpRouteAsPath({this.asns, this.type});

  $BgpRouteAsPath.fromJson(core.Map json_)
    : this(
        asns:
            (json_['asns'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (asns != null) 'asns': asns!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : BgpRouteNetworkLayerReachabilityInformation
/// - compute:beta : BgpRouteNetworkLayerReachabilityInformation
/// - compute:v1 : BgpRouteNetworkLayerReachabilityInformation
class $BgpRouteNetworkLayerReachabilityInformation {
  /// If the BGP session supports multiple paths (RFC 7911), the path identifier
  /// for this route.
  core.int? pathId;

  /// Human readable CIDR notation for a prefix.
  ///
  /// E.g. 10.42.0.0/16.
  core.String? prefix;

  $BgpRouteNetworkLayerReachabilityInformation({this.pathId, this.prefix});

  $BgpRouteNetworkLayerReachabilityInformation.fromJson(core.Map json_)
    : this(
        pathId: json_['pathId'] as core.int?,
        prefix: json_['prefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pathId != null) 'pathId': pathId!,
    if (prefix != null) 'prefix': prefix!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BigQueryDestination
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BigQueryDestination
class $BigQueryDestination00 {
  /// BigQuery URI to a project or table, up to 2000 characters long.
  ///
  /// When only the project is specified, the Dataset and Table is created. When
  /// the full table reference is specified, the Dataset must exist and table
  /// must not exist. Accepted forms: * BigQuery path. For example:
  /// `bq://projectId` or `bq://projectId.bqDatasetId` or
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? outputUri;

  $BigQueryDestination00({this.outputUri});

  $BigQueryDestination00.fromJson(core.Map json_)
    : this(outputUri: json_['outputUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputUri != null) 'outputUri': outputUri!,
  };
}

/// Used by:
///
/// - container:v1 : BigQueryDestination
/// - container:v1beta1 : BigQueryDestination
class $BigQueryDestination01 {
  /// The ID of a BigQuery Dataset.
  core.String? datasetId;

  $BigQueryDestination01({this.datasetId});

  $BigQueryDestination01.fromJson(core.Map json_)
    : this(datasetId: json_['datasetId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetId != null) 'datasetId': datasetId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BigQuerySource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BigQuerySource
class $BigQuerySource {
  /// BigQuery URI to a table, up to 2000 characters long.
  ///
  /// Accepted forms: * BigQuery path. For example:
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? inputUri;

  $BigQuerySource({this.inputUri});

  $BigQuerySource.fromJson(core.Map json_)
    : this(inputUri: json_['inputUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputUri != null) 'inputUri': inputUri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1BigtableOptionsBigtableColumn
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumn
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaBigtableOptionsBigtableColumn
class $BigtableOptionsBigtableColumn {
  /// The encoding mode of the values when the type is not `STRING`.
  ///
  /// Acceptable encoding values are: * `TEXT`: indicates values are
  /// alphanumeric text strings. * `BINARY`: indicates values are encoded using
  /// `HBase Bytes.toBytes` family of functions. This can be overridden for a
  /// specific column by listing that column in `columns` and specifying an
  /// encoding for it.
  /// Possible string values are:
  /// - "ENCODING_UNSPECIFIED" : The encoding is unspecified.
  /// - "TEXT" : Text encoding.
  /// - "BINARY" : Binary encoding.
  core.String? encoding;

  /// The field name to use for this column in the document.
  ///
  /// The name has to match the pattern `a-zA-Z0-9*`. If not set, it is parsed
  /// from the qualifier bytes with best effort. However, due to different
  /// naming patterns, field name collisions could happen, where parsing
  /// behavior is undefined.
  core.String? fieldName;

  /// Qualifier of the column.
  ///
  /// If it cannot be decoded with utf-8, use a base-64 encoded string instead.
  ///
  /// Required.
  core.String? qualifier;
  core.List<core.int> get qualifierAsBytes => convert.base64.decode(qualifier!);

  set qualifierAsBytes(core.List<core.int> bytes_) {
    qualifier = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The type of values in this column family.
  ///
  /// The values are expected to be encoded using `HBase Bytes.toBytes` function
  /// when the encoding value is set to `BINARY`.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type is unspecified.
  /// - "STRING" : String type.
  /// - "NUMBER" : Numerical type.
  /// - "INTEGER" : Integer type.
  /// - "VAR_INTEGER" : Variable length integer type.
  /// - "BIG_NUMERIC" : BigDecimal type.
  /// - "BOOLEAN" : Boolean type.
  /// - "JSON" : JSON type.
  core.String? type;

  $BigtableOptionsBigtableColumn({
    this.encoding,
    this.fieldName,
    this.qualifier,
    this.type,
  });

  $BigtableOptionsBigtableColumn.fromJson(core.Map json_)
    : this(
        encoding: json_['encoding'] as core.String?,
        fieldName: json_['fieldName'] as core.String?,
        qualifier: json_['qualifier'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encoding != null) 'encoding': encoding!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (qualifier != null) 'qualifier': qualifier!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - connectors:v1 : BillingConfig
/// - integrations:v1 : GoogleCloudConnectorsV1BillingConfig
class $BillingConfig {
  /// Billing category for the connector.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BILLING_CATEGORY_UNSPECIFIED" : Billing category is not specified.
  /// - "GCP_AND_TECHNICAL_CONNECTOR" : GCP/Technical connector.
  /// - "NON_GCP_CONNECTOR" : Non-GCP connector.
  core.String? billingCategory;

  $BillingConfig({this.billingCategory});

  $BillingConfig.fromJson(core.Map json_)
    : this(billingCategory: json_['billingCategory'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (billingCategory != null) 'billingCategory': billingCategory!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : BinLogCoordinates
/// - sqladmin:v1beta4 : BinLogCoordinates
class $BinLogCoordinates {
  /// Name of the binary log file for a Cloud SQL instance.
  core.String? binLogFileName;

  /// Position (offset) within the binary log file.
  core.String? binLogPosition;

  /// This is always `sql#binLogCoordinates`.
  core.String? kind;

  $BinLogCoordinates({this.binLogFileName, this.binLogPosition, this.kind});

  $BinLogCoordinates.fromJson(core.Map json_)
    : this(
        binLogFileName: json_['binLogFileName'] as core.String?,
        binLogPosition: json_['binLogPosition'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (binLogFileName != null) 'binLogFileName': binLogFileName!,
    if (binLogPosition != null) 'binLogPosition': binLogPosition!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - policysimulator:v1 : GoogleCloudPolicysimulatorV1BindingExplanationAnnotatedMembership
/// - policysimulator:v1beta : GoogleCloudPolicysimulatorV1betaBindingExplanationAnnotatedMembership
class $BindingExplanationAnnotatedMembership {
  /// Indicates whether the binding includes the principal.
  /// Possible string values are:
  /// - "MEMBERSHIP_UNSPECIFIED" : Default value. This value is unused.
  /// - "MEMBERSHIP_INCLUDED" : The binding includes the principal. The
  /// principal can be included directly or indirectly. For example: * A
  /// principal is included directly if that principal is listed in the binding.
  /// * A principal is included indirectly if that principal is in a Google
  /// group or Google Workspace domain that is listed in the binding.
  /// - "MEMBERSHIP_NOT_INCLUDED" : The binding does not include the principal.
  /// - "MEMBERSHIP_UNKNOWN_INFO_DENIED" : The user who created the Replay is
  /// not allowed to access the binding.
  /// - "MEMBERSHIP_UNKNOWN_UNSUPPORTED" : The principal is an unsupported type.
  /// Only Google Accounts and service accounts are supported.
  core.String? membership;

  /// The relevance of the principal's status to the overall determination for
  /// the binding.
  /// Possible string values are:
  /// - "HEURISTIC_RELEVANCE_UNSPECIFIED" : Default value. This value is unused.
  /// - "NORMAL" : The data point has a limited effect on the result. Changing
  /// the data point is unlikely to affect the overall determination.
  /// - "HIGH" : The data point has a strong effect on the result. Changing the
  /// data point is likely to affect the overall determination.
  core.String? relevance;

  $BindingExplanationAnnotatedMembership({this.membership, this.relevance});

  $BindingExplanationAnnotatedMembership.fromJson(core.Map json_)
    : this(
        membership: json_['membership'] as core.String?,
        relevance: json_['relevance'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (membership != null) 'membership': membership!,
    if (relevance != null) 'relevance': relevance!,
  };
}

/// Used by:
///
/// - firestore:v1 : BitSequence
/// - firestore:v1beta1 : BitSequence
class $BitSequence {
  /// The bytes that encode the bit sequence.
  ///
  /// May have a length of zero.
  core.String? bitmap;
  core.List<core.int> get bitmapAsBytes => convert.base64.decode(bitmap!);

  set bitmapAsBytes(core.List<core.int> bytes_) {
    bitmap = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The number of bits of the last byte in `bitmap` to ignore as "padding".
  ///
  /// If the length of `bitmap` is zero, then this value must be `0`. Otherwise,
  /// this value must be between 0 and 7, inclusive.
  core.int? padding;

  $BitSequence({this.bitmap, this.padding});

  $BitSequence.fromJson(core.Map json_)
    : this(
        bitmap: json_['bitmap'] as core.String?,
        padding: json_['padding'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bitmap != null) 'bitmap': bitmap!,
    if (padding != null) 'padding': padding!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BleuMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BleuMetricValue
class $BleuMetricValue {
  /// Bleu score.
  ///
  /// Output only.
  core.double? score;

  $BleuMetricValue({this.score});

  $BleuMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BleuSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BleuSpec
class $BleuSpec {
  /// Whether to use_effective_order to compute bleu score.
  ///
  /// Optional.
  core.bool? useEffectiveOrder;

  $BleuSpec({this.useEffectiveOrder});

  $BleuSpec.fromJson(core.Map json_)
    : this(useEffectiveOrder: json_['useEffectiveOrder'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (useEffectiveOrder != null) 'useEffectiveOrder': useEffectiveOrder!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Blob
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Blob
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1Blob
class $Blob {
  /// Raw bytes.
  ///
  /// Required.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Display name of the blob.
  ///
  /// Used to provide a label or filename to distinguish blobs. This field is
  /// only returned in PromptMessage for prompt management. It is currently used
  /// in the Gemini GenerateContent calls only when server side tools
  /// (code_execution, google_search, and url_context) are enabled.
  ///
  /// Optional.
  core.String? displayName;

  /// The IANA standard MIME type of the source data.
  ///
  /// Required.
  core.String? mimeType;

  $Blob({this.data, this.displayName, this.mimeType});

  $Blob.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (displayName != null) 'displayName': displayName!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - healthcare:v1 : BlobStorageInfo
/// - healthcare:v1beta1 : BlobStorageInfo
class $BlobStorageInfo {
  /// Size in bytes of data stored in Blob Storage.
  core.String? sizeBytes;

  /// The storage class in which the Blob data is stored.
  /// Possible string values are:
  /// - "BLOB_STORAGE_CLASS_UNSPECIFIED" : If unspecified in CreateDataset, the
  /// StorageClass defaults to STANDARD. If unspecified in UpdateDataset and the
  /// StorageClass is set in the field mask, an InvalidRequest error is thrown.
  /// - "STANDARD" : This stores the Object in Blob Standard Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#standard
  /// - "NEARLINE" : This stores the Object in Blob Nearline Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#nearline
  /// - "COLDLINE" : This stores the Object in Blob Coldline Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#coldline
  /// - "ARCHIVE" : This stores the Object in Blob Archive Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#archive
  core.String? storageClass;

  /// The time at which the storage class was updated.
  ///
  /// This is used to compute early deletion fees of the resource.
  core.String? storageClassUpdateTime;

  $BlobStorageInfo({
    this.sizeBytes,
    this.storageClass,
    this.storageClassUpdateTime,
  });

  $BlobStorageInfo.fromJson(core.Map json_)
    : this(
        sizeBytes: json_['sizeBytes'] as core.String?,
        storageClass: json_['storageClass'] as core.String?,
        storageClassUpdateTime: json_['storageClassUpdateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sizeBytes != null) 'sizeBytes': sizeBytes!,
    if (storageClass != null) 'storageClass': storageClass!,
    if (storageClassUpdateTime != null)
      'storageClassUpdateTime': storageClassUpdateTime!,
  };
}

/// Used by:
///
/// - healthcare:v1 : BlobStorageSettings
/// - healthcare:v1beta1 : BlobStorageSettings
class $BlobStorageSettings {
  /// The Storage class in which the Blob data is stored.
  /// Possible string values are:
  /// - "BLOB_STORAGE_CLASS_UNSPECIFIED" : If unspecified in CreateDataset, the
  /// StorageClass defaults to STANDARD. If unspecified in UpdateDataset and the
  /// StorageClass is set in the field mask, an InvalidRequest error is thrown.
  /// - "STANDARD" : This stores the Object in Blob Standard Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#standard
  /// - "NEARLINE" : This stores the Object in Blob Nearline Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#nearline
  /// - "COLDLINE" : This stores the Object in Blob Coldline Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#coldline
  /// - "ARCHIVE" : This stores the Object in Blob Archive Storage:
  /// https://cloud.google.com/storage/docs/storage-classes#archive
  core.String? blobStorageClass;

  $BlobStorageSettings({this.blobStorageClass});

  $BlobStorageSettings.fromJson(core.Map json_)
    : this(blobStorageClass: json_['blobStorageClass'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobStorageClass != null) 'blobStorageClass': blobStorageClass!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GdataBlobstore2Info
/// - discoveryengine:v1alpha : GdataBlobstore2Info
/// - discoveryengine:v1beta : GdataBlobstore2Info
/// - firebaseappdistribution:v1 : GdataBlobstore2Info
/// - walletobjects:v1 : Blobstore2Info
class $Blobstore2Info00 {
  /// The blob generation id.
  core.String? blobGeneration;

  /// The blob id, e.g., /blobstore/prod/playground/scotty
  core.String? blobId;

  /// Read handle passed from Bigstore -\> Scotty for a GCS download.
  ///
  /// This is a signed, serialized blobstore2.ReadHandle proto which must never
  /// be set outside of Bigstore, and is not applicable to non-GCS media
  /// downloads.
  core.String? downloadReadHandle;
  core.List<core.int> get downloadReadHandleAsBytes =>
      convert.base64.decode(downloadReadHandle!);

  set downloadReadHandleAsBytes(core.List<core.int> bytes_) {
    downloadReadHandle = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The blob read token.
  ///
  /// Needed to read blobs that have not been replicated. Might not be available
  /// until the final call.
  core.String? readToken;

  /// Metadata passed from Blobstore -\> Scotty for a new GCS upload.
  ///
  /// This is a signed, serialized blobstore2.BlobMetadataContainer proto which
  /// must never be consumed outside of Bigstore, and is not applicable to
  /// non-GCS media uploads.
  core.String? uploadMetadataContainer;
  core.List<core.int> get uploadMetadataContainerAsBytes =>
      convert.base64.decode(uploadMetadataContainer!);

  set uploadMetadataContainerAsBytes(core.List<core.int> bytes_) {
    uploadMetadataContainer = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Blobstore2Info00({
    this.blobGeneration,
    this.blobId,
    this.downloadReadHandle,
    this.readToken,
    this.uploadMetadataContainer,
  });

  $Blobstore2Info00.fromJson(core.Map json_)
    : this(
        blobGeneration: json_['blobGeneration'] as core.String?,
        blobId: json_['blobId'] as core.String?,
        downloadReadHandle: json_['downloadReadHandle'] as core.String?,
        readToken: json_['readToken'] as core.String?,
        uploadMetadataContainer:
            json_['uploadMetadataContainer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobGeneration != null) 'blobGeneration': blobGeneration!,
    if (blobId != null) 'blobId': blobId!,
    if (downloadReadHandle != null) 'downloadReadHandle': downloadReadHandle!,
    if (readToken != null) 'readToken': readToken!,
    if (uploadMetadataContainer != null)
      'uploadMetadataContainer': uploadMetadataContainer!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : Blobstore2Info
/// - cloudsupport:v2beta : Blobstore2Info
class $Blobstore2Info01 {
  /// # gdata.* are outside protos with mising documentation
  core.String? blobGeneration;

  /// # gdata.* are outside protos with mising documentation
  core.String? blobId;

  /// # gdata.* are outside protos with mising documentation
  core.String? downloadReadHandle;
  core.List<core.int> get downloadReadHandleAsBytes =>
      convert.base64.decode(downloadReadHandle!);

  set downloadReadHandleAsBytes(core.List<core.int> bytes_) {
    downloadReadHandle = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// # gdata.* are outside protos with mising documentation
  core.String? readToken;

  /// # gdata.* are outside protos with mising documentation
  core.String? uploadMetadataContainer;
  core.List<core.int> get uploadMetadataContainerAsBytes =>
      convert.base64.decode(uploadMetadataContainer!);

  set uploadMetadataContainerAsBytes(core.List<core.int> bytes_) {
    uploadMetadataContainer = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Blobstore2Info01({
    this.blobGeneration,
    this.blobId,
    this.downloadReadHandle,
    this.readToken,
    this.uploadMetadataContainer,
  });

  $Blobstore2Info01.fromJson(core.Map json_)
    : this(
        blobGeneration: json_['blobGeneration'] as core.String?,
        blobId: json_['blobId'] as core.String?,
        downloadReadHandle: json_['downloadReadHandle'] as core.String?,
        readToken: json_['readToken'] as core.String?,
        uploadMetadataContainer:
            json_['uploadMetadataContainer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobGeneration != null) 'blobGeneration': blobGeneration!,
    if (blobId != null) 'blobId': blobId!,
    if (downloadReadHandle != null) 'downloadReadHandle': downloadReadHandle!,
    if (readToken != null) 'readToken': readToken!,
    if (uploadMetadataContainer != null)
      'uploadMetadataContainer': uploadMetadataContainer!,
  };
}

/// Used by:
///
/// - blogger:v2 : Blog
/// - blogger:v3 : Blog
class $Blog {
  /// The JSON custom meta-data for the Blog.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? customMetaData;

  /// The description of this blog.
  ///
  /// This is displayed underneath the title.
  core.String? description;

  /// The identifier for this resource.
  core.String? id;

  /// The kind of this entry.
  ///
  /// Always blogger#blog.
  core.String? kind;

  /// The locale this Blog is set to.
  BlogLocale? locale;

  /// The name of this blog.
  ///
  /// This is displayed as the title.
  core.String? name;

  /// The container of pages in this blog.
  BlogPages? pages;

  /// The container of posts in this blog.
  BlogPosts? posts;

  /// RFC 3339 date-time when this blog was published.
  core.String? published;

  /// The API REST URL to fetch this resource from.
  core.String? selfLink;

  /// The status of the blog.
  /// Possible string values are:
  /// - "LIVE"
  /// - "DELETED"
  core.String? status;

  /// RFC 3339 date-time when this blog was last updated.
  core.String? updated;

  /// The URL where this blog is published.
  core.String? url;

  $Blog({
    this.customMetaData,
    this.description,
    this.id,
    this.kind,
    this.locale,
    this.name,
    this.pages,
    this.posts,
    this.published,
    this.selfLink,
    this.status,
    this.updated,
    this.url,
  });

  $Blog.fromJson(core.Map json_)
    : this(
        customMetaData: json_['customMetaData'] as core.String?,
        description: json_['description'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        locale:
            json_.containsKey('locale')
                ? BlogLocale.fromJson(
                  json_['locale'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        pages:
            json_.containsKey('pages')
                ? BlogPages.fromJson(
                  json_['pages'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        posts:
            json_.containsKey('posts')
                ? BlogPosts.fromJson(
                  json_['posts'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        published: json_['published'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        updated: json_['updated'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customMetaData != null) 'customMetaData': customMetaData!,
    if (description != null) 'description': description!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (locale != null) 'locale': locale!,
    if (name != null) 'name': name!,
    if (pages != null) 'pages': pages!,
    if (posts != null) 'posts': posts!,
    if (published != null) 'published': published!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (updated != null) 'updated': updated!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - blogger:v2 : BlogPerUserInfo
/// - blogger:v3 : BlogPerUserInfo
class $BlogPerUserInfo {
  /// ID of the Blog resource.
  core.String? blogId;

  /// True if the user has Admin level access to the blog.
  core.bool? hasAdminAccess;

  /// The kind of this entity.
  ///
  /// Always blogger#blogPerUserInfo.
  core.String? kind;

  /// The Photo Album Key for the user when adding photos to the blog.
  core.String? photosAlbumKey;

  /// Access permissions that the user has for the blog (ADMIN, AUTHOR, or
  /// READER).
  /// Possible string values are:
  /// - "VIEW_TYPE_UNSPECIFIED"
  /// - "READER"
  /// - "AUTHOR"
  /// - "ADMIN"
  core.String? role;

  /// ID of the User.
  core.String? userId;

  $BlogPerUserInfo({
    this.blogId,
    this.hasAdminAccess,
    this.kind,
    this.photosAlbumKey,
    this.role,
    this.userId,
  });

  $BlogPerUserInfo.fromJson(core.Map json_)
    : this(
        blogId: json_['blogId'] as core.String?,
        hasAdminAccess: json_['hasAdminAccess'] as core.bool?,
        kind: json_['kind'] as core.String?,
        photosAlbumKey: json_['photosAlbumKey'] as core.String?,
        role: json_['role'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blogId != null) 'blogId': blogId!,
    if (hasAdminAccess != null) 'hasAdminAccess': hasAdminAccess!,
    if (kind != null) 'kind': kind!,
    if (photosAlbumKey != null) 'photosAlbumKey': photosAlbumKey!,
    if (role != null) 'role': role!,
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BlurBaselineConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BlurBaselineConfig
class $BlurBaselineConfig {
  /// The standard deviation of the blur kernel for the blurred baseline.
  ///
  /// The same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  core.double? maxBlurSigma;

  $BlurBaselineConfig({this.maxBlurSigma});

  $BlurBaselineConfig.fromJson(core.Map json_)
    : this(maxBlurSigma: (json_['maxBlurSigma'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxBlurSigma != null) 'maxBlurSigma': maxBlurSigma!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BoolArray
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BoolArray
class $BoolArray {
  /// A list of bool values.
  core.List<core.bool>? values;

  $BoolArray({this.values});

  $BoolArray.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.bool)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : GoogleCloudOrgpolicyV1BooleanPolicy
/// - cloudasset:v1beta1 : GoogleCloudOrgpolicyV1BooleanPolicy
/// - cloudasset:v1p5beta1 : GoogleCloudOrgpolicyV1BooleanPolicy
/// - cloudresourcemanager:v1 : BooleanPolicy
class $BooleanPolicy {
  /// If `true`, then the `Policy` is enforced.
  ///
  /// If `false`, then any configuration is acceptable. Suppose you have a
  /// `Constraint` `constraints/compute.disableSerialPortAccess` with
  /// `constraint_default` set to `ALLOW`. A `Policy` for that `Constraint`
  /// exhibits the following behavior: - If the `Policy` at this resource has
  /// enforced set to `false`, serial port connection attempts will be allowed.
  /// - If the `Policy` at this resource has enforced set to `true`, serial port
  /// connection attempts will be refused. - If the `Policy` at this resource is
  /// `RestoreDefault`, serial port connection attempts will be allowed. - If no
  /// `Policy` is set at this resource or anywhere higher in the resource
  /// hierarchy, serial port connection attempts will be allowed. - If no
  /// `Policy` is set at this resource, but one exists higher in the resource
  /// hierarchy, the behavior is as if the`Policy` were set at this resource.
  /// The following examples demonstrate the different possible layerings:
  /// Example 1 (nearest `Constraint` wins): `organizations/foo` has a `Policy`
  /// with: {enforced: false} `projects/bar` has no `Policy` set. The constraint
  /// at `projects/bar` and `organizations/foo` will not be enforced. Example 2
  /// (enforcement gets replaced): `organizations/foo` has a `Policy` with:
  /// {enforced: false} `projects/bar` has a `Policy` with: {enforced: true} The
  /// constraint at `organizations/foo` is not enforced. The constraint at
  /// `projects/bar` is enforced. Example 3 (RestoreDefault):
  /// `organizations/foo` has a `Policy` with: {enforced: true} `projects/bar`
  /// has a `Policy` with: {RestoreDefault: {}} The constraint at
  /// `organizations/foo` is enforced. The constraint at `projects/bar` is not
  /// enforced, because `constraint_default` for the `Constraint` is `ALLOW`.
  core.bool? enforced;

  $BooleanPolicy({this.enforced});

  $BooleanPolicy.fromJson(core.Map json_)
    : this(enforced: json_['enforced'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enforced != null) 'enforced': enforced!,
  };
}

/// Used by:
///
/// - container:v1 : BootDisk
/// - container:v1beta1 : BootDisk
class $BootDisk {
  /// Disk type of the boot disk.
  ///
  /// (i.e. Hyperdisk-Balanced, PD-Balanced, etc.)
  core.String? diskType;

  /// For Hyperdisk-Balanced only, the provisioned IOPS config value.
  core.String? provisionedIops;

  /// For Hyperdisk-Balanced only, the provisioned throughput config value.
  core.String? provisionedThroughput;

  /// Disk size in GB.
  ///
  /// Replaces NodeConfig.disk_size_gb
  core.String? sizeGb;

  $BootDisk({
    this.diskType,
    this.provisionedIops,
    this.provisionedThroughput,
    this.sizeGb,
  });

  $BootDisk.fromJson(core.Map json_)
    : this(
        diskType: json_['diskType'] as core.String?,
        provisionedIops: json_['provisionedIops'] as core.String?,
        provisionedThroughput: json_['provisionedThroughput'] as core.String?,
        sizeGb: json_['sizeGb'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskType != null) 'diskType': diskType!,
    if (provisionedIops != null) 'provisionedIops': provisionedIops!,
    if (provisionedThroughput != null)
      'provisionedThroughput': provisionedThroughput!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : BrowserAssignedTargetingOptionDetails
/// - displayvideo:v3 : BrowserAssignedTargetingOptionDetails
/// - displayvideo:v4 : BrowserAssignedTargetingOptionDetails
class $BrowserAssignedTargetingOptionDetails {
  /// The display name of the browser.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  ///
  /// All assigned browser targeting options on the same resource must have the
  /// same value for this field.
  core.bool? negative;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_BROWSER`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $BrowserAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $BrowserAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1BrowserInfo
/// - cloudidentity:v1beta1 : BrowserInfo
class $BrowserInfo {
  /// Browser's management state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNSPECIFIED" : Management state is not specified.
  /// - "UNMANAGED" : Browser/Profile is not managed by any customer.
  /// - "MANAGED_BY_OTHER_DOMAIN" : Browser/Profile is managed, but by some
  /// other customer.
  /// - "PROFILE_MANAGED" : Profile is managed by customer.
  /// - "BROWSER_MANAGED" : Browser is managed by customer.
  core.String? browserManagementState;

  /// Version of the request initiating browser.
  ///
  /// E.g. `91.0.4442.4`.
  core.String? browserVersion;

  /// Current state of \[built-in DNS
  /// client\](https://chromeenterprise.google/policies/#BuiltInDnsClientEnabled).
  core.bool? isBuiltInDnsClientEnabled;

  /// Current state of
  /// [bulk data analysis](https://chromeenterprise.google/policies/#OnBulkDataEntryEnterpriseConnector).
  ///
  /// Set to true if provider list from Chrome is non-empty.
  core.bool? isBulkDataEntryAnalysisEnabled;

  /// Current state of
  /// [Chrome Cleanup](https://chromeenterprise.google/policies/#ChromeCleanupEnabled).
  core.bool? isChromeCleanupEnabled;

  /// Current state of
  /// [Chrome Remote Desktop app](https://chromeenterprise.google/policies/#URLBlocklist).
  core.bool? isChromeRemoteDesktopAppBlocked;

  /// Current state of
  /// [file download analysis](https://chromeenterprise.google/policies/#OnFileDownloadedEnterpriseConnector).
  ///
  /// Set to true if provider list from Chrome is non-empty.
  core.bool? isFileDownloadAnalysisEnabled;

  /// Current state of
  /// [file upload analysis](https://chromeenterprise.google/policies/#OnFileAttachedEnterpriseConnector).
  ///
  /// Set to true if provider list from Chrome is non-empty.
  core.bool? isFileUploadAnalysisEnabled;

  /// Current state of \[real-time URL
  /// check\](https://chromeenterprise.google/policies/#EnterpriseRealTimeUrlCheckMode).
  ///
  /// Set to true if provider list from Chrome is non-empty.
  core.bool? isRealtimeUrlCheckEnabled;

  /// Current state of
  /// [security event analysis](https://chromeenterprise.google/policies/#OnSecurityEventEnterpriseConnector).
  ///
  /// Set to true if provider list from Chrome is non-empty.
  core.bool? isSecurityEventAnalysisEnabled;

  /// Current state of
  /// [site isolation](https://chromeenterprise.google/policies/?policy=IsolateOrigins).
  core.bool? isSiteIsolationEnabled;

  /// Current state of \[third-party
  /// blocking\](https://chromeenterprise.google/policies/#ThirdPartyBlockingEnabled).
  core.bool? isThirdPartyBlockingEnabled;

  /// Current state of
  /// [password protection trigger](https://chromeenterprise.google/policies/#PasswordProtectionWarningTrigger).
  /// Possible string values are:
  /// - "PASSWORD_PROTECTION_TRIGGER_UNSPECIFIED" : Password protection is not
  /// specified.
  /// - "PROTECTION_OFF" : Password reuse is never detected.
  /// - "PASSWORD_REUSE" : Warning is shown when the user reuses their protected
  /// password on a non-allowed site.
  /// - "PHISHING_REUSE" : Warning is shown when the user reuses their protected
  /// password on a phishing site.
  core.String? passwordProtectionWarningTrigger;

  /// Current state of
  /// [Safe Browsing protection level](https://chromeenterprise.google/policies/#SafeBrowsingProtectionLevel).
  /// Possible string values are:
  /// - "SAFE_BROWSING_LEVEL_UNSPECIFIED" : Browser protection level is not
  /// specified.
  /// - "DISABLED" : No protection against dangerous websites, downloads, and
  /// extensions.
  /// - "STANDARD" : Standard protection against websites, downloads, and
  /// extensions that are known to be dangerous.
  /// - "ENHANCED" : Faster, proactive protection against dangerous websites,
  /// downloads, and extensions.
  core.String? safeBrowsingProtectionLevel;

  $BrowserInfo({
    this.browserManagementState,
    this.browserVersion,
    this.isBuiltInDnsClientEnabled,
    this.isBulkDataEntryAnalysisEnabled,
    this.isChromeCleanupEnabled,
    this.isChromeRemoteDesktopAppBlocked,
    this.isFileDownloadAnalysisEnabled,
    this.isFileUploadAnalysisEnabled,
    this.isRealtimeUrlCheckEnabled,
    this.isSecurityEventAnalysisEnabled,
    this.isSiteIsolationEnabled,
    this.isThirdPartyBlockingEnabled,
    this.passwordProtectionWarningTrigger,
    this.safeBrowsingProtectionLevel,
  });

  $BrowserInfo.fromJson(core.Map json_)
    : this(
        browserManagementState: json_['browserManagementState'] as core.String?,
        browserVersion: json_['browserVersion'] as core.String?,
        isBuiltInDnsClientEnabled:
            json_['isBuiltInDnsClientEnabled'] as core.bool?,
        isBulkDataEntryAnalysisEnabled:
            json_['isBulkDataEntryAnalysisEnabled'] as core.bool?,
        isChromeCleanupEnabled: json_['isChromeCleanupEnabled'] as core.bool?,
        isChromeRemoteDesktopAppBlocked:
            json_['isChromeRemoteDesktopAppBlocked'] as core.bool?,
        isFileDownloadAnalysisEnabled:
            json_['isFileDownloadAnalysisEnabled'] as core.bool?,
        isFileUploadAnalysisEnabled:
            json_['isFileUploadAnalysisEnabled'] as core.bool?,
        isRealtimeUrlCheckEnabled:
            json_['isRealtimeUrlCheckEnabled'] as core.bool?,
        isSecurityEventAnalysisEnabled:
            json_['isSecurityEventAnalysisEnabled'] as core.bool?,
        isSiteIsolationEnabled: json_['isSiteIsolationEnabled'] as core.bool?,
        isThirdPartyBlockingEnabled:
            json_['isThirdPartyBlockingEnabled'] as core.bool?,
        passwordProtectionWarningTrigger:
            json_['passwordProtectionWarningTrigger'] as core.String?,
        safeBrowsingProtectionLevel:
            json_['safeBrowsingProtectionLevel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (browserManagementState != null)
      'browserManagementState': browserManagementState!,
    if (browserVersion != null) 'browserVersion': browserVersion!,
    if (isBuiltInDnsClientEnabled != null)
      'isBuiltInDnsClientEnabled': isBuiltInDnsClientEnabled!,
    if (isBulkDataEntryAnalysisEnabled != null)
      'isBulkDataEntryAnalysisEnabled': isBulkDataEntryAnalysisEnabled!,
    if (isChromeCleanupEnabled != null)
      'isChromeCleanupEnabled': isChromeCleanupEnabled!,
    if (isChromeRemoteDesktopAppBlocked != null)
      'isChromeRemoteDesktopAppBlocked': isChromeRemoteDesktopAppBlocked!,
    if (isFileDownloadAnalysisEnabled != null)
      'isFileDownloadAnalysisEnabled': isFileDownloadAnalysisEnabled!,
    if (isFileUploadAnalysisEnabled != null)
      'isFileUploadAnalysisEnabled': isFileUploadAnalysisEnabled!,
    if (isRealtimeUrlCheckEnabled != null)
      'isRealtimeUrlCheckEnabled': isRealtimeUrlCheckEnabled!,
    if (isSecurityEventAnalysisEnabled != null)
      'isSecurityEventAnalysisEnabled': isSecurityEventAnalysisEnabled!,
    if (isSiteIsolationEnabled != null)
      'isSiteIsolationEnabled': isSiteIsolationEnabled!,
    if (isThirdPartyBlockingEnabled != null)
      'isThirdPartyBlockingEnabled': isThirdPartyBlockingEnabled!,
    if (passwordProtectionWarningTrigger != null)
      'passwordProtectionWarningTrigger': passwordProtectionWarningTrigger!,
    if (safeBrowsingProtectionLevel != null)
      'safeBrowsingProtectionLevel': safeBrowsingProtectionLevel!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : BrowserTargetingOptionDetails
/// - displayvideo:v3 : BrowserTargetingOptionDetails
/// - displayvideo:v4 : BrowserTargetingOptionDetails
class $BrowserTargetingOptionDetails {
  /// The display name of the browser.
  ///
  /// Output only.
  core.String? displayName;

  $BrowserTargetingOptionDetails({this.displayName});

  $BrowserTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - jobs:v3 : BucketRange
/// - jobs:v3p1beta1 : BucketRange
class $BucketRange {
  /// Starting value of the bucket range.
  core.double? from;

  /// Ending value of the bucket range.
  core.double? to;

  $BucketRange({this.from, this.to});

  $BucketRange.fromJson(core.Map json_)
    : this(
        from: (json_['from'] as core.num?)?.toDouble(),
        to: (json_['to'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (from != null) 'from': from!,
    if (to != null) 'to': to!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : BuildMetadata
/// - containeranalysis:v1alpha1 : BuildMetadata
/// - containeranalysis:v1beta1 : BuildMetadata
/// - ondemandscanning:v1 : BuildMetadata
/// - ondemandscanning:v1beta1 : BuildMetadata
class $BuildMetadata {
  core.String? finishedOn;
  core.String? invocationId;
  core.String? startedOn;

  $BuildMetadata({this.finishedOn, this.invocationId, this.startedOn});

  $BuildMetadata.fromJson(core.Map json_)
    : this(
        finishedOn: json_['finishedOn'] as core.String?,
        invocationId: json_['invocationId'] as core.String?,
        startedOn: json_['startedOn'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (finishedOn != null) 'finishedOn': finishedOn!,
    if (invocationId != null) 'invocationId': invocationId!,
    if (startedOn != null) 'startedOn': startedOn!,
  };
}

/// Used by:
///
/// - healthcare:v1 : BulkExportGcsDestination
/// - healthcare:v1beta1 : BulkExportGcsDestination
class $BulkExportGcsDestination {
  /// URI for a Cloud Storage directory where the server writes result files, in
  /// the format `gs://{bucket-id}/{path/to/destination/dir}`.
  ///
  /// If there is no trailing slash, the service appends one when composing the
  /// object path. The user is responsible for creating the Cloud Storage bucket
  /// referenced in `uri_prefix`.
  ///
  /// Optional.
  core.String? uriPrefix;

  $BulkExportGcsDestination({this.uriPrefix});

  $BulkExportGcsDestination.fromJson(core.Map json_)
    : this(uriPrefix: json_['uriPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uriPrefix != null) 'uriPrefix': uriPrefix!,
  };
}

/// Used by:
///
/// - compute:beta : BulkInsertDiskResource
/// - compute:v1 : BulkInsertDiskResource
class $BulkInsertDiskResource {
  /// The URL of the DiskConsistencyGroupPolicy for the group of disks to clone.
  ///
  /// This may be a full or partial URL, such as: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /resourcePolicies/resourcePolicy -
  /// projects/project/regions/region/resourcePolicies/resourcePolicy -
  /// regions/region/resourcePolicies/resourcePolicy
  core.String? sourceConsistencyGroupPolicy;

  $BulkInsertDiskResource({this.sourceConsistencyGroupPolicy});

  $BulkInsertDiskResource.fromJson(core.Map json_)
    : this(
        sourceConsistencyGroupPolicy:
            json_['sourceConsistencyGroupPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceConsistencyGroupPolicy != null)
      'sourceConsistencyGroupPolicy': sourceConsistencyGroupPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : BulkInsertInstanceResourcePerInstanceProperties
/// - compute:beta : BulkInsertInstanceResourcePerInstanceProperties
/// - compute:v1 : BulkInsertInstanceResourcePerInstanceProperties
class $BulkInsertInstanceResourcePerInstanceProperties {
  /// Specifies the hostname of the instance.
  ///
  /// More details in:
  /// https://cloud.google.com/compute/docs/instances/custom-hostname-vm#naming_convention
  core.String? hostname;

  /// This field is only temporary.
  ///
  /// It will be removed. Do not use it.
  core.String? name;

  $BulkInsertInstanceResourcePerInstanceProperties({this.hostname, this.name});

  $BulkInsertInstanceResourcePerInstanceProperties.fromJson(core.Map json_)
    : this(
        hostname: json_['hostname'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostname != null) 'hostname': hostname!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : BulkInsertOperationStatus
/// - compute:beta : BulkInsertOperationStatus
/// - compute:v1 : BulkInsertOperationStatus
class $BulkInsertOperationStatus00 {
  /// Count of VMs successfully created so far.
  ///
  /// Output only.
  core.int? createdVmCount;

  /// Count of VMs that got deleted during rollback.
  ///
  /// Output only.
  core.int? deletedVmCount;

  /// Count of VMs that started creating but encountered an error.
  ///
  /// Output only.
  core.int? failedToCreateVmCount;

  /// Creation status of BulkInsert operation - information if the flow is
  /// rolling forward or rolling back.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Rolling forward - creating VMs.
  /// - "DONE" : Done
  /// - "ROLLING_BACK" : Rolling back - cleaning up after an error.
  /// - "STATUS_UNSPECIFIED"
  core.String? status;

  /// Count of VMs originally planned to be created.
  ///
  /// Output only.
  core.int? targetVmCount;

  $BulkInsertOperationStatus00({
    this.createdVmCount,
    this.deletedVmCount,
    this.failedToCreateVmCount,
    this.status,
    this.targetVmCount,
  });

  $BulkInsertOperationStatus00.fromJson(core.Map json_)
    : this(
        createdVmCount: json_['createdVmCount'] as core.int?,
        deletedVmCount: json_['deletedVmCount'] as core.int?,
        failedToCreateVmCount: json_['failedToCreateVmCount'] as core.int?,
        status: json_['status'] as core.String?,
        targetVmCount: json_['targetVmCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createdVmCount != null) 'createdVmCount': createdVmCount!,
    if (deletedVmCount != null) 'deletedVmCount': deletedVmCount!,
    if (failedToCreateVmCount != null)
      'failedToCreateVmCount': failedToCreateVmCount!,
    if (status != null) 'status': status!,
    if (targetVmCount != null) 'targetVmCount': targetVmCount!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : BulkInsertOperationStatus
/// - deploymentmanager:v2 : BulkInsertOperationStatus
/// - deploymentmanager:v2beta : BulkInsertOperationStatus
class $BulkInsertOperationStatus01 {
  /// Count of VMs successfully created so far.
  ///
  /// Output only.
  core.int? createdVmCount;

  /// Count of VMs that got deleted during rollback.
  ///
  /// Output only.
  core.int? deletedVmCount;

  /// Count of VMs that started creating but encountered an error.
  ///
  /// Output only.
  core.int? failedToCreateVmCount;

  /// Creation status of BulkInsert operation - information if the flow is
  /// rolling forward or rolling back.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATUS_UNSPECIFIED"
  /// - "CREATING" : Rolling forward - creating VMs.
  /// - "ROLLING_BACK" : Rolling back - cleaning up after an error.
  /// - "DONE" : Done
  core.String? status;

  /// Count of VMs originally planned to be created.
  ///
  /// Output only.
  core.int? targetVmCount;

  $BulkInsertOperationStatus01({
    this.createdVmCount,
    this.deletedVmCount,
    this.failedToCreateVmCount,
    this.status,
    this.targetVmCount,
  });

  $BulkInsertOperationStatus01.fromJson(core.Map json_)
    : this(
        createdVmCount: json_['createdVmCount'] as core.int?,
        deletedVmCount: json_['deletedVmCount'] as core.int?,
        failedToCreateVmCount: json_['failedToCreateVmCount'] as core.int?,
        status: json_['status'] as core.String?,
        targetVmCount: json_['targetVmCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createdVmCount != null) 'createdVmCount': createdVmCount!,
    if (deletedVmCount != null) 'deletedVmCount': deletedVmCount!,
    if (failedToCreateVmCount != null)
      'failedToCreateVmCount': failedToCreateVmCount!,
    if (status != null) 'status': status!,
    if (targetVmCount != null) 'targetVmCount': targetVmCount!,
  };
}

/// Used by:
///
/// - compute:alpha : BulkSetLabelsRequest
/// - compute:beta : BulkSetLabelsRequest
/// - compute:v1 : BulkSetLabelsRequest
class $BulkSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You may optionally provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  $BulkSetLabelsRequest({this.labelFingerprint, this.labels});

  $BulkSetLabelsRequest.fromJson(core.Map json_)
    : this(
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - compute:alpha : BundledLocalSsds
/// - compute:beta : BundledLocalSsds
class $BundledLocalSsds {
  /// The default disk interface if the interface is not specified.
  core.String? defaultInterface;

  /// The number of partitions.
  core.int? partitionCount;

  $BundledLocalSsds({this.defaultInterface, this.partitionCount});

  $BundledLocalSsds.fromJson(core.Map json_)
    : this(
        defaultInterface: json_['defaultInterface'] as core.String?,
        partitionCount: json_['partitionCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultInterface != null) 'defaultInterface': defaultInterface!,
    if (partitionCount != null) 'partitionCount': partitionCount!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : BusinessChainAssignedTargetingOptionDetails
/// - displayvideo:v3 : BusinessChainAssignedTargetingOptionDetails
/// - displayvideo:v4 : BusinessChainAssignedTargetingOptionDetails
class $BusinessChainAssignedTargetingOptionDetails {
  /// The display name of a business chain, e.g. "KFC", "Chase Bank".
  ///
  /// Output only.
  core.String? displayName;

  /// The radius of the area around the business chain that will be targeted.
  ///
  /// The units of the radius are specified by proximity_radius_unit. Must be 1
  /// to 800 if unit is `DISTANCE_UNIT_KILOMETERS` and 1 to 500 if unit is
  /// `DISTANCE_UNIT_MILES`. The minimum increment for both cases is 0.1. Inputs
  /// will be rounded to the nearest acceptable value if it is too granular,
  /// e.g. 15.57 will become 15.6.
  ///
  /// Required.
  core.double? proximityRadiusAmount;

  /// The unit of distance by which the targeting radius is measured.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DISTANCE_UNIT_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "DISTANCE_UNIT_MILES" : Miles.
  /// - "DISTANCE_UNIT_KILOMETERS" : Kilometers.
  core.String? proximityRadiusUnit;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_BUSINESS_CHAIN`.
  ///
  /// Accepted business chain targeting option IDs can be retrieved using
  /// SearchTargetingOptions.
  ///
  /// Required.
  core.String? targetingOptionId;

  $BusinessChainAssignedTargetingOptionDetails({
    this.displayName,
    this.proximityRadiusAmount,
    this.proximityRadiusUnit,
    this.targetingOptionId,
  });

  $BusinessChainAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        proximityRadiusAmount:
            (json_['proximityRadiusAmount'] as core.num?)?.toDouble(),
        proximityRadiusUnit: json_['proximityRadiusUnit'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (proximityRadiusAmount != null)
      'proximityRadiusAmount': proximityRadiusAmount!,
    if (proximityRadiusUnit != null)
      'proximityRadiusUnit': proximityRadiusUnit!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : BusinessChainSearchTerms
/// - displayvideo:v3 : BusinessChainSearchTerms
/// - displayvideo:v4 : BusinessChainSearchTerms
class $BusinessChainSearchTerms {
  /// The search query for the desired business chain.
  ///
  /// The query must be the full name of the business, e.g. "KFC",
  /// "mercedes-benz".
  core.String? businessChainQuery;

  /// The search query for the desired geo region, e.g. "Seattle", "United
  /// State".
  core.String? regionQuery;

  $BusinessChainSearchTerms({this.businessChainQuery, this.regionQuery});

  $BusinessChainSearchTerms.fromJson(core.Map json_)
    : this(
        businessChainQuery: json_['businessChainQuery'] as core.String?,
        regionQuery: json_['regionQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (businessChainQuery != null) 'businessChainQuery': businessChainQuery!,
    if (regionQuery != null) 'regionQuery': regionQuery!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : BusinessChainTargetingOptionDetails
/// - displayvideo:v3 : BusinessChainTargetingOptionDetails
/// - displayvideo:v4 : BusinessChainTargetingOptionDetails
class $BusinessChainTargetingOptionDetails {
  /// The display name of the business chain, e.g. "KFC", "Chase Bank".
  ///
  /// Output only.
  core.String? businessChain;

  /// The display name of the geographic region, e.g. "Ontario, Canada".
  ///
  /// Output only.
  core.String? geoRegion;

  /// The type of the geographic region.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GEO_REGION_TYPE_UNKNOWN" : The geographic region type is unknown.
  /// - "GEO_REGION_TYPE_OTHER" : The geographic region type is other.
  /// - "GEO_REGION_TYPE_COUNTRY" : The geographic region is a country.
  /// - "GEO_REGION_TYPE_REGION" : The geographic region type is region.
  /// - "GEO_REGION_TYPE_TERRITORY" : The geographic region is a territory.
  /// - "GEO_REGION_TYPE_PROVINCE" : The geographic region is a province.
  /// - "GEO_REGION_TYPE_STATE" : The geographic region is a state.
  /// - "GEO_REGION_TYPE_PREFECTURE" : The geographic region is a prefecture.
  /// - "GEO_REGION_TYPE_GOVERNORATE" : The geographic region is a governorate.
  /// - "GEO_REGION_TYPE_CANTON" : The geographic region is a canton.
  /// - "GEO_REGION_TYPE_UNION_TERRITORY" : The geographic region is a union
  /// territory.
  /// - "GEO_REGION_TYPE_AUTONOMOUS_COMMUNITY" : The geographic region is an
  /// autonomous community.
  /// - "GEO_REGION_TYPE_DMA_REGION" : The geographic region is a designated
  /// market area (DMA) region.
  /// - "GEO_REGION_TYPE_METRO" : The geographic region type is metro.
  /// - "GEO_REGION_TYPE_CONGRESSIONAL_DISTRICT" : The geographic region is a
  /// congressional district.
  /// - "GEO_REGION_TYPE_COUNTY" : The geographic region is a county.
  /// - "GEO_REGION_TYPE_MUNICIPALITY" : The geographic region is a
  /// municipality.
  /// - "GEO_REGION_TYPE_CITY" : The geographic region is a city.
  /// - "GEO_REGION_TYPE_POSTAL_CODE" : The geographic region targeting type is
  /// postal code.
  /// - "GEO_REGION_TYPE_DEPARTMENT" : The geographic region targeting type is
  /// department.
  /// - "GEO_REGION_TYPE_AIRPORT" : The geographic region is an airport.
  /// - "GEO_REGION_TYPE_TV_REGION" : The geographic region is a TV region.
  /// - "GEO_REGION_TYPE_OKRUG" : The geographic region is an okrug.
  /// - "GEO_REGION_TYPE_BOROUGH" : The geographic region is a borough.
  /// - "GEO_REGION_TYPE_CITY_REGION" : The geographic region is a city region.
  /// - "GEO_REGION_TYPE_ARRONDISSEMENT" : The geographic region is an
  /// arrondissement.
  /// - "GEO_REGION_TYPE_NEIGHBORHOOD" : The geographic region is a
  /// neighborhood.
  /// - "GEO_REGION_TYPE_UNIVERSITY" : The geographic region is a university.
  /// - "GEO_REGION_TYPE_DISTRICT" : The geographic region is a district.
  /// - "GEO_REGION_TYPE_NATIONAL_PARK" : The geographic region is a national
  /// park.
  /// - "GEO_REGION_TYPE_BARRIO" : The geographic region is a barrio.
  /// - "GEO_REGION_TYPE_SUB_WARD" : The geographic region is a sub ward.
  /// - "GEO_REGION_TYPE_MUNICIPALITY_DISTRICT" : The geographic region is a
  /// municipality district.
  /// - "GEO_REGION_TYPE_SUB_DISTRICT" : The geographic region is a sub
  /// district.
  /// - "GEO_REGION_TYPE_QUARTER" : The geographic region is a quarter.
  /// - "GEO_REGION_TYPE_DIVISION" : The geographic region is a division.
  /// - "GEO_REGION_TYPE_COMMUNE" : The geographic region is a commune.
  /// - "GEO_REGION_TYPE_COLLOQUIAL_AREA" : The geographic region is a
  /// colloquial area.
  core.String? geoRegionType;

  $BusinessChainTargetingOptionDetails({
    this.businessChain,
    this.geoRegion,
    this.geoRegionType,
  });

  $BusinessChainTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        businessChain: json_['businessChain'] as core.String?,
        geoRegion: json_['geoRegion'] as core.String?,
        geoRegionType: json_['geoRegionType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (businessChain != null) 'businessChain': businessChain!,
    if (geoRegion != null) 'geoRegion': geoRegion!,
    if (geoRegionType != null) 'geoRegionType': geoRegionType!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : CVSS
/// - ondemandscanning:v1 : CVSS
/// - ondemandscanning:v1beta1 : CVSS
class $CVSS00 {
  ///
  /// Possible string values are:
  /// - "ATTACK_COMPLEXITY_UNSPECIFIED"
  /// - "ATTACK_COMPLEXITY_LOW"
  /// - "ATTACK_COMPLEXITY_HIGH"
  /// - "ATTACK_COMPLEXITY_MEDIUM"
  core.String? attackComplexity;

  /// Base Metrics Represents the intrinsic characteristics of a vulnerability
  /// that are constant over time and across user environments.
  /// Possible string values are:
  /// - "ATTACK_VECTOR_UNSPECIFIED"
  /// - "ATTACK_VECTOR_NETWORK"
  /// - "ATTACK_VECTOR_ADJACENT"
  /// - "ATTACK_VECTOR_LOCAL"
  /// - "ATTACK_VECTOR_PHYSICAL"
  core.String? attackVector;

  ///
  /// Possible string values are:
  /// - "AUTHENTICATION_UNSPECIFIED"
  /// - "AUTHENTICATION_MULTIPLE"
  /// - "AUTHENTICATION_SINGLE"
  /// - "AUTHENTICATION_NONE"
  core.String? authentication;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  /// - "IMPACT_PARTIAL"
  /// - "IMPACT_COMPLETE"
  core.String? availabilityImpact;

  /// The base score is a function of the base metric scores.
  core.double? baseScore;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  /// - "IMPACT_PARTIAL"
  /// - "IMPACT_COMPLETE"
  core.String? confidentialityImpact;
  core.double? exploitabilityScore;
  core.double? impactScore;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  /// - "IMPACT_PARTIAL"
  /// - "IMPACT_COMPLETE"
  core.String? integrityImpact;

  ///
  /// Possible string values are:
  /// - "PRIVILEGES_REQUIRED_UNSPECIFIED"
  /// - "PRIVILEGES_REQUIRED_NONE"
  /// - "PRIVILEGES_REQUIRED_LOW"
  /// - "PRIVILEGES_REQUIRED_HIGH"
  core.String? privilegesRequired;

  ///
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED"
  /// - "SCOPE_UNCHANGED"
  /// - "SCOPE_CHANGED"
  core.String? scope;

  ///
  /// Possible string values are:
  /// - "USER_INTERACTION_UNSPECIFIED"
  /// - "USER_INTERACTION_NONE"
  /// - "USER_INTERACTION_REQUIRED"
  core.String? userInteraction;

  $CVSS00({
    this.attackComplexity,
    this.attackVector,
    this.authentication,
    this.availabilityImpact,
    this.baseScore,
    this.confidentialityImpact,
    this.exploitabilityScore,
    this.impactScore,
    this.integrityImpact,
    this.privilegesRequired,
    this.scope,
    this.userInteraction,
  });

  $CVSS00.fromJson(core.Map json_)
    : this(
        attackComplexity: json_['attackComplexity'] as core.String?,
        attackVector: json_['attackVector'] as core.String?,
        authentication: json_['authentication'] as core.String?,
        availabilityImpact: json_['availabilityImpact'] as core.String?,
        baseScore: (json_['baseScore'] as core.num?)?.toDouble(),
        confidentialityImpact: json_['confidentialityImpact'] as core.String?,
        exploitabilityScore:
            (json_['exploitabilityScore'] as core.num?)?.toDouble(),
        impactScore: (json_['impactScore'] as core.num?)?.toDouble(),
        integrityImpact: json_['integrityImpact'] as core.String?,
        privilegesRequired: json_['privilegesRequired'] as core.String?,
        scope: json_['scope'] as core.String?,
        userInteraction: json_['userInteraction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attackComplexity != null) 'attackComplexity': attackComplexity!,
    if (attackVector != null) 'attackVector': attackVector!,
    if (authentication != null) 'authentication': authentication!,
    if (availabilityImpact != null) 'availabilityImpact': availabilityImpact!,
    if (baseScore != null) 'baseScore': baseScore!,
    if (confidentialityImpact != null)
      'confidentialityImpact': confidentialityImpact!,
    if (exploitabilityScore != null)
      'exploitabilityScore': exploitabilityScore!,
    if (impactScore != null) 'impactScore': impactScore!,
    if (integrityImpact != null) 'integrityImpact': integrityImpact!,
    if (privilegesRequired != null) 'privilegesRequired': privilegesRequired!,
    if (scope != null) 'scope': scope!,
    if (userInteraction != null) 'userInteraction': userInteraction!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : CVSS
/// - containeranalysis:v1beta1 : CVSS
class $CVSS01 {
  /// Defined in CVSS v3, CVSS v2
  /// Possible string values are:
  /// - "ATTACK_COMPLEXITY_UNSPECIFIED" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_COMPLEXITY_LOW" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_COMPLEXITY_HIGH" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_COMPLEXITY_MEDIUM" : Defined in CVSS v2
  core.String? attackComplexity;

  /// Base Metrics Represents the intrinsic characteristics of a vulnerability
  /// that are constant over time and across user environments.
  ///
  /// Defined in CVSS v3, CVSS v2
  /// Possible string values are:
  /// - "ATTACK_VECTOR_UNSPECIFIED" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_VECTOR_NETWORK" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_VECTOR_ADJACENT" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_VECTOR_LOCAL" : Defined in CVSS v3, CVSS v2
  /// - "ATTACK_VECTOR_PHYSICAL" : Defined in CVSS v3
  core.String? attackVector;

  /// Defined in CVSS v2
  /// Possible string values are:
  /// - "AUTHENTICATION_UNSPECIFIED" : Defined in CVSS v2
  /// - "AUTHENTICATION_MULTIPLE" : Defined in CVSS v2
  /// - "AUTHENTICATION_SINGLE" : Defined in CVSS v2
  /// - "AUTHENTICATION_NONE" : Defined in CVSS v2
  core.String? authentication;

  /// Defined in CVSS v3, CVSS v2
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_HIGH" : Defined in CVSS v3
  /// - "IMPACT_LOW" : Defined in CVSS v3
  /// - "IMPACT_NONE" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_PARTIAL" : Defined in CVSS v2
  /// - "IMPACT_COMPLETE" : Defined in CVSS v2
  core.String? availabilityImpact;

  /// The base score is a function of the base metric scores.
  core.double? baseScore;

  /// Defined in CVSS v3, CVSS v2
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_HIGH" : Defined in CVSS v3
  /// - "IMPACT_LOW" : Defined in CVSS v3
  /// - "IMPACT_NONE" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_PARTIAL" : Defined in CVSS v2
  /// - "IMPACT_COMPLETE" : Defined in CVSS v2
  core.String? confidentialityImpact;
  core.double? exploitabilityScore;
  core.double? impactScore;

  /// Defined in CVSS v3, CVSS v2
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_HIGH" : Defined in CVSS v3
  /// - "IMPACT_LOW" : Defined in CVSS v3
  /// - "IMPACT_NONE" : Defined in CVSS v3, CVSS v2
  /// - "IMPACT_PARTIAL" : Defined in CVSS v2
  /// - "IMPACT_COMPLETE" : Defined in CVSS v2
  core.String? integrityImpact;

  /// Defined in CVSS v3
  /// Possible string values are:
  /// - "PRIVILEGES_REQUIRED_UNSPECIFIED" : Defined in CVSS v3
  /// - "PRIVILEGES_REQUIRED_NONE" : Defined in CVSS v3
  /// - "PRIVILEGES_REQUIRED_LOW" : Defined in CVSS v3
  /// - "PRIVILEGES_REQUIRED_HIGH" : Defined in CVSS v3
  core.String? privilegesRequired;

  /// Defined in CVSS v3
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED" : Defined in CVSS v3
  /// - "SCOPE_UNCHANGED" : Defined in CVSS v3
  /// - "SCOPE_CHANGED" : Defined in CVSS v3
  core.String? scope;

  /// Defined in CVSS v3
  /// Possible string values are:
  /// - "USER_INTERACTION_UNSPECIFIED" : Defined in CVSS v3
  /// - "USER_INTERACTION_NONE" : Defined in CVSS v3
  /// - "USER_INTERACTION_REQUIRED" : Defined in CVSS v3
  core.String? userInteraction;

  $CVSS01({
    this.attackComplexity,
    this.attackVector,
    this.authentication,
    this.availabilityImpact,
    this.baseScore,
    this.confidentialityImpact,
    this.exploitabilityScore,
    this.impactScore,
    this.integrityImpact,
    this.privilegesRequired,
    this.scope,
    this.userInteraction,
  });

  $CVSS01.fromJson(core.Map json_)
    : this(
        attackComplexity: json_['attackComplexity'] as core.String?,
        attackVector: json_['attackVector'] as core.String?,
        authentication: json_['authentication'] as core.String?,
        availabilityImpact: json_['availabilityImpact'] as core.String?,
        baseScore: (json_['baseScore'] as core.num?)?.toDouble(),
        confidentialityImpact: json_['confidentialityImpact'] as core.String?,
        exploitabilityScore:
            (json_['exploitabilityScore'] as core.num?)?.toDouble(),
        impactScore: (json_['impactScore'] as core.num?)?.toDouble(),
        integrityImpact: json_['integrityImpact'] as core.String?,
        privilegesRequired: json_['privilegesRequired'] as core.String?,
        scope: json_['scope'] as core.String?,
        userInteraction: json_['userInteraction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attackComplexity != null) 'attackComplexity': attackComplexity!,
    if (attackVector != null) 'attackVector': attackVector!,
    if (authentication != null) 'authentication': authentication!,
    if (availabilityImpact != null) 'availabilityImpact': availabilityImpact!,
    if (baseScore != null) 'baseScore': baseScore!,
    if (confidentialityImpact != null)
      'confidentialityImpact': confidentialityImpact!,
    if (exploitabilityScore != null)
      'exploitabilityScore': exploitabilityScore!,
    if (impactScore != null) 'impactScore': impactScore!,
    if (integrityImpact != null) 'integrityImpact': integrityImpact!,
    if (privilegesRequired != null) 'privilegesRequired': privilegesRequired!,
    if (scope != null) 'scope': scope!,
    if (userInteraction != null) 'userInteraction': userInteraction!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : CVSSv3
/// - containeranalysis:v1beta1 : CVSSv3
class $CVSSv300 {
  ///
  /// Possible string values are:
  /// - "ATTACK_COMPLEXITY_UNSPECIFIED"
  /// - "ATTACK_COMPLEXITY_LOW"
  /// - "ATTACK_COMPLEXITY_HIGH"
  core.String? attackComplexity;

  /// Base Metrics Represents the intrinsic characteristics of a vulnerability
  /// that are constant over time and across user environments.
  /// Possible string values are:
  /// - "ATTACK_VECTOR_UNSPECIFIED"
  /// - "ATTACK_VECTOR_NETWORK"
  /// - "ATTACK_VECTOR_ADJACENT"
  /// - "ATTACK_VECTOR_LOCAL"
  /// - "ATTACK_VECTOR_PHYSICAL"
  core.String? attackVector;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  core.String? availabilityImpact;

  /// The base score is a function of the base metric scores.
  core.double? baseScore;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  core.String? confidentialityImpact;
  core.double? exploitabilityScore;
  core.double? impactScore;

  ///
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED"
  /// - "IMPACT_HIGH"
  /// - "IMPACT_LOW"
  /// - "IMPACT_NONE"
  core.String? integrityImpact;

  ///
  /// Possible string values are:
  /// - "PRIVILEGES_REQUIRED_UNSPECIFIED"
  /// - "PRIVILEGES_REQUIRED_NONE"
  /// - "PRIVILEGES_REQUIRED_LOW"
  /// - "PRIVILEGES_REQUIRED_HIGH"
  core.String? privilegesRequired;

  ///
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED"
  /// - "SCOPE_UNCHANGED"
  /// - "SCOPE_CHANGED"
  core.String? scope;

  ///
  /// Possible string values are:
  /// - "USER_INTERACTION_UNSPECIFIED"
  /// - "USER_INTERACTION_NONE"
  /// - "USER_INTERACTION_REQUIRED"
  core.String? userInteraction;

  $CVSSv300({
    this.attackComplexity,
    this.attackVector,
    this.availabilityImpact,
    this.baseScore,
    this.confidentialityImpact,
    this.exploitabilityScore,
    this.impactScore,
    this.integrityImpact,
    this.privilegesRequired,
    this.scope,
    this.userInteraction,
  });

  $CVSSv300.fromJson(core.Map json_)
    : this(
        attackComplexity: json_['attackComplexity'] as core.String?,
        attackVector: json_['attackVector'] as core.String?,
        availabilityImpact: json_['availabilityImpact'] as core.String?,
        baseScore: (json_['baseScore'] as core.num?)?.toDouble(),
        confidentialityImpact: json_['confidentialityImpact'] as core.String?,
        exploitabilityScore:
            (json_['exploitabilityScore'] as core.num?)?.toDouble(),
        impactScore: (json_['impactScore'] as core.num?)?.toDouble(),
        integrityImpact: json_['integrityImpact'] as core.String?,
        privilegesRequired: json_['privilegesRequired'] as core.String?,
        scope: json_['scope'] as core.String?,
        userInteraction: json_['userInteraction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attackComplexity != null) 'attackComplexity': attackComplexity!,
    if (attackVector != null) 'attackVector': attackVector!,
    if (availabilityImpact != null) 'availabilityImpact': availabilityImpact!,
    if (baseScore != null) 'baseScore': baseScore!,
    if (confidentialityImpact != null)
      'confidentialityImpact': confidentialityImpact!,
    if (exploitabilityScore != null)
      'exploitabilityScore': exploitabilityScore!,
    if (impactScore != null) 'impactScore': impactScore!,
    if (integrityImpact != null) 'integrityImpact': integrityImpact!,
    if (privilegesRequired != null) 'privilegesRequired': privilegesRequired!,
    if (scope != null) 'scope': scope!,
    if (userInteraction != null) 'userInteraction': userInteraction!,
  };
}

/// Used by:
///
/// - osconfig:v1 : CVSSv3
/// - osconfig:v1alpha : CVSSv3
class $CVSSv301 {
  /// This metric describes the conditions beyond the attacker's control that
  /// must exist in order to exploit the vulnerability.
  /// Possible string values are:
  /// - "ATTACK_COMPLEXITY_UNSPECIFIED" : Invalid value.
  /// - "ATTACK_COMPLEXITY_LOW" : Specialized access conditions or extenuating
  /// circumstances do not exist. An attacker can expect repeatable success when
  /// attacking the vulnerable component.
  /// - "ATTACK_COMPLEXITY_HIGH" : A successful attack depends on conditions
  /// beyond the attacker's control. That is, a successful attack cannot be
  /// accomplished at will, but requires the attacker to invest in some
  /// measurable amount of effort in preparation or execution against the
  /// vulnerable component before a successful attack can be expected.
  core.String? attackComplexity;

  /// This metric reflects the context by which vulnerability exploitation is
  /// possible.
  /// Possible string values are:
  /// - "ATTACK_VECTOR_UNSPECIFIED" : Invalid value.
  /// - "ATTACK_VECTOR_NETWORK" : The vulnerable component is bound to the
  /// network stack and the set of possible attackers extends beyond the other
  /// options listed below, up to and including the entire Internet.
  /// - "ATTACK_VECTOR_ADJACENT" : The vulnerable component is bound to the
  /// network stack, but the attack is limited at the protocol level to a
  /// logically adjacent topology.
  /// - "ATTACK_VECTOR_LOCAL" : The vulnerable component is not bound to the
  /// network stack and the attacker's path is via read/write/execute
  /// capabilities.
  /// - "ATTACK_VECTOR_PHYSICAL" : The attack requires the attacker to
  /// physically touch or manipulate the vulnerable component.
  core.String? attackVector;

  /// This metric measures the impact to the availability of the impacted
  /// component resulting from a successfully exploited vulnerability.
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Invalid value.
  /// - "IMPACT_HIGH" : High impact.
  /// - "IMPACT_LOW" : Low impact.
  /// - "IMPACT_NONE" : No impact.
  core.String? availabilityImpact;

  /// The base score is a function of the base metric scores.
  ///
  /// https://www.first.org/cvss/specification-document#Base-Metrics
  core.double? baseScore;

  /// This metric measures the impact to the confidentiality of the information
  /// resources managed by a software component due to a successfully exploited
  /// vulnerability.
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Invalid value.
  /// - "IMPACT_HIGH" : High impact.
  /// - "IMPACT_LOW" : Low impact.
  /// - "IMPACT_NONE" : No impact.
  core.String? confidentialityImpact;

  /// The Exploitability sub-score equation is derived from the Base
  /// Exploitability metrics.
  ///
  /// https://www.first.org/cvss/specification-document#2-1-Exploitability-Metrics
  core.double? exploitabilityScore;

  /// The Impact sub-score equation is derived from the Base Impact metrics.
  core.double? impactScore;

  /// This metric measures the impact to integrity of a successfully exploited
  /// vulnerability.
  /// Possible string values are:
  /// - "IMPACT_UNSPECIFIED" : Invalid value.
  /// - "IMPACT_HIGH" : High impact.
  /// - "IMPACT_LOW" : Low impact.
  /// - "IMPACT_NONE" : No impact.
  core.String? integrityImpact;

  /// This metric describes the level of privileges an attacker must possess
  /// before successfully exploiting the vulnerability.
  /// Possible string values are:
  /// - "PRIVILEGES_REQUIRED_UNSPECIFIED" : Invalid value.
  /// - "PRIVILEGES_REQUIRED_NONE" : The attacker is unauthorized prior to
  /// attack, and therefore does not require any access to settings or files of
  /// the vulnerable system to carry out an attack.
  /// - "PRIVILEGES_REQUIRED_LOW" : The attacker requires privileges that
  /// provide basic user capabilities that could normally affect only settings
  /// and files owned by a user. Alternatively, an attacker with Low privileges
  /// has the ability to access only non-sensitive resources.
  /// - "PRIVILEGES_REQUIRED_HIGH" : The attacker requires privileges that
  /// provide significant (e.g., administrative) control over the vulnerable
  /// component allowing access to component-wide settings and files.
  core.String? privilegesRequired;

  /// The Scope metric captures whether a vulnerability in one vulnerable
  /// component impacts resources in components beyond its security scope.
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED" : Invalid value.
  /// - "SCOPE_UNCHANGED" : An exploited vulnerability can only affect resources
  /// managed by the same security authority.
  /// - "SCOPE_CHANGED" : An exploited vulnerability can affect resources beyond
  /// the security scope managed by the security authority of the vulnerable
  /// component.
  core.String? scope;

  /// This metric captures the requirement for a human user, other than the
  /// attacker, to participate in the successful compromise of the vulnerable
  /// component.
  /// Possible string values are:
  /// - "USER_INTERACTION_UNSPECIFIED" : Invalid value.
  /// - "USER_INTERACTION_NONE" : The vulnerable system can be exploited without
  /// interaction from any user.
  /// - "USER_INTERACTION_REQUIRED" : Successful exploitation of this
  /// vulnerability requires a user to take some action before the vulnerability
  /// can be exploited.
  core.String? userInteraction;

  $CVSSv301({
    this.attackComplexity,
    this.attackVector,
    this.availabilityImpact,
    this.baseScore,
    this.confidentialityImpact,
    this.exploitabilityScore,
    this.impactScore,
    this.integrityImpact,
    this.privilegesRequired,
    this.scope,
    this.userInteraction,
  });

  $CVSSv301.fromJson(core.Map json_)
    : this(
        attackComplexity: json_['attackComplexity'] as core.String?,
        attackVector: json_['attackVector'] as core.String?,
        availabilityImpact: json_['availabilityImpact'] as core.String?,
        baseScore: (json_['baseScore'] as core.num?)?.toDouble(),
        confidentialityImpact: json_['confidentialityImpact'] as core.String?,
        exploitabilityScore:
            (json_['exploitabilityScore'] as core.num?)?.toDouble(),
        impactScore: (json_['impactScore'] as core.num?)?.toDouble(),
        integrityImpact: json_['integrityImpact'] as core.String?,
        privilegesRequired: json_['privilegesRequired'] as core.String?,
        scope: json_['scope'] as core.String?,
        userInteraction: json_['userInteraction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attackComplexity != null) 'attackComplexity': attackComplexity!,
    if (attackVector != null) 'attackVector': attackVector!,
    if (availabilityImpact != null) 'availabilityImpact': availabilityImpact!,
    if (baseScore != null) 'baseScore': baseScore!,
    if (confidentialityImpact != null)
      'confidentialityImpact': confidentialityImpact!,
    if (exploitabilityScore != null)
      'exploitabilityScore': exploitabilityScore!,
    if (impactScore != null) 'impactScore': impactScore!,
    if (integrityImpact != null) 'integrityImpact': integrityImpact!,
    if (privilegesRequired != null) 'privilegesRequired': privilegesRequired!,
    if (scope != null) 'scope': scope!,
    if (userInteraction != null) 'userInteraction': userInteraction!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CacheConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CacheConfig
class $CacheConfig {
  /// If set to true, disables GenAI caching.
  ///
  /// Otherwise caching is enabled.
  core.bool? disableCache;

  /// Identifier.
  ///
  /// Name of the cache config. Format: - `projects/{project}/cacheConfig`.
  core.String? name;

  $CacheConfig({this.disableCache, this.name});

  $CacheConfig.fromJson(core.Map json_)
    : this(
        disableCache: json_['disableCache'] as core.bool?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableCache != null) 'disableCache': disableCache!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : CacheInvalidationRule
/// - compute:beta : CacheInvalidationRule
/// - compute:v1 : CacheInvalidationRule
class $CacheInvalidationRule {
  /// A list of cache tags used to identify cached objects.
  ///
  /// - Cache tags are specified when the response is first cached, by setting
  /// the `Cache-Tag` response header at the origin. - Multiple cache tags in
  /// the same invalidation request are treated as Boolean `OR` - for example,
  /// `tag1 OR tag2 OR tag3`. - If other fields are also specified, these are
  /// treated as Boolean `AND` with any tags. Up to 10 tags can be specified in
  /// a single invalidation request.
  core.List<core.String>? cacheTags;

  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String? host;
  core.String? path;

  $CacheInvalidationRule({this.cacheTags, this.host, this.path});

  $CacheInvalidationRule.fromJson(core.Map json_)
    : this(
        cacheTags:
            (json_['cacheTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        host: json_['host'] as core.String?,
        path: json_['path'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cacheTags != null) 'cacheTags': cacheTags!,
    if (host != null) 'host': host!,
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - compute:alpha : CacheKeyPolicy
/// - compute:beta : CacheKeyPolicy
/// - compute:v1 : CacheKeyPolicy
class $CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool? includeHost;

  /// Allows HTTP request headers (by name) to be used in the cache key.
  core.List<core.String>? includeHttpHeaders;

  /// Allows HTTP cookies (by name) to be used in the cache key.
  ///
  /// The name=value pair will be used in the cache key Cloud CDN generates.
  core.List<core.String>? includeNamedCookies;

  /// If true, http and https requests will be cached separately.
  core.bool? includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist.
  ///
  /// If neither is set, the entire query string will be included. If false, the
  /// query string will be excluded from the cache key entirely.
  core.bool? includeQueryString;

  /// Names of query string parameters to exclude in cache keys.
  ///
  /// All other parameters will be included. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringBlacklist;

  /// Names of query string parameters to include in cache keys.
  ///
  /// All other parameters will be excluded. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringWhitelist;

  $CacheKeyPolicy({
    this.includeHost,
    this.includeHttpHeaders,
    this.includeNamedCookies,
    this.includeProtocol,
    this.includeQueryString,
    this.queryStringBlacklist,
    this.queryStringWhitelist,
  });

  $CacheKeyPolicy.fromJson(core.Map json_)
    : this(
        includeHost: json_['includeHost'] as core.bool?,
        includeHttpHeaders:
            (json_['includeHttpHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        includeNamedCookies:
            (json_['includeNamedCookies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        includeProtocol: json_['includeProtocol'] as core.bool?,
        includeQueryString: json_['includeQueryString'] as core.bool?,
        queryStringBlacklist:
            (json_['queryStringBlacklist'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        queryStringWhitelist:
            (json_['queryStringWhitelist'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeHost != null) 'includeHost': includeHost!,
    if (includeHttpHeaders != null) 'includeHttpHeaders': includeHttpHeaders!,
    if (includeNamedCookies != null)
      'includeNamedCookies': includeNamedCookies!,
    if (includeProtocol != null) 'includeProtocol': includeProtocol!,
    if (includeQueryString != null) 'includeQueryString': includeQueryString!,
    if (queryStringBlacklist != null)
      'queryStringBlacklist': queryStringBlacklist!,
    if (queryStringWhitelist != null)
      'queryStringWhitelist': queryStringWhitelist!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CachedContentUsageMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CachedContentUsageMetadata
class $CachedContentUsageMetadata {
  /// Duration of audio in seconds.
  core.int? audioDurationSeconds;

  /// Number of images.
  core.int? imageCount;

  /// Number of text characters.
  core.int? textCount;

  /// Total number of tokens that the cached content consumes.
  core.int? totalTokenCount;

  /// Duration of video in seconds.
  core.int? videoDurationSeconds;

  $CachedContentUsageMetadata({
    this.audioDurationSeconds,
    this.imageCount,
    this.textCount,
    this.totalTokenCount,
    this.videoDurationSeconds,
  });

  $CachedContentUsageMetadata.fromJson(core.Map json_)
    : this(
        audioDurationSeconds: json_['audioDurationSeconds'] as core.int?,
        imageCount: json_['imageCount'] as core.int?,
        textCount: json_['textCount'] as core.int?,
        totalTokenCount: json_['totalTokenCount'] as core.int?,
        videoDurationSeconds: json_['videoDurationSeconds'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioDurationSeconds != null)
      'audioDurationSeconds': audioDurationSeconds!,
    if (imageCount != null) 'imageCount': imageCount!,
    if (textCount != null) 'textCount': textCount!,
    if (totalTokenCount != null) 'totalTokenCount': totalTokenCount!,
    if (videoDurationSeconds != null)
      'videoDurationSeconds': videoDurationSeconds!,
  };
}

/// Used by:
///
/// - container:v1 : CancelOperationRequest
/// - container:v1beta1 : CancelOperationRequest
class $CancelOperationRequest {
  /// The name (project, location, operation id) of the operation to cancel.
  ///
  /// Specified in the format `projects / * /locations / * /operations / * `.
  core.String? name;

  /// The server-assigned `name` of the operation.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? operationId;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the operation resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $CancelOperationRequest({
    this.name,
    this.operationId,
    this.projectId,
    this.zone,
  });

  $CancelOperationRequest.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        operationId: json_['operationId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (operationId != null) 'operationId': operationId!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CarrierAndIspAssignedTargetingOptionDetails
/// - displayvideo:v3 : CarrierAndIspAssignedTargetingOptionDetails
/// - displayvideo:v4 : CarrierAndIspAssignedTargetingOptionDetails
class $CarrierAndIspAssignedTargetingOptionDetails {
  /// The display name of the carrier or ISP.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  ///
  /// All assigned carrier and ISP targeting options on the same resource must
  /// have the same value for this field.
  core.bool? negative;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_CARRIER_AND_ISP`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $CarrierAndIspAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $CarrierAndIspAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CarrierAndIspTargetingOptionDetails
/// - displayvideo:v3 : CarrierAndIspTargetingOptionDetails
/// - displayvideo:v4 : CarrierAndIspTargetingOptionDetails
class $CarrierAndIspTargetingOptionDetails {
  /// The display name of the carrier or ISP.
  ///
  /// Output only.
  core.String? displayName;

  /// The type indicating if it's carrier or ISP.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CARRIER_AND_ISP_TYPE_UNSPECIFIED" : Default value when type is not
  /// specified or is unknown in this version.
  /// - "CARRIER_AND_ISP_TYPE_ISP" : Indicates this targeting resource refers to
  /// an ISP.
  /// - "CARRIER_AND_ISP_TYPE_CARRIER" : Indicates this targeting resource
  /// refers to a mobile carrier.
  core.String? type;

  $CarrierAndIspTargetingOptionDetails({this.displayName, this.type});

  $CarrierAndIspTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CatalogAttributeFacetConfigIgnoredFacetValues
/// - retail:v2alpha : GoogleCloudRetailV2alphaCatalogAttributeFacetConfigIgnoredFacetValues
/// - retail:v2beta : GoogleCloudRetailV2betaCatalogAttributeFacetConfigIgnoredFacetValues
class $CatalogAttributeFacetConfigIgnoredFacetValues {
  /// If start time is empty and end time is not empty, then ignore these facet
  /// values before end time.
  core.String? endTime;

  /// Time range for the current list of facet values to ignore.
  ///
  /// If multiple time ranges are specified for an facet value for the current
  /// attribute, consider all of them. If both are empty, ignore always. If
  /// start time and end time are set, then start time must be before end time.
  /// If start time is not empty and end time is empty, then will ignore these
  /// facet values after the start time.
  core.String? startTime;

  /// List of facet values to ignore for the following time range.
  ///
  /// The facet values are the same as the attribute values. There is a limit of
  /// 10 values per instance of IgnoredFacetValues. Each value can have at most
  /// 128 characters.
  core.List<core.String>? values;

  $CatalogAttributeFacetConfigIgnoredFacetValues({
    this.endTime,
    this.startTime,
    this.values,
  });

  $CatalogAttributeFacetConfigIgnoredFacetValues.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CatalogAttributeFacetConfigMergedFacet
/// - retail:v2alpha : GoogleCloudRetailV2alphaCatalogAttributeFacetConfigMergedFacet
/// - retail:v2beta : GoogleCloudRetailV2betaCatalogAttributeFacetConfigMergedFacet
class $CatalogAttributeFacetConfigMergedFacet {
  /// The merged facet key should be a valid facet key that is different than
  /// the facet key of the current catalog attribute.
  ///
  /// We refer this is merged facet key as the child of the current catalog
  /// attribute. This merged facet key can't be a parent of another facet key
  /// (i.e. no directed path of length 2). This merged facet key needs to be
  /// either a textual custom attribute or a numerical custom attribute.
  core.String? mergedFacetKey;

  $CatalogAttributeFacetConfigMergedFacet({this.mergedFacetKey});

  $CatalogAttributeFacetConfigMergedFacet.fromJson(core.Map json_)
    : this(mergedFacetKey: json_['mergedFacetKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mergedFacetKey != null) 'mergedFacetKey': mergedFacetKey!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CatalogAttributeFacetConfigMergedFacetValue
/// - retail:v2alpha : GoogleCloudRetailV2alphaCatalogAttributeFacetConfigMergedFacetValue
/// - retail:v2beta : GoogleCloudRetailV2betaCatalogAttributeFacetConfigMergedFacetValue
class $CatalogAttributeFacetConfigMergedFacetValue {
  /// All the previous values are replaced by this merged facet value.
  ///
  /// This merged_value must be non-empty and can have up to 128 characters.
  core.String? mergedValue;

  /// All the facet values that are replaces by the same merged_value that
  /// follows.
  ///
  /// The maximum number of values per MergedFacetValue is 25. Each value can
  /// have up to 128 characters.
  core.List<core.String>? values;

  $CatalogAttributeFacetConfigMergedFacetValue({this.mergedValue, this.values});

  $CatalogAttributeFacetConfigMergedFacetValue.fromJson(core.Map json_)
    : this(
        mergedValue: json_['mergedValue'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mergedValue != null) 'mergedValue': mergedValue!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CatalogAttributeFacetConfigRerankConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaCatalogAttributeFacetConfigRerankConfig
/// - retail:v2beta : GoogleCloudRetailV2betaCatalogAttributeFacetConfigRerankConfig
class $CatalogAttributeFacetConfigRerankConfig {
  /// If empty, rerank on all facet values for the current key.
  ///
  /// Otherwise, will rerank on the facet values from this list only.
  core.List<core.String>? facetValues;

  /// If set to true, then we also rerank the dynamic facets based on the facet
  /// values engaged by the user for the current attribute key during serving.
  core.bool? rerankFacet;

  $CatalogAttributeFacetConfigRerankConfig({
    this.facetValues,
    this.rerankFacet,
  });

  $CatalogAttributeFacetConfigRerankConfig.fromJson(core.Map json_)
    : this(
        facetValues:
            (json_['facetValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        rerankFacet: json_['rerankFacet'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (facetValues != null) 'facetValues': facetValues!,
    if (rerankFacet != null) 'rerankFacet': rerankFacet!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Category
/// - ondemandscanning:v1 : Category
/// - ondemandscanning:v1beta1 : Category
class $Category {
  /// The identifier of the category.
  core.String? categoryId;

  /// The localized name of the category.
  core.String? name;

  $Category({this.categoryId, this.name});

  $Category.fromJson(core.Map json_)
    : this(
        categoryId: json_['categoryId'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categoryId != null) 'categoryId': categoryId!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CategoryAssignedTargetingOptionDetails
/// - displayvideo:v3 : CategoryAssignedTargetingOptionDetails
/// - displayvideo:v4 : CategoryAssignedTargetingOptionDetails
class $CategoryAssignedTargetingOptionDetails {
  /// The display name of the category.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_CATEGORY`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $CategoryAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $CategoryAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CategoryTargetingOptionDetails
/// - displayvideo:v3 : CategoryTargetingOptionDetails
/// - displayvideo:v4 : CategoryTargetingOptionDetails
class $CategoryTargetingOptionDetails {
  /// The display name of the category.
  ///
  /// Output only.
  core.String? displayName;

  $CategoryTargetingOptionDetails({this.displayName});

  $CategoryTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - metastore:v1 : CdcConfig
/// - metastore:v1alpha : CdcConfig
/// - metastore:v1beta : CdcConfig
class $CdcConfig {
  /// The bucket to write the intermediate stream event data in.
  ///
  /// The bucket name must be without any prefix like "gs://". See the bucket
  /// naming requirements
  /// (https://cloud.google.com/storage/docs/buckets#naming). This field is
  /// optional. If not set, the Artifacts Cloud Storage bucket will be used.
  ///
  /// Optional.
  core.String? bucket;

  /// Input only.
  ///
  /// The password for the user that Datastream service should use for the MySQL
  /// connection. This field is not returned on request.
  ///
  /// Required.
  core.String? password;

  /// The URL of the subnetwork resource to create the VM instance hosting the
  /// reverse proxy in.
  ///
  /// More context in
  /// https://cloud.google.com/datastream/docs/private-connectivity#reverse-csql-proxy
  /// The subnetwork should reside in the network provided in the request that
  /// Datastream will peer to and should be in the same region as Datastream, in
  /// the following format.
  /// projects/{project_id}/regions/{region_id}/subnetworks/{subnetwork_id}
  ///
  /// Required.
  core.String? reverseProxySubnet;

  /// The root path inside the Cloud Storage bucket.
  ///
  /// The stream event data will be written to this path. The default value is
  /// /migration.
  ///
  /// Optional.
  core.String? rootPath;

  /// A /29 CIDR IP range for peering with datastream.
  ///
  /// Required.
  core.String? subnetIpRange;

  /// The username that the Datastream service should use for the MySQL
  /// connection.
  ///
  /// Required.
  core.String? username;

  /// Fully qualified name of the Cloud SQL instance's VPC network or the shared
  /// VPC network that Datastream will peer to, in the following format:
  /// projects/{project_id}/locations/global/networks/{network_id}.
  ///
  /// More context in
  /// https://cloud.google.com/datastream/docs/network-connectivity-options#privateconnectivity
  ///
  /// Required.
  core.String? vpcNetwork;

  $CdcConfig({
    this.bucket,
    this.password,
    this.reverseProxySubnet,
    this.rootPath,
    this.subnetIpRange,
    this.username,
    this.vpcNetwork,
  });

  $CdcConfig.fromJson(core.Map json_)
    : this(
        bucket: json_['bucket'] as core.String?,
        password: json_['password'] as core.String?,
        reverseProxySubnet: json_['reverseProxySubnet'] as core.String?,
        rootPath: json_['rootPath'] as core.String?,
        subnetIpRange: json_['subnetIpRange'] as core.String?,
        username: json_['username'] as core.String?,
        vpcNetwork: json_['vpcNetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
    if (password != null) 'password': password!,
    if (reverseProxySubnet != null) 'reverseProxySubnet': reverseProxySubnet!,
    if (rootPath != null) 'rootPath': rootPath!,
    if (subnetIpRange != null) 'subnetIpRange': subnetIpRange!,
    if (username != null) 'username': username!,
    if (vpcNetwork != null) 'vpcNetwork': vpcNetwork!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendBucketCdnPolicyBypassCacheOnRequestHeader
/// - compute:alpha : BackendServiceCdnPolicyBypassCacheOnRequestHeader
/// - compute:beta : BackendBucketCdnPolicyBypassCacheOnRequestHeader
/// - compute:beta : BackendServiceCdnPolicyBypassCacheOnRequestHeader
/// - compute:v1 : BackendBucketCdnPolicyBypassCacheOnRequestHeader
/// - compute:v1 : BackendServiceCdnPolicyBypassCacheOnRequestHeader
class $CdnPolicyBypassCacheOnRequestHeader {
  /// The header field name to match on when bypassing cache.
  ///
  /// Values are case-insensitive.
  core.String? headerName;

  $CdnPolicyBypassCacheOnRequestHeader({this.headerName});

  $CdnPolicyBypassCacheOnRequestHeader.fromJson(core.Map json_)
    : this(headerName: json_['headerName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (headerName != null) 'headerName': headerName!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendBucketCdnPolicyNegativeCachingPolicy
/// - compute:alpha : BackendServiceCdnPolicyNegativeCachingPolicy
/// - compute:beta : BackendBucketCdnPolicyNegativeCachingPolicy
/// - compute:beta : BackendServiceCdnPolicyNegativeCachingPolicy
/// - compute:v1 : BackendBucketCdnPolicyNegativeCachingPolicy
/// - compute:v1 : BackendServiceCdnPolicyNegativeCachingPolicy
class $CdnPolicyNegativeCachingPolicy {
  /// The HTTP status code to define a TTL against.
  ///
  /// Only HTTP status codes 300, 301, 302, 307, 308, 404, 405, 410, 421, 451
  /// and 501 are can be specified as values, and you cannot specify a status
  /// code more than once.
  core.int? code;

  /// The TTL (in seconds) for which to cache responses with the corresponding
  /// status code.
  ///
  /// The maximum allowed value is 1800s (30 minutes), noting that infrequently
  /// accessed objects may be evicted from the cache before the defined TTL.
  core.int? ttl;

  $CdnPolicyNegativeCachingPolicy({this.code, this.ttl});

  $CdnPolicyNegativeCachingPolicy.fromJson(core.Map json_)
    : this(code: json_['code'] as core.int?, ttl: json_['ttl'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - privateca:v1 : CertChain
/// - redis:v1 : CertChain
/// - redis:v1beta1 : CertChain
class $CertChain {
  /// The certificates that form the CA chain, from leaf to root order.
  core.List<core.String>? certificates;

  $CertChain({this.certificates});

  $CertChain.fromJson(core.Map json_)
    : this(
        certificates:
            (json_['certificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificates != null) 'certificates': certificates!,
  };
}

/// Used by:
///
/// - cloudkms:v1 : CertificateChains
/// - kmsinventory:v1 : GoogleCloudKmsV1KeyOperationAttestationCertificateChains
class $CertificateChains {
  /// Cavium certificate chain corresponding to the attestation.
  core.List<core.String>? caviumCerts;

  /// Google card certificate chain corresponding to the attestation.
  core.List<core.String>? googleCardCerts;

  /// Google partition certificate chain corresponding to the attestation.
  core.List<core.String>? googlePartitionCerts;

  $CertificateChains({
    this.caviumCerts,
    this.googleCardCerts,
    this.googlePartitionCerts,
  });

  $CertificateChains.fromJson(core.Map json_)
    : this(
        caviumCerts:
            (json_['caviumCerts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        googleCardCerts:
            (json_['googleCardCerts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        googlePartitionCerts:
            (json_['googlePartitionCerts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caviumCerts != null) 'caviumCerts': caviumCerts!,
    if (googleCardCerts != null) 'googleCardCerts': googleCardCerts!,
    if (googlePartitionCerts != null)
      'googlePartitionCerts': googlePartitionCerts!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : CertificateProviderInstance
/// - networksecurity:v1beta1 : CertificateProviderInstance
class $CertificateProviderInstance {
  /// Plugin instance name, used to locate and load CertificateProvider instance
  /// configuration.
  ///
  /// Set to "google_cloud_private_spiffe" to use Certificate Authority Service
  /// certificate provider instance.
  ///
  /// Required.
  core.String? pluginInstance;

  $CertificateProviderInstance({this.pluginInstance});

  $CertificateProviderInstance.fromJson(core.Map json_)
    : this(pluginInstance: json_['pluginInstance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pluginInstance != null) 'pluginInstance': pluginInstance!,
  };
}

/// Used by:
///
/// - appengine:v1 : CertificateRawData
/// - appengine:v1alpha : CertificateRawData
/// - appengine:v1beta : CertificateRawData
class $CertificateRawData {
  /// Unencrypted PEM encoded RSA private key.
  ///
  /// This field is set once on certificate creation and then encrypted. The key
  /// size must be 2048 bits or fewer. Must include the header and footer.
  /// Example: -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY-----
  /// @InputOnly
  core.String? privateKey;

  /// PEM encoded x.509 public key certificate.
  ///
  /// This field is set once on certificate creation. Must include the header
  /// and footer. Example: -----BEGIN CERTIFICATE----- -----END CERTIFICATE-----
  core.String? publicCertificate;

  $CertificateRawData({this.privateKey, this.publicCertificate});

  $CertificateRawData.fromJson(core.Map json_)
    : this(
        privateKey: json_['privateKey'] as core.String?,
        publicCertificate: json_['publicCertificate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (privateKey != null) 'privateKey': privateKey!,
    if (publicCertificate != null) 'publicCertificate': publicCertificate!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1CertificateTemplate
/// - cloudidentity:v1beta1 : CertificateTemplate
class $CertificateTemplate {
  /// The template id of the template.
  ///
  /// Example:
  /// "1.3.6.1.4.1.311.21.8.15608621.11768144.5720724.16068415.6889630.81.2472537.7784047".
  core.String? id;

  /// The Major version of the template.
  ///
  /// Example: 100.
  core.int? majorVersion;

  /// The minor version of the template.
  ///
  /// Example: 12.
  core.int? minorVersion;

  $CertificateTemplate({this.id, this.majorVersion, this.minorVersion});

  $CertificateTemplate.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        majorVersion: json_['majorVersion'] as core.int?,
        minorVersion: json_['minorVersion'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (majorVersion != null) 'majorVersion': majorVersion!,
    if (minorVersion != null) 'minorVersion': minorVersion!,
  };
}

/// Used by:
///
/// - container:v1 : MeshCertificates
/// - container:v1beta1 : MeshCertificates
/// - container:v1beta1 : WorkloadCertificates
class $Certificates {
  /// enable_certificates controls issuance of workload mTLS certificates.
  ///
  /// If set, the GKE Workload Identity Certificates controller and node agent
  /// will be deployed in the cluster, which can then be configured by creating
  /// a WorkloadCertificateConfig Custom Resource. Requires Workload Identity
  /// (workload_pool must be non-empty).
  core.bool? enableCertificates;

  $Certificates({this.enableCertificates});

  $Certificates.fromJson(core.Map json_)
    : this(enableCertificates: json_['enableCertificates'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableCertificates != null) 'enableCertificates': enableCertificates!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3Changelog
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1Changelog
class $Changelog {
  /// The action of the change.
  core.String? action;

  /// The timestamp of the change.
  core.String? createTime;

  /// The affected resource display name of the change.
  core.String? displayName;

  /// The affected language code of the change.
  core.String? languageCode;

  /// The unique identifier of the changelog.
  ///
  /// Format: `projects//locations//agents//changelogs/`.
  core.String? name;

  /// The affected resource name of the change.
  core.String? resource;

  /// The affected resource type.
  core.String? type;

  /// Email address of the authenticated user.
  core.String? userEmail;

  $Changelog({
    this.action,
    this.createTime,
    this.displayName,
    this.languageCode,
    this.name,
    this.resource,
    this.type,
    this.userEmail,
  });

  $Changelog.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        name: json_['name'] as core.String?,
        resource: json_['resource'] as core.String?,
        type: json_['type'] as core.String?,
        userEmail: json_['userEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (name != null) 'name': name!,
    if (resource != null) 'resource': resource!,
    if (type != null) 'type': type!,
    if (userEmail != null) 'userEmail': userEmail!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : Channel
/// - displayvideo:v3 : Channel
/// - displayvideo:v4 : Channel
class $Channel00 {
  /// The ID of the advertiser that owns the channel.
  core.String? advertiserId;

  /// The unique ID of the channel.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? channelId;

  /// The display name of the channel.
  ///
  /// Must be UTF-8 encoded with a maximum length of 240 bytes.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the channel.
  ///
  /// Output only.
  core.String? name;

  /// Number of line items that are directly targeting this channel negatively.
  ///
  /// Output only.
  core.String? negativelyTargetedLineItemCount;

  /// The ID of the partner that owns the channel.
  core.String? partnerId;

  /// Number of line items that are directly targeting this channel positively.
  ///
  /// Output only.
  core.String? positivelyTargetedLineItemCount;

  $Channel00({
    this.advertiserId,
    this.channelId,
    this.displayName,
    this.name,
    this.negativelyTargetedLineItemCount,
    this.partnerId,
    this.positivelyTargetedLineItemCount,
  });

  $Channel00.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        channelId: json_['channelId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        negativelyTargetedLineItemCount:
            json_['negativelyTargetedLineItemCount'] as core.String?,
        partnerId: json_['partnerId'] as core.String?,
        positivelyTargetedLineItemCount:
            json_['positivelyTargetedLineItemCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (channelId != null) 'channelId': channelId!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (negativelyTargetedLineItemCount != null)
      'negativelyTargetedLineItemCount': negativelyTargetedLineItemCount!,
    if (partnerId != null) 'partnerId': partnerId!,
    if (positivelyTargetedLineItemCount != null)
      'positivelyTargetedLineItemCount': positivelyTargetedLineItemCount!,
  };
}

/// Used by:
///
/// - drive:v2 : Channel
/// - drive:v3 : Channel
class $Channel01 {
  /// The address where notifications are delivered for this channel.
  core.String? address;

  /// Date and time of notification channel expiration, expressed as a Unix
  /// timestamp, in milliseconds.
  ///
  /// Optional.
  core.String? expiration;

  /// A UUID or similar unique string that identifies this channel.
  core.String? id;

  /// Identifies this as a notification channel used to watch for changes to a
  /// resource, which is `api#channel`.
  core.String? kind;

  /// Additional parameters controlling delivery channel behavior.
  ///
  /// Optional.
  core.Map<core.String, core.String>? params;

  /// A Boolean value to indicate whether payload is wanted.
  ///
  /// Optional.
  core.bool? payload;

  /// An opaque ID that identifies the resource being watched on this channel.
  ///
  /// Stable across different API versions.
  core.String? resourceId;

  /// A version-specific identifier for the watched resource.
  core.String? resourceUri;

  /// An arbitrary string delivered to the target address with each notification
  /// delivered over this channel.
  ///
  /// Optional.
  core.String? token;

  /// The type of delivery mechanism used for this channel.
  ///
  /// Valid values are "web_hook" or "webhook".
  core.String? type;

  $Channel01({
    this.address,
    this.expiration,
    this.id,
    this.kind,
    this.params,
    this.payload,
    this.resourceId,
    this.resourceUri,
    this.token,
    this.type,
  });

  $Channel01.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        expiration: json_['expiration'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        params: (json_['params'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        payload: json_['payload'] as core.bool?,
        resourceId: json_['resourceId'] as core.String?,
        resourceUri: json_['resourceUri'] as core.String?,
        token: json_['token'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (expiration != null) 'expiration': expiration!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (params != null) 'params': params!,
    if (payload != null) 'payload': payload!,
    if (resourceId != null) 'resourceId': resourceId!,
    if (resourceUri != null) 'resourceUri': resourceUri!,
    if (token != null) 'token': token!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ChannelAssignedTargetingOptionDetails
/// - displayvideo:v3 : ChannelAssignedTargetingOptionDetails
/// - displayvideo:v4 : ChannelAssignedTargetingOptionDetails
class $ChannelAssignedTargetingOptionDetails {
  /// ID of the channel.
  ///
  /// Should refer to the channel ID field on a \[Partner-owned
  /// channel\](partners.channels#Channel.FIELDS.channel_id) or
  /// \[advertiser-owned
  /// channel\](advertisers.channels#Channel.FIELDS.channel_id) resource.
  ///
  /// Required.
  core.String? channelId;

  /// Indicates if this option is being negatively targeted.
  ///
  /// For advertiser level assigned targeting option, this field must be true.
  core.bool? negative;

  $ChannelAssignedTargetingOptionDetails({this.channelId, this.negative});

  $ChannelAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        channelId: json_['channelId'] as core.String?,
        negative: json_['negative'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (channelId != null) 'channelId': channelId!,
    if (negative != null) 'negative': negative!,
  };
}

/// Used by:
///
/// - dataportability:v1 : CheckAccessTypeResponse
/// - dataportability:v1beta : CheckAccessTypeResponse
class $CheckAccessTypeResponse {
  /// Jobs initiated with this token will be one-time if any requested resources
  /// have one-time access.
  core.List<core.String>? oneTimeResources;

  /// Jobs initiated with this token will be time-based if all requested
  /// resources have time-based access.
  core.List<core.String>? timeBasedResources;

  $CheckAccessTypeResponse({this.oneTimeResources, this.timeBasedResources});

  $CheckAccessTypeResponse.fromJson(core.Map json_)
    : this(
        oneTimeResources:
            (json_['oneTimeResources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        timeBasedResources:
            (json_['timeBasedResources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (oneTimeResources != null) 'oneTimeResources': oneTimeResources!,
    if (timeBasedResources != null) 'timeBasedResources': timeBasedResources!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CheckGroundingResponseCheckGroundingFactChunk
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseCheckGroundingFactChunk
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCheckGroundingResponseCheckGroundingFactChunk
class $CheckGroundingResponseCheckGroundingFactChunk {
  /// Text content of the fact chunk.
  ///
  /// Can be at most 10K characters long.
  core.String? chunkText;

  $CheckGroundingResponseCheckGroundingFactChunk({this.chunkText});

  $CheckGroundingResponseCheckGroundingFactChunk.fromJson(core.Map json_)
    : this(chunkText: json_['chunkText'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkText != null) 'chunkText': chunkText!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CheckGroundingResponseClaim
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseClaim
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCheckGroundingResponseClaim
class $CheckGroundingResponseClaim {
  /// A list of indices (into 'cited_chunks') specifying the citations
  /// associated with the claim.
  ///
  /// For instance \[1,3,4\] means that cited_chunks\[1\], cited_chunks\[3\],
  /// cited_chunks\[4\] are the facts cited supporting for the claim. A citation
  /// to a fact indicates that the claim is supported by the fact.
  core.List<core.int>? citationIndices;

  /// Text for the claim in the answer candidate.
  ///
  /// Always provided regardless of whether citations or anti-citations are
  /// found.
  core.String? claimText;

  /// Position indicating the end of the claim in the answer candidate,
  /// exclusive, in bytes.
  ///
  /// Note that this is not measured in characters and, therefore, must be
  /// rendered as such. For example, if the claim text contains non-ASCII
  /// characters, the start and end positions vary when measured in characters
  /// (programming-language-dependent) and when measured in bytes
  /// (programming-language-independent).
  core.int? endPos;

  /// Indicates that this claim required grounding check.
  ///
  /// When the system decided this claim doesn't require attribution/grounding
  /// check, this field will be set to false. In that case, no grounding check
  /// was done for the claim and therefore citation_indices should not be
  /// returned.
  core.bool? groundingCheckRequired;

  /// Confidence score for the claim in the answer candidate, in the range of
  /// \[0, 1\].
  ///
  /// This is set only when
  /// `CheckGroundingRequest.grounding_spec.enable_claim_level_score` is true.
  core.double? score;

  /// Position indicating the start of the claim in the answer candidate,
  /// measured in bytes.
  ///
  /// Note that this is not measured in characters and, therefore, must be
  /// rendered in the user interface keeping in mind that some characters may
  /// take more than one byte. For example, if the claim text contains non-ASCII
  /// characters, the start and end positions vary when measured in characters
  /// (programming-language-dependent) and when measured in bytes
  /// (programming-language-independent).
  core.int? startPos;

  $CheckGroundingResponseClaim({
    this.citationIndices,
    this.claimText,
    this.endPos,
    this.groundingCheckRequired,
    this.score,
    this.startPos,
  });

  $CheckGroundingResponseClaim.fromJson(core.Map json_)
    : this(
        citationIndices:
            (json_['citationIndices'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        claimText: json_['claimText'] as core.String?,
        endPos: json_['endPos'] as core.int?,
        groundingCheckRequired: json_['groundingCheckRequired'] as core.bool?,
        score: (json_['score'] as core.num?)?.toDouble(),
        startPos: json_['startPos'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citationIndices != null) 'citationIndices': citationIndices!,
    if (claimText != null) 'claimText': claimText!,
    if (endPos != null) 'endPos': endPos!,
    if (groundingCheckRequired != null)
      'groundingCheckRequired': groundingCheckRequired!,
    if (score != null) 'score': score!,
    if (startPos != null) 'startPos': startPos!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CheckGroundingSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCheckGroundingSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCheckGroundingSpec
class $CheckGroundingSpec {
  /// The threshold (in \[0,1\]) used for determining whether a fact must be
  /// cited for a claim in the answer candidate.
  ///
  /// Choosing a higher threshold will lead to fewer but very strong citations,
  /// while choosing a lower threshold may lead to more but somewhat weaker
  /// citations. If unset, the threshold will default to 0.6.
  core.double? citationThreshold;

  /// The control flag that enables claim-level grounding score in the response.
  core.bool? enableClaimLevelScore;

  $CheckGroundingSpec({this.citationThreshold, this.enableClaimLevelScore});

  $CheckGroundingSpec.fromJson(core.Map json_)
    : this(
        citationThreshold:
            (json_['citationThreshold'] as core.num?)?.toDouble(),
        enableClaimLevelScore: json_['enableClaimLevelScore'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citationThreshold != null) 'citationThreshold': citationThreshold!,
    if (enableClaimLevelScore != null)
      'enableClaimLevelScore': enableClaimLevelScore!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : CheckTransitiveMembershipResponse
/// - cloudidentity:v1beta1 : CheckTransitiveMembershipResponse
class $CheckTransitiveMembershipResponse {
  /// Response does not include the possible roles of a member since the
  /// behavior of this rpc is not all-or-nothing unlike the other rpcs.
  ///
  /// So, it may not be possible to list all the roles definitively, due to
  /// possible lack of authorization in some of the paths.
  core.bool? hasMembership;

  $CheckTransitiveMembershipResponse({this.hasMembership});

  $CheckTransitiveMembershipResponse.fromJson(core.Map json_)
    : this(hasMembership: json_['hasMembership'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (hasMembership != null) 'hasMembership': hasMembership!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Checkpoint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Checkpoint
class $Checkpoint {
  /// The ID of the checkpoint.
  core.String? checkpointId;

  /// The epoch of the checkpoint.
  core.String? epoch;

  /// The step of the checkpoint.
  core.String? step;

  $Checkpoint({this.checkpointId, this.epoch, this.step});

  $Checkpoint.fromJson(core.Map json_)
    : this(
        checkpointId: json_['checkpointId'] as core.String?,
        epoch: json_['epoch'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (epoch != null) 'epoch': epoch!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - safebrowsing:v4 : GoogleSecuritySafebrowsingV4Checksum
/// - webrisk:v1 : GoogleCloudWebriskV1ComputeThreatListDiffResponseChecksum
class $Checksum {
  /// The SHA256 hash of the client state; that is, of the sorted list of all
  /// hashes present in the database.
  core.String? sha256;
  core.List<core.int> get sha256AsBytes => convert.base64.decode(sha256!);

  set sha256AsBytes(core.List<core.int> bytes_) {
    sha256 = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Checksum({this.sha256});

  $Checksum.fromJson(core.Map json_)
    : this(sha256: json_['sha256'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sha256 != null) 'sha256': sha256!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ChunkDocumentMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaChunkDocumentMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaChunkDocumentMetadata
class $ChunkDocumentMetadata {
  /// Data representation.
  ///
  /// The structured JSON data for the document. It should conform to the
  /// registered Schema or an `INVALID_ARGUMENT` error is thrown.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  /// Title of the document.
  core.String? title;

  /// Uri of the document.
  core.String? uri;

  $ChunkDocumentMetadata({this.structData, this.title, this.uri});

  $ChunkDocumentMetadata.fromJson(core.Map json_)
    : this(
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (structData != null) 'structData': structData!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ChunkPageSpan
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaChunkPageSpan
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaChunkPageSpan
class $ChunkPageSpan {
  /// The end page of the chunk.
  core.int? pageEnd;

  /// The start page of the chunk.
  core.int? pageStart;

  $ChunkPageSpan({this.pageEnd, this.pageStart});

  $ChunkPageSpan.fromJson(core.Map json_)
    : this(
        pageEnd: json_['pageEnd'] as core.int?,
        pageStart: json_['pageStart'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageEnd != null) 'pageEnd': pageEnd!,
    if (pageStart != null) 'pageStart': pageStart!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ChunkStructuredContent
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaChunkStructuredContent
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaChunkStructuredContent
class $ChunkStructuredContent {
  /// The content of the structured content.
  ///
  /// Output only.
  core.String? content;

  /// The structure type of the structured content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STRUCTURE_TYPE_UNSPECIFIED" : Default value.
  /// - "SHAREHOLDER_STRUCTURE" : Shareholder structure.
  /// - "SIGNATURE_STRUCTURE" : Signature structure.
  /// - "CHECKBOX_STRUCTURE" : Checkbox structure.
  core.String? structureType;

  $ChunkStructuredContent({this.content, this.structureType});

  $ChunkStructuredContent.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        structureType: json_['structureType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (structureType != null) 'structureType': structureType!,
  };
}

/// Used by:
///
/// - composer:v1 : CidrBlock
/// - composer:v1beta1 : CidrBlock
class $CidrBlock00 {
  /// CIDR block that must be specified in CIDR notation.
  core.String? cidrBlock;

  /// User-defined name that identifies the CIDR block.
  core.String? displayName;

  $CidrBlock00({this.cidrBlock, this.displayName});

  $CidrBlock00.fromJson(core.Map json_)
    : this(
        cidrBlock: json_['cidrBlock'] as core.String?,
        displayName: json_['displayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cidrBlock != null) 'cidrBlock': cidrBlock!,
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - container:v1 : CidrBlock
/// - container:v1beta1 : CidrBlock
class $CidrBlock01 {
  /// cidr_block must be specified in CIDR notation.
  core.String? cidrBlock;

  /// display_name is an optional field for users to identify CIDR blocks.
  core.String? displayName;

  $CidrBlock01({this.cidrBlock, this.displayName});

  $CidrBlock01.fromJson(core.Map json_)
    : this(
        cidrBlock: json_['cidrBlock'] as core.String?,
        displayName: json_['displayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cidrBlock != null) 'cidrBlock': cidrBlock!,
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Claim
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Claim
class $Claim {
  /// Index in the input text where the claim ends (exclusive).
  core.int? endIndex;

  /// Indexes of the facts supporting this claim.
  core.List<core.int>? factIndexes;

  /// Confidence score of this corroboration.
  core.double? score;

  /// Index in the input text where the claim starts (inclusive).
  core.int? startIndex;

  $Claim({this.endIndex, this.factIndexes, this.score, this.startIndex});

  $Claim.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.int?,
        factIndexes:
            (json_['factIndexes'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        score: (json_['score'] as core.num?)?.toDouble(),
        startIndex: json_['startIndex'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (factIndexes != null) 'factIndexes': factIndexes!,
    if (score != null) 'score': score!,
    if (startIndex != null) 'startIndex': startIndex!,
  };
}

/// Used by:
///
/// - speech:v1 : ClassItem
/// - speech:v1p1beta1 : ClassItem
class $ClassItem {
  /// The class item's value.
  core.String? value;

  $ClassItem({this.value});

  $ClassItem.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - language:v1 : ClassificationCategory
/// - language:v1beta2 : ClassificationCategory
class $ClassificationCategory {
  /// The classifier's confidence of the category.
  ///
  /// Number represents how certain the classifier is that this category
  /// represents the given text.
  core.double? confidence;

  /// The name of the category representing the document.
  core.String? name;

  $ClassificationCategory({this.confidence, this.name});

  $ClassificationCategory.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - language:v1 : ClassificationModelOptionsV2Model
/// - language:v1beta2 : ClassificationModelOptionsV2Model
class $ClassificationModelOptionsV2Model {
  /// The content categories used for classification.
  /// Possible string values are:
  /// - "CONTENT_CATEGORIES_VERSION_UNSPECIFIED" : If `ContentCategoriesVersion`
  /// is not specified, this option will default to `V1`.
  /// - "V1" : Legacy content categories of our initial launch in 2017.
  /// - "V2" : Updated content categories in 2022.
  core.String? contentCategoriesVersion;

  $ClassificationModelOptionsV2Model({this.contentCategoriesVersion});

  $ClassificationModelOptionsV2Model.fromJson(core.Map json_)
    : this(
        contentCategoriesVersion:
            json_['contentCategoriesVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentCategoriesVersion != null)
      'contentCategoriesVersion': contentCategoriesVersion!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : Client
/// - authorizedbuyersmarketplace:v1alpha : Client
class $Client {
  /// Display name shown to publishers.
  ///
  /// Must be unique for clients without partnerClientId specified. Maximum
  /// length of 255 characters is allowed.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the client.
  ///
  /// Format: `buyers/{accountId}/clients/{clientAccountId}`
  ///
  /// Output only.
  core.String? name;

  /// Arbitrary unique identifier provided by the buyer.
  ///
  /// This field can be used to associate a client with an identifier in the
  /// namespace of the buyer, lookup clients by that identifier and verify
  /// whether an Authorized Buyers account of the client already exists. If
  /// present, must be unique across all the clients.
  core.String? partnerClientId;

  /// The role assigned to the client.
  ///
  /// Each role implies a set of permissions granted to the client.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CLIENT_ROLE_UNSPECIFIED" : A placeholder for an undefined client role.
  /// This value should never be specified in user input for create or update
  /// method, otherwise an error will be returned.
  /// - "CLIENT_DEAL_VIEWER" : Users associated with this client role can only
  /// view proposals and deals in the Marketplace UI. They cannot negotiate or
  /// approve proposals and deals sent from publishers or send RFP to
  /// publishers.
  /// - "CLIENT_DEAL_NEGOTIATOR" : Users associated with this client role can
  /// view and negotiate on the proposals and deals in the Marketplace UI sent
  /// from publishers and send RFP to publishers, but cannot approve the
  /// proposals and deals by themselves. The buyer can approve the proposals and
  /// deals on behalf of the client.
  /// - "CLIENT_DEAL_APPROVER" : Users associated with this client role can
  /// view, negotiate and approve proposals and deals in the Marketplace UI and
  /// send RFP to publishers.
  core.String? role;

  /// Whether the client will be visible to sellers.
  core.bool? sellerVisible;

  /// The state of the client.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : A placeholder for an undefined client state.
  /// Should not be used.
  /// - "ACTIVE" : A client that is currently active and allowed to access the
  /// Authorized Buyers UI.
  /// - "INACTIVE" : A client that is currently inactive and not allowed to
  /// access the Authorized Buyers UI.
  core.String? state;

  $Client({
    this.displayName,
    this.name,
    this.partnerClientId,
    this.role,
    this.sellerVisible,
    this.state,
  });

  $Client.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        partnerClientId: json_['partnerClientId'] as core.String?,
        role: json_['role'] as core.String?,
        sellerVisible: json_['sellerVisible'] as core.bool?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (partnerClientId != null) 'partnerClientId': partnerClientId!,
    if (role != null) 'role': role!,
    if (sellerVisible != null) 'sellerVisible': sellerVisible!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - container:v1 : ClientCertificateConfig
/// - container:v1beta1 : ClientCertificateConfig
class $ClientCertificateConfig {
  /// Issue a client certificate.
  core.bool? issueClientCertificate;

  $ClientCertificateConfig({this.issueClientCertificate});

  $ClientCertificateConfig.fromJson(core.Map json_)
    : this(
        issueClientCertificate: json_['issueClientCertificate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (issueClientCertificate != null)
      'issueClientCertificate': issueClientCertificate!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ClientConnectionConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ClientConnectionConfig
class $ClientConnectionConfig {
  /// Customizable online prediction request timeout.
  core.String? inferenceTimeout;

  $ClientConnectionConfig({this.inferenceTimeout});

  $ClientConnectionConfig.fromJson(core.Map json_)
    : this(inferenceTimeout: json_['inferenceTimeout'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (inferenceTimeout != null) 'inferenceTimeout': inferenceTimeout!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ClientSecretCredentials
/// - vmmigration:v1alpha1 : ClientSecretCredentials
class $ClientSecretCredentials {
  /// Azure client ID.
  core.String? clientId;

  /// Input only.
  ///
  /// Azure client secret.
  core.String? clientSecret;

  /// Azure tenant ID.
  core.String? tenantId;

  $ClientSecretCredentials({this.clientId, this.clientSecret, this.tenantId});

  $ClientSecretCredentials.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        clientSecret: json_['clientSecret'] as core.String?,
        tenantId: json_['tenantId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (tenantId != null) 'tenantId': tenantId!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : ClientUser
/// - authorizedbuyersmarketplace:v1alpha : ClientUser
class $ClientUser {
  /// The client user's email address that has to be unique across all users for
  /// the same client.
  ///
  /// Required.
  core.String? email;

  /// The resource name of the client user.
  ///
  /// Format: `buyers/{accountId}/clients/{clientAccountId}/users/{userId}`
  ///
  /// Output only.
  core.String? name;

  /// The state of the client user.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : A placeholder for an undefined user state.
  /// - "INVITED" : A user who was created but hasn't accepted the invitation
  /// yet, not allowed to access the Authorized Buyers UI.
  /// - "ACTIVE" : A user that is currently active and allowed to access the
  /// Authorized Buyers UI.
  /// - "INACTIVE" : A user that is currently inactive and not allowed to access
  /// the Authorized Buyers UI.
  core.String? state;

  $ClientUser({this.email, this.name, this.state});

  $ClientUser.fromJson(core.Map json_)
    : this(
        email: json_['email'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : CloneAddressGroupItemsRequest
/// - networksecurity:v1beta1 : CloneAddressGroupItemsRequest
class $CloneAddressGroupItemsRequest {
  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes since the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// Source address group to clone items from.
  ///
  /// Required.
  core.String? sourceAddressGroup;

  $CloneAddressGroupItemsRequest({this.requestId, this.sourceAddressGroup});

  $CloneAddressGroupItemsRequest.fromJson(core.Map json_)
    : this(
        requestId: json_['requestId'] as core.String?,
        sourceAddressGroup: json_['sourceAddressGroup'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
    if (sourceAddressGroup != null) 'sourceAddressGroup': sourceAddressGroup!,
  };
}

/// Used by:
///
/// - appengine:v1 : CloudBuildOptions
/// - appengine:v1beta : CloudBuildOptions
class $CloudBuildOptions {
  /// Path to the yaml file used in deployment, used to determine runtime
  /// configuration details.Required for flexible environment builds.See
  /// https://cloud.google.com/appengine/docs/standard/python/config/appref for
  /// more details.
  core.String? appYamlPath;

  /// The Cloud Build timeout used as part of any dependent builds performed by
  /// version creation.
  ///
  /// Defaults to 10 minutes.
  core.String? cloudBuildTimeout;

  $CloudBuildOptions({this.appYamlPath, this.cloudBuildTimeout});

  $CloudBuildOptions.fromJson(core.Map json_)
    : this(
        appYamlPath: json_['appYamlPath'] as core.String?,
        cloudBuildTimeout: json_['cloudBuildTimeout'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appYamlPath != null) 'appYamlPath': appYamlPath!,
    if (cloudBuildTimeout != null) 'cloudBuildTimeout': cloudBuildTimeout!,
  };
}

/// Used by:
///
/// - composer:v1 : CloudDataLineageIntegration
/// - composer:v1beta1 : CloudDataLineageIntegration
class $CloudDataLineageIntegration {
  /// Whether or not Cloud Data Lineage integration is enabled.
  ///
  /// Optional.
  core.bool? enabled;

  $CloudDataLineageIntegration({this.enabled});

  $CloudDataLineageIntegration.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : CloudFunctionEndpoint
/// - networkmanagement:v1beta1 : CloudFunctionEndpoint
class $CloudFunctionEndpoint {
  /// A [Cloud Function](https://cloud.google.com/functions) name.
  core.String? uri;

  $CloudFunctionEndpoint({this.uri});

  $CloudFunctionEndpoint.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : CloudFunctionInfo
/// - networkmanagement:v1beta1 : CloudFunctionInfo
class $CloudFunctionInfo {
  /// Name of a Cloud Function.
  core.String? displayName;

  /// Location in which the Cloud Function is deployed.
  core.String? location;

  /// URI of a Cloud Function.
  core.String? uri;

  /// Latest successfully deployed version id of the Cloud Function.
  core.String? versionId;

  $CloudFunctionInfo({
    this.displayName,
    this.location,
    this.uri,
    this.versionId,
  });

  $CloudFunctionInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        location: json_['location'] as core.String?,
        uri: json_['uri'] as core.String?,
        versionId: json_['versionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (location != null) 'location': location!,
    if (uri != null) 'uri': uri!,
    if (versionId != null) 'versionId': versionId!,
  };
}

/// Used by:
///
/// - container:v1 : CloudRunConfig
/// - container:v1beta1 : CloudRunConfig
class $CloudRunConfig {
  /// Whether Cloud Run addon is enabled for this cluster.
  core.bool? disabled;

  /// Which load balancer type is installed for Cloud Run.
  /// Possible string values are:
  /// - "LOAD_BALANCER_TYPE_UNSPECIFIED" : Load balancer type for Cloud Run is
  /// unspecified.
  /// - "LOAD_BALANCER_TYPE_EXTERNAL" : Install external load balancer for Cloud
  /// Run.
  /// - "LOAD_BALANCER_TYPE_INTERNAL" : Install internal load balancer for Cloud
  /// Run.
  core.String? loadBalancerType;

  $CloudRunConfig({this.disabled, this.loadBalancerType});

  $CloudRunConfig.fromJson(core.Map json_)
    : this(
        disabled: json_['disabled'] as core.bool?,
        loadBalancerType: json_['loadBalancerType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
    if (loadBalancerType != null) 'loadBalancerType': loadBalancerType!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : CloudRunRevisionEndpoint
/// - networkmanagement:v1beta1 : CloudRunRevisionEndpoint
class $CloudRunRevisionEndpoint {
  /// The URI of the Cloud Run service that the revision belongs to.
  ///
  /// The format is: projects/{project}/locations/{location}/services/{service}
  ///
  /// Output only.
  core.String? serviceUri;

  /// A [Cloud Run](https://cloud.google.com/run)
  /// [revision](https://cloud.google.com/run/docs/reference/rest/v1/namespaces.revisions/get)
  /// URI.
  ///
  /// The format is:
  /// projects/{project}/locations/{location}/revisions/{revision}
  core.String? uri;

  $CloudRunRevisionEndpoint({this.serviceUri, this.uri});

  $CloudRunRevisionEndpoint.fromJson(core.Map json_)
    : this(
        serviceUri: json_['serviceUri'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceUri != null) 'serviceUri': serviceUri!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : CloudRunRevisionInfo
/// - networkmanagement:v1beta1 : CloudRunRevisionInfo
class $CloudRunRevisionInfo {
  /// Name of a Cloud Run revision.
  core.String? displayName;

  /// Location in which this revision is deployed.
  core.String? location;

  /// URI of Cloud Run service this revision belongs to.
  core.String? serviceUri;

  /// URI of a Cloud Run revision.
  core.String? uri;

  $CloudRunRevisionInfo({
    this.displayName,
    this.location,
    this.serviceUri,
    this.uri,
  });

  $CloudRunRevisionInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        location: json_['location'] as core.String?,
        serviceUri: json_['serviceUri'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (location != null) 'location': location!,
    if (serviceUri != null) 'serviceUri': serviceUri!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - alloydb:v1 : CloudSQLBackupRunSource
/// - alloydb:v1alpha : CloudSQLBackupRunSource
/// - alloydb:v1beta : CloudSQLBackupRunSource
class $CloudSQLBackupRunSource {
  /// The CloudSQL backup run ID.
  ///
  /// Required.
  core.String? backupRunId;

  /// The CloudSQL instance ID.
  ///
  /// Required.
  core.String? instanceId;

  /// The project ID of the source CloudSQL instance.
  ///
  /// This should be the same as the AlloyDB cluster's project.
  core.String? project;

  $CloudSQLBackupRunSource({this.backupRunId, this.instanceId, this.project});

  $CloudSQLBackupRunSource.fromJson(core.Map json_)
    : this(
        backupRunId: json_['backupRunId'] as core.String?,
        instanceId: json_['instanceId'] as core.String?,
        project: json_['project'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupRunId != null) 'backupRunId': backupRunId!,
    if (instanceId != null) 'instanceId': instanceId!,
    if (project != null) 'project': project!,
  };
}

/// Used by:
///
/// - metastore:v1 : CloudSQLConnectionConfig
/// - metastore:v1alpha : CloudSQLConnectionConfig
/// - metastore:v1beta : CloudSQLConnectionConfig
class $CloudSQLConnectionConfig {
  /// The hive database name.
  ///
  /// Required.
  core.String? hiveDatabaseName;

  /// Cloud SQL database connection name (project_id:region:instance_name)
  ///
  /// Required.
  core.String? instanceConnectionName;

  /// The private IP address of the Cloud SQL instance.
  ///
  /// Required.
  core.String? ipAddress;

  /// The relative resource name of the subnetwork to be used for Private
  /// Service Connect.
  ///
  /// Note that this cannot be a regular subnet and is used only for NAT.
  /// (https://cloud.google.com/vpc/docs/about-vpc-hosted-services#psc-subnets)
  /// This subnet is used to publish the SOCKS5 proxy service. The subnet size
  /// must be at least /29 and it should reside in a network through which the
  /// Cloud SQL instance is accessible. The resource name should be in the
  /// format,
  /// projects/{project_id}/regions/{region_id}/subnetworks/{subnetwork_id}
  ///
  /// Required.
  core.String? natSubnet;

  /// Input only.
  ///
  /// The password for the user that Dataproc Metastore service will be using to
  /// connect to the database. This field is not returned on request.
  ///
  /// Required.
  core.String? password;

  /// The network port of the database.
  ///
  /// Required.
  core.int? port;

  /// The relative resource name of the subnetwork to deploy the SOCKS5 proxy
  /// service in.
  ///
  /// The subnetwork should reside in a network through which the Cloud SQL
  /// instance is accessible. The resource name should be in the format,
  /// projects/{project_id}/regions/{region_id}/subnetworks/{subnetwork_id}
  ///
  /// Required.
  core.String? proxySubnet;

  /// The username that Dataproc Metastore service will use to connect to the
  /// database.
  ///
  /// Required.
  core.String? username;

  $CloudSQLConnectionConfig({
    this.hiveDatabaseName,
    this.instanceConnectionName,
    this.ipAddress,
    this.natSubnet,
    this.password,
    this.port,
    this.proxySubnet,
    this.username,
  });

  $CloudSQLConnectionConfig.fromJson(core.Map json_)
    : this(
        hiveDatabaseName: json_['hiveDatabaseName'] as core.String?,
        instanceConnectionName: json_['instanceConnectionName'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        natSubnet: json_['natSubnet'] as core.String?,
        password: json_['password'] as core.String?,
        port: json_['port'] as core.int?,
        proxySubnet: json_['proxySubnet'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hiveDatabaseName != null) 'hiveDatabaseName': hiveDatabaseName!,
    if (instanceConnectionName != null)
      'instanceConnectionName': instanceConnectionName!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (natSubnet != null) 'natSubnet': natSubnet!,
    if (password != null) 'password': password!,
    if (port != null) 'port': port!,
    if (proxySubnet != null) 'proxySubnet': proxySubnet!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : CloudSQLInstanceInfo
/// - networkmanagement:v1beta1 : CloudSQLInstanceInfo
class $CloudSQLInstanceInfo {
  /// Name of a Cloud SQL instance.
  core.String? displayName;

  /// External IP address of a Cloud SQL instance.
  core.String? externalIp;

  /// Internal IP address of a Cloud SQL instance.
  core.String? internalIp;

  /// URI of a Cloud SQL instance network or empty string if the instance does
  /// not have one.
  core.String? networkUri;

  /// Region in which the Cloud SQL instance is running.
  core.String? region;

  /// URI of a Cloud SQL instance.
  core.String? uri;

  $CloudSQLInstanceInfo({
    this.displayName,
    this.externalIp,
    this.internalIp,
    this.networkUri,
    this.region,
    this.uri,
  });

  $CloudSQLInstanceInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        externalIp: json_['externalIp'] as core.String?,
        internalIp: json_['internalIp'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        region: json_['region'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (externalIp != null) 'externalIp': externalIp!,
    if (internalIp != null) 'internalIp': internalIp!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (region != null) 'region': region!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoCloudSchedulerConfig
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaCloudSchedulerConfig
class $CloudSchedulerConfig {
  /// The cron tab of cloud scheduler trigger.
  ///
  /// Required.
  core.String? cronTab;

  /// When the job was deleted from Pantheon UI, error_message will be populated
  /// when Get/List integrations
  ///
  /// Optional.
  core.String? errorMessage;

  /// The location where associated cloud scheduler job will be created
  ///
  /// Required.
  core.String? location;

  /// Service account used by Cloud Scheduler to trigger the integration at
  /// scheduled time
  ///
  /// Required.
  core.String? serviceAccountEmail;

  $CloudSchedulerConfig({
    this.cronTab,
    this.errorMessage,
    this.location,
    this.serviceAccountEmail,
  });

  $CloudSchedulerConfig.fromJson(core.Map json_)
    : this(
        cronTab: json_['cronTab'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
        location: json_['location'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cronTab != null) 'cronTab': cronTab!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (location != null) 'location': location!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - bigqueryconnection:v1 : CloudSqlCredential
/// - bigqueryconnection:v1beta1 : CloudSqlCredential
class $CloudSqlCredential {
  /// The password for the credential.
  core.String? password;

  /// The username for the credential.
  core.String? username;

  $CloudSqlCredential({this.password, this.username});

  $CloudSqlCredential.fromJson(core.Map json_)
    : this(
        password: json_['password'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : CloudSqlInstance
/// - firebasedataconnect:v1beta : CloudSqlInstance
class $CloudSqlInstance {
  /// Name of the CloudSQL instance, in the format: ```
  /// projects/{project}/locations/{location}/instances/{instance} ```
  ///
  /// Required.
  core.String? instance;

  $CloudSqlInstance({this.instance});

  $CloudSqlInstance.fromJson(core.Map json_)
    : this(instance: json_['instance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CloudSqlSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCloudSqlSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCloudSqlSource
class $CloudSqlSource {
  /// The Cloud SQL database to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? databaseId;

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters.
  ///
  /// Can be specified if one wants to have the Cloud SQL export to a specific
  /// Cloud Storage directory. Ensure that the Cloud SQL service account has the
  /// necessary Cloud Storage Admin permissions to access the specified Cloud
  /// Storage directory.
  core.String? gcsStagingDir;

  /// The Cloud SQL instance to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? instanceId;

  /// Option for serverless export.
  ///
  /// Enabling this option will incur additional cost. More info can be found
  /// [here](https://cloud.google.com/sql/pricing#serverless).
  core.bool? offload;

  /// The project ID that contains the Cloud SQL source.
  ///
  /// Has a length limit of 128 characters. If not specified, inherits the
  /// project ID from the parent request.
  core.String? projectId;

  /// The Cloud SQL table to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? tableId;

  $CloudSqlSource({
    this.databaseId,
    this.gcsStagingDir,
    this.instanceId,
    this.offload,
    this.projectId,
    this.tableId,
  });

  $CloudSqlSource.fromJson(core.Map json_)
    : this(
        databaseId: json_['databaseId'] as core.String?,
        gcsStagingDir: json_['gcsStagingDir'] as core.String?,
        instanceId: json_['instanceId'] as core.String?,
        offload: json_['offload'] as core.bool?,
        projectId: json_['projectId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseId != null) 'databaseId': databaseId!,
    if (gcsStagingDir != null) 'gcsStagingDir': gcsStagingDir!,
    if (instanceId != null) 'instanceId': instanceId!,
    if (offload != null) 'offload': offload!,
    if (projectId != null) 'projectId': projectId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// Used by:
///
/// - redis:v1 : ClusterMaintenanceSchedule
/// - redis:v1beta1 : ClusterMaintenanceSchedule
class $ClusterMaintenanceSchedule {
  /// The end time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? endTime;

  /// The start time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? startTime;

  $ClusterMaintenanceSchedule({this.endTime, this.startTime});

  $ClusterMaintenanceSchedule.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminClusterOperationsConfig
/// - gkeonprem:v1 : BareMetalClusterOperationsConfig
class $ClusterOperationsConfig {
  /// Whether collection of application logs/metrics should be enabled (in
  /// addition to system logs/metrics).
  core.bool? enableApplicationLogs;

  $ClusterOperationsConfig({this.enableApplicationLogs});

  $ClusterOperationsConfig.fromJson(core.Map json_)
    : this(enableApplicationLogs: json_['enableApplicationLogs'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableApplicationLogs != null)
      'enableApplicationLogs': enableApplicationLogs!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ClusterUpgradeGKEUpgrade
/// - gkehub:v1alpha : ClusterUpgradeGKEUpgrade
/// - gkehub:v1beta : ClusterUpgradeGKEUpgrade
class $ClusterUpgradeGKEUpgrade00 {
  /// Name of the upgrade, e.g., "k8s_control_plane".
  ///
  /// It should be a valid upgrade name. It must not exceet 99 characters.
  core.String? name;

  /// Version of the upgrade, e.g., "1.22.1-gke.100".
  ///
  /// It should be a valid version. It must not exceet 99 characters.
  core.String? version;

  $ClusterUpgradeGKEUpgrade00({this.name, this.version});

  $ClusterUpgradeGKEUpgrade00.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ClusterUpgradeGKEUpgrade
/// - gkehub:v2alpha : ClusterUpgradeGKEUpgrade
/// - gkehub:v2beta : ClusterUpgradeGKEUpgrade
class $ClusterUpgradeGKEUpgrade01 {
  /// Name of the upgrade, e.g., "k8s_control_plane".
  core.String? name;

  /// Version of the upgrade, e.g., "1.22.1-gke.100".
  core.String? version;

  $ClusterUpgradeGKEUpgrade01({this.name, this.version});

  $ClusterUpgradeGKEUpgrade01.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ClusterUpgradeGKEUpgradeFeatureCondition
/// - gkehub:v1alpha : ClusterUpgradeGKEUpgradeFeatureCondition
/// - gkehub:v1beta : ClusterUpgradeGKEUpgradeFeatureCondition
class $ClusterUpgradeGKEUpgradeFeatureCondition {
  /// Reason why the feature is in this status.
  core.String? reason;

  /// Status of the condition, one of True, False, Unknown.
  core.String? status;

  /// Type of the condition, for example, "ready".
  core.String? type;

  /// Last timestamp the condition was updated.
  core.String? updateTime;

  $ClusterUpgradeGKEUpgradeFeatureCondition({
    this.reason,
    this.status,
    this.type,
    this.updateTime,
  });

  $ClusterUpgradeGKEUpgradeFeatureCondition.fromJson(core.Map json_)
    : this(
        reason: json_['reason'] as core.String?,
        status: json_['status'] as core.String?,
        type: json_['type'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (reason != null) 'reason': reason!,
    if (status != null) 'status': status!,
    if (type != null) 'type': type!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ClusterUpgradeIgnoredMembership
/// - gkehub:v1alpha : ClusterUpgradeIgnoredMembership
/// - gkehub:v1beta : ClusterUpgradeIgnoredMembership
/// - gkehub:v2 : ClusterUpgradeIgnoredMembership
/// - gkehub:v2alpha : ClusterUpgradeIgnoredMembership
/// - gkehub:v2beta : ClusterUpgradeIgnoredMembership
class $ClusterUpgradeIgnoredMembership {
  /// Time when the membership was first set to ignored.
  core.String? ignoredTime;

  /// Reason why the membership is ignored.
  core.String? reason;

  $ClusterUpgradeIgnoredMembership({this.ignoredTime, this.reason});

  $ClusterUpgradeIgnoredMembership.fromJson(core.Map json_)
    : this(
        ignoredTime: json_['ignoredTime'] as core.String?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ignoredTime != null) 'ignoredTime': ignoredTime!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ClusterUpgradePostConditions
/// - gkehub:v1alpha : ClusterUpgradePostConditions
/// - gkehub:v1beta : ClusterUpgradePostConditions
class $ClusterUpgradePostConditions {
  /// Amount of time to "soak" after a rollout has been finished before marking
  /// it COMPLETE.
  ///
  /// Cannot exceed 30 days. Required.
  ///
  /// Required.
  core.String? soaking;

  $ClusterUpgradePostConditions({this.soaking});

  $ClusterUpgradePostConditions.fromJson(core.Map json_)
    : this(soaking: json_['soaking'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (soaking != null) 'soaking': soaking!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ClusterUpgradeUpgradeStatus
/// - gkehub:v1alpha : ClusterUpgradeUpgradeStatus
/// - gkehub:v1beta : ClusterUpgradeUpgradeStatus
/// - gkehub:v2 : ClusterUpgradeUpgradeStatus
/// - gkehub:v2alpha : ClusterUpgradeUpgradeStatus
/// - gkehub:v2beta : ClusterUpgradeUpgradeStatus
class $ClusterUpgradeUpgradeStatus {
  /// Status code of the upgrade.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Required by https://linter.aip.dev/126/unspecified.
  /// - "INELIGIBLE" : The upgrade is ineligible. At the scope level, this means
  /// the upgrade is ineligible for all the clusters in the scope.
  /// - "PENDING" : The upgrade is pending. At the scope level, this means the
  /// upgrade is pending for all the clusters in the scope.
  /// - "IN_PROGRESS" : The upgrade is in progress. At the scope level, this
  /// means the upgrade is in progress for at least one cluster in the scope.
  /// - "SOAKING" : The upgrade has finished and is soaking until the soaking
  /// time is up. At the scope level, this means at least one cluster is in
  /// soaking while the rest are either soaking or complete.
  /// - "FORCED_SOAKING" : A cluster will be forced to enter soaking if an
  /// upgrade doesn't finish within a certain limit, despite it's actual status.
  /// - "COMPLETE" : The upgrade has passed all post conditions (soaking). At
  /// the scope level, this means all eligible clusters are in COMPLETE status.
  /// - "FORCED_COMPLETE" : The upgrade was forced into soaking and the soaking
  /// time has passed. This is the equivalent of COMPLETE status for upgrades
  /// that were forced into soaking.
  core.String? code;

  /// Reason for this status.
  core.String? reason;

  /// Last timestamp the status was updated.
  core.String? updateTime;

  $ClusterUpgradeUpgradeStatus({this.code, this.reason, this.updateTime});

  $ClusterUpgradeUpgradeStatus.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        reason: json_['reason'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (reason != null) 'reason': reason!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CmHybridConfig
/// - displayvideo:v3 : CmHybridConfig
/// - displayvideo:v4 : CmHybridConfig
class $CmHybridConfig {
  /// Account ID of the CM360 Floodlight configuration linked with the DV360
  /// advertiser.
  ///
  /// Required. Immutable.
  core.String? cmAccountId;

  /// The set of CM360 Advertiser IDs sharing the CM360 Floodlight
  /// configuration.
  ///
  /// Output only.
  core.List<core.String>? cmAdvertiserIds;

  /// ID of the CM360 Floodlight configuration linked with the DV360 advertiser.
  ///
  /// Required. Immutable.
  core.String? cmFloodlightConfigId;

  /// By setting this field to `true`, you, on behalf of your company, authorize
  /// the sharing of information from the given Floodlight configuration to this
  /// Display & Video 360 advertiser.
  ///
  /// Required. Immutable.
  core.bool? cmFloodlightLinkingAuthorized;

  /// A list of CM360 sites whose placements will be synced to DV360 as
  /// creatives.
  ///
  /// If absent or empty in CreateAdvertiser method, the system will
  /// automatically create a CM360 site. Removing sites from this list may cause
  /// DV360 creatives synced from CM360 to be deleted. At least one site must be
  /// specified.
  core.List<core.String>? cmSyncableSiteIds;

  /// Whether or not to report DV360 cost to CM360.
  core.bool? dv360ToCmCostReportingEnabled;

  /// Whether or not to include DV360 data in CM360 data transfer reports.
  core.bool? dv360ToCmDataSharingEnabled;

  $CmHybridConfig({
    this.cmAccountId,
    this.cmAdvertiserIds,
    this.cmFloodlightConfigId,
    this.cmFloodlightLinkingAuthorized,
    this.cmSyncableSiteIds,
    this.dv360ToCmCostReportingEnabled,
    this.dv360ToCmDataSharingEnabled,
  });

  $CmHybridConfig.fromJson(core.Map json_)
    : this(
        cmAccountId: json_['cmAccountId'] as core.String?,
        cmAdvertiserIds:
            (json_['cmAdvertiserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        cmFloodlightConfigId: json_['cmFloodlightConfigId'] as core.String?,
        cmFloodlightLinkingAuthorized:
            json_['cmFloodlightLinkingAuthorized'] as core.bool?,
        cmSyncableSiteIds:
            (json_['cmSyncableSiteIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        dv360ToCmCostReportingEnabled:
            json_['dv360ToCmCostReportingEnabled'] as core.bool?,
        dv360ToCmDataSharingEnabled:
            json_['dv360ToCmDataSharingEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cmAccountId != null) 'cmAccountId': cmAccountId!,
    if (cmAdvertiserIds != null) 'cmAdvertiserIds': cmAdvertiserIds!,
    if (cmFloodlightConfigId != null)
      'cmFloodlightConfigId': cmFloodlightConfigId!,
    if (cmFloodlightLinkingAuthorized != null)
      'cmFloodlightLinkingAuthorized': cmFloodlightLinkingAuthorized!,
    if (cmSyncableSiteIds != null) 'cmSyncableSiteIds': cmSyncableSiteIds!,
    if (dv360ToCmCostReportingEnabled != null)
      'dv360ToCmCostReportingEnabled': dv360ToCmCostReportingEnabled!,
    if (dv360ToCmDataSharingEnabled != null)
      'dv360ToCmDataSharingEnabled': dv360ToCmDataSharingEnabled!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CmTrackingAd
/// - displayvideo:v3 : CmTrackingAd
/// - displayvideo:v4 : CmTrackingAd
class $CmTrackingAd {
  /// The ad ID of the campaign manager 360 tracking Ad.
  ///
  /// Optional.
  core.String? cmAdId;

  /// The creative ID of the campaign manager 360 tracking Ad.
  ///
  /// Optional.
  core.String? cmCreativeId;

  /// The placement ID of the campaign manager 360 tracking Ad.
  ///
  /// Optional.
  core.String? cmPlacementId;

  $CmTrackingAd({this.cmAdId, this.cmCreativeId, this.cmPlacementId});

  $CmTrackingAd.fromJson(core.Map json_)
    : this(
        cmAdId: json_['cmAdId'] as core.String?,
        cmCreativeId: json_['cmCreativeId'] as core.String?,
        cmPlacementId: json_['cmPlacementId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cmAdId != null) 'cmAdId': cmAdId!,
    if (cmCreativeId != null) 'cmCreativeId': cmCreativeId!,
    if (cmPlacementId != null) 'cmPlacementId': cmPlacementId!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : CmekConfig
/// - cloudtasks:v2beta2 : CmekConfig
/// - cloudtasks:v2beta3 : CmekConfig
class $CmekConfig {
  /// Resource name of the Cloud KMS key, of the form
  /// `projects/PROJECT_ID/locations/LOCATION_ID/keyRings/KEY_RING_ID/cryptoKeys/KEY_ID`,
  /// that will be used to encrypt the Queues & Tasks in the region.
  ///
  /// Setting this as blank will turn off CMEK encryption.
  core.String? kmsKey;

  /// The config resource name which includes the project and location and must
  /// end in 'cmekConfig', in the format
  /// projects/PROJECT_ID/locations/LOCATION_ID/cmekConfig\`
  ///
  /// Output only.
  core.String? name;

  $CmekConfig({this.kmsKey, this.name});

  $CmekConfig.fromJson(core.Map json_)
    : this(
        kmsKey: json_['kmsKey'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CodeExecutionResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CodeExecutionResult
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1AssistantContentCodeExecutionResult
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAssistantContentCodeExecutionResult
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAssistantContentCodeExecutionResult
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1CodeExecutionResult
class $CodeExecutionResult {
  /// Outcome of the code execution.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OUTCOME_UNSPECIFIED" : Unspecified status. This value should not be
  /// used.
  /// - "OUTCOME_OK" : Code execution completed successfully.
  /// - "OUTCOME_FAILED" : Code execution finished but with a failure. `stderr`
  /// should contain the reason.
  /// - "OUTCOME_DEADLINE_EXCEEDED" : Code execution ran for too long, and was
  /// cancelled. There may or may not be a partial output present.
  core.String? outcome;

  /// Contains stdout when code execution is successful, stderr or other
  /// description otherwise.
  ///
  /// Optional.
  core.String? output;

  $CodeExecutionResult({this.outcome, this.output});

  $CodeExecutionResult.fromJson(core.Map json_)
    : this(
        outcome: json_['outcome'] as core.String?,
        output: json_['output'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (outcome != null) 'outcome': outcome!,
    if (output != null) 'output': output!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : Codebase
/// - firebaseapphosting:v1beta : Codebase
class $Codebase {
  /// The resource name for the Developer Connect
  /// \[`gitRepositoryLink`\](https://cloud.google.com/developer-connect/docs/api/reference/rest/v1/projects.locations.connections.gitRepositoryLinks)
  /// connected to this backend, in the format:
  /// `projects/{project}/locations/{location}/connections/{connection}/gitRepositoryLinks/{repositoryLink}`
  /// The connection for the `gitRepositoryLink` must made be using the Firebase
  /// App Hosting GitHub App via the Firebase Console.
  ///
  /// Required.
  core.String? repository;

  /// If `repository` is provided, the directory relative to the root of the
  /// repository to use as the root for the deployed web app.
  ///
  /// Optional.
  core.String? rootDirectory;

  $Codebase({this.repository, this.rootDirectory});

  $Codebase.fromJson(core.Map json_)
    : this(
        repository: json_['repository'] as core.String?,
        rootDirectory: json_['rootDirectory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (repository != null) 'repository': repository!,
    if (rootDirectory != null) 'rootDirectory': rootDirectory!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CoherenceResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CoherenceResult
class $CoherenceResult {
  /// Confidence for coherence score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for coherence score.
  ///
  /// Output only.
  core.String? explanation;

  /// Coherence score.
  ///
  /// Output only.
  core.double? score;

  $CoherenceResult({this.confidence, this.explanation, this.score});

  $CoherenceResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ColabImage
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ColabImage
class $ColabImage {
  /// A human-readable description of the specified colab image release,
  /// populated by the system.
  ///
  /// Example: "Python 3.10", "Latest - current Python 3.11"
  ///
  /// Output only.
  core.String? description;

  /// The release name of the NotebookRuntime Colab image, e.g. "py310".
  ///
  /// If not specified, detault to the latest release.
  ///
  /// Optional.
  core.String? releaseName;

  $ColabImage({this.description, this.releaseName});

  $ColabImage.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        releaseName: json_['releaseName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (releaseName != null) 'releaseName': releaseName!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CollectUserEventRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaCollectUserEventRequest
/// - retail:v2beta : GoogleCloudRetailV2betaCollectUserEventRequest
class $CollectUserEventRequest {
  /// The event timestamp in milliseconds.
  ///
  /// This prevents browser caching of otherwise identical get requests. The
  /// name is abbreviated to reduce the payload bytes.
  core.String? ets;

  /// The prebuilt rule name that can convert a specific type of raw_json.
  ///
  /// For example: "ga4_bq" rule for the GA4 user event schema.
  core.String? prebuiltRule;

  /// An arbitrary serialized JSON string that contains necessary information
  /// that can comprise a user event.
  ///
  /// When this field is specified, the user_event field will be ignored. Note:
  /// line-delimited JSON is not supported, a single JSON only.
  core.String? rawJson;

  /// The URL including cgi-parameters but excluding the hash fragment with a
  /// length limit of 5,000 characters.
  ///
  /// This is often more useful than the referer URL, because many browsers only
  /// send the domain for 3rd party requests.
  core.String? uri;

  /// URL encoded UserEvent proto with a length limit of 2,000,000 characters.
  ///
  /// Required.
  core.String? userEvent;

  $CollectUserEventRequest({
    this.ets,
    this.prebuiltRule,
    this.rawJson,
    this.uri,
    this.userEvent,
  });

  $CollectUserEventRequest.fromJson(core.Map json_)
    : this(
        ets: json_['ets'] as core.String?,
        prebuiltRule: json_['prebuiltRule'] as core.String?,
        rawJson: json_['rawJson'] as core.String?,
        uri: json_['uri'] as core.String?,
        userEvent: json_['userEvent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ets != null) 'ets': ets!,
    if (prebuiltRule != null) 'prebuiltRule': prebuiltRule!,
    if (rawJson != null) 'rawJson': rawJson!,
    if (uri != null) 'uri': uri!,
    if (userEvent != null) 'userEvent': userEvent!,
  };
}

/// Used by:
///
/// - firestore:v1 : CollectionSelector
/// - firestore:v1beta1 : CollectionSelector
class $CollectionSelector {
  /// When false, selects only collections that are immediate children of the
  /// `parent` specified in the containing `RunQueryRequest`.
  ///
  /// When true, selects all descendant collections.
  core.bool? allDescendants;

  /// The collection ID.
  ///
  /// When set, selects only collections with this ID.
  core.String? collectionId;

  $CollectionSelector({this.allDescendants, this.collectionId});

  $CollectionSelector.fromJson(core.Map json_)
    : this(
        allDescendants: json_['allDescendants'] as core.bool?,
        collectionId: json_['collectionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allDescendants != null) 'allDescendants': allDescendants!,
    if (collectionId != null) 'collectionId': collectionId!,
  };
}

/// Used by:
///
/// - airquality:v1 : Color
/// - chat:v1 : Color
/// - contentwarehouse:v1 : GoogleTypeColor
/// - documentai:v1 : GoogleTypeColor
/// - documentai:v1beta3 : GoogleTypeColor
/// - drivelabels:v2 : GoogleTypeColor
/// - drivelabels:v2beta : GoogleTypeColor
/// - fcm:v1 : Color
/// - pollen:v1 : Color
/// - sheets:v4 : Color
/// - vision:v1 : Color
/// - vision:v1p1beta1 : Color
/// - vision:v1p2beta1 : Color
class $Color {
  /// The fraction of this color that should be applied to the pixel.
  ///
  /// That is, the final pixel color is defined by the equation: `pixel color =
  /// alpha * (this color) + (1.0 - alpha) * (background color)` This means that
  /// a value of 1.0 corresponds to a solid color, whereas a value of 0.0
  /// corresponds to a completely transparent color. This uses a wrapper message
  /// rather than a simple float scalar so that it is possible to distinguish
  /// between a default value and the value being unset. If omitted, this color
  /// object is rendered as a solid color (as if the alpha value had been
  /// explicitly given a value of 1.0).
  core.double? alpha;

  /// The amount of blue in the color as a value in the interval \[0, 1\].
  core.double? blue;

  /// The amount of green in the color as a value in the interval \[0, 1\].
  core.double? green;

  /// The amount of red in the color as a value in the interval \[0, 1\].
  core.double? red;

  $Color({this.alpha, this.blue, this.green, this.red});

  $Color.fromJson(core.Map json_)
    : this(
        alpha: (json_['alpha'] as core.num?)?.toDouble(),
        blue: (json_['blue'] as core.num?)?.toDouble(),
        green: (json_['green'] as core.num?)?.toDouble(),
        red: (json_['red'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alpha != null) 'alpha': alpha!,
    if (blue != null) 'blue': blue!,
    if (green != null) 'green': green!,
    if (red != null) 'red': red!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ColorInfo
/// - retail:v2alpha : GoogleCloudRetailV2alphaColorInfo
/// - retail:v2beta : GoogleCloudRetailV2betaColorInfo
class $ColorInfo {
  /// The standard color families.
  ///
  /// Strongly recommended to use the following standard color groups: "Red",
  /// "Pink", "Orange", "Yellow", "Purple", "Green", "Cyan", "Blue", "Brown",
  /// "White", "Gray", "Black" and "Mixed". Normally it is expected to have only
  /// 1 color family. May consider using single "Mixed" instead of multiple
  /// values. A maximum of 5 values are allowed. Each value must be a UTF-8
  /// encoded string with a length limit of 128 characters. Otherwise, an
  /// INVALID_ARGUMENT error is returned. Google Merchant Center property
  /// [color](https://support.google.com/merchants/answer/6324487). Schema.org
  /// property [Product.color](https://schema.org/color). The colorFamilies
  /// field as a system attribute is not a required field but strongly
  /// recommended to be specified. Google Search models treat this field as more
  /// important than a custom product attribute when specified.
  core.List<core.String>? colorFamilies;

  /// The color display names, which may be different from standard color family
  /// names, such as the color aliases used in the website frontend.
  ///
  /// Normally it is expected to have only 1 color. May consider using single
  /// "Mixed" instead of multiple values. A maximum of 75 colors are allowed.
  /// Each value must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned. Google
  /// Merchant Center property
  /// [color](https://support.google.com/merchants/answer/6324487). Schema.org
  /// property [Product.color](https://schema.org/color).
  core.List<core.String>? colors;

  $ColorInfo({this.colorFamilies, this.colors});

  $ColorInfo.fromJson(core.Map json_)
    : this(
        colorFamilies:
            (json_['colorFamilies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        colors:
            (json_['colors'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (colorFamilies != null) 'colorFamilies': colorFamilies!,
    if (colors != null) 'colors': colors!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CombinedAudience
/// - displayvideo:v3 : CombinedAudience
/// - displayvideo:v4 : CombinedAudience
class $CombinedAudience {
  /// The unique ID of the combined audience.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? combinedAudienceId;

  /// The display name of the combined audience.
  ///
  /// .
  ///
  /// Output only.
  core.String? displayName;

  /// The resource name of the combined audience.
  ///
  /// Output only.
  core.String? name;

  $CombinedAudience({this.combinedAudienceId, this.displayName, this.name});

  $CombinedAudience.fromJson(core.Map json_)
    : this(
        combinedAudienceId: json_['combinedAudienceId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (combinedAudienceId != null) 'combinedAudienceId': combinedAudienceId!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CombinedAudienceTargetingSetting
/// - displayvideo:v3 : CombinedAudienceTargetingSetting
/// - displayvideo:v4 : CombinedAudienceTargetingSetting
class $CombinedAudienceTargetingSetting {
  /// Combined audience id of combined audience targeting setting.
  ///
  /// This id is combined_audience_id.
  ///
  /// Required.
  core.String? combinedAudienceId;

  $CombinedAudienceTargetingSetting({this.combinedAudienceId});

  $CombinedAudienceTargetingSetting.fromJson(core.Map json_)
    : this(combinedAudienceId: json_['combinedAudienceId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (combinedAudienceId != null) 'combinedAudienceId': combinedAudienceId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CometResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CometResult
class $CometResult {
  /// Comet score.
  ///
  /// Range depends on version.
  ///
  /// Output only.
  core.double? score;

  $CometResult({this.score});

  $CometResult.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CometSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CometSpec
class $CometSpec {
  /// Source language in BCP-47 format.
  ///
  /// Optional.
  core.String? sourceLanguage;

  /// Target language in BCP-47 format.
  ///
  /// Covers both prediction and reference.
  ///
  /// Optional.
  core.String? targetLanguage;

  /// Which version to use for evaluation.
  ///
  /// Required.
  /// Possible string values are:
  /// - "COMET_VERSION_UNSPECIFIED" : Comet version unspecified.
  /// - "COMET_22_SRC_REF" : Comet 22 for translation + source + reference
  /// (source-reference-combined).
  core.String? version;

  $CometSpec({this.sourceLanguage, this.targetLanguage, this.version});

  $CometSpec.fromJson(core.Map json_)
    : this(
        sourceLanguage: json_['sourceLanguage'] as core.String?,
        targetLanguage: json_['targetLanguage'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceLanguage != null) 'sourceLanguage': sourceLanguage!,
    if (targetLanguage != null) 'targetLanguage': targetLanguage!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Command
/// - containeranalysis:v1beta1 : Command
/// - ondemandscanning:v1 : Command
/// - ondemandscanning:v1beta1 : Command
class $Command {
  /// Command-line arguments used when executing this command.
  core.List<core.String>? args;

  /// Working directory (relative to project source root) used when running this
  /// command.
  core.String? dir;

  /// Environment variables set before running this command.
  core.List<core.String>? env;

  /// Optional unique identifier for this command, used in wait_for to reference
  /// this command as a dependency.
  core.String? id;

  /// Name of the command, as presented on the command line, or if the command
  /// is packaged as a Docker container, as presented to `docker pull`.
  ///
  /// Required.
  core.String? name;

  /// The ID(s) of the command(s) that this command depends on.
  core.List<core.String>? waitFor;

  $Command({this.args, this.dir, this.env, this.id, this.name, this.waitFor});

  $Command.fromJson(core.Map json_)
    : this(
        args:
            (json_['args'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        dir: json_['dir'] as core.String?,
        env:
            (json_['env'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
        waitFor:
            (json_['waitFor'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (dir != null) 'dir': dir!,
    if (env != null) 'env': env!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
    if (waitFor != null) 'waitFor': waitFor!,
  };
}

/// Used by:
///
/// - blogger:v2 : Comment
/// - blogger:v3 : Comment
class $Comment {
  /// The author of this Comment.
  CommentAuthor? author;

  /// Data about the blog containing this comment.
  CommentBlog? blog;

  /// The actual content of the comment.
  ///
  /// May include HTML markup.
  core.String? content;

  /// The identifier for this resource.
  core.String? id;

  /// Data about the comment this is in reply to.
  CommentInReplyTo? inReplyTo;

  /// The kind of this entry.
  ///
  /// Always blogger#comment.
  core.String? kind;

  /// Data about the post containing this comment.
  CommentPost? post;

  /// RFC 3339 date-time when this comment was published.
  core.String? published;

  /// The API REST URL to fetch this resource from.
  core.String? selfLink;

  /// The status of the comment (only populated for admin users).
  /// Possible string values are:
  /// - "LIVE"
  /// - "EMPTIED"
  /// - "PENDING"
  /// - "SPAM"
  core.String? status;

  /// RFC 3339 date-time when this comment was last updated.
  core.String? updated;

  $Comment({
    this.author,
    this.blog,
    this.content,
    this.id,
    this.inReplyTo,
    this.kind,
    this.post,
    this.published,
    this.selfLink,
    this.status,
    this.updated,
  });

  $Comment.fromJson(core.Map json_)
    : this(
        author:
            json_.containsKey('author')
                ? CommentAuthor.fromJson(
                  json_['author'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        blog:
            json_.containsKey('blog')
                ? CommentBlog.fromJson(
                  json_['blog'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        content: json_['content'] as core.String?,
        id: json_['id'] as core.String?,
        inReplyTo:
            json_.containsKey('inReplyTo')
                ? CommentInReplyTo.fromJson(
                  json_['inReplyTo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        kind: json_['kind'] as core.String?,
        post:
            json_.containsKey('post')
                ? CommentPost.fromJson(
                  json_['post'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        published: json_['published'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        updated: json_['updated'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (author != null) 'author': author!,
    if (blog != null) 'blog': blog!,
    if (content != null) 'content': content!,
    if (id != null) 'id': id!,
    if (inReplyTo != null) 'inReplyTo': inReplyTo!,
    if (kind != null) 'kind': kind!,
    if (post != null) 'post': post!,
    if (published != null) 'published': published!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (updated != null) 'updated': updated!,
  };
}

/// Used by:
///
/// - compute:beta : CommitmentResourceStatus
/// - compute:v1 : CommitmentResourceStatus
class $CommitmentResourceStatus {
  /// Indicates the end time of customer's eligibility to send custom term
  /// requests in RFC3339 text format.
  ///
  /// Term extension requests that (not the end time in the request) after this
  /// time will be rejected.
  ///
  /// Output only.
  core.String? customTermEligibilityEndTimestamp;

  $CommitmentResourceStatus({this.customTermEligibilityEndTimestamp});

  $CommitmentResourceStatus.fromJson(core.Map json_)
    : this(
        customTermEligibilityEndTimestamp:
            json_['customTermEligibilityEndTimestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customTermEligibilityEndTimestamp != null)
      'customTermEligibilityEndTimestamp': customTermEligibilityEndTimestamp!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3CompareVersionsRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1CompareVersionsRequest
class $CompareVersionsRequest {
  /// The language to compare the flow versions for.
  ///
  /// If not specified, the agent's default language is used.
  /// [Many languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported. Note: languages must be enabled in the agent before they
  /// can be used.
  core.String? languageCode;

  /// Name of the target flow version to compare with the base version.
  ///
  /// Use version ID `0` to indicate the draft version of the specified flow.
  /// Format: `projects//locations//agents//flows//versions/`.
  ///
  /// Required.
  core.String? targetVersion;

  $CompareVersionsRequest({this.languageCode, this.targetVersion});

  $CompareVersionsRequest.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        targetVersion: json_['targetVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (targetVersion != null) 'targetVersion': targetVersion!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3CompareVersionsResponse
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1CompareVersionsResponse
class $CompareVersionsResponse {
  /// JSON representation of the base version content.
  core.String? baseVersionContentJson;

  /// The timestamp when the two version compares.
  core.String? compareTime;

  /// JSON representation of the target version content.
  core.String? targetVersionContentJson;

  $CompareVersionsResponse({
    this.baseVersionContentJson,
    this.compareTime,
    this.targetVersionContentJson,
  });

  $CompareVersionsResponse.fromJson(core.Map json_)
    : this(
        baseVersionContentJson: json_['baseVersionContentJson'] as core.String?,
        compareTime: json_['compareTime'] as core.String?,
        targetVersionContentJson:
            json_['targetVersionContentJson'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseVersionContentJson != null)
      'baseVersionContentJson': baseVersionContentJson!,
    if (compareTime != null) 'compareTime': compareTime!,
    if (targetVersionContentJson != null)
      'targetVersionContentJson': targetVersionContentJson!,
  };
}

/// Used by:
///
/// - container:v1 : CompleteIPRotationRequest
/// - container:v1beta1 : CompleteIPRotationRequest
class $CompleteIPRotationRequest {
  /// The name of the cluster.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The name (project, location, cluster name) of the cluster to complete IP
  /// rotation.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $CompleteIPRotationRequest({
    this.clusterId,
    this.name,
    this.projectId,
    this.zone,
  });

  $CompleteIPRotationRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CompleteQueryResponseAttributeResult
/// - retail:v2alpha : GoogleCloudRetailV2alphaCompleteQueryResponseAttributeResult
/// - retail:v2beta : GoogleCloudRetailV2betaCompleteQueryResponseAttributeResult
class $CompleteQueryResponseAttributeResult {
  /// The list of suggestions for the attribute.
  core.List<core.String>? suggestions;

  $CompleteQueryResponseAttributeResult({this.suggestions});

  $CompleteQueryResponseAttributeResult.fromJson(core.Map json_)
    : this(
        suggestions:
            (json_['suggestions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (suggestions != null) 'suggestions': suggestions!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CompleteQueryResponseQuerySuggestion
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCompleteQueryResponseQuerySuggestion
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCompleteQueryResponseQuerySuggestion
class $CompleteQueryResponseQuerySuggestion {
  /// The unique document field paths that serve as the source of this
  /// suggestion if it was generated from completable fields.
  ///
  /// This field is only populated for the document-completable model.
  core.List<core.String>? completableFieldPaths;

  /// The suggestion for the query.
  core.String? suggestion;

  $CompleteQueryResponseQuerySuggestion({
    this.completableFieldPaths,
    this.suggestion,
  });

  $CompleteQueryResponseQuerySuggestion.fromJson(core.Map json_)
    : this(
        completableFieldPaths:
            (json_['completableFieldPaths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completableFieldPaths != null)
      'completableFieldPaths': completableFieldPaths!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CompleteQueryResponseRecentSearchResult
/// - retail:v2alpha : GoogleCloudRetailV2alphaCompleteQueryResponseRecentSearchResult
/// - retail:v2beta : GoogleCloudRetailV2betaCompleteQueryResponseRecentSearchResult
class $CompleteQueryResponseRecentSearchResult {
  /// The recent search query.
  core.String? recentSearch;

  $CompleteQueryResponseRecentSearchResult({this.recentSearch});

  $CompleteQueryResponseRecentSearchResult.fromJson(core.Map json_)
    : this(recentSearch: json_['recentSearch'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (recentSearch != null) 'recentSearch': recentSearch!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Completeness
/// - containeranalysis:v1 : SlsaCompleteness
/// - containeranalysis:v1alpha1 : Completeness
/// - containeranalysis:v1alpha1 : SlsaCompleteness
/// - ondemandscanning:v1 : Completeness
/// - ondemandscanning:v1 : SlsaCompleteness
/// - ondemandscanning:v1beta1 : Completeness
/// - ondemandscanning:v1beta1 : SlsaCompleteness
class $Completeness {
  /// If true, the builder claims that recipe.arguments is complete, meaning
  /// that all external inputs are properly captured in the recipe.
  core.bool? arguments;

  /// If true, the builder claims that recipe.environment is claimed to be
  /// complete.
  core.bool? environment;

  /// If true, the builder claims that materials are complete, usually through
  /// some controls to prevent network access.
  ///
  /// Sometimes called "hermetic".
  core.bool? materials;

  $Completeness({this.arguments, this.environment, this.materials});

  $Completeness.fromJson(core.Map json_)
    : this(
        arguments: json_['arguments'] as core.bool?,
        environment: json_['environment'] as core.bool?,
        materials: json_['materials'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (arguments != null) 'arguments': arguments!,
    if (environment != null) 'environment': environment!,
    if (materials != null) 'materials': materials!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CompletionDetail
/// - retail:v2alpha : GoogleCloudRetailV2alphaCompletionDetail
/// - retail:v2beta : GoogleCloudRetailV2betaCompletionDetail
class $CompletionDetail {
  /// Completion attribution token in CompleteQueryResponse.attribution_token.
  core.String? completionAttributionToken;

  /// End user selected CompleteQueryResponse.CompletionResult.suggestion
  /// position, starting from 0.
  core.int? selectedPosition;

  /// End user selected CompleteQueryResponse.CompletionResult.suggestion.
  core.String? selectedSuggestion;

  $CompletionDetail({
    this.completionAttributionToken,
    this.selectedPosition,
    this.selectedSuggestion,
  });

  $CompletionDetail.fromJson(core.Map json_)
    : this(
        completionAttributionToken:
            json_['completionAttributionToken'] as core.String?,
        selectedPosition: json_['selectedPosition'] as core.int?,
        selectedSuggestion: json_['selectedSuggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completionAttributionToken != null)
      'completionAttributionToken': completionAttributionToken!,
    if (selectedPosition != null) 'selectedPosition': selectedPosition!,
    if (selectedSuggestion != null) 'selectedSuggestion': selectedSuggestion!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CompletionInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCompletionInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCompletionInfo
class $CompletionInfo {
  /// End user selected CompleteQueryResponse.QuerySuggestion.suggestion
  /// position, starting from 0.
  core.int? selectedPosition;

  /// End user selected CompleteQueryResponse.QuerySuggestion.suggestion.
  core.String? selectedSuggestion;

  $CompletionInfo({this.selectedPosition, this.selectedSuggestion});

  $CompletionInfo.fromJson(core.Map json_)
    : this(
        selectedPosition: json_['selectedPosition'] as core.int?,
        selectedSuggestion: json_['selectedSuggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (selectedPosition != null) 'selectedPosition': selectedPosition!,
    if (selectedSuggestion != null) 'selectedSuggestion': selectedSuggestion!,
  };
}

/// Used by:
///
/// - jobs:v3 : CompletionResult
/// - jobs:v3p1beta1 : CompletionResult
class $CompletionResult {
  /// The URI of the company image for CompletionType.COMPANY_NAME.
  core.String? imageUri;

  /// The suggestion for the query.
  core.String? suggestion;

  /// The completion topic.
  /// Possible string values are:
  /// - "COMPLETION_TYPE_UNSPECIFIED" : Default value.
  /// - "JOB_TITLE" : Only suggest job titles.
  /// - "COMPANY_NAME" : Only suggest company names.
  /// - "COMBINED" : Suggest both job titles and company names.
  core.String? type;

  $CompletionResult({this.imageUri, this.suggestion, this.type});

  $CompletionResult.fromJson(core.Map json_)
    : this(
        imageUri: json_['imageUri'] as core.String?,
        suggestion: json_['suggestion'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageUri != null) 'imageUri': imageUri!,
    if (suggestion != null) 'suggestion': suggestion!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CompletionStats
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CompletionStats
class $CompletionStats {
  /// The number of entities for which any error was encountered.
  ///
  /// Output only.
  core.String? failedCount;

  /// In cases when enough errors are encountered a job, pipeline, or operation
  /// may be failed as a whole.
  ///
  /// Below is the number of entities for which the processing had not been
  /// finished (either in successful or failed state). Set to -1 if the number
  /// is unknown (for example, the operation failed before the total entity
  /// number could be collected).
  ///
  /// Output only.
  core.String? incompleteCount;

  /// The number of entities that had been processed successfully.
  ///
  /// Output only.
  core.String? successfulCount;

  /// The number of the successful forecast points that are generated by the
  /// forecasting model.
  ///
  /// This is ONLY used by the forecasting batch prediction.
  ///
  /// Output only.
  core.String? successfulForecastPointCount;

  $CompletionStats({
    this.failedCount,
    this.incompleteCount,
    this.successfulCount,
    this.successfulForecastPointCount,
  });

  $CompletionStats.fromJson(core.Map json_)
    : this(
        failedCount: json_['failedCount'] as core.String?,
        incompleteCount: json_['incompleteCount'] as core.String?,
        successfulCount: json_['successfulCount'] as core.String?,
        successfulForecastPointCount:
            json_['successfulForecastPointCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (failedCount != null) 'failedCount': failedCount!,
    if (incompleteCount != null) 'incompleteCount': incompleteCount!,
    if (successfulCount != null) 'successfulCount': successfulCount!,
    if (successfulForecastPointCount != null)
      'successfulForecastPointCount': successfulForecastPointCount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CompletionSuggestion
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCompletionSuggestion
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCompletionSuggestion
class $CompletionSuggestion {
  /// Alternative matching phrases for this suggestion.
  core.List<core.String>? alternativePhrases;

  /// Frequency of this suggestion.
  ///
  /// Will be used to rank suggestions when score is not available.
  core.String? frequency;

  /// Global score of this suggestion.
  ///
  /// Control how this suggestion would be scored / ranked.
  core.double? globalScore;

  /// If two suggestions have the same groupId, they will not be returned
  /// together.
  ///
  /// Instead the one ranked higher will be returned. This can be used to
  /// deduplicate semantically identical suggestions.
  core.String? groupId;

  /// The score of this suggestion within its group.
  core.double? groupScore;

  /// BCP-47 language code of this suggestion.
  core.String? languageCode;

  /// The suggestion text.
  ///
  /// Required.
  core.String? suggestion;

  $CompletionSuggestion({
    this.alternativePhrases,
    this.frequency,
    this.globalScore,
    this.groupId,
    this.groupScore,
    this.languageCode,
    this.suggestion,
  });

  $CompletionSuggestion.fromJson(core.Map json_)
    : this(
        alternativePhrases:
            (json_['alternativePhrases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        frequency: json_['frequency'] as core.String?,
        globalScore: (json_['globalScore'] as core.num?)?.toDouble(),
        groupId: json_['groupId'] as core.String?,
        groupScore: (json_['groupScore'] as core.num?)?.toDouble(),
        languageCode: json_['languageCode'] as core.String?,
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alternativePhrases != null) 'alternativePhrases': alternativePhrases!,
    if (frequency != null) 'frequency': frequency!,
    if (globalScore != null) 'globalScore': globalScore!,
    if (groupId != null) 'groupId': groupId!,
    if (groupScore != null) 'groupScore': groupScore!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Used by:
///
/// - container:v1 : ComplianceStandard
/// - container:v1beta1 : ComplianceStandard
/// - gkehub:v1 : ComplianceStandard
/// - gkehub:v1alpha : ComplianceStandard
/// - gkehub:v1beta : ComplianceStandard
class $ComplianceStandard {
  /// Name of the compliance standard.
  core.String? standard;

  $ComplianceStandard({this.standard});

  $ComplianceStandard.fromJson(core.Map json_)
    : this(standard: json_['standard'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (standard != null) 'standard': standard!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : ComplianceVersion
/// - containeranalysis:v1alpha1 : ComplianceVersion
/// - ondemandscanning:v1 : ComplianceVersion
/// - ondemandscanning:v1beta1 : ComplianceVersion
class $ComplianceVersion {
  /// The name of the document that defines this benchmark, e.g. "CIS
  /// Container-Optimized OS".
  core.String? benchmarkDocument;

  /// The CPE URI (https://cpe.mitre.org/specification/) this benchmark is
  /// applicable to.
  core.String? cpeUri;

  /// The version of the benchmark.
  ///
  /// This is set to the version of the OS-specific CIS document the benchmark
  /// is defined in.
  core.String? version;

  $ComplianceVersion({this.benchmarkDocument, this.cpeUri, this.version});

  $ComplianceVersion.fromJson(core.Map json_)
    : this(
        benchmarkDocument: json_['benchmarkDocument'] as core.String?,
        cpeUri: json_['cpeUri'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (benchmarkDocument != null) 'benchmarkDocument': benchmarkDocument!,
    if (cpeUri != null) 'cpeUri': cpeUri!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - composer:v1 : ComposerWorkloadStatus
/// - composer:v1beta1 : ComposerWorkloadStatus
class $ComposerWorkloadStatus {
  /// Detailed message of the status.
  ///
  /// Output only.
  core.String? detailedStatusMessage;

  /// Workload state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "COMPOSER_WORKLOAD_STATE_UNSPECIFIED" : Not able to determine the status
  /// of the workload.
  /// - "PENDING" : Workload is in pending state and has not yet started.
  /// - "OK" : Workload is running fine.
  /// - "WARNING" : Workload is running but there are some non-critical
  /// problems.
  /// - "ERROR" : Workload is not running due to an error.
  /// - "SUCCEEDED" : Workload has finished execution with success.
  /// - "FAILED" : Workload has finished execution with failure.
  core.String? state;

  /// Text to provide more descriptive status.
  ///
  /// Output only.
  core.String? statusMessage;

  $ComposerWorkloadStatus({
    this.detailedStatusMessage,
    this.state,
    this.statusMessage,
  });

  $ComposerWorkloadStatus.fromJson(core.Map json_)
    : this(
        detailedStatusMessage: json_['detailedStatusMessage'] as core.String?,
        state: json_['state'] as core.String?,
        statusMessage: json_['statusMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (detailedStatusMessage != null)
      'detailedStatusMessage': detailedStatusMessage!,
    if (state != null) 'state': state!,
    if (statusMessage != null) 'statusMessage': statusMessage!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualityRuleRowConditionExpectation
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualityRuleTableConditionExpectation
class $ConditionExpectation {
  /// The SQL expression.
  ///
  /// Optional.
  core.String? sqlExpression;

  $ConditionExpectation({this.sqlExpression});

  $ConditionExpectation.fromJson(core.Map json_)
    : this(sqlExpression: json_['sqlExpression'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sqlExpression != null) 'sqlExpression': sqlExpression!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ConditionQueryTerm
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaConditionQueryTerm
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaConditionQueryTerm
class $ConditionQueryTerm00 {
  /// Whether the search query needs to exactly match the query term.
  core.bool? fullMatch;

  /// The specific query value to match against Must be lowercase, must be
  /// UTF-8.
  ///
  /// Can have at most 3 space separated terms if full_match is true. Cannot be
  /// an empty string. Maximum length of 5000 characters.
  core.String? value;

  $ConditionQueryTerm00({this.fullMatch, this.value});

  $ConditionQueryTerm00.fromJson(core.Map json_)
    : this(
        fullMatch: json_['fullMatch'] as core.bool?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fullMatch != null) 'fullMatch': fullMatch!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ConditionQueryTerm
/// - retail:v2alpha : GoogleCloudRetailV2alphaConditionQueryTerm
/// - retail:v2beta : GoogleCloudRetailV2betaConditionQueryTerm
class $ConditionQueryTerm01 {
  /// Whether this is supposed to be a full or partial match.
  core.bool? fullMatch;

  /// The value of the term to match on.
  ///
  /// Value cannot be empty. Value can have at most 3 terms if specified as a
  /// partial match. Each space separated string is considered as one term. For
  /// example, "a b c" is 3 terms and allowed, but " a b c d" is 4 terms and not
  /// allowed for a partial match.
  core.String? value;

  $ConditionQueryTerm01({this.fullMatch, this.value});

  $ConditionQueryTerm01.fromJson(core.Map json_)
    : this(
        fullMatch: json_['fullMatch'] as core.bool?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fullMatch != null) 'fullMatch': fullMatch!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ConditionTimeRange
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaConditionTimeRange
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaConditionTimeRange
class $ConditionTimeRange00 {
  /// End of time range.
  ///
  /// Range is inclusive. Must be in the future.
  core.String? endTime;

  /// Start of time range.
  ///
  /// Range is inclusive.
  core.String? startTime;

  $ConditionTimeRange00({this.endTime, this.startTime});

  $ConditionTimeRange00.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ConditionTimeRange
/// - retail:v2alpha : GoogleCloudRetailV2alphaConditionTimeRange
/// - retail:v2beta : GoogleCloudRetailV2betaConditionTimeRange
class $ConditionTimeRange01 {
  /// End of time range.
  ///
  /// Range is inclusive.
  core.String? endTime;

  /// Start of time range.
  ///
  /// Range is inclusive.
  core.String? startTime;

  $ConditionTimeRange01({this.endTime, this.startTime});

  $ConditionTimeRange01.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - backupdr:v1 : ConfidentialInstanceConfig
/// - dataproc:v1 : ConfidentialInstanceConfig
class $ConfidentialInstanceConfig00 {
  /// Defines whether the instance should have confidential compute enabled.
  ///
  /// Optional.
  core.bool? enableConfidentialCompute;

  $ConfidentialInstanceConfig00({this.enableConfidentialCompute});

  $ConfidentialInstanceConfig00.fromJson(core.Map json_)
    : this(
        enableConfidentialCompute:
            json_['enableConfidentialCompute'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableConfidentialCompute != null)
      'enableConfidentialCompute': enableConfidentialCompute!,
  };
}

/// Used by:
///
/// - compute:beta : ConfidentialInstanceConfig
/// - compute:v1 : ConfidentialInstanceConfig
class $ConfidentialInstanceConfig01 {
  /// Defines the type of technology used by the confidential instance.
  /// Possible string values are:
  /// - "CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED" : No type specified. Do not use
  /// this value.
  /// - "SEV" : AMD Secure Encrypted Virtualization.
  /// - "SEV_SNP" : AMD Secure Encrypted Virtualization - Secure Nested Paging.
  /// - "TDX" : Intel Trust Domain eXtension.
  core.String? confidentialInstanceType;

  /// Defines whether the instance should have confidential compute enabled.
  core.bool? enableConfidentialCompute;

  $ConfidentialInstanceConfig01({
    this.confidentialInstanceType,
    this.enableConfidentialCompute,
  });

  $ConfidentialInstanceConfig01.fromJson(core.Map json_)
    : this(
        confidentialInstanceType:
            json_['confidentialInstanceType'] as core.String?,
        enableConfidentialCompute:
            json_['enableConfidentialCompute'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidentialInstanceType != null)
      'confidentialInstanceType': confidentialInstanceType!,
    if (enableConfidentialCompute != null)
      'enableConfidentialCompute': enableConfidentialCompute!,
  };
}

/// Used by:
///
/// - container:v1 : ConfidentialNodes
/// - container:v1beta1 : ConfidentialNodes
class $ConfidentialNodes {
  /// Defines the type of technology used by the confidential node.
  /// Possible string values are:
  /// - "CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED" : No type specified. Do not use
  /// this value.
  /// - "SEV" : AMD Secure Encrypted Virtualization.
  /// - "SEV_SNP" : AMD Secure Encrypted Virtualization - Secure Nested Paging.
  /// - "TDX" : Intel Trust Domain eXtension.
  core.String? confidentialInstanceType;

  /// Whether Confidential Nodes feature is enabled.
  core.bool? enabled;

  $ConfidentialNodes({this.confidentialInstanceType, this.enabled});

  $ConfidentialNodes.fromJson(core.Map json_)
    : this(
        confidentialInstanceType:
            json_['confidentialInstanceType'] as core.String?,
        enabled: json_['enabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidentialInstanceType != null)
      'confidentialInstanceType': confidentialInstanceType!,
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : GeminiClusterConfig
/// - alloydb:v1alpha : GeminiInstanceConfig
/// - alloydb:v1beta : GeminiClusterConfig
/// - alloydb:v1beta : GeminiInstanceConfig
class $Config00 {
  /// Deprecated and unused.
  ///
  /// This field will be removed in the near future.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? entitled;

  $Config00({this.entitled});

  $Config00.fromJson(core.Map json_)
    : this(entitled: json_['entitled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (entitled != null) 'entitled': entitled!,
  };
}

/// Used by:
///
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1BoundingPolyConfig
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1PolylineConfig
class $Config01 {
  /// Annotation spec set resource name.
  ///
  /// Required.
  core.String? annotationSpecSet;

  /// Instruction message showed on contributors UI.
  ///
  /// Optional.
  core.String? instructionMessage;

  $Config01({this.annotationSpecSet, this.instructionMessage});

  $Config01.fromJson(core.Map json_)
    : this(
        annotationSpecSet: json_['annotationSpecSet'] as core.String?,
        instructionMessage: json_['instructionMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationSpecSet != null) 'annotationSpecSet': annotationSpecSet!,
    if (instructionMessage != null) 'instructionMessage': instructionMessage!,
  };
}

/// Used by:
///
/// - container:v1 : ConfigConnectorConfig
/// - container:v1beta1 : ConfigConnectorConfig
class $ConfigConnectorConfig {
  /// Whether Cloud Connector is enabled for this cluster.
  core.bool? enabled;

  $ConfigConnectorConfig({this.enabled});

  $ConfigConnectorConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : ConfigFile
/// - deploymentmanager:v2 : ConfigFile
/// - deploymentmanager:v2beta : ConfigFile
class $ConfigFile {
  /// The contents of the file.
  core.String? content;

  $ConfigFile({this.content});

  $ConfigFile.fromJson(core.Map json_)
    : this(content: json_['content'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : ConfigManagementBinauthzConfig
/// - gkehub:v1beta : ConfigManagementBinauthzConfig
/// - gkehub:v2 : ConfigManagementBinauthzConfig
/// - gkehub:v2alpha : ConfigManagementBinauthzConfig
/// - gkehub:v2beta : ConfigManagementBinauthzConfig
class $ConfigManagementBinauthzConfig {
  /// Whether binauthz is enabled in this cluster.
  core.bool? enabled;

  $ConfigManagementBinauthzConfig({this.enabled});

  $ConfigManagementBinauthzConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : ConfigManagementBinauthzVersion
/// - gkehub:v1beta : ConfigManagementBinauthzVersion
/// - gkehub:v2 : ConfigManagementBinauthzVersion
/// - gkehub:v2alpha : ConfigManagementBinauthzVersion
/// - gkehub:v2beta : ConfigManagementBinauthzVersion
class $ConfigManagementBinauthzVersion {
  /// The version of the binauthz webhook.
  core.String? webhookVersion;

  $ConfigManagementBinauthzVersion({this.webhookVersion});

  $ConfigManagementBinauthzVersion.fromJson(core.Map json_)
    : this(webhookVersion: json_['webhookVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (webhookVersion != null) 'webhookVersion': webhookVersion!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementConfigSyncDeploymentState
/// - gkehub:v1alpha : ConfigManagementConfigSyncDeploymentState
/// - gkehub:v1beta : ConfigManagementConfigSyncDeploymentState
class $ConfigManagementConfigSyncDeploymentState00 {
  /// Deployment state of admission-webhook
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? admissionWebhook;

  /// Deployment state of the git-sync pod
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gitSync;

  /// Deployment state of the importer pod
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? importer;

  /// Deployment state of the monitor pod
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? monitor;

  /// Deployment state of otel-collector
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? otelCollector;

  /// Deployment state of reconciler-manager pod
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? reconcilerManager;

  /// Deployment state of resource-group-controller-manager
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? resourceGroupControllerManager;

  /// Deployment state of root-reconciler
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? rootReconciler;

  /// Deployment state of the syncer pod
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? syncer;

  $ConfigManagementConfigSyncDeploymentState00({
    this.admissionWebhook,
    this.gitSync,
    this.importer,
    this.monitor,
    this.otelCollector,
    this.reconcilerManager,
    this.resourceGroupControllerManager,
    this.rootReconciler,
    this.syncer,
  });

  $ConfigManagementConfigSyncDeploymentState00.fromJson(core.Map json_)
    : this(
        admissionWebhook: json_['admissionWebhook'] as core.String?,
        gitSync: json_['gitSync'] as core.String?,
        importer: json_['importer'] as core.String?,
        monitor: json_['monitor'] as core.String?,
        otelCollector: json_['otelCollector'] as core.String?,
        reconcilerManager: json_['reconcilerManager'] as core.String?,
        resourceGroupControllerManager:
            json_['resourceGroupControllerManager'] as core.String?,
        rootReconciler: json_['rootReconciler'] as core.String?,
        syncer: json_['syncer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (admissionWebhook != null) 'admissionWebhook': admissionWebhook!,
    if (gitSync != null) 'gitSync': gitSync!,
    if (importer != null) 'importer': importer!,
    if (monitor != null) 'monitor': monitor!,
    if (otelCollector != null) 'otelCollector': otelCollector!,
    if (reconcilerManager != null) 'reconcilerManager': reconcilerManager!,
    if (resourceGroupControllerManager != null)
      'resourceGroupControllerManager': resourceGroupControllerManager!,
    if (rootReconciler != null) 'rootReconciler': rootReconciler!,
    if (syncer != null) 'syncer': syncer!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementConfigSyncDeploymentState
/// - gkehub:v2alpha : ConfigManagementConfigSyncDeploymentState
/// - gkehub:v2beta : ConfigManagementConfigSyncDeploymentState
class $ConfigManagementConfigSyncDeploymentState01 {
  /// Deployment state of admission-webhook.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? admissionWebhook;

  /// Deployment state of the git-sync pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gitSync;

  /// Deployment state of the importer pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? importer;

  /// Deployment state of the monitor pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? monitor;

  /// Deployment state of otel-collector
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? otelCollector;

  /// Deployment state of reconciler-manager pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? reconcilerManager;

  /// Deployment state of resource-group-controller-manager
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? resourceGroupControllerManager;

  /// Deployment state of root-reconciler.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? rootReconciler;

  /// Deployment state of the syncer pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? syncer;

  $ConfigManagementConfigSyncDeploymentState01({
    this.admissionWebhook,
    this.gitSync,
    this.importer,
    this.monitor,
    this.otelCollector,
    this.reconcilerManager,
    this.resourceGroupControllerManager,
    this.rootReconciler,
    this.syncer,
  });

  $ConfigManagementConfigSyncDeploymentState01.fromJson(core.Map json_)
    : this(
        admissionWebhook: json_['admissionWebhook'] as core.String?,
        gitSync: json_['gitSync'] as core.String?,
        importer: json_['importer'] as core.String?,
        monitor: json_['monitor'] as core.String?,
        otelCollector: json_['otelCollector'] as core.String?,
        reconcilerManager: json_['reconcilerManager'] as core.String?,
        resourceGroupControllerManager:
            json_['resourceGroupControllerManager'] as core.String?,
        rootReconciler: json_['rootReconciler'] as core.String?,
        syncer: json_['syncer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (admissionWebhook != null) 'admissionWebhook': admissionWebhook!,
    if (gitSync != null) 'gitSync': gitSync!,
    if (importer != null) 'importer': importer!,
    if (monitor != null) 'monitor': monitor!,
    if (otelCollector != null) 'otelCollector': otelCollector!,
    if (reconcilerManager != null) 'reconcilerManager': reconcilerManager!,
    if (resourceGroupControllerManager != null)
      'resourceGroupControllerManager': resourceGroupControllerManager!,
    if (rootReconciler != null) 'rootReconciler': rootReconciler!,
    if (syncer != null) 'syncer': syncer!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementConfigSyncVersion
/// - gkehub:v1alpha : ConfigManagementConfigSyncVersion
/// - gkehub:v1beta : ConfigManagementConfigSyncVersion
class $ConfigManagementConfigSyncVersion00 {
  /// Version of the deployed admission-webhook pod
  core.String? admissionWebhook;

  /// Version of the deployed git-sync pod
  core.String? gitSync;

  /// Version of the deployed importer pod
  core.String? importer;

  /// Version of the deployed monitor pod
  core.String? monitor;

  /// Version of the deployed otel-collector pod
  core.String? otelCollector;

  /// Version of the deployed reconciler-manager pod
  core.String? reconcilerManager;

  /// Version of the deployed resource-group-controller-manager pod
  core.String? resourceGroupControllerManager;

  /// Version of the deployed reconciler container in root-reconciler pod
  core.String? rootReconciler;

  /// Version of the deployed syncer pod
  core.String? syncer;

  $ConfigManagementConfigSyncVersion00({
    this.admissionWebhook,
    this.gitSync,
    this.importer,
    this.monitor,
    this.otelCollector,
    this.reconcilerManager,
    this.resourceGroupControllerManager,
    this.rootReconciler,
    this.syncer,
  });

  $ConfigManagementConfigSyncVersion00.fromJson(core.Map json_)
    : this(
        admissionWebhook: json_['admissionWebhook'] as core.String?,
        gitSync: json_['gitSync'] as core.String?,
        importer: json_['importer'] as core.String?,
        monitor: json_['monitor'] as core.String?,
        otelCollector: json_['otelCollector'] as core.String?,
        reconcilerManager: json_['reconcilerManager'] as core.String?,
        resourceGroupControllerManager:
            json_['resourceGroupControllerManager'] as core.String?,
        rootReconciler: json_['rootReconciler'] as core.String?,
        syncer: json_['syncer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (admissionWebhook != null) 'admissionWebhook': admissionWebhook!,
    if (gitSync != null) 'gitSync': gitSync!,
    if (importer != null) 'importer': importer!,
    if (monitor != null) 'monitor': monitor!,
    if (otelCollector != null) 'otelCollector': otelCollector!,
    if (reconcilerManager != null) 'reconcilerManager': reconcilerManager!,
    if (resourceGroupControllerManager != null)
      'resourceGroupControllerManager': resourceGroupControllerManager!,
    if (rootReconciler != null) 'rootReconciler': rootReconciler!,
    if (syncer != null) 'syncer': syncer!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementConfigSyncVersion
/// - gkehub:v2alpha : ConfigManagementConfigSyncVersion
/// - gkehub:v2beta : ConfigManagementConfigSyncVersion
class $ConfigManagementConfigSyncVersion01 {
  /// Version of the deployed admission-webhook pod.
  core.String? admissionWebhook;

  /// Version of the deployed git-sync pod.
  core.String? gitSync;

  /// Version of the deployed importer pod.
  core.String? importer;

  /// Version of the deployed monitor pod.
  core.String? monitor;

  /// Version of the deployed otel-collector pod
  core.String? otelCollector;

  /// Version of the deployed reconciler-manager pod.
  core.String? reconcilerManager;

  /// Version of the deployed resource-group-controller-manager pod
  core.String? resourceGroupControllerManager;

  /// Version of the deployed reconciler container in root-reconciler pod.
  core.String? rootReconciler;

  /// Version of the deployed syncer pod.
  core.String? syncer;

  $ConfigManagementConfigSyncVersion01({
    this.admissionWebhook,
    this.gitSync,
    this.importer,
    this.monitor,
    this.otelCollector,
    this.reconcilerManager,
    this.resourceGroupControllerManager,
    this.rootReconciler,
    this.syncer,
  });

  $ConfigManagementConfigSyncVersion01.fromJson(core.Map json_)
    : this(
        admissionWebhook: json_['admissionWebhook'] as core.String?,
        gitSync: json_['gitSync'] as core.String?,
        importer: json_['importer'] as core.String?,
        monitor: json_['monitor'] as core.String?,
        otelCollector: json_['otelCollector'] as core.String?,
        reconcilerManager: json_['reconcilerManager'] as core.String?,
        resourceGroupControllerManager:
            json_['resourceGroupControllerManager'] as core.String?,
        rootReconciler: json_['rootReconciler'] as core.String?,
        syncer: json_['syncer'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (admissionWebhook != null) 'admissionWebhook': admissionWebhook!,
    if (gitSync != null) 'gitSync': gitSync!,
    if (importer != null) 'importer': importer!,
    if (monitor != null) 'monitor': monitor!,
    if (otelCollector != null) 'otelCollector': otelCollector!,
    if (reconcilerManager != null) 'reconcilerManager': reconcilerManager!,
    if (resourceGroupControllerManager != null)
      'resourceGroupControllerManager': resourceGroupControllerManager!,
    if (rootReconciler != null) 'rootReconciler': rootReconciler!,
    if (syncer != null) 'syncer': syncer!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementContainerOverride
/// - gkehub:v1alpha : ConfigManagementContainerOverride
/// - gkehub:v1beta : ConfigManagementContainerOverride
/// - gkehub:v2 : ConfigManagementContainerOverride
/// - gkehub:v2alpha : ConfigManagementContainerOverride
/// - gkehub:v2beta : ConfigManagementContainerOverride
class $ConfigManagementContainerOverride {
  /// The name of the container.
  ///
  /// Required.
  core.String? containerName;

  /// The cpu limit of the container.
  ///
  /// Optional.
  core.String? cpuLimit;

  /// The cpu request of the container.
  ///
  /// Optional.
  core.String? cpuRequest;

  /// The memory limit of the container.
  ///
  /// Optional.
  core.String? memoryLimit;

  /// The memory request of the container.
  ///
  /// Optional.
  core.String? memoryRequest;

  $ConfigManagementContainerOverride({
    this.containerName,
    this.cpuLimit,
    this.cpuRequest,
    this.memoryLimit,
    this.memoryRequest,
  });

  $ConfigManagementContainerOverride.fromJson(core.Map json_)
    : this(
        containerName: json_['containerName'] as core.String?,
        cpuLimit: json_['cpuLimit'] as core.String?,
        cpuRequest: json_['cpuRequest'] as core.String?,
        memoryLimit: json_['memoryLimit'] as core.String?,
        memoryRequest: json_['memoryRequest'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (containerName != null) 'containerName': containerName!,
    if (cpuLimit != null) 'cpuLimit': cpuLimit!,
    if (cpuRequest != null) 'cpuRequest': cpuRequest!,
    if (memoryLimit != null) 'memoryLimit': memoryLimit!,
    if (memoryRequest != null) 'memoryRequest': memoryRequest!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementGatekeeperDeploymentState
/// - gkehub:v1alpha : ConfigManagementGatekeeperDeploymentState
/// - gkehub:v1beta : ConfigManagementGatekeeperDeploymentState
class $ConfigManagementGatekeeperDeploymentState00 {
  /// Status of gatekeeper-audit deployment.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperAudit;

  /// Status of gatekeeper-controller-manager pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperControllerManagerState;

  /// Status of the pod serving the mutation webhook.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperMutation;

  $ConfigManagementGatekeeperDeploymentState00({
    this.gatekeeperAudit,
    this.gatekeeperControllerManagerState,
    this.gatekeeperMutation,
  });

  $ConfigManagementGatekeeperDeploymentState00.fromJson(core.Map json_)
    : this(
        gatekeeperAudit: json_['gatekeeperAudit'] as core.String?,
        gatekeeperControllerManagerState:
            json_['gatekeeperControllerManagerState'] as core.String?,
        gatekeeperMutation: json_['gatekeeperMutation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gatekeeperAudit != null) 'gatekeeperAudit': gatekeeperAudit!,
    if (gatekeeperControllerManagerState != null)
      'gatekeeperControllerManagerState': gatekeeperControllerManagerState!,
    if (gatekeeperMutation != null) 'gatekeeperMutation': gatekeeperMutation!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementGatekeeperDeploymentState
/// - gkehub:v2alpha : ConfigManagementGatekeeperDeploymentState
/// - gkehub:v2beta : ConfigManagementGatekeeperDeploymentState
class $ConfigManagementGatekeeperDeploymentState01 {
  /// Status of gatekeeper-audit deployment.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperAudit;

  /// Status of gatekeeper-controller-manager pod.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperControllerManagerState;

  /// Status of the pod serving the mutation webhook.
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? gatekeeperMutation;

  $ConfigManagementGatekeeperDeploymentState01({
    this.gatekeeperAudit,
    this.gatekeeperControllerManagerState,
    this.gatekeeperMutation,
  });

  $ConfigManagementGatekeeperDeploymentState01.fromJson(core.Map json_)
    : this(
        gatekeeperAudit: json_['gatekeeperAudit'] as core.String?,
        gatekeeperControllerManagerState:
            json_['gatekeeperControllerManagerState'] as core.String?,
        gatekeeperMutation: json_['gatekeeperMutation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gatekeeperAudit != null) 'gatekeeperAudit': gatekeeperAudit!,
    if (gatekeeperControllerManagerState != null)
      'gatekeeperControllerManagerState': gatekeeperControllerManagerState!,
    if (gatekeeperMutation != null) 'gatekeeperMutation': gatekeeperMutation!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementGitConfig
/// - gkehub:v1alpha : ConfigManagementGitConfig
/// - gkehub:v1beta : ConfigManagementGitConfig
/// - gkehub:v2 : ConfigManagementGitConfig
/// - gkehub:v2alpha : ConfigManagementGitConfig
/// - gkehub:v2beta : ConfigManagementGitConfig
class $ConfigManagementGitConfig {
  /// The Google Cloud Service Account Email used for auth when secret_type is
  /// gcpServiceAccount.
  ///
  /// Optional.
  core.String? gcpServiceAccountEmail;

  /// URL for the HTTPS proxy to be used when communicating with the Git repo.
  ///
  /// Optional.
  core.String? httpsProxy;

  /// The path within the Git repository that represents the top level of the
  /// repo to sync.
  ///
  /// Default: the root directory of the repository.
  ///
  /// Optional.
  core.String? policyDir;

  /// Type of secret configured for access to the Git repo.
  ///
  /// Must be one of ssh, cookiefile, gcenode, token, gcpserviceaccount,
  /// githubapp or none. The validation of this is case-sensitive.
  ///
  /// Required.
  core.String? secretType;

  /// The branch of the repository to sync from.
  ///
  /// Default: master.
  ///
  /// Optional.
  core.String? syncBranch;

  /// The URL of the Git repository to use as the source of truth.
  ///
  /// Required.
  core.String? syncRepo;

  /// Git revision (tag or hash) to check out.
  ///
  /// Default HEAD.
  ///
  /// Optional.
  core.String? syncRev;

  /// Period in seconds between consecutive syncs.
  ///
  /// Default: 15.
  ///
  /// Optional.
  core.String? syncWaitSecs;

  $ConfigManagementGitConfig({
    this.gcpServiceAccountEmail,
    this.httpsProxy,
    this.policyDir,
    this.secretType,
    this.syncBranch,
    this.syncRepo,
    this.syncRev,
    this.syncWaitSecs,
  });

  $ConfigManagementGitConfig.fromJson(core.Map json_)
    : this(
        gcpServiceAccountEmail: json_['gcpServiceAccountEmail'] as core.String?,
        httpsProxy: json_['httpsProxy'] as core.String?,
        policyDir: json_['policyDir'] as core.String?,
        secretType: json_['secretType'] as core.String?,
        syncBranch: json_['syncBranch'] as core.String?,
        syncRepo: json_['syncRepo'] as core.String?,
        syncRev: json_['syncRev'] as core.String?,
        syncWaitSecs: json_['syncWaitSecs'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcpServiceAccountEmail != null)
      'gcpServiceAccountEmail': gcpServiceAccountEmail!,
    if (httpsProxy != null) 'httpsProxy': httpsProxy!,
    if (policyDir != null) 'policyDir': policyDir!,
    if (secretType != null) 'secretType': secretType!,
    if (syncBranch != null) 'syncBranch': syncBranch!,
    if (syncRepo != null) 'syncRepo': syncRepo!,
    if (syncRev != null) 'syncRev': syncRev!,
    if (syncWaitSecs != null) 'syncWaitSecs': syncWaitSecs!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementGroupVersionKind
/// - gkehub:v1alpha : ConfigManagementGroupVersionKind
/// - gkehub:v1beta : ConfigManagementGroupVersionKind
/// - gkehub:v2 : ConfigManagementGroupVersionKind
/// - gkehub:v2alpha : ConfigManagementGroupVersionKind
/// - gkehub:v2beta : ConfigManagementGroupVersionKind
class $ConfigManagementGroupVersionKind {
  /// Kubernetes Group
  core.String? group;

  /// Kubernetes Kind
  core.String? kind;

  /// Kubernetes Version
  core.String? version;

  $ConfigManagementGroupVersionKind({this.group, this.kind, this.version});

  $ConfigManagementGroupVersionKind.fromJson(core.Map json_)
    : this(
        group: json_['group'] as core.String?,
        kind: json_['kind'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (group != null) 'group': group!,
    if (kind != null) 'kind': kind!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementHierarchyControllerConfig
/// - gkehub:v1alpha : ConfigManagementHierarchyControllerConfig
/// - gkehub:v1beta : ConfigManagementHierarchyControllerConfig
/// - gkehub:v2 : ConfigManagementHierarchyControllerConfig
/// - gkehub:v2alpha : ConfigManagementHierarchyControllerConfig
/// - gkehub:v2beta : ConfigManagementHierarchyControllerConfig
class $ConfigManagementHierarchyControllerConfig {
  /// Whether hierarchical resource quota is enabled in this cluster.
  core.bool? enableHierarchicalResourceQuota;

  /// Whether pod tree labels are enabled in this cluster.
  core.bool? enablePodTreeLabels;

  /// Whether Hierarchy Controller is enabled in this cluster.
  core.bool? enabled;

  $ConfigManagementHierarchyControllerConfig({
    this.enableHierarchicalResourceQuota,
    this.enablePodTreeLabels,
    this.enabled,
  });

  $ConfigManagementHierarchyControllerConfig.fromJson(core.Map json_)
    : this(
        enableHierarchicalResourceQuota:
            json_['enableHierarchicalResourceQuota'] as core.bool?,
        enablePodTreeLabels: json_['enablePodTreeLabels'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableHierarchicalResourceQuota != null)
      'enableHierarchicalResourceQuota': enableHierarchicalResourceQuota!,
    if (enablePodTreeLabels != null)
      'enablePodTreeLabels': enablePodTreeLabels!,
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementHierarchyControllerDeploymentState
/// - gkehub:v1alpha : ConfigManagementHierarchyControllerDeploymentState
/// - gkehub:v1beta : ConfigManagementHierarchyControllerDeploymentState
class $ConfigManagementHierarchyControllerDeploymentState00 {
  /// The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1)
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? extension;

  /// The deployment state for open source HNC (e.g. v0.7.0-hc.0)
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be determined
  /// - "NOT_INSTALLED" : Deployment is not installed
  /// - "INSTALLED" : Deployment is installed
  /// - "ERROR" : Deployment was attempted to be installed, but has errors
  /// - "PENDING" : Deployment is installing or terminating
  core.String? hnc;

  $ConfigManagementHierarchyControllerDeploymentState00({
    this.extension,
    this.hnc,
  });

  $ConfigManagementHierarchyControllerDeploymentState00.fromJson(core.Map json_)
    : this(
        extension: json_['extension'] as core.String?,
        hnc: json_['hnc'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (hnc != null) 'hnc': hnc!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementHierarchyControllerDeploymentState
/// - gkehub:v2alpha : ConfigManagementHierarchyControllerDeploymentState
/// - gkehub:v2beta : ConfigManagementHierarchyControllerDeploymentState
class $ConfigManagementHierarchyControllerDeploymentState01 {
  /// The deployment state for Hierarchy Controller extension (e.g.
  /// v0.7.0-hc.1).
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? extension;

  /// The deployment state for open source HNC (e.g. v0.7.0-hc.0).
  /// Possible string values are:
  /// - "DEPLOYMENT_STATE_UNSPECIFIED" : Deployment's state cannot be
  /// determined.
  /// - "NOT_INSTALLED" : Deployment is not installed.
  /// - "INSTALLED" : Deployment is installed.
  /// - "ERROR" : Deployment was attempted to be installed, but has errors.
  /// - "PENDING" : Deployment is installing or terminating
  core.String? hnc;

  $ConfigManagementHierarchyControllerDeploymentState01({
    this.extension,
    this.hnc,
  });

  $ConfigManagementHierarchyControllerDeploymentState01.fromJson(core.Map json_)
    : this(
        extension: json_['extension'] as core.String?,
        hnc: json_['hnc'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (hnc != null) 'hnc': hnc!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementHierarchyControllerVersion
/// - gkehub:v1alpha : ConfigManagementHierarchyControllerVersion
/// - gkehub:v1beta : ConfigManagementHierarchyControllerVersion
class $ConfigManagementHierarchyControllerVersion00 {
  /// Version for Hierarchy Controller extension
  core.String? extension;

  /// Version for open source HNC
  core.String? hnc;

  $ConfigManagementHierarchyControllerVersion00({this.extension, this.hnc});

  $ConfigManagementHierarchyControllerVersion00.fromJson(core.Map json_)
    : this(
        extension: json_['extension'] as core.String?,
        hnc: json_['hnc'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (hnc != null) 'hnc': hnc!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementHierarchyControllerVersion
/// - gkehub:v2alpha : ConfigManagementHierarchyControllerVersion
/// - gkehub:v2beta : ConfigManagementHierarchyControllerVersion
class $ConfigManagementHierarchyControllerVersion01 {
  /// Version for Hierarchy Controller extension.
  core.String? extension;

  /// Version for open source HNC.
  core.String? hnc;

  $ConfigManagementHierarchyControllerVersion01({this.extension, this.hnc});

  $ConfigManagementHierarchyControllerVersion01.fromJson(core.Map json_)
    : this(
        extension: json_['extension'] as core.String?,
        hnc: json_['hnc'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (hnc != null) 'hnc': hnc!,
  };
}

/// Used by:
///
/// - gkehub:v2 : ConfigManagementInstallError
/// - gkehub:v2alpha : ConfigManagementInstallError
/// - gkehub:v2beta : ConfigManagementInstallError
class $ConfigManagementInstallError {
  /// A string representing the user facing error message.
  core.String? errorMessage;

  $ConfigManagementInstallError({this.errorMessage});

  $ConfigManagementInstallError.fromJson(core.Map json_)
    : this(errorMessage: json_['errorMessage'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementOciConfig
/// - gkehub:v1alpha : ConfigManagementOciConfig
/// - gkehub:v1beta : ConfigManagementOciConfig
/// - gkehub:v2 : ConfigManagementOciConfig
/// - gkehub:v2alpha : ConfigManagementOciConfig
/// - gkehub:v2beta : ConfigManagementOciConfig
class $ConfigManagementOciConfig {
  /// The Google Cloud Service Account Email used for auth when secret_type is
  /// gcpServiceAccount.
  ///
  /// Optional.
  core.String? gcpServiceAccountEmail;

  /// The absolute path of the directory that contains the local resources.
  ///
  /// Default: the root directory of the image.
  ///
  /// Optional.
  core.String? policyDir;

  /// Type of secret configured for access to the OCI repo.
  ///
  /// Must be one of gcenode, gcpserviceaccount, k8sserviceaccount or none. The
  /// validation of this is case-sensitive.
  ///
  /// Required.
  core.String? secretType;

  /// The OCI image repository URL for the package to sync from.
  ///
  /// e.g. `LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME`.
  ///
  /// Required.
  core.String? syncRepo;

  /// Period in seconds between consecutive syncs.
  ///
  /// Default: 15.
  ///
  /// Optional.
  core.String? syncWaitSecs;

  $ConfigManagementOciConfig({
    this.gcpServiceAccountEmail,
    this.policyDir,
    this.secretType,
    this.syncRepo,
    this.syncWaitSecs,
  });

  $ConfigManagementOciConfig.fromJson(core.Map json_)
    : this(
        gcpServiceAccountEmail: json_['gcpServiceAccountEmail'] as core.String?,
        policyDir: json_['policyDir'] as core.String?,
        secretType: json_['secretType'] as core.String?,
        syncRepo: json_['syncRepo'] as core.String?,
        syncWaitSecs: json_['syncWaitSecs'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcpServiceAccountEmail != null)
      'gcpServiceAccountEmail': gcpServiceAccountEmail!,
    if (policyDir != null) 'policyDir': policyDir!,
    if (secretType != null) 'secretType': secretType!,
    if (syncRepo != null) 'syncRepo': syncRepo!,
    if (syncWaitSecs != null) 'syncWaitSecs': syncWaitSecs!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementPolicyControllerMigration
/// - gkehub:v1alpha : ConfigManagementPolicyControllerMigration
/// - gkehub:v1beta : ConfigManagementPolicyControllerMigration
/// - gkehub:v2 : ConfigManagementPolicyControllerMigration
/// - gkehub:v2alpha : ConfigManagementPolicyControllerMigration
/// - gkehub:v2beta : ConfigManagementPolicyControllerMigration
class $ConfigManagementPolicyControllerMigration {
  /// Last time this membership spec was copied to PoCo feature.
  core.String? copyTime;

  /// Stage of the migration.
  /// Possible string values are:
  /// - "STAGE_UNSPECIFIED" : Unknown state of migration.
  /// - "ACM_MANAGED" : ACM Hub/Operator manages policycontroller. No migration
  /// yet completed.
  /// - "POCO_MANAGED" : All migrations steps complete; Poco Hub now manages
  /// policycontroller.
  core.String? stage;

  $ConfigManagementPolicyControllerMigration({this.copyTime, this.stage});

  $ConfigManagementPolicyControllerMigration.fromJson(core.Map json_)
    : this(
        copyTime: json_['copyTime'] as core.String?,
        stage: json_['stage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (copyTime != null) 'copyTime': copyTime!,
    if (stage != null) 'stage': stage!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementPolicyControllerVersion
/// - gkehub:v1alpha : ConfigManagementPolicyControllerVersion
/// - gkehub:v1beta : ConfigManagementPolicyControllerVersion
/// - gkehub:v2 : ConfigManagementPolicyControllerVersion
/// - gkehub:v2alpha : ConfigManagementPolicyControllerVersion
/// - gkehub:v2beta : ConfigManagementPolicyControllerVersion
class $ConfigManagementPolicyControllerVersion {
  /// The gatekeeper image tag that is composed of ACM version, git tag, build
  /// number.
  core.String? version;

  $ConfigManagementPolicyControllerVersion({this.version});

  $ConfigManagementPolicyControllerVersion.fromJson(core.Map json_)
    : this(version: json_['version'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewIndexConfigTreeAHConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigTreeAHConfig
class $ConfigTreeAHConfig {
  /// Number of embeddings on each leaf node.
  ///
  /// The default value is 1000 if not set.
  ///
  /// Optional.
  core.String? leafNodeEmbeddingCount;

  $ConfigTreeAHConfig({this.leafNodeEmbeddingCount});

  $ConfigTreeAHConfig.fromJson(core.Map json_)
    : this(
        leafNodeEmbeddingCount: json_['leafNodeEmbeddingCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (leafNodeEmbeddingCount != null)
      'leafNodeEmbeddingCount': leafNodeEmbeddingCount!,
  };
}

/// Used by:
///
/// - compute:alpha : ConnectionDraining
/// - compute:beta : ConnectionDraining
/// - compute:v1 : ConnectionDraining
class $ConnectionDraining {
  /// Configures a duration timeout for existing requests on a removed backend
  /// instance.
  ///
  /// For supported load balancers and protocols, as described in Enabling
  /// connection draining.
  core.int? drainingTimeoutSec;

  $ConnectionDraining({this.drainingTimeoutSec});

  $ConnectionDraining.fromJson(core.Map json_)
    : this(drainingTimeoutSec: json_['drainingTimeoutSec'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (drainingTimeoutSec != null) 'drainingTimeoutSec': drainingTimeoutSec!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : ConnectionError
/// - cloudcontrolspartner:v1beta : ConnectionError
class $ConnectionError {
  /// The error domain for the error
  core.String? errorDomain;

  /// The error message for the error
  core.String? errorMessage;

  $ConnectionError({this.errorDomain, this.errorMessage});

  $ConnectionError.fromJson(core.Map json_)
    : this(
        errorDomain: json_['errorDomain'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorDomain != null) 'errorDomain': errorDomain!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ConnectionErrorDetails
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ConnectionErrorDetails
class $ConnectionErrorDetails {
  /// The status of the certificate authentication.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CERTIFICATE_STATE_UNSPECIFIED" : Certificate state is not specified.
  /// - "CERTIFICATE_VALID" : Certificate is valid.
  /// - "CERTIFICATE_INVALID" : Catch all for any error not specified.
  /// - "CERTIFICATE_EXPIRED" : Certificate leaf node has expired.
  /// - "CERTIFICATE_HOSTNAME_NOT_FOUND" : There is no hostname defined to
  /// authenticate in SipTrunkingServer.
  /// - "CERTIFICATE_UNAUTHENTICATED" : No path found from the leaf certificate
  /// to any root.
  /// - "CERTIFICATE_TRUST_STORE_NOT_FOUND" : Trust store does not exist.
  /// - "CERTIFICATE_HOSTNAME_INVALID_FORMAT" : Hostname has invalid format.
  /// - "CERTIFICATE_QUOTA_EXCEEDED" : Certificate has exhausted its quota.
  core.String? certificateState;

  /// The error message provided from SIP trunking auth service
  core.String? errorMessage;

  $ConnectionErrorDetails({this.certificateState, this.errorMessage});

  $ConnectionErrorDetails.fromJson(core.Map json_)
    : this(
        certificateState: json_['certificateState'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateState != null) 'certificateState': certificateState!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : ConnectionInfo
/// - alloydb:v1beta : ConnectionInfo
class $ConnectionInfo {
  /// The unique ID of the Instance.
  ///
  /// Output only.
  core.String? instanceUid;

  /// The private network IP address for the Instance.
  ///
  /// This is the default IP for the instance and is always created (even if
  /// enable_public_ip is set). This is the connection endpoint for an end-user
  /// application.
  ///
  /// Output only.
  core.String? ipAddress;

  /// The name of the ConnectionInfo singleton resource, e.g.:
  /// projects/{project}/locations/{location}/clusters / * /instances / *
  /// /connectionInfo This field currently has no semantic meaning.
  core.String? name;

  /// The pem-encoded chain that may be used to verify the X.509 certificate.
  ///
  /// Expected to be in issuer-to-root order according to RFC 5246.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? pemCertificateChain;

  /// The DNS name to use with PSC for the Instance.
  ///
  /// Output only.
  core.String? pscDnsName;

  /// The public IP addresses for the Instance.
  ///
  /// This is available ONLY when enable_public_ip is set. This is the
  /// connection endpoint for an end-user application.
  ///
  /// Output only.
  core.String? publicIpAddress;

  $ConnectionInfo({
    this.instanceUid,
    this.ipAddress,
    this.name,
    this.pemCertificateChain,
    this.pscDnsName,
    this.publicIpAddress,
  });

  $ConnectionInfo.fromJson(core.Map json_)
    : this(
        instanceUid: json_['instanceUid'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        name: json_['name'] as core.String?,
        pemCertificateChain:
            (json_['pemCertificateChain'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pscDnsName: json_['pscDnsName'] as core.String?,
        publicIpAddress: json_['publicIpAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceUid != null) 'instanceUid': instanceUid!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (name != null) 'name': name!,
    if (pemCertificateChain != null)
      'pemCertificateChain': pemCertificateChain!,
    if (pscDnsName != null) 'pscDnsName': pscDnsName!,
    if (publicIpAddress != null) 'publicIpAddress': publicIpAddress!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : ConnectionPoolConfig
/// - alloydb:v1beta : ConnectionPoolConfig
class $ConnectionPoolConfig {
  /// Use 'flags' instead.
  ///
  /// The default pool size. Defaults to 20. Note: This field should not be
  /// added to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.String? defaultPoolSize;

  /// Deprecated; Prefer 'enabled' as this will be removed soon.
  ///
  /// Optional.
  core.bool? enable;

  /// Whether to enable Managed Connection Pool (MCP).
  ///
  /// Optional.
  core.bool? enabled;

  /// Connection Pool flags, as a list of "key": "value" pairs.
  ///
  /// Optional.
  core.Map<core.String, core.String>? flags;

  /// Use 'flags' instead.
  ///
  /// The list of startup parameters to ignore. Defaults to
  /// \["extra_float_digits"\] Note: This field should not be added to client
  /// libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.List<core.String>? ignoreStartupParameters;

  /// Use 'flags' instead.
  ///
  /// The maximum number of client connections allowed. Note: This field should
  /// not be added to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.String? maxClientConn;

  /// Use 'flags' instead.
  ///
  /// The maximum number of prepared statements allowed. MCP makes sure that any
  /// statement prepared by a client, up to this limit, is available on the
  /// backing server connection in transaction and statement pooling mode. Even
  /// if the statement was originally prepared on another server connection.
  /// Defaults to 0. Note: This field should not be added to client libraries if
  /// not present already.
  ///
  /// Optional. Deprecated.
  core.String? maxPreparedStatements;

  /// Use 'flags' instead.
  ///
  /// The minimum pool size. Defaults to 0. Note: This field should not be added
  /// to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.String? minPoolSize;

  /// Use 'flags' instead.
  ///
  /// The pool mode. Defaults to `POOL_MODE_TRANSACTION`. Note: This field
  /// should not be added to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  /// Possible string values are:
  /// - "POOL_MODE_UNSPECIFIED" : The pool mode is not specified. Defaults to
  /// `POOL_MODE_TRANSACTION`.
  /// - "POOL_MODE_SESSION" : Server is released back to pool after a client
  /// disconnects.
  /// - "POOL_MODE_TRANSACTION" : Server is released back to pool after a
  /// transaction finishes.
  core.String? poolMode;

  /// The number of running poolers per instance.
  ///
  /// Output only.
  core.int? poolerCount;

  /// Use 'flags' instead.
  ///
  /// The maximum number of seconds queries are allowed to spend waiting for
  /// execution. If the query is not assigned to a server during that time, the
  /// client is disconnected. 0 disables. Note: This field should not be added
  /// to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.String? queryWaitTimeout;

  /// Use 'flags' instead.
  ///
  /// The maximum number of seconds a server is allowed to be idle before it is
  /// disconnected. 0 disables. Note: This field should not be added to client
  /// libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.String? serverIdleTimeout;

  /// Use 'flags' instead.
  ///
  /// The list of users that are allowed to connect to the MCP stats console.
  /// The users must exist in the database. Note: This field should not be added
  /// to client libraries if not present already.
  ///
  /// Optional. Deprecated.
  core.List<core.String>? statsUsers;

  $ConnectionPoolConfig({
    this.defaultPoolSize,
    this.enable,
    this.enabled,
    this.flags,
    this.ignoreStartupParameters,
    this.maxClientConn,
    this.maxPreparedStatements,
    this.minPoolSize,
    this.poolMode,
    this.poolerCount,
    this.queryWaitTimeout,
    this.serverIdleTimeout,
    this.statsUsers,
  });

  $ConnectionPoolConfig.fromJson(core.Map json_)
    : this(
        defaultPoolSize: json_['defaultPoolSize'] as core.String?,
        enable: json_['enable'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
        flags: (json_['flags'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        ignoreStartupParameters:
            (json_['ignoreStartupParameters'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        maxClientConn: json_['maxClientConn'] as core.String?,
        maxPreparedStatements: json_['maxPreparedStatements'] as core.String?,
        minPoolSize: json_['minPoolSize'] as core.String?,
        poolMode: json_['poolMode'] as core.String?,
        poolerCount: json_['poolerCount'] as core.int?,
        queryWaitTimeout: json_['queryWaitTimeout'] as core.String?,
        serverIdleTimeout: json_['serverIdleTimeout'] as core.String?,
        statsUsers:
            (json_['statsUsers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultPoolSize != null) 'defaultPoolSize': defaultPoolSize!,
    if (enable != null) 'enable': enable!,
    if (enabled != null) 'enabled': enabled!,
    if (flags != null) 'flags': flags!,
    if (ignoreStartupParameters != null)
      'ignoreStartupParameters': ignoreStartupParameters!,
    if (maxClientConn != null) 'maxClientConn': maxClientConn!,
    if (maxPreparedStatements != null)
      'maxPreparedStatements': maxPreparedStatements!,
    if (minPoolSize != null) 'minPoolSize': minPoolSize!,
    if (poolMode != null) 'poolMode': poolMode!,
    if (poolerCount != null) 'poolerCount': poolerCount!,
    if (queryWaitTimeout != null) 'queryWaitTimeout': queryWaitTimeout!,
    if (serverIdleTimeout != null) 'serverIdleTimeout': serverIdleTimeout!,
    if (statsUsers != null) 'statsUsers': statsUsers!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : ConnectionPoolFlags
/// - sqladmin:v1beta4 : ConnectionPoolFlags
class $ConnectionPoolFlags {
  /// The name of the flag.
  ///
  /// Required.
  core.String? name;

  /// The value of the flag.
  ///
  /// Boolean flags are set to `on` for true and `off` for false. This field
  /// must be omitted if the flag doesn't take a value.
  ///
  /// Required.
  core.String? value;

  $ConnectionPoolFlags({this.name, this.value});

  $ConnectionPoolFlags.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - connectors:v1 : ConnectionStatus
/// - integrations:v1 : GoogleCloudConnectorsV1ConnectionStatus
class $ConnectionStatus {
  /// Description.
  core.String? description;

  /// State.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Connection does not have a state yet.
  /// - "CREATING" : Connection is being created.
  /// - "ACTIVE" : Connection is running and ready for requests.
  /// - "INACTIVE" : Connection is stopped.
  /// - "DELETING" : Connection is being deleted.
  /// - "UPDATING" : Connection is being updated.
  /// - "ERROR" : Connection is not running due to an error.
  /// - "AUTHORIZATION_REQUIRED" : Connection is not running because the
  /// authorization configuration is not complete.
  core.String? state;

  /// Status provides detailed information for the state.
  core.String? status;

  $ConnectionStatus({this.description, this.state, this.status});

  $ConnectionStatus.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        state: json_['state'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (state != null) 'state': state!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : Consent
/// - displayvideo:v4 : Consent
class $Consent {
  /// Represents consent for ad personalization.
  /// Possible string values are:
  /// - "CONSENT_STATUS_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "CONSENT_STATUS_GRANTED" : Consent is granted.
  /// - "CONSENT_STATUS_DENIED" : Consent is denied.
  core.String? adPersonalization;

  /// Represents consent for ad user data.
  /// Possible string values are:
  /// - "CONSENT_STATUS_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "CONSENT_STATUS_GRANTED" : Consent is granted.
  /// - "CONSENT_STATUS_DENIED" : Consent is denied.
  core.String? adUserData;

  $Consent({this.adPersonalization, this.adUserData});

  $Consent.fromJson(core.Map json_)
    : this(
        adPersonalization: json_['adPersonalization'] as core.String?,
        adUserData: json_['adUserData'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adPersonalization != null) 'adPersonalization': adPersonalization!,
    if (adUserData != null) 'adUserData': adUserData!,
  };
}

/// Used by:
///
/// - healthcare:v1 : ConsentAccessorScope
/// - healthcare:v1beta1 : ConsentAccessorScope
class $ConsentAccessorScope {
  /// An individual, group, or access role that identifies the accessor or a
  /// characteristic of the accessor.
  ///
  /// This can be a resource ID (such as `{resourceType}/{id}`) or an external
  /// URI. This value must be present.
  core.String? actor;

  /// An abstract identifier that describes the environment or conditions under
  /// which the accessor is acting.
  ///
  /// If it's not specified, it applies to all environments.
  core.String? environment;

  /// The intent of data use.
  ///
  /// If it's not specified, it applies to all purposes.
  core.String? purpose;

  $ConsentAccessorScope({this.actor, this.environment, this.purpose});

  $ConsentAccessorScope.fromJson(core.Map json_)
    : this(
        actor: json_['actor'] as core.String?,
        environment: json_['environment'] as core.String?,
        purpose: json_['purpose'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actor != null) 'actor': actor!,
    if (environment != null) 'environment': environment!,
    if (purpose != null) 'purpose': purpose!,
  };
}

/// Used by:
///
/// - healthcare:v1 : ConsentEvaluation
/// - healthcare:v1beta1 : ConsentEvaluation
class $ConsentEvaluation {
  /// The evaluation result.
  /// Possible string values are:
  /// - "EVALUATION_RESULT_UNSPECIFIED" : No evaluation result specified. This
  /// option is invalid.
  /// - "NOT_APPLICABLE" : The Consent is not applicable to the requested access
  /// determination. For example, the Consent does not apply to the user for
  /// which the access determination is requested, or it has a `state` of
  /// `REVOKED`, or it has expired.
  /// - "NO_MATCHING_POLICY" : The Consent does not have a policy that matches
  /// the `resource_attributes` of the evaluated resource.
  /// - "NO_SATISFIED_POLICY" : The Consent has at least one policy that matches
  /// the `resource_attributes` of the evaluated resource, but no
  /// `authorization_rule` was satisfied.
  /// - "HAS_SATISFIED_POLICY" : The Consent has at least one policy that
  /// matches the `resource_attributes` of the evaluated resource, and at least
  /// one `authorization_rule` was satisfied.
  core.String? evaluationResult;

  $ConsentEvaluation({this.evaluationResult});

  $ConsentEvaluation.fromJson(core.Map json_)
    : this(evaluationResult: json_['evaluationResult'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (evaluationResult != null) 'evaluationResult': evaluationResult!,
  };
}

/// Used by:
///
/// - healthcare:v1 : GoogleCloudHealthcareV1ConsentGcsDestination
/// - healthcare:v1beta1 : GoogleCloudHealthcareV1beta1ConsentGcsDestination
class $ConsentGcsDestination {
  /// URI for a Cloud Storage directory where the server writes result files, in
  /// the format `gs://{bucket-id}/{path/to/destination/dir}`.
  ///
  /// If there is no trailing slash, the service appends one when composing the
  /// object path. The user is responsible for creating the Cloud Storage bucket
  /// and directory referenced in `uri_prefix`.
  core.String? uriPrefix;

  $ConsentGcsDestination({this.uriPrefix});

  $ConsentGcsDestination.fromJson(core.Map json_)
    : this(uriPrefix: json_['uriPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uriPrefix != null) 'uriPrefix': uriPrefix!,
  };
}

/// Used by:
///
/// - healthcare:v1 : ConsentHeaderHandling
/// - healthcare:v1beta1 : ConsentHeaderHandling
class $ConsentHeaderHandling {
  /// Specifies the default server behavior when the header is empty.
  ///
  /// If not specified, the `ScopeProfile.PERMIT_EMPTY_SCOPE` option is used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SCOPE_PROFILE_UNSPECIFIED" : If not specified, the default value
  /// `PERMIT_EMPTY_SCOPE` is used.
  /// - "PERMIT_EMPTY_SCOPE" : When no consent scopes are provided (for example,
  /// if there's an empty or missing header), then consent check is disabled,
  /// similar to when `access_enforced` is `false`. You can use audit logs to
  /// differentiate these two cases by looking at the value of
  /// `protopayload.metadata.consentMode`. If consents scopes are present, they
  /// must be valid and within the allowed limits, otherwise the request will be
  /// rejected with a `4xx` code.
  /// - "REQUIRED_ON_READ" : The consent header must be non-empty when
  /// performing read and search operations, otherwise the request is rejected
  /// with a `4xx` code. Additionally, invalid consent scopes or scopes
  /// exceeding the allowed limits are rejected.
  core.String? profile;

  $ConsentHeaderHandling({this.profile});

  $ConsentHeaderHandling.fromJson(core.Map json_)
    : this(profile: json_['profile'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (profile != null) 'profile': profile!,
  };
}

/// Used by:
///
/// - healthcare:v1 : ConsentList
/// - healthcare:v1beta1 : ConsentList
class $ConsentList {
  /// The resource names of the Consents to evaluate against, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consents/{consent_id}`.
  core.List<core.String>? consents;

  $ConsentList({this.consents});

  $ConsentList.fromJson(core.Map json_)
    : this(
        consents:
            (json_['consents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consents != null) 'consents': consents!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1ViolationRemediationInstructionsConsole
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1ViolationRemediationInstructionsConsole
/// - cloudcontrolspartner:v1 : Console
/// - cloudcontrolspartner:v1beta : Console
class $Console {
  /// Additional urls for more information about steps
  core.List<core.String>? additionalLinks;

  /// Link to console page where violations can be resolved
  core.List<core.String>? consoleUris;

  /// Steps to resolve violation via cloud console
  core.List<core.String>? steps;

  $Console({this.additionalLinks, this.consoleUris, this.steps});

  $Console.fromJson(core.Map json_)
    : this(
        additionalLinks:
            (json_['additionalLinks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        consoleUris:
            (json_['consoleUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        steps:
            (json_['steps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (additionalLinks != null) 'additionalLinks': additionalLinks!,
    if (consoleUris != null) 'consoleUris': consoleUris!,
    if (steps != null) 'steps': steps!,
  };
}

/// Used by:
///
/// - metastore:v1 : Consumer
/// - metastore:v1alpha : Consumer
/// - metastore:v1beta : Consumer
class $Consumer {
  /// The location of the endpoint URI.
  ///
  /// Format: projects/{project}/locations/{location}.
  ///
  /// Output only.
  core.String? endpointLocation;

  /// The URI of the endpoint used to access the metastore service.
  ///
  /// Output only.
  core.String? endpointUri;

  /// The subnetwork of the customer project from which an IP address is
  /// reserved and used as the Dataproc Metastore service's endpoint.
  ///
  /// It is accessible to hosts in the subnet and to all hosts in a subnet in
  /// the same region and same network. There must be at least one IP address
  /// available in the subnet's primary range. The subnet is specified in the
  /// following
  /// form:projects/{project_number}/regions/{region_id}/subnetworks/{subnetwork_id}
  ///
  /// Immutable.
  core.String? subnetwork;

  $Consumer({this.endpointLocation, this.endpointUri, this.subnetwork});

  $Consumer.fromJson(core.Map json_)
    : this(
        endpointLocation: json_['endpointLocation'] as core.String?,
        endpointUri: json_['endpointUri'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpointLocation != null) 'endpointLocation': endpointLocation!,
    if (endpointUri != null) 'endpointUri': endpointUri!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - container:v1 : ConsumptionMeteringConfig
/// - container:v1beta1 : ConsumptionMeteringConfig
class $ConsumptionMeteringConfig {
  /// Whether to enable consumption metering for this cluster.
  ///
  /// If enabled, a second BigQuery table will be created to hold resource
  /// consumption records.
  core.bool? enabled;

  $ConsumptionMeteringConfig({this.enabled});

  $ConsumptionMeteringConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : Contact
/// - authorizedbuyersmarketplace:v1alpha : Contact
class $Contact {
  /// The display_name of the contact.
  core.String? displayName;

  /// Email address for the contact.
  core.String? email;

  $Contact({this.displayName, this.email});

  $Contact.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        email: json_['email'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (email != null) 'email': email!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : ContactInfo
/// - displayvideo:v4 : ContactInfo
class $ContactInfo {
  /// Country code of the member.
  ///
  /// Must also be set with the following fields: * hashed_first_name *
  /// hashed_last_name * zip_codes
  core.String? countryCode;

  /// A list of SHA256 hashed email of the member.
  ///
  /// Before hashing, remove all whitespace and make sure the string is all
  /// lowercase.
  core.List<core.String>? hashedEmails;

  /// SHA256 hashed first name of the member.
  ///
  /// Before hashing, remove all whitespace and make sure the string is all
  /// lowercase. Must also be set with the following fields: * country_code *
  /// hashed_last_name * zip_codes
  core.String? hashedFirstName;

  /// SHA256 hashed last name of the member.
  ///
  /// Before hashing, remove all whitespace and make sure the string is all
  /// lowercase. Must also be set with the following fields: * country_code *
  /// hashed_first_name * zip_codes
  core.String? hashedLastName;

  /// A list of SHA256 hashed phone numbers of the member.
  ///
  /// Before hashing, all phone numbers must be formatted using the \[E.164
  /// format\](//en.wikipedia.org/wiki/E.164) and include the country calling
  /// code.
  core.List<core.String>? hashedPhoneNumbers;

  /// A list of zip codes of the member.
  ///
  /// Must also be set with the following fields: * country_code *
  /// hashed_first_name * hashed_last_name
  core.List<core.String>? zipCodes;

  $ContactInfo({
    this.countryCode,
    this.hashedEmails,
    this.hashedFirstName,
    this.hashedLastName,
    this.hashedPhoneNumbers,
    this.zipCodes,
  });

  $ContactInfo.fromJson(core.Map json_)
    : this(
        countryCode: json_['countryCode'] as core.String?,
        hashedEmails:
            (json_['hashedEmails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        hashedFirstName: json_['hashedFirstName'] as core.String?,
        hashedLastName: json_['hashedLastName'] as core.String?,
        hashedPhoneNumbers:
            (json_['hashedPhoneNumbers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        zipCodes:
            (json_['zipCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (countryCode != null) 'countryCode': countryCode!,
    if (hashedEmails != null) 'hashedEmails': hashedEmails!,
    if (hashedFirstName != null) 'hashedFirstName': hashedFirstName!,
    if (hashedLastName != null) 'hashedLastName': hashedLastName!,
    if (hashedPhoneNumbers != null) 'hashedPhoneNumbers': hashedPhoneNumbers!,
    if (zipCodes != null) 'zipCodes': zipCodes!,
  };
}

/// Used by:
///
/// - workstations:v1 : Container
/// - workstations:v1beta : Container
class $Container {
  /// Arguments passed to the entrypoint.
  ///
  /// Optional.
  core.List<core.String>? args;

  /// If set, overrides the default ENTRYPOINT specified by the image.
  ///
  /// Optional.
  core.List<core.String>? command;

  /// Environment variables passed to the container's entrypoint.
  ///
  /// Optional.
  core.Map<core.String, core.String>? env;

  /// A Docker container image that defines a custom environment.
  ///
  /// Cloud Workstations provides a number of
  /// [preconfigured images](https://cloud.google.com/workstations/docs/preconfigured-base-images),
  /// but you can create your own
  /// [custom container images](https://cloud.google.com/workstations/docs/custom-container-images).
  /// If using a private image, the `host.gceInstance.serviceAccount` field must
  /// be specified in the workstation configuration. If using a custom container
  /// image, the service account must have
  /// [Artifact Registry Reader](https://cloud.google.com/artifact-registry/docs/access-control#roles)
  /// permission to pull the specified image. Otherwise, the image must be
  /// publicly accessible.
  ///
  /// Optional.
  core.String? image;

  /// If set, overrides the USER specified in the image with the given uid.
  ///
  /// Optional.
  core.int? runAsUser;

  /// If set, overrides the default DIR specified by the image.
  ///
  /// Optional.
  core.String? workingDir;

  $Container({
    this.args,
    this.command,
    this.env,
    this.image,
    this.runAsUser,
    this.workingDir,
  });

  $Container.fromJson(core.Map json_)
    : this(
        args:
            (json_['args'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        command:
            (json_['command'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        env: (json_['env'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        image: json_['image'] as core.String?,
        runAsUser: json_['runAsUser'] as core.int?,
        workingDir: json_['workingDir'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (command != null) 'command': command!,
    if (env != null) 'env': env!,
    if (image != null) 'image': image!,
    if (runAsUser != null) 'runAsUser': runAsUser!,
    if (workingDir != null) 'workingDir': workingDir!,
  };
}

/// Used by:
///
/// - appengine:v1 : ContainerInfo
/// - appengine:v1beta : ContainerInfo
class $ContainerInfo {
  /// URI to the hosted container image in Google Container Registry.
  ///
  /// The URI must be fully qualified and include a tag or digest. Examples:
  /// "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
  core.String? image;

  $ContainerInfo({this.image});

  $ContainerInfo.fromJson(core.Map json_)
    : this(image: json_['image'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (image != null) 'image': image!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ContainerRegistryDestination
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ContainerRegistryDestination
class $ContainerRegistryDestination {
  /// Container Registry URI of a container image.
  ///
  /// Only Google Container Registry and Artifact Registry are supported now.
  /// Accepted forms: * Google Container Registry path. For example:
  /// `gcr.io/projectId/imageName:tag`. * Artifact Registry path. For example:
  /// `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`. If a tag is
  /// not specified, "latest" will be used as the default tag.
  ///
  /// Required.
  core.String? outputUri;

  $ContainerRegistryDestination({this.outputUri});

  $ContainerRegistryDestination.fromJson(core.Map json_)
    : this(outputUri: json_['outputUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputUri != null) 'outputUri': outputUri!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : ContainerSource
/// - firebaseapphosting:v1beta : ContainerSource
class $ContainerSource {
  /// A URI representing a container for the backend to use.
  ///
  /// Required.
  core.String? image;

  $ContainerSource({this.image});

  $ContainerSource.fromJson(core.Map json_)
    : this(image: json_['image'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (image != null) 'image': image!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentDurationAssignedTargetingOptionDetails
/// - displayvideo:v3 : ContentDurationAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentDurationAssignedTargetingOptionDetails
class $ContentDurationAssignedTargetingOptionDetails {
  /// The content duration.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_DURATION_UNSPECIFIED" : Content duration is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real content duration.
  /// - "CONTENT_DURATION_UNKNOWN" : The content duration is unknown.
  /// - "CONTENT_DURATION_0_TO_1_MIN" : Content is 0-1 minute long.
  /// - "CONTENT_DURATION_1_TO_5_MIN" : Content is 1-5 minutes long.
  /// - "CONTENT_DURATION_5_TO_15_MIN" : Content is 5-15 minutes long.
  /// - "CONTENT_DURATION_15_TO_30_MIN" : Content is 15-30 minutes long.
  /// - "CONTENT_DURATION_30_TO_60_MIN" : Content is 30-60 minutes long.
  /// - "CONTENT_DURATION_OVER_60_MIN" : Content is over 60 minutes long.
  core.String? contentDuration;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_CONTENT_DURATION`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $ContentDurationAssignedTargetingOptionDetails({
    this.contentDuration,
    this.targetingOptionId,
  });

  $ContentDurationAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        contentDuration: json_['contentDuration'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentDuration != null) 'contentDuration': contentDuration!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentDurationTargetingOptionDetails
/// - displayvideo:v3 : ContentDurationTargetingOptionDetails
/// - displayvideo:v4 : ContentDurationTargetingOptionDetails
class $ContentDurationTargetingOptionDetails {
  /// The content duration.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_DURATION_UNSPECIFIED" : Content duration is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real content duration.
  /// - "CONTENT_DURATION_UNKNOWN" : The content duration is unknown.
  /// - "CONTENT_DURATION_0_TO_1_MIN" : Content is 0-1 minute long.
  /// - "CONTENT_DURATION_1_TO_5_MIN" : Content is 1-5 minutes long.
  /// - "CONTENT_DURATION_5_TO_15_MIN" : Content is 5-15 minutes long.
  /// - "CONTENT_DURATION_15_TO_30_MIN" : Content is 15-30 minutes long.
  /// - "CONTENT_DURATION_30_TO_60_MIN" : Content is 30-60 minutes long.
  /// - "CONTENT_DURATION_OVER_60_MIN" : Content is over 60 minutes long.
  core.String? contentDuration;

  $ContentDurationTargetingOptionDetails({this.contentDuration});

  $ContentDurationTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentDuration: json_['contentDuration'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentDuration != null) 'contentDuration': contentDuration!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentGenreAssignedTargetingOptionDetails
/// - displayvideo:v3 : ContentGenreAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentGenreAssignedTargetingOptionDetails
class $ContentGenreAssignedTargetingOptionDetails {
  /// The display name of the content genre.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_CONTENT_GENRE`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $ContentGenreAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $ContentGenreAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentGenreTargetingOptionDetails
/// - displayvideo:v3 : ContentGenreTargetingOptionDetails
/// - displayvideo:v4 : ContentGenreTargetingOptionDetails
class $ContentGenreTargetingOptionDetails {
  /// The display name of the content genre
  ///
  /// Output only.
  core.String? displayName;

  $ContentGenreTargetingOptionDetails({this.displayName});

  $ContentGenreTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentInstreamPositionAssignedTargetingOptionDetails
/// - displayvideo:v3 : ContentInstreamPositionAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentInstreamPositionAssignedTargetingOptionDetails
class $ContentInstreamPositionAssignedTargetingOptionDetails {
  /// The ad type to target.
  ///
  /// Only applicable to insertion order targeting and new line items supporting
  /// the specified ad type will inherit this targeting option by default.
  /// Possible values are: * `AD_TYPE_VIDEO`, the setting will be inherited by
  /// new line item when line_item_type is `LINE_ITEM_TYPE_VIDEO_DEFAULT`. *
  /// `AD_TYPE_AUDIO`, the setting will be inherited by new line item when
  /// line_item_type is `LINE_ITEM_TYPE_AUDIO_DEFAULT`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AD_TYPE_UNSPECIFIED" : Ad type is not specified or is unknown in this
  /// version.
  /// - "AD_TYPE_DISPLAY" : Display creatives, e.g. image and HTML5.
  /// - "AD_TYPE_VIDEO" : Video creatives, e.g. video ads that play during
  /// streaming content in video players.
  /// - "AD_TYPE_AUDIO" : Audio creatives, e.g. audio ads that play during audio
  /// content.
  core.String? adType;

  /// The content instream position for video or audio ads.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONTENT_INSTREAM_POSITION_UNSPECIFIED" : Content instream position is
  /// not specified in this version. This enum is a place holder for a default
  /// value and does not represent a real in stream ad position.
  /// - "CONTENT_INSTREAM_POSITION_PRE_ROLL" : Ads that play before streaming
  /// content.
  /// - "CONTENT_INSTREAM_POSITION_MID_ROLL" : Ads that play between the
  /// beginning and end of streaming content.
  /// - "CONTENT_INSTREAM_POSITION_POST_ROLL" : Ads that play at the end of
  /// streaming content.
  /// - "CONTENT_INSTREAM_POSITION_UNKNOWN" : Ads instream position is unknown.
  core.String? contentInstreamPosition;

  $ContentInstreamPositionAssignedTargetingOptionDetails({
    this.adType,
    this.contentInstreamPosition,
  });

  $ContentInstreamPositionAssignedTargetingOptionDetails.fromJson(
    core.Map json_,
  ) : this(
        adType: json_['adType'] as core.String?,
        contentInstreamPosition:
            json_['contentInstreamPosition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adType != null) 'adType': adType!,
    if (contentInstreamPosition != null)
      'contentInstreamPosition': contentInstreamPosition!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentInstreamPositionTargetingOptionDetails
/// - displayvideo:v3 : ContentInstreamPositionTargetingOptionDetails
/// - displayvideo:v4 : ContentInstreamPositionTargetingOptionDetails
class $ContentInstreamPositionTargetingOptionDetails {
  /// The content instream position.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_INSTREAM_POSITION_UNSPECIFIED" : Content instream position is
  /// not specified in this version. This enum is a place holder for a default
  /// value and does not represent a real in stream ad position.
  /// - "CONTENT_INSTREAM_POSITION_PRE_ROLL" : Ads that play before streaming
  /// content.
  /// - "CONTENT_INSTREAM_POSITION_MID_ROLL" : Ads that play between the
  /// beginning and end of streaming content.
  /// - "CONTENT_INSTREAM_POSITION_POST_ROLL" : Ads that play at the end of
  /// streaming content.
  /// - "CONTENT_INSTREAM_POSITION_UNKNOWN" : Ads instream position is unknown.
  core.String? contentInstreamPosition;

  $ContentInstreamPositionTargetingOptionDetails({
    this.contentInstreamPosition,
  });

  $ContentInstreamPositionTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        contentInstreamPosition:
            json_['contentInstreamPosition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentInstreamPosition != null)
      'contentInstreamPosition': contentInstreamPosition!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentOutstreamPositionAssignedTargetingOptionDetails
/// - displayvideo:v3 : ContentOutstreamPositionAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentOutstreamPositionAssignedTargetingOptionDetails
class $ContentOutstreamPositionAssignedTargetingOptionDetails {
  /// The ad type to target.
  ///
  /// Only applicable to insertion order targeting and new line items supporting
  /// the specified ad type will inherit this targeting option by default.
  /// Possible values are: * `AD_TYPE_DISPLAY`, the setting will be inherited by
  /// new line item when line_item_type is `LINE_ITEM_TYPE_DISPLAY_DEFAULT`. *
  /// `AD_TYPE_VIDEO`, the setting will be inherited by new line item when
  /// line_item_type is `LINE_ITEM_TYPE_VIDEO_DEFAULT`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AD_TYPE_UNSPECIFIED" : Ad type is not specified or is unknown in this
  /// version.
  /// - "AD_TYPE_DISPLAY" : Display creatives, e.g. image and HTML5.
  /// - "AD_TYPE_VIDEO" : Video creatives, e.g. video ads that play during
  /// streaming content in video players.
  /// - "AD_TYPE_AUDIO" : Audio creatives, e.g. audio ads that play during audio
  /// content.
  core.String? adType;

  /// The content outstream position.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONTENT_OUTSTREAM_POSITION_UNSPECIFIED" : Content outstream position is
  /// not specified in this version. This enum is a place holder for a default
  /// value and does not represent a real content outstream position.
  /// - "CONTENT_OUTSTREAM_POSITION_UNKNOWN" : The ad position is unknown in the
  /// content outstream.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_ARTICLE" : Ads that appear between the
  /// paragraphs of your pages.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_BANNER" : Ads that display on the top and
  /// the sides of a page.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_FEED" : Ads that appear in a scrollable
  /// stream of content. A feed is typically editorial (e.g. a list of articles
  /// or news) or listings (e.g. a list of products or services).
  /// - "CONTENT_OUTSTREAM_POSITION_INTERSTITIAL" : Ads shown before or between
  /// content loads.
  core.String? contentOutstreamPosition;

  $ContentOutstreamPositionAssignedTargetingOptionDetails({
    this.adType,
    this.contentOutstreamPosition,
  });

  $ContentOutstreamPositionAssignedTargetingOptionDetails.fromJson(
    core.Map json_,
  ) : this(
        adType: json_['adType'] as core.String?,
        contentOutstreamPosition:
            json_['contentOutstreamPosition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adType != null) 'adType': adType!,
    if (contentOutstreamPosition != null)
      'contentOutstreamPosition': contentOutstreamPosition!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentOutstreamPositionTargetingOptionDetails
/// - displayvideo:v3 : ContentOutstreamPositionTargetingOptionDetails
/// - displayvideo:v4 : ContentOutstreamPositionTargetingOptionDetails
class $ContentOutstreamPositionTargetingOptionDetails {
  /// The content outstream position.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_OUTSTREAM_POSITION_UNSPECIFIED" : Content outstream position is
  /// not specified in this version. This enum is a place holder for a default
  /// value and does not represent a real content outstream position.
  /// - "CONTENT_OUTSTREAM_POSITION_UNKNOWN" : The ad position is unknown in the
  /// content outstream.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_ARTICLE" : Ads that appear between the
  /// paragraphs of your pages.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_BANNER" : Ads that display on the top and
  /// the sides of a page.
  /// - "CONTENT_OUTSTREAM_POSITION_IN_FEED" : Ads that appear in a scrollable
  /// stream of content. A feed is typically editorial (e.g. a list of articles
  /// or news) or listings (e.g. a list of products or services).
  /// - "CONTENT_OUTSTREAM_POSITION_INTERSTITIAL" : Ads shown before or between
  /// content loads.
  core.String? contentOutstreamPosition;

  $ContentOutstreamPositionTargetingOptionDetails({
    this.contentOutstreamPosition,
  });

  $ContentOutstreamPositionTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        contentOutstreamPosition:
            json_['contentOutstreamPosition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentOutstreamPosition != null)
      'contentOutstreamPosition': contentOutstreamPosition!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentStreamTypeAssignedTargetingOptionDetails
/// - displayvideo:v3 : ContentStreamTypeAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentStreamTypeAssignedTargetingOptionDetails
class $ContentStreamTypeAssignedTargetingOptionDetails {
  /// The content stream type.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_STREAM_TYPE_UNSPECIFIED" : Content stream type is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real content stream type.
  /// - "CONTENT_LIVE_STREAM" : The content is being live-streamed.
  /// - "CONTENT_ON_DEMAND" : The content is viewed on-demand.
  core.String? contentStreamType;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_CONTENT_STREAM_TYPE`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $ContentStreamTypeAssignedTargetingOptionDetails({
    this.contentStreamType,
    this.targetingOptionId,
  });

  $ContentStreamTypeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        contentStreamType: json_['contentStreamType'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentStreamType != null) 'contentStreamType': contentStreamType!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ContentStreamTypeTargetingOptionDetails
/// - displayvideo:v3 : ContentStreamTypeTargetingOptionDetails
/// - displayvideo:v4 : ContentStreamTypeTargetingOptionDetails
class $ContentStreamTypeTargetingOptionDetails {
  /// The content stream type.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_STREAM_TYPE_UNSPECIFIED" : Content stream type is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real content stream type.
  /// - "CONTENT_LIVE_STREAM" : The content is being live-streamed.
  /// - "CONTENT_ON_DEMAND" : The content is viewed on-demand.
  core.String? contentStreamType;

  $ContentStreamTypeTargetingOptionDetails({this.contentStreamType});

  $ContentStreamTypeTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentStreamType: json_['contentStreamType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentStreamType != null) 'contentStreamType': contentStreamType!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : ContentThemeAssignedTargetingOptionDetails
/// - displayvideo:v4 : ContentThemeAssignedTargetingOptionDetails
class $ContentThemeAssignedTargetingOptionDetails {
  /// An enum for the DV360 content theme classifier.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_THEME_UNSPECIFIED" : Content theme is not specified or is
  /// unknown in this version.
  /// - "CONTENT_THEME_FIGHTING_VIDEO_GAMES" : Fighting video games.
  /// - "CONTENT_THEME_MATURE_GAMES" : Mature games.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_HEALTH_SOURCES" : Not yet determined
  /// health sources.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_NEWS_SOURCES" : Not yet determined
  /// news sources.
  /// - "CONTENT_THEME_POLITICS" : Politics.
  /// - "CONTENT_THEME_RECENT_NEWS" : Recent news.
  /// - "CONTENT_THEME_RELIGION" : Religion.
  /// - "CONTENT_THEME_UNPLEASANT_HEALTH_CONTENT" : Unpleasant health content.
  /// - "CONTENT_THEME_UNPLEASANT_NEWS" : Unpleasant news.
  core.String? contentTheme;

  /// An enum for the DV360 content theme classified to be EXCLUDED.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONTENT_THEME_UNSPECIFIED" : Content theme is not specified or is
  /// unknown in this version.
  /// - "CONTENT_THEME_FIGHTING_VIDEO_GAMES" : Fighting video games.
  /// - "CONTENT_THEME_MATURE_GAMES" : Mature games.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_HEALTH_SOURCES" : Not yet determined
  /// health sources.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_NEWS_SOURCES" : Not yet determined
  /// news sources.
  /// - "CONTENT_THEME_POLITICS" : Politics.
  /// - "CONTENT_THEME_RECENT_NEWS" : Recent news.
  /// - "CONTENT_THEME_RELIGION" : Religion.
  /// - "CONTENT_THEME_UNPLEASANT_HEALTH_CONTENT" : Unpleasant health content.
  /// - "CONTENT_THEME_UNPLEASANT_NEWS" : Unpleasant news.
  core.String? excludedContentTheme;

  /// ID of the content theme to be EXCLUDED.
  ///
  /// Required.
  core.String? excludedTargetingOptionId;

  $ContentThemeAssignedTargetingOptionDetails({
    this.contentTheme,
    this.excludedContentTheme,
    this.excludedTargetingOptionId,
  });

  $ContentThemeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        contentTheme: json_['contentTheme'] as core.String?,
        excludedContentTheme: json_['excludedContentTheme'] as core.String?,
        excludedTargetingOptionId:
            json_['excludedTargetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentTheme != null) 'contentTheme': contentTheme!,
    if (excludedContentTheme != null)
      'excludedContentTheme': excludedContentTheme!,
    if (excludedTargetingOptionId != null)
      'excludedTargetingOptionId': excludedTargetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : ContentThemeTargetingOptionDetails
/// - displayvideo:v4 : ContentThemeTargetingOptionDetails
class $ContentThemeTargetingOptionDetails {
  /// An enum for the DV360 content theme content classifier.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_THEME_UNSPECIFIED" : Content theme is not specified or is
  /// unknown in this version.
  /// - "CONTENT_THEME_FIGHTING_VIDEO_GAMES" : Fighting video games.
  /// - "CONTENT_THEME_MATURE_GAMES" : Mature games.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_HEALTH_SOURCES" : Not yet determined
  /// health sources.
  /// - "CONTENT_THEME_NOT_YET_DETERMINED_NEWS_SOURCES" : Not yet determined
  /// news sources.
  /// - "CONTENT_THEME_POLITICS" : Politics.
  /// - "CONTENT_THEME_RECENT_NEWS" : Recent news.
  /// - "CONTENT_THEME_RELIGION" : Religion.
  /// - "CONTENT_THEME_UNPLEASANT_HEALTH_CONTENT" : Unpleasant health content.
  /// - "CONTENT_THEME_UNPLEASANT_NEWS" : Unpleasant news.
  core.String? contentTheme;

  $ContentThemeTargetingOptionDetails({this.contentTheme});

  $ContentThemeTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentTheme: json_['contentTheme'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentTheme != null) 'contentTheme': contentTheme!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GdataContentTypeInfo
/// - discoveryengine:v1alpha : GdataContentTypeInfo
/// - discoveryengine:v1beta : GdataContentTypeInfo
/// - firebaseappdistribution:v1 : GdataContentTypeInfo
/// - walletobjects:v1 : ContentTypeInfo
class $ContentTypeInfo00 {
  /// Scotty's best guess of what the content type of the file is.
  core.String? bestGuess;

  /// The content type of the file derived by looking at specific bytes (i.e.
  /// "magic bytes") of the actual file.
  core.String? fromBytes;

  /// The content type of the file derived from the file extension of the
  /// original file name used by the client.
  core.String? fromFileName;

  /// The content type of the file as specified in the request headers,
  /// multipart headers, or RUPIO start request.
  core.String? fromHeader;

  /// The content type of the file derived from the file extension of the URL
  /// path.
  ///
  /// The URL path is assumed to represent a file name (which is typically only
  /// true for agents that are providing a REST API).
  core.String? fromUrlPath;

  $ContentTypeInfo00({
    this.bestGuess,
    this.fromBytes,
    this.fromFileName,
    this.fromHeader,
    this.fromUrlPath,
  });

  $ContentTypeInfo00.fromJson(core.Map json_)
    : this(
        bestGuess: json_['bestGuess'] as core.String?,
        fromBytes: json_['fromBytes'] as core.String?,
        fromFileName: json_['fromFileName'] as core.String?,
        fromHeader: json_['fromHeader'] as core.String?,
        fromUrlPath: json_['fromUrlPath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bestGuess != null) 'bestGuess': bestGuess!,
    if (fromBytes != null) 'fromBytes': fromBytes!,
    if (fromFileName != null) 'fromFileName': fromFileName!,
    if (fromHeader != null) 'fromHeader': fromHeader!,
    if (fromUrlPath != null) 'fromUrlPath': fromUrlPath!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : ContentTypeInfo
/// - cloudsupport:v2beta : ContentTypeInfo
class $ContentTypeInfo01 {
  /// # gdata.* are outside protos with mising documentation
  core.String? bestGuess;

  /// # gdata.* are outside protos with mising documentation
  core.String? fromBytes;

  /// # gdata.* are outside protos with mising documentation
  core.String? fromFileName;

  /// # gdata.* are outside protos with mising documentation
  core.String? fromHeader;

  /// # gdata.* are outside protos with mising documentation
  core.String? fromUrlPath;

  $ContentTypeInfo01({
    this.bestGuess,
    this.fromBytes,
    this.fromFileName,
    this.fromHeader,
    this.fromUrlPath,
  });

  $ContentTypeInfo01.fromJson(core.Map json_)
    : this(
        bestGuess: json_['bestGuess'] as core.String?,
        fromBytes: json_['fromBytes'] as core.String?,
        fromFileName: json_['fromFileName'] as core.String?,
        fromHeader: json_['fromHeader'] as core.String?,
        fromUrlPath: json_['fromUrlPath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bestGuess != null) 'bestGuess': bestGuess!,
    if (fromBytes != null) 'fromBytes': fromBytes!,
    if (fromFileName != null) 'fromFileName': fromFileName!,
    if (fromHeader != null) 'fromHeader': fromHeader!,
    if (fromUrlPath != null) 'fromUrlPath': fromUrlPath!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Context
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Context
class $Context {
  /// Timestamp when this Context was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Context
  core.String? description;

  /// User provided display name of the Context.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Contexts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Context (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Context.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Context.
  ///
  /// Immutable.
  core.String? name;

  /// A list of resource names of Contexts that are parents of this Context.
  ///
  /// A Context may have at most 10 parent_contexts.
  ///
  /// Output only.
  core.List<core.String>? parentContexts;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// Timestamp when this Context was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Context({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.parentContexts,
    this.schemaTitle,
    this.schemaVersion,
    this.updateTime,
  });

  $Context.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        parentContexts:
            (json_['parentContexts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        schemaTitle: json_['schemaTitle'] as core.String?,
        schemaVersion: json_['schemaVersion'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (parentContexts != null) 'parentContexts': parentContexts!,
    if (schemaTitle != null) 'schemaTitle': schemaTitle!,
    if (schemaVersion != null) 'schemaVersion': schemaVersion!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1AddContextChildrenRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1RemoveContextChildrenRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AddContextChildrenRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RemoveContextChildrenRequest
class $ContextChildrenRequest {
  /// The resource names of the child Contexts.
  core.List<core.String>? childContexts;

  $ContextChildrenRequest({this.childContexts});

  $ContextChildrenRequest.fromJson(core.Map json_)
    : this(
        childContexts:
            (json_['childContexts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (childContexts != null) 'childContexts': childContexts!,
  };
}

/// Used by:
///
/// - alloydb:v1 : ContinuousBackupSource
/// - alloydb:v1alpha : ContinuousBackupSource
/// - alloydb:v1beta : ContinuousBackupSource
class $ContinuousBackupSource {
  /// The source cluster from which to restore.
  ///
  /// This cluster must have continuous backup enabled for this operation to
  /// succeed. For the required format, see the comment on the Cluster.name
  /// field.
  ///
  /// Required.
  core.String? cluster;

  /// The point in time to restore to.
  ///
  /// Required.
  core.String? pointInTime;

  $ContinuousBackupSource({this.cluster, this.pointInTime});

  $ContinuousBackupSource.fromJson(core.Map json_)
    : this(
        cluster: json_['cluster'] as core.String?,
        pointInTime: json_['pointInTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cluster != null) 'cluster': cluster!,
    if (pointInTime != null) 'pointInTime': pointInTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ContinuousTestResult
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ContinuousTestResult
class $ContinuousTestResult {
  /// The resource name for the continuous test result.
  ///
  /// Format:
  /// `projects//locations//agents//environments//continuousTestResults/`.
  core.String? name;

  /// The result of this continuous test run, i.e. whether all the tests in this
  /// continuous test run pass or not.
  /// Possible string values are:
  /// - "AGGREGATED_TEST_RESULT_UNSPECIFIED" : Not specified. Should never be
  /// used.
  /// - "PASSED" : All the tests passed.
  /// - "FAILED" : At least one test did not pass.
  core.String? result;

  /// Time when the continuous testing run starts.
  core.String? runTime;

  /// A list of individual test case results names in this continuous test run.
  core.List<core.String>? testCaseResults;

  $ContinuousTestResult({
    this.name,
    this.result,
    this.runTime,
    this.testCaseResults,
  });

  $ContinuousTestResult.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        result: json_['result'] as core.String?,
        runTime: json_['runTime'] as core.String?,
        testCaseResults:
            (json_['testCaseResults'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (result != null) 'result': result!,
    if (runTime != null) 'runTime': runTime!,
    if (testCaseResults != null) 'testCaseResults': testCaseResults!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ControlFilterAction
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaControlFilterAction
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaControlFilterAction
class $ControlFilterAction {
  /// Specifies which data store's documents can be filtered by this control.
  ///
  /// Full data store name e.g.
  /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
  ///
  /// Required.
  core.String? dataStore;

  /// A filter to apply on the matching condition results.
  ///
  /// Required Syntax documentation:
  /// https://cloud.google.com/retail/docs/filter-and-order Maximum length is
  /// 5000 characters. Otherwise an INVALID ARGUMENT error is thrown.
  ///
  /// Required.
  core.String? filter;

  $ControlFilterAction({this.dataStore, this.filter});

  $ControlFilterAction.fromJson(core.Map json_)
    : this(
        dataStore: json_['dataStore'] as core.String?,
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ControlRedirectAction
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaControlRedirectAction
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaControlRedirectAction
class $ControlRedirectAction {
  /// The URI to which the shopper will be redirected.
  ///
  /// Required. URI must have length equal or less than 2000 characters.
  /// Otherwise an INVALID ARGUMENT error is thrown.
  ///
  /// Required.
  core.String? redirectUri;

  $ControlRedirectAction({this.redirectUri});

  $ControlRedirectAction.fromJson(core.Map json_)
    : this(redirectUri: json_['redirectUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (redirectUri != null) 'redirectUri': redirectUri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ControlSynonymsAction
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaControlSynonymsAction
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaControlSynonymsAction
class $ControlSynonymsAction {
  /// Defines a set of synonyms.
  ///
  /// Can specify up to 100 synonyms. Must specify at least 2 synonyms.
  /// Otherwise an INVALID ARGUMENT error is thrown.
  core.List<core.String>? synonyms;

  $ControlSynonymsAction({this.synonyms});

  $ControlSynonymsAction.fromJson(core.Map json_)
    : this(
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (synonyms != null) 'synonyms': synonyms!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ConversationContext
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaConversationContext
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaConversationContext
class $ConversationContext {
  /// The current active document the user opened.
  ///
  /// It contains the document resource reference.
  core.String? activeDocument;

  /// The current list of documents the user is seeing.
  ///
  /// It contains the document resource references.
  core.List<core.String>? contextDocuments;

  $ConversationContext({this.activeDocument, this.contextDocuments});

  $ConversationContext.fromJson(core.Map json_)
    : this(
        activeDocument: json_['activeDocument'] as core.String?,
        contextDocuments:
            (json_['contextDocuments'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeDocument != null) 'activeDocument': activeDocument!,
    if (contextDocuments != null) 'contextDocuments': contextDocuments!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ConversationContextReferenceContextContent
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ConversationContextReferenceContextContent
class $ConversationContextReferenceContextContent {
  /// The information ingested in a single request.
  ///
  /// Required.
  core.String? content;

  /// The format of the ingested string.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONTENT_FORMAT_UNSPECIFIED" : Unspecified content format.
  /// - "JSON" : Content was provided in JSON format.
  /// - "PLAIN_TEXT" : Content was provided as plain text.
  core.String? contentFormat;

  /// The time when this information was incorporated into the relevant context
  /// reference.
  ///
  /// Output only.
  core.String? ingestionTime;

  $ConversationContextReferenceContextContent({
    this.content,
    this.contentFormat,
    this.ingestionTime,
  });

  $ConversationContextReferenceContextContent.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        contentFormat: json_['contentFormat'] as core.String?,
        ingestionTime: json_['ingestionTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (contentFormat != null) 'contentFormat': contentFormat!,
    if (ingestionTime != null) 'ingestionTime': ingestionTime!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ConversationPhoneNumber
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ConversationPhoneNumber
class $ConversationPhoneNumber {
  /// Desired country code for the phone number.
  ///
  /// Output only.
  core.int? countryCode;

  /// The phone number to connect to this conversation.
  ///
  /// Output only.
  core.String? phoneNumber;

  $ConversationPhoneNumber({this.countryCode, this.phoneNumber});

  $ConversationPhoneNumber.fromJson(core.Map json_)
    : this(
        countryCode: json_['countryCode'] as core.int?,
        phoneNumber: json_['phoneNumber'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (countryCode != null) 'countryCode': countryCode!,
    if (phoneNumber != null) 'phoneNumber': phoneNumber!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ConversationTelephonyConnectionInfoMimeContent
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ConversationTelephonyConnectionInfoMimeContent
class $ConversationTelephonyConnectionInfoMimeContent {
  /// The content payload.
  ///
  /// Optional.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The mime type of the content.
  ///
  /// Optional.
  core.String? mimeType;

  $ConversationTelephonyConnectionInfoMimeContent({
    this.content,
    this.mimeType,
  });

  $ConversationTelephonyConnectionInfoMimeContent.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ConversationTelephonyConnectionInfoSipHeader
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ConversationTelephonyConnectionInfoSipHeader
class $ConversationTelephonyConnectionInfoSipHeader {
  /// The name of the header.
  ///
  /// Optional.
  core.String? name;

  /// The value of the header.
  ///
  /// Optional.
  core.String? value;

  $ConversationTelephonyConnectionInfoSipHeader({this.name, this.value});

  $ConversationTelephonyConnectionInfoSipHeader.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaConversionEventDefaultConversionValue
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaConversionEventDefaultConversionValue
class $ConversionEventDefaultConversionValue {
  /// When a conversion event for this event_name has no set currency, this
  /// currency will be applied as the default.
  ///
  /// Must be in ISO 4217 currency code format. See
  /// https://en.wikipedia.org/wiki/ISO_4217 for more information.
  core.String? currencyCode;

  /// This value will be used to populate the value for all conversions of the
  /// specified event_name where the event "value" parameter is unset.
  core.double? value;

  $ConversionEventDefaultConversionValue({this.currencyCode, this.value});

  $ConversionEventDefaultConversionValue.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CorpusStatus
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CorpusStatus
class $CorpusStatus {
  /// Only when the `state` field is ERROR.
  ///
  /// Output only.
  core.String? errorStatus;

  /// RagCorpus life state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNKNOWN" : This state is not supposed to happen.
  /// - "INITIALIZED" : RagCorpus resource entry is initialized, but hasn't done
  /// validation.
  /// - "ACTIVE" : RagCorpus is provisioned successfully and is ready to serve.
  /// - "ERROR" : RagCorpus is in a problematic situation. See `error_message`
  /// field for details.
  core.String? state;

  $CorpusStatus({this.errorStatus, this.state});

  $CorpusStatus.fromJson(core.Map json_)
    : this(
        errorStatus: json_['errorStatus'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorStatus != null) 'errorStatus': errorStatus!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CorroborateContentRequestParameters
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CorroborateContentRequestParameters
class $CorroborateContentRequestParameters {
  /// Only return claims with citation score larger than the threshold.
  ///
  /// Optional.
  core.double? citationThreshold;

  $CorroborateContentRequestParameters({this.citationThreshold});

  $CorroborateContentRequestParameters.fromJson(core.Map json_)
    : this(
        citationThreshold:
            (json_['citationThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citationThreshold != null) 'citationThreshold': citationThreshold!,
  };
}

/// Used by:
///
/// - compute:alpha : CorsPolicy
/// - compute:beta : CorsPolicy
/// - compute:v1 : CorsPolicy
class $CorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials.
  ///
  /// This field translates to the Access-Control-Allow-Credentials header.
  /// Default is false.
  core.bool? allowCredentials;

  /// Specifies the content for the Access-Control-Allow-Headers header.
  core.List<core.String>? allowHeaders;

  /// Specifies the content for the Access-Control-Allow-Methods header.
  core.List<core.String>? allowMethods;

  /// Specifies a regular expression that matches allowed origins.
  ///
  /// For more information, see regular expression syntax . An origin is allowed
  /// if it matches either an item in allowOrigins or an item in
  /// allowOriginRegexes. Regular expressions can only be used when the
  /// loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
  core.List<core.String>? allowOriginRegexes;

  /// Specifies the list of origins that is allowed to do CORS requests.
  ///
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String>? allowOrigins;

  /// If true, disables the CORS policy.
  ///
  /// The default value is false, which indicates that the CORS policy is in
  /// effect.
  core.bool? disabled;

  /// Specifies the content for the Access-Control-Expose-Headers header.
  core.List<core.String>? exposeHeaders;

  /// Specifies how long results of a preflight request can be cached in
  /// seconds.
  ///
  /// This field translates to the Access-Control-Max-Age header.
  core.int? maxAge;

  $CorsPolicy({
    this.allowCredentials,
    this.allowHeaders,
    this.allowMethods,
    this.allowOriginRegexes,
    this.allowOrigins,
    this.disabled,
    this.exposeHeaders,
    this.maxAge,
  });

  $CorsPolicy.fromJson(core.Map json_)
    : this(
        allowCredentials: json_['allowCredentials'] as core.bool?,
        allowHeaders:
            (json_['allowHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowMethods:
            (json_['allowMethods'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowOriginRegexes:
            (json_['allowOriginRegexes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowOrigins:
            (json_['allowOrigins'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        disabled: json_['disabled'] as core.bool?,
        exposeHeaders:
            (json_['exposeHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        maxAge: json_['maxAge'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowCredentials != null) 'allowCredentials': allowCredentials!,
    if (allowHeaders != null) 'allowHeaders': allowHeaders!,
    if (allowMethods != null) 'allowMethods': allowMethods!,
    if (allowOriginRegexes != null) 'allowOriginRegexes': allowOriginRegexes!,
    if (allowOrigins != null) 'allowOrigins': allowOrigins!,
    if (disabled != null) 'disabled': disabled!,
    if (exposeHeaders != null) 'exposeHeaders': exposeHeaders!,
    if (maxAge != null) 'maxAge': maxAge!,
  };
}

/// Used by:
///
/// - container:v1 : CostManagementConfig
/// - container:v1beta1 : CostManagementConfig
class $CostManagementConfig {
  /// Whether the feature is enabled or not.
  core.bool? enabled;

  $CostManagementConfig({this.enabled});

  $CostManagementConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - datastore:v1 : Count
/// - datastore:v1beta3 : Count
class $Count00 {
  /// Optional constraint on the maximum number of entities to count.
  ///
  /// This provides a way to set an upper bound on the number of entities to
  /// scan, limiting latency, and cost. Unspecified is interpreted as no bound.
  /// If a zero value is provided, a count result of zero should always be
  /// expected. High-Level Example: ``` AGGREGATE COUNT_UP_TO(1000) OVER (
  /// SELECT * FROM k ); ``` Requires: * Must be non-negative when present.
  ///
  /// Optional.
  core.String? upTo;

  $Count00({this.upTo});

  $Count00.fromJson(core.Map json_) : this(upTo: json_['upTo'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (upTo != null) 'upTo': upTo!,
  };
}

/// Used by:
///
/// - firestore:v1 : Count
/// - firestore:v1beta1 : Count
class $Count01 {
  /// Optional constraint on the maximum number of documents to count.
  ///
  /// This provides a way to set an upper bound on the number of documents to
  /// scan, limiting latency, and cost. Unspecified is interpreted as no bound.
  /// High-Level Example: ``` AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k
  /// ); ``` Requires: * Must be greater than zero when present.
  ///
  /// Optional.
  core.String? upTo;

  $Count01({this.upTo});

  $Count01.fromJson(core.Map json_) : this(upTo: json_['upTo'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (upTo != null) 'upTo': upTo!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CounterEvent
/// - displayvideo:v3 : CounterEvent
/// - displayvideo:v4 : CounterEvent
class $CounterEvent {
  /// The name of the counter event.
  ///
  /// Required.
  core.String? name;

  /// The name used to identify this counter event in reports.
  ///
  /// Required.
  core.String? reportingName;

  $CounterEvent({this.name, this.reportingName});

  $CounterEvent.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        reportingName: json_['reportingName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (reportingName != null) 'reportingName': reportingName!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : CpuUsageSample
/// - migrationcenter:v1alpha1 : CpuUsageSample
class $CpuUsageSample {
  /// Percentage of total CPU capacity utilized.
  ///
  /// Must be in the interval \[0, 100\]. On most systems can be calculated
  /// using 100 - idle percentage.
  core.double? utilizedPercentage;

  $CpuUsageSample({this.utilizedPercentage});

  $CpuUsageSample.fromJson(core.Map json_)
    : this(
        utilizedPercentage:
            (json_['utilizedPercentage'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (utilizedPercentage != null) 'utilizedPercentage': utilizedPercentage!,
  };
}

/// Used by:
///
/// - appengine:v1 : CpuUtilization
/// - appengine:v1beta : CpuUtilization
class $CpuUtilization {
  /// Period of time over which CPU utilization is calculated.
  core.String? aggregationWindowLength;

  /// Target CPU utilization ratio to maintain when scaling.
  ///
  /// Must be between 0 and 1.
  core.double? targetUtilization;

  $CpuUtilization({this.aggregationWindowLength, this.targetUtilization});

  $CpuUtilization.fromJson(core.Map json_)
    : this(
        aggregationWindowLength:
            json_['aggregationWindowLength'] as core.String?,
        targetUtilization:
            (json_['targetUtilization'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aggregationWindowLength != null)
      'aggregationWindowLength': aggregationWindowLength!,
    if (targetUtilization != null) 'targetUtilization': targetUtilization!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : CrawledUrl
/// - websecurityscanner:v1alpha : CrawledUrl
class $CrawledUrl {
  /// The body of the request that was used to visit the URL.
  ///
  /// Output only.
  core.String? body;

  /// The http method of the request that was used to visit the URL, in
  /// uppercase.
  ///
  /// Output only.
  core.String? httpMethod;

  /// The URL that was crawled.
  ///
  /// Output only.
  core.String? url;

  $CrawledUrl({this.body, this.httpMethod, this.url});

  $CrawledUrl.fromJson(core.Map json_)
    : this(
        body: json_['body'] as core.String?,
        httpMethod: json_['httpMethod'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (body != null) 'body': body!,
    if (httpMethod != null) 'httpMethod': httpMethod!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CreateAssetRequest
/// - displayvideo:v3 : CreateAssetRequest
/// - displayvideo:v4 : CreateAssetRequest
class $CreateAssetRequest {
  /// The filename of the asset, including the file extension.
  ///
  /// The filename must be UTF-8 encoded with a maximum size of 240 bytes.
  ///
  /// Required.
  core.String? filename;

  $CreateAssetRequest({this.filename});

  $CreateAssetRequest.fromJson(core.Map json_)
    : this(filename: json_['filename'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (filename != null) 'filename': filename!,
  };
}

/// Used by:
///
/// - dfareporting:v3.5 : CreativeAssetId
/// - dfareporting:v4 : CreativeAssetId
class $CreativeAssetId {
  /// Name of the creative asset.
  ///
  /// This is a required field while inserting an asset. After insertion, this
  /// assetIdentifier is used to identify the uploaded asset. Characters in the
  /// name must be alphanumeric or one of the following: ".-_ ". Spaces are
  /// allowed.
  core.String? name;

  /// Type of asset to upload.
  ///
  /// This is a required field. FLASH and IMAGE are no longer supported for new
  /// uploads. All image assets should use HTML_IMAGE.
  /// Possible string values are:
  /// - "IMAGE"
  /// - "FLASH"
  /// - "VIDEO"
  /// - "HTML"
  /// - "HTML_IMAGE"
  /// - "AUDIO"
  core.String? type;

  $CreativeAssetId({this.name, this.type});

  $CreativeAssetId.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - dfareporting:v3.5 : CreativeClickThroughUrl
/// - dfareporting:v4 : CreativeClickThroughUrl
class $CreativeClickThroughUrl {
  /// Read-only convenience field representing the actual URL that will be used
  /// for this click-through.
  ///
  /// The URL is computed as follows: - If landingPageId is specified then that
  /// landing page's URL is assigned to this field. - Otherwise, the
  /// customClickThroughUrl is assigned to this field.
  core.String? computedClickThroughUrl;

  /// Custom click-through URL.
  ///
  /// Applicable if the landingPageId field is left unset.
  core.String? customClickThroughUrl;

  /// ID of the landing page for the click-through URL.
  core.String? landingPageId;

  $CreativeClickThroughUrl({
    this.computedClickThroughUrl,
    this.customClickThroughUrl,
    this.landingPageId,
  });

  $CreativeClickThroughUrl.fromJson(core.Map json_)
    : this(
        computedClickThroughUrl:
            json_['computedClickThroughUrl'] as core.String?,
        customClickThroughUrl: json_['customClickThroughUrl'] as core.String?,
        landingPageId: json_['landingPageId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (computedClickThroughUrl != null)
      'computedClickThroughUrl': computedClickThroughUrl!,
    if (customClickThroughUrl != null)
      'customClickThroughUrl': customClickThroughUrl!,
    if (landingPageId != null) 'landingPageId': landingPageId!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : CreativeRequirements
/// - authorizedbuyersmarketplace:v1alpha : CreativeRequirements
class $CreativeRequirements {
  /// The format of the creative, only applicable for programmatic guaranteed
  /// and preferred deals.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATIVE_FORMAT_UNSPECIFIED" : A placeholder for an unspecified
  /// creative format.
  /// - "DISPLAY" : Banner creatives such as image or HTML5 assets.
  /// - "VIDEO" : Video creatives that can be played in a video player.
  /// - "AUDIO" : Audio creatives that can play during audio content or point to
  /// a third party ad server.
  core.String? creativeFormat;

  /// Specifies the creative pre-approval policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATIVE_PRE_APPROVAL_POLICY_UNSPECIFIED" : A placeholder for an
  /// undefined creative pre-approval policy.
  /// - "SELLER_PRE_APPROVAL_REQUIRED" : The seller needs to approve each
  /// creative before it can serve.
  /// - "SELLER_PRE_APPROVAL_NOT_REQUIRED" : The seller does not need to approve
  /// each creative before it can serve.
  core.String? creativePreApprovalPolicy;

  /// Specifies whether the creative is safeFrame compatible.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATIVE_SAFE_FRAME_COMPATIBILITY_UNSPECIFIED" : A placeholder for an
  /// undefined creative safe-frame compatibility.
  /// - "COMPATIBLE" : The creatives need to be compatible with the safe frame
  /// option.
  /// - "INCOMPATIBLE" : The creatives can be incompatible with the safe frame
  /// option.
  core.String? creativeSafeFrameCompatibility;

  /// The max duration of the video creative in milliseconds.
  ///
  /// only applicable for deals with video creatives.
  ///
  /// Output only.
  core.String? maxAdDurationMs;

  /// Specifies the creative source for programmatic deals.
  ///
  /// PUBLISHER means creative is provided by seller and ADVERTISER means
  /// creative is provided by the buyer.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PROGRAMMATIC_CREATIVE_SOURCE_UNSPECIFIED" : A placeholder for an
  /// undefined programmatic creative source.
  /// - "ADVERTISER" : The advertiser provides the creatives.
  /// - "PUBLISHER" : The publisher provides the creatives to be served.
  core.String? programmaticCreativeSource;

  /// Skippable video ads allow viewers to skip ads after 5 seconds.
  ///
  /// Only applicable for deals with video creatives.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SKIPPABLE_AD_TYPE_UNSPECIFIED" : A placeholder for an unspecified
  /// skippable ad type.
  /// - "SKIPPABLE" : Video ad that can be skipped after 5 seconds. This value
  /// will appear in RTB bid requests as
  /// SkippableBidRequestType::REQUIRE_SKIPPABLE.
  /// - "INSTREAM_SELECT" : Video ad that can be skipped after 5 seconds, and is
  /// counted as engaged view after 30 seconds. The creative is hosted on
  /// YouTube only, and viewcount of the YouTube video increments after the
  /// engaged view. This value will appear in RTB bid requests as
  /// SkippableBidRequestType::REQUIRE_SKIPPABLE.
  /// - "NOT_SKIPPABLE" : This video ad is not skippable. This value will appear
  /// in RTB bid requests as SkippableBidRequestType::BLOCK_SKIPPABLE.
  /// - "ANY" : This video ad can be skipped after 5 seconds or not-skippable.
  /// This value will appear in RTB bid requests as
  /// SkippableBidRequestType::ALLOW_SKIPPABLE.
  core.String? skippableAdType;

  $CreativeRequirements({
    this.creativeFormat,
    this.creativePreApprovalPolicy,
    this.creativeSafeFrameCompatibility,
    this.maxAdDurationMs,
    this.programmaticCreativeSource,
    this.skippableAdType,
  });

  $CreativeRequirements.fromJson(core.Map json_)
    : this(
        creativeFormat: json_['creativeFormat'] as core.String?,
        creativePreApprovalPolicy:
            json_['creativePreApprovalPolicy'] as core.String?,
        creativeSafeFrameCompatibility:
            json_['creativeSafeFrameCompatibility'] as core.String?,
        maxAdDurationMs: json_['maxAdDurationMs'] as core.String?,
        programmaticCreativeSource:
            json_['programmaticCreativeSource'] as core.String?,
        skippableAdType: json_['skippableAdType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creativeFormat != null) 'creativeFormat': creativeFormat!,
    if (creativePreApprovalPolicy != null)
      'creativePreApprovalPolicy': creativePreApprovalPolicy!,
    if (creativeSafeFrameCompatibility != null)
      'creativeSafeFrameCompatibility': creativeSafeFrameCompatibility!,
    if (maxAdDurationMs != null) 'maxAdDurationMs': maxAdDurationMs!,
    if (programmaticCreativeSource != null)
      'programmaticCreativeSource': programmaticCreativeSource!,
    if (skippableAdType != null) 'skippableAdType': skippableAdType!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : CriteriaTargeting
/// - authorizedbuyersmarketplace:v1 : CriteriaTargeting
/// - authorizedbuyersmarketplace:v1alpha : CriteriaTargeting
class $CriteriaTargeting {
  /// A list of numeric IDs to be excluded.
  core.List<core.String>? excludedCriteriaIds;

  /// A list of numeric IDs to be included.
  core.List<core.String>? targetedCriteriaIds;

  $CriteriaTargeting({this.excludedCriteriaIds, this.targetedCriteriaIds});

  $CriteriaTargeting.fromJson(core.Map json_)
    : this(
        excludedCriteriaIds:
            (json_['excludedCriteriaIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetedCriteriaIds:
            (json_['targetedCriteriaIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedCriteriaIds != null)
      'excludedCriteriaIds': excludedCriteriaIds!,
    if (targetedCriteriaIds != null)
      'targetedCriteriaIds': targetedCriteriaIds!,
  };
}

/// Used by:
///
/// - vision:v1 : CropHintsParams
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1CropHintsParams
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1CropHintsParams
class $CropHintsParams {
  /// Aspect ratios in floats, representing the ratio of the width to the height
  /// of the image.
  ///
  /// For example, if the desired aspect ratio is 4/3, the corresponding float
  /// value should be 1.33333. If not specified, the best possible crop is
  /// returned. The number of provided aspect ratios is limited to a maximum of
  /// 16; any aspect ratios provided after the 16th are ignored.
  core.List<core.double>? aspectRatios;

  $CropHintsParams({this.aspectRatios});

  $CropHintsParams.fromJson(core.Map json_)
    : this(
        aspectRatios:
            (json_['aspectRatios'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aspectRatios != null) 'aspectRatios': aspectRatios!,
  };
}

/// Used by:
///
/// - datafusion:v1 : CryptoKeyConfig
/// - datafusion:v1beta1 : CryptoKeyConfig
class $CryptoKeyConfig {
  /// The name of the key which is used to encrypt/decrypt customer data.
  ///
  /// For key in Cloud KMS, the key should be in the format of `projects / *
  /// /locations / * /keyRings / * /cryptoKeys / * `.
  ///
  /// Optional.
  core.String? keyReference;

  $CryptoKeyConfig({this.keyReference});

  $CryptoKeyConfig.fromJson(core.Map json_)
    : this(keyReference: json_['keyReference'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (keyReference != null) 'keyReference': keyReference!,
  };
}

/// Used by:
///
/// - alloydb:v1 : CsvExportOptions
/// - alloydb:v1alpha : CsvExportOptions
/// - alloydb:v1beta : CsvExportOptions
class $CsvExportOptions {
  /// Specifies the character that should appear before a data character that
  /// needs to be escaped.
  ///
  /// The default is the same as quote character. The value of this argument has
  /// to be a character in Hex ASCII Code.
  ///
  /// Optional.
  core.String? escapeCharacter;

  /// Specifies the character that separates columns within each row (line) of
  /// the file.
  ///
  /// The default is comma. The value of this argument has to be a character in
  /// Hex ASCII Code.
  ///
  /// Optional.
  core.String? fieldDelimiter;

  /// Specifies the quoting character to be used when a data value is quoted.
  ///
  /// The default is double-quote. The value of this argument has to be a
  /// character in Hex ASCII Code.
  ///
  /// Optional.
  core.String? quoteCharacter;

  /// The SELECT query used to extract the data.
  ///
  /// Required.
  core.String? selectQuery;

  $CsvExportOptions({
    this.escapeCharacter,
    this.fieldDelimiter,
    this.quoteCharacter,
    this.selectQuery,
  });

  $CsvExportOptions.fromJson(core.Map json_)
    : this(
        escapeCharacter: json_['escapeCharacter'] as core.String?,
        fieldDelimiter: json_['fieldDelimiter'] as core.String?,
        quoteCharacter: json_['quoteCharacter'] as core.String?,
        selectQuery: json_['selectQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (escapeCharacter != null) 'escapeCharacter': escapeCharacter!,
    if (fieldDelimiter != null) 'fieldDelimiter': fieldDelimiter!,
    if (quoteCharacter != null) 'quoteCharacter': quoteCharacter!,
    if (selectQuery != null) 'selectQuery': selectQuery!,
  };
}

/// Used by:
///
/// - alloydb:v1 : CsvImportOptions
/// - alloydb:v1alpha : CsvImportOptions
/// - alloydb:v1beta : CsvImportOptions
class $CsvImportOptions {
  /// The columns to which CSV data is imported.
  ///
  /// If not specified, all columns of the database table are loaded with CSV
  /// data.
  ///
  /// Optional.
  core.List<core.String>? columns;

  /// Specifies the character that should appear before a data character that
  /// needs to be escaped.
  ///
  /// The default is same as quote character. The value of this argument has to
  /// be a character in Hex ASCII Code.
  ///
  /// Optional.
  core.String? escapeCharacter;

  /// Specifies the character that separates columns within each row (line) of
  /// the file.
  ///
  /// The default is comma. The value of this argument has to be a character in
  /// Hex ASCII Code.
  ///
  /// Optional.
  core.String? fieldDelimiter;

  /// Specifies the quoting character to be used when a data value is quoted.
  ///
  /// The default is double-quote. The value of this argument has to be a
  /// character in Hex ASCII Code.
  ///
  /// Optional.
  core.String? quoteCharacter;

  /// The database table to import CSV file into.
  ///
  /// Required.
  core.String? table;

  $CsvImportOptions({
    this.columns,
    this.escapeCharacter,
    this.fieldDelimiter,
    this.quoteCharacter,
    this.table,
  });

  $CsvImportOptions.fromJson(core.Map json_)
    : this(
        columns:
            (json_['columns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        escapeCharacter: json_['escapeCharacter'] as core.String?,
        fieldDelimiter: json_['fieldDelimiter'] as core.String?,
        quoteCharacter: json_['quoteCharacter'] as core.String?,
        table: json_['table'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (columns != null) 'columns': columns!,
    if (escapeCharacter != null) 'escapeCharacter': escapeCharacter!,
    if (fieldDelimiter != null) 'fieldDelimiter': fieldDelimiter!,
    if (quoteCharacter != null) 'quoteCharacter': quoteCharacter!,
    if (table != null) 'table': table!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : CustomAccount
/// - websecurityscanner:v1alpha : CustomAccount
/// - websecurityscanner:v1beta : CustomAccount
class $CustomAccount {
  /// The login form URL of the website.
  ///
  /// Required.
  core.String? loginUrl;

  /// Input only.
  ///
  /// The password of the custom account. The credential is stored encrypted and
  /// not returned in any response nor included in audit logs.
  ///
  /// Required.
  core.String? password;

  /// The user name of the custom account.
  ///
  /// Required.
  core.String? username;

  $CustomAccount({this.loginUrl, this.password, this.username});

  $CustomAccount.fromJson(core.Map json_)
    : this(
        loginUrl: json_['loginUrl'] as core.String?,
        password: json_['password'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (loginUrl != null) 'loginUrl': loginUrl!,
    if (password != null) 'password': password!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CustomAttribute
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCustomAttribute
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCustomAttribute
class $CustomAttribute00 {
  /// The numerical values of this custom attribute.
  ///
  /// For example, `[2.3, 15.4]` when the key is "lengths_cm". Exactly one of
  /// CustomAttribute.text or CustomAttribute.numbers should be set. Otherwise,
  /// an `INVALID_ARGUMENT` error is returned.
  core.List<core.double>? numbers;

  /// The textual values of this custom attribute.
  ///
  /// For example, `["yellow", "green"]` when the key is "color". Empty string
  /// is not allowed. Otherwise, an `INVALID_ARGUMENT` error is returned.
  /// Exactly one of CustomAttribute.text or CustomAttribute.numbers should be
  /// set. Otherwise, an `INVALID_ARGUMENT` error is returned.
  core.List<core.String>? text;

  $CustomAttribute00({this.numbers, this.text});

  $CustomAttribute00.fromJson(core.Map json_)
    : this(
        numbers:
            (json_['numbers'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        text:
            (json_['text'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numbers != null) 'numbers': numbers!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2CustomAttribute
/// - retail:v2alpha : GoogleCloudRetailV2alphaCustomAttribute
/// - retail:v2beta : GoogleCloudRetailV2betaCustomAttribute
class $CustomAttribute01 {
  /// This field is normally ignored unless
  /// AttributesConfig.attribute_config_level of the Catalog is set to the
  /// deprecated 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode.
  ///
  /// For information about product-level attribute configuration, see
  /// [Configuration modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
  /// If true, custom attribute values are indexed, so that they can be
  /// filtered, faceted or boosted in SearchService.Search. This field is
  /// ignored in a UserEvent. See SearchRequest.filter,
  /// SearchRequest.facet_specs and SearchRequest.boost_spec for more details.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? indexable;

  /// The numerical values of this custom attribute.
  ///
  /// For example, `[2.3, 15.4]` when the key is "lengths_cm". Exactly one of
  /// text or numbers should be set. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  core.List<core.double>? numbers;

  /// This field is normally ignored unless
  /// AttributesConfig.attribute_config_level of the Catalog is set to the
  /// deprecated 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode.
  ///
  /// For information about product-level attribute configuration, see
  /// [Configuration modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
  /// If true, custom attribute values are searchable by text queries in
  /// SearchService.Search. This field is ignored in a UserEvent. Only set if
  /// type text is set. Otherwise, a INVALID_ARGUMENT error is returned.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? searchable;

  /// The textual values of this custom attribute.
  ///
  /// For example, `["yellow", "green"]` when the key is "color". Empty string
  /// is not allowed. Otherwise, an INVALID_ARGUMENT error is returned. Exactly
  /// one of text or numbers should be set. Otherwise, an INVALID_ARGUMENT error
  /// is returned.
  core.List<core.String>? text;

  $CustomAttribute01({
    this.indexable,
    this.numbers,
    this.searchable,
    this.text,
  });

  $CustomAttribute01.fromJson(core.Map json_)
    : this(
        indexable: json_['indexable'] as core.bool?,
        numbers:
            (json_['numbers'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        searchable: json_['searchable'] as core.bool?,
        text:
            (json_['text'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (indexable != null) 'indexable': indexable!,
    if (numbers != null) 'numbers': numbers!,
    if (searchable != null) 'searchable': searchable!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - jobs:v3 : CustomAttribute
/// - jobs:v3p1beta1 : CustomAttribute
class $CustomAttribute02 {
  /// If the `filterable` flag is true, the custom field values may be used for
  /// custom attribute filters JobQuery.custom_attribute_filter.
  ///
  /// If false, these values may not be used for custom attribute filters.
  /// Default is false.
  ///
  /// Optional.
  core.bool? filterable;

  /// Optional but exactly one of string_values or long_values must be
  /// specified.
  ///
  /// This field is used to perform number range search. (`EQ`, `GT`, `GE`,
  /// `LE`, `LT`) over filterable `long_value`. Currently at most 1 long_values
  /// is supported.
  core.List<core.String>? longValues;

  /// Optional but exactly one of string_values or long_values must be
  /// specified.
  ///
  /// This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or
  /// `CASE_INSENSITIVE_MATCH`) search. For filterable `string_value`s, a
  /// maximum total number of 200 values is allowed, with each `string_value`
  /// has a byte size of no more than 500B. For unfilterable `string_values`,
  /// the maximum total byte size of unfilterable `string_values` is 50KB. Empty
  /// string is not allowed.
  core.List<core.String>? stringValues;

  $CustomAttribute02({this.filterable, this.longValues, this.stringValues});

  $CustomAttribute02.fromJson(core.Map json_)
    : this(
        filterable: json_['filterable'] as core.bool?,
        longValues:
            (json_['longValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        stringValues:
            (json_['stringValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filterable != null) 'filterable': filterable!,
    if (longValues != null) 'longValues': longValues!,
    if (stringValues != null) 'stringValues': stringValues!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1CustomAttributeValue
/// - cloudidentity:v1beta1 : CustomAttributeValue
class $CustomAttributeValue {
  /// Represents a boolean value.
  core.bool? boolValue;

  /// Represents a double value.
  core.double? numberValue;

  /// Represents a string value.
  core.String? stringValue;

  $CustomAttributeValue({this.boolValue, this.numberValue, this.stringValue});

  $CustomAttributeValue.fromJson(core.Map json_)
    : this(
        boolValue: json_['boolValue'] as core.bool?,
        numberValue: (json_['numberValue'] as core.num?)?.toDouble(),
        stringValue: json_['stringValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boolValue != null) 'boolValue': boolValue!,
    if (numberValue != null) 'numberValue': numberValue!,
    if (stringValue != null) 'stringValue': stringValue!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : CustomBiddingAlgorithmRulesError
/// - displayvideo:v4 : CustomBiddingAlgorithmRulesError
class $CustomBiddingAlgorithmRulesError {
  /// The type of error.
  /// Possible string values are:
  /// - "ERROR_CODE_UNSPECIFIED" : The error is not specified or is unknown in
  /// this version.
  /// - "SYNTAX_ERROR" : The rules have a syntax error.
  /// - "CONSTRAINT_VIOLATION_ERROR" : The rules have a constraint violation
  /// error.
  /// - "INTERNAL_ERROR" : Internal errors were thrown while processing the
  /// rules.
  core.String? errorCode;

  $CustomBiddingAlgorithmRulesError({this.errorCode});

  $CustomBiddingAlgorithmRulesError.fromJson(core.Map json_)
    : this(errorCode: json_['errorCode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorCode != null) 'errorCode': errorCode!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : CustomBiddingAlgorithmRulesRef
/// - displayvideo:v4 : CustomBiddingAlgorithmRulesRef
class $CustomBiddingAlgorithmRulesRef {
  /// A resource name to be used in media.download to download the rules files.
  ///
  /// Or media.upload to upload the rules files. Resource names have the format
  /// `customBiddingAlgorithms/{custom_bidding_algorithm_id}/rulesRef/{ref_id}`.
  core.String? resourceName;

  $CustomBiddingAlgorithmRulesRef({this.resourceName});

  $CustomBiddingAlgorithmRulesRef.fromJson(core.Map json_)
    : this(resourceName: json_['resourceName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceName != null) 'resourceName': resourceName!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : CustomBiddingModelDetails
/// - displayvideo:v4 : CustomBiddingModelDetails
class $CustomBiddingModelDetails {
  /// The unique ID of the relevant advertiser.
  core.String? advertiserId;

  /// The readiness state of custom bidding model.
  /// Possible string values are:
  /// - "READINESS_STATE_UNSPECIFIED" : State is not specified or is unknown in
  /// this version.
  /// - "READINESS_STATE_ACTIVE" : The model is trained and ready for serving.
  /// - "READINESS_STATE_INSUFFICIENT_DATA" : There is not enough data to train
  /// the serving model.
  /// - "READINESS_STATE_TRAINING" : The model is training and not ready for
  /// serving.
  /// - "READINESS_STATE_NO_VALID_SCRIPT" : A valid custom bidding script has
  /// not been provided with which to train the model. This state will only be
  /// applied to algorithms whose `custom_bidding_algorithm_type` is
  /// `SCRIPT_BASED`.
  /// - "READINESS_STATE_EVALUATION_FAILURE" : A valid script was provided but
  /// failed evaluation. This is applicable for scripts that could not be
  /// evaluated in the alloted time.
  core.String? readinessState;

  /// The suspension state of custom bidding model.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SUSPENSION_STATE_UNSPECIFIED" : State is not specified or is unknown in
  /// this version.
  /// - "SUSPENSION_STATE_ENABLED" : Model is enabled, either recently used,
  /// currently used or scheduled to be used. The algorithm is actively scoring
  /// impressions for this advertiser.
  /// - "SUSPENSION_STATE_DORMANT" : Model has not been used recently. Although
  /// the model still acts as `ENABLED`, it will eventually be suspended if not
  /// used.
  /// - "SUSPENSION_STATE_SUSPENDED" : Model is suspended from scoring
  /// impressions and cannot serve. If the algorithm is assigned to a line item
  /// under this advertiser or otherwise updated, it will switch back to the
  /// `ENABLED` state and require time to prepare the serving model again.
  core.String? suspensionState;

  $CustomBiddingModelDetails({
    this.advertiserId,
    this.readinessState,
    this.suspensionState,
  });

  $CustomBiddingModelDetails.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        readinessState: json_['readinessState'] as core.String?,
        suspensionState: json_['suspensionState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (readinessState != null) 'readinessState': readinessState!,
    if (suspensionState != null) 'suspensionState': suspensionState!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CustomBiddingScriptRef
/// - displayvideo:v3 : CustomBiddingScriptRef
/// - displayvideo:v4 : CustomBiddingScriptRef
class $CustomBiddingScriptRef {
  /// A resource name to be used in media.download to Download the script files.
  ///
  /// Or media.upload to Upload the script files. Resource names have the format
  /// `customBiddingAlgorithms/{custom_bidding_algorithm_id}/scriptRef/{ref_id}`.
  core.String? resourceName;

  $CustomBiddingScriptRef({this.resourceName});

  $CustomBiddingScriptRef.fromJson(core.Map json_)
    : this(resourceName: json_['resourceName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceName != null) 'resourceName': resourceName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaCustomDimension
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaCustomDimension
class $CustomDimension {
  /// Description for this custom dimension.
  ///
  /// Max length of 150 characters.
  ///
  /// Optional.
  core.String? description;

  /// If set to true, sets this dimension as NPA and excludes it from ads
  /// personalization.
  ///
  /// This is currently only supported by user-scoped custom dimensions.
  ///
  /// Optional.
  core.bool? disallowAdsPersonalization;

  /// Display name for this custom dimension as shown in the Analytics UI.
  ///
  /// Max length of 82 characters, alphanumeric plus space and underscore
  /// starting with a letter. Legacy system-generated display names may contain
  /// square brackets, but updates to this field will never permit square
  /// brackets.
  ///
  /// Required.
  core.String? displayName;

  /// Resource name for this CustomDimension resource.
  ///
  /// Format: properties/{property}/customDimensions/{customDimension}
  ///
  /// Output only.
  core.String? name;

  /// Tagging parameter name for this custom dimension.
  ///
  /// If this is a user-scoped dimension, then this is the user property name.
  /// If this is an event-scoped dimension, then this is the event parameter
  /// name. If this is an item-scoped dimension, then this is the parameter name
  /// found in the eCommerce items array. May only contain alphanumeric and
  /// underscore characters, starting with a letter. Max length of 24 characters
  /// for user-scoped dimensions, 40 characters for event-scoped dimensions.
  ///
  /// Required. Immutable.
  core.String? parameterName;

  /// The scope of this dimension.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "DIMENSION_SCOPE_UNSPECIFIED" : Scope unknown or not specified.
  /// - "EVENT" : Dimension scoped to an event.
  /// - "USER" : Dimension scoped to a user.
  /// - "ITEM" : Dimension scoped to eCommerce items
  core.String? scope;

  $CustomDimension({
    this.description,
    this.disallowAdsPersonalization,
    this.displayName,
    this.name,
    this.parameterName,
    this.scope,
  });

  $CustomDimension.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        disallowAdsPersonalization:
            json_['disallowAdsPersonalization'] as core.bool?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        parameterName: json_['parameterName'] as core.String?,
        scope: json_['scope'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (disallowAdsPersonalization != null)
      'disallowAdsPersonalization': disallowAdsPersonalization!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (parameterName != null) 'parameterName': parameterName!,
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - compute:alpha : CustomErrorResponsePolicyCustomErrorResponseRule
/// - compute:beta : CustomErrorResponsePolicyCustomErrorResponseRule
/// - compute:v1 : CustomErrorResponsePolicyCustomErrorResponseRule
class $CustomErrorResponsePolicyCustomErrorResponseRule {
  /// Valid values include: - A number between 400 and 599: For example 401 or
  /// 503, in which case the load balancer applies the policy if the error code
  /// exactly matches this value.
  ///
  /// - 5xx: Load Balancer will apply the policy if the backend service responds
  /// with any response code in the range of 500 to 599. - 4xx: Load Balancer
  /// will apply the policy if the backend service responds with any response
  /// code in the range of 400 to 499. Values must be unique within
  /// matchResponseCodes and across all errorResponseRules of
  /// CustomErrorResponsePolicy.
  core.List<core.String>? matchResponseCodes;

  /// The HTTP status code returned with the response containing the custom
  /// error content.
  ///
  /// If overrideResponseCode is not supplied, the same response code returned
  /// by the original backend bucket or backend service is returned to the
  /// client.
  core.int? overrideResponseCode;

  /// The full path to a file within backendBucket .
  ///
  /// For example: /errors/defaultError.html path must start with a leading
  /// slash. path cannot have trailing slashes. If the file is not available in
  /// backendBucket or the load balancer cannot reach the BackendBucket, a
  /// simple Not Found Error is returned to the client. The value must be from 1
  /// to 1024 characters
  core.String? path;

  $CustomErrorResponsePolicyCustomErrorResponseRule({
    this.matchResponseCodes,
    this.overrideResponseCode,
    this.path,
  });

  $CustomErrorResponsePolicyCustomErrorResponseRule.fromJson(core.Map json_)
    : this(
        matchResponseCodes:
            (json_['matchResponseCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        overrideResponseCode: json_['overrideResponseCode'] as core.int?,
        path: json_['path'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (matchResponseCodes != null) 'matchResponseCodes': matchResponseCodes!,
    if (overrideResponseCode != null)
      'overrideResponseCode': overrideResponseCode!,
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : CustomInterceptProfile
/// - networksecurity:v1beta1 : CustomInterceptProfile
class $CustomInterceptProfile {
  /// The target InterceptEndpointGroup.
  ///
  /// When a firewall rule with this security profile attached matches a packet,
  /// the packet will be intercepted to the location-local target in this group.
  ///
  /// Required.
  core.String? interceptEndpointGroup;

  $CustomInterceptProfile({this.interceptEndpointGroup});

  $CustomInterceptProfile.fromJson(core.Map json_)
    : this(
        interceptEndpointGroup: json_['interceptEndpointGroup'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interceptEndpointGroup != null)
      'interceptEndpointGroup': interceptEndpointGroup!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CustomLabel
/// - displayvideo:v3 : CustomLabel
/// - displayvideo:v4 : CustomLabel
class $CustomLabel {
  /// The key of the label.
  /// Possible string values are:
  /// - "CUSTOM_LABEL_KEY_UNSPECIFIED" : Not specified or unknown.
  /// - "CUSTOM_LABEL_KEY_0" : Key index 0.
  /// - "CUSTOM_LABEL_KEY_1" : Key index 1.
  /// - "CUSTOM_LABEL_KEY_2" : Key index 2.
  /// - "CUSTOM_LABEL_KEY_3" : Key index 3.
  /// - "CUSTOM_LABEL_KEY_4" : Key index 4.
  core.String? key;

  /// The value of the label.
  core.String? value;

  $CustomLabel({this.key, this.value});

  $CustomLabel.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CustomList
/// - displayvideo:v3 : CustomList
/// - displayvideo:v4 : CustomList
class $CustomList {
  /// The unique ID of the custom list.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? customListId;

  /// The display name of the custom list.
  ///
  /// .
  ///
  /// Output only.
  core.String? displayName;

  /// The resource name of the custom list.
  ///
  /// Output only.
  core.String? name;

  $CustomList({this.customListId, this.displayName, this.name});

  $CustomList.fromJson(core.Map json_)
    : this(
        customListId: json_['customListId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customListId != null) 'customListId': customListId!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : CustomListTargetingSetting
/// - displayvideo:v3 : CustomListTargetingSetting
/// - displayvideo:v4 : CustomListTargetingSetting
class $CustomListTargetingSetting {
  /// Custom id of custom list targeting setting.
  ///
  /// This id is custom_list_id.
  ///
  /// Required.
  core.String? customListId;

  $CustomListTargetingSetting({this.customListId});

  $CustomListTargetingSetting.fromJson(core.Map json_)
    : this(customListId: json_['customListId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (customListId != null) 'customListId': customListId!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaCustomMetric
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaCustomMetric
class $CustomMetric {
  /// Description for this custom dimension.
  ///
  /// Max length of 150 characters.
  ///
  /// Optional.
  core.String? description;

  /// Display name for this custom metric as shown in the Analytics UI.
  ///
  /// Max length of 82 characters, alphanumeric plus space and underscore
  /// starting with a letter. Legacy system-generated display names may contain
  /// square brackets, but updates to this field will never permit square
  /// brackets.
  ///
  /// Required.
  core.String? displayName;

  /// The type for the custom metric's value.
  ///
  /// Required.
  /// Possible string values are:
  /// - "MEASUREMENT_UNIT_UNSPECIFIED" : MeasurementUnit unspecified or missing.
  /// - "STANDARD" : This metric uses default units.
  /// - "CURRENCY" : This metric measures a currency.
  /// - "FEET" : This metric measures feet.
  /// - "METERS" : This metric measures meters.
  /// - "KILOMETERS" : This metric measures kilometers.
  /// - "MILES" : This metric measures miles.
  /// - "MILLISECONDS" : This metric measures milliseconds.
  /// - "SECONDS" : This metric measures seconds.
  /// - "MINUTES" : This metric measures minutes.
  /// - "HOURS" : This metric measures hours.
  core.String? measurementUnit;

  /// Resource name for this CustomMetric resource.
  ///
  /// Format: properties/{property}/customMetrics/{customMetric}
  ///
  /// Output only.
  core.String? name;

  /// Tagging name for this custom metric.
  ///
  /// If this is an event-scoped metric, then this is the event parameter name.
  /// May only contain alphanumeric and underscore charactes, starting with a
  /// letter. Max length of 40 characters for event-scoped metrics.
  ///
  /// Required. Immutable.
  core.String? parameterName;

  /// Types of restricted data that this metric may contain.
  ///
  /// Required for metrics with CURRENCY measurement unit. Must be empty for
  /// metrics with a non-CURRENCY measurement unit.
  ///
  /// Optional.
  core.List<core.String>? restrictedMetricType;

  /// The scope of this custom metric.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "METRIC_SCOPE_UNSPECIFIED" : Scope unknown or not specified.
  /// - "EVENT" : Metric scoped to an event.
  core.String? scope;

  $CustomMetric({
    this.description,
    this.displayName,
    this.measurementUnit,
    this.name,
    this.parameterName,
    this.restrictedMetricType,
    this.scope,
  });

  $CustomMetric.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        measurementUnit: json_['measurementUnit'] as core.String?,
        name: json_['name'] as core.String?,
        parameterName: json_['parameterName'] as core.String?,
        restrictedMetricType:
            (json_['restrictedMetricType'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        scope: json_['scope'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (measurementUnit != null) 'measurementUnit': measurementUnit!,
    if (name != null) 'name': name!,
    if (parameterName != null) 'parameterName': parameterName!,
    if (restrictedMetricType != null)
      'restrictedMetricType': restrictedMetricType!,
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : CustomMirroringProfile
/// - networksecurity:v1beta1 : CustomMirroringProfile
class $CustomMirroringProfile {
  /// The target MirroringEndpointGroup.
  ///
  /// When a mirroring rule with this security profile attached matches a
  /// packet, a replica will be mirrored to the location-local target in this
  /// group.
  ///
  /// Required.
  core.String? mirroringEndpointGroup;

  $CustomMirroringProfile({this.mirroringEndpointGroup});

  $CustomMirroringProfile.fromJson(core.Map json_)
    : this(
        mirroringEndpointGroup: json_['mirroringEndpointGroup'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mirroringEndpointGroup != null)
      'mirroringEndpointGroup': mirroringEndpointGroup!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CustomOutputFormatConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CustomOutputFormatConfig
class $CustomOutputFormatConfig {
  /// Whether to return raw output.
  ///
  /// Optional.
  core.bool? returnRawOutput;

  $CustomOutputFormatConfig({this.returnRawOutput});

  $CustomOutputFormatConfig.fromJson(core.Map json_)
    : this(returnRawOutput: json_['returnRawOutput'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (returnRawOutput != null) 'returnRawOutput': returnRawOutput!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2CustomPronunciationParams
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1CustomPronunciationParams
class $CustomPronunciationParams00 {
  /// The phonetic encoding of the phrase.
  /// Possible string values are:
  /// - "PHONETIC_ENCODING_UNSPECIFIED" : Not specified.
  /// - "PHONETIC_ENCODING_IPA" : IPA, such as apple -\> pl.
  /// https://en.wikipedia.org/wiki/International_Phonetic_Alphabet
  /// - "PHONETIC_ENCODING_X_SAMPA" : X-SAMPA, such as apple -\> "{p@l".
  /// https://en.wikipedia.org/wiki/X-SAMPA
  core.String? phoneticEncoding;

  /// The phrase to which the customization is applied.
  ///
  /// The phrase can be multiple words, such as proper nouns, but shouldn't span
  /// the length of the sentence.
  core.String? phrase;

  /// The pronunciation of the phrase.
  ///
  /// This must be in the phonetic encoding specified above.
  core.String? pronunciation;

  $CustomPronunciationParams00({
    this.phoneticEncoding,
    this.phrase,
    this.pronunciation,
  });

  $CustomPronunciationParams00.fromJson(core.Map json_)
    : this(
        phoneticEncoding: json_['phoneticEncoding'] as core.String?,
        phrase: json_['phrase'] as core.String?,
        pronunciation: json_['pronunciation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (phoneticEncoding != null) 'phoneticEncoding': phoneticEncoding!,
    if (phrase != null) 'phrase': phrase!,
    if (pronunciation != null) 'pronunciation': pronunciation!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : CustomPronunciationParams
/// - texttospeech:v1beta1 : CustomPronunciationParams
class $CustomPronunciationParams01 {
  /// The phonetic encoding of the phrase.
  /// Possible string values are:
  /// - "PHONETIC_ENCODING_UNSPECIFIED" : Not specified.
  /// - "PHONETIC_ENCODING_IPA" : IPA, such as apple -\> pl.
  /// https://en.wikipedia.org/wiki/International_Phonetic_Alphabet
  /// - "PHONETIC_ENCODING_X_SAMPA" : X-SAMPA, such as apple -\> "{p@l".
  /// https://en.wikipedia.org/wiki/X-SAMPA
  /// - "PHONETIC_ENCODING_JAPANESE_YOMIGANA" : For reading-to-pron conversion
  /// to work well, the `pronunciation` field should only contain Kanji,
  /// Hiragana, and Katakana. The pronunciation can also contain pitch accents.
  /// The start of a pitch phrase is specified with `^` and the down-pitch
  /// position is specified with `!`, for example: phrase: pronunciation:^
  /// phrase: pronunciation:^! phrase: pronunciation:^! We currently only
  /// support the Tokyo dialect, which allows at most one down-pitch per phrase
  /// (i.e. at most one `!` between `^`).
  /// - "PHONETIC_ENCODING_PINYIN" : Used to specify pronunciations for Mandarin
  /// words. See https://en.wikipedia.org/wiki/Pinyin. For example: , the
  /// pronunciation is "chao2 yang2". The number represents the tone, and there
  /// is a space between syllables. Neutral tones are represented by 5, for
  /// example  "hai2 zi5".
  core.String? phoneticEncoding;

  /// The phrase to which the customization is applied.
  ///
  /// The phrase can be multiple words, such as proper nouns, but shouldn't span
  /// the length of the sentence.
  core.String? phrase;

  /// The pronunciation of the phrase.
  ///
  /// This must be in the phonetic encoding specified above.
  core.String? pronunciation;

  $CustomPronunciationParams01({
    this.phoneticEncoding,
    this.phrase,
    this.pronunciation,
  });

  $CustomPronunciationParams01.fromJson(core.Map json_)
    : this(
        phoneticEncoding: json_['phoneticEncoding'] as core.String?,
        phrase: json_['phrase'] as core.String?,
        pronunciation: json_['pronunciation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (phoneticEncoding != null) 'phoneticEncoding': phoneticEncoding!,
    if (phrase != null) 'phrase': phrase!,
    if (pronunciation != null) 'pronunciation': pronunciation!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : CustomRegionConfig
/// - metastore:v1beta : CustomRegionConfig
class $CustomRegionConfig {
  /// The list of read-only regions where the metastore service runs in.
  ///
  /// These regions should be part (or subset) of the multi-region.
  ///
  /// Optional.
  core.List<core.String>? readOnlyRegions;

  /// The list of read-write regions where the metastore service runs in.
  ///
  /// These regions should be part (or subset) of the multi-region.
  ///
  /// Required.
  core.List<core.String>? readWriteRegions;

  $CustomRegionConfig({this.readOnlyRegions, this.readWriteRegions});

  $CustomRegionConfig.fromJson(core.Map json_)
    : this(
        readOnlyRegions:
            (json_['readOnlyRegions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        readWriteRegions:
            (json_['readWriteRegions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (readOnlyRegions != null) 'readOnlyRegions': readOnlyRegions!,
    if (readWriteRegions != null) 'readWriteRegions': readWriteRegions!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1CustomTuningModel
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaCustomTuningModel
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaCustomTuningModel
class $CustomTuningModel {
  /// Deprecated: Timestamp the Model was created at.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? createTime;

  /// The display name of the model.
  core.String? displayName;

  /// Currently this is only populated if the model state is
  /// `INPUT_VALIDATION_FAILED`.
  core.String? errorMessage;

  /// The metrics of the trained model.
  core.Map<core.String, core.double>? metrics;

  /// The state that the model is in (e.g.`TRAINING` or `TRAINING_FAILED`).
  /// Possible string values are:
  /// - "MODEL_STATE_UNSPECIFIED" : Default value.
  /// - "TRAINING_PAUSED" : The model is in a paused training state.
  /// - "TRAINING" : The model is currently training.
  /// - "TRAINING_COMPLETE" : The model has successfully completed training.
  /// - "READY_FOR_SERVING" : The model is ready for serving.
  /// - "TRAINING_FAILED" : The model training failed.
  /// - "NO_IMPROVEMENT" : The model training finished successfully but metrics
  /// did not improve.
  /// - "INPUT_VALIDATION_FAILED" : Input data validation failed. Model training
  /// didn't start.
  core.String? modelState;

  /// The version of the model.
  core.String? modelVersion;

  /// The fully qualified resource name of the model.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/customTuningModels/{custom_tuning_model}`.
  /// Model must be an alpha-numerical string with limit of 40 characters.
  ///
  /// Required.
  core.String? name;

  /// Timestamp the model training was initiated.
  core.String? trainingStartTime;

  $CustomTuningModel({
    this.createTime,
    this.displayName,
    this.errorMessage,
    this.metrics,
    this.modelState,
    this.modelVersion,
    this.name,
    this.trainingStartTime,
  });

  $CustomTuningModel.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
        metrics: (json_['metrics'] as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) =>
                  core.MapEntry(key, (value as core.num).toDouble()),
            ),
        modelState: json_['modelState'] as core.String?,
        modelVersion: json_['modelVersion'] as core.String?,
        name: json_['name'] as core.String?,
        trainingStartTime: json_['trainingStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (metrics != null) 'metrics': metrics!,
    if (modelState != null) 'modelState': modelState!,
    if (modelVersion != null) 'modelVersion': modelVersion!,
    if (name != null) 'name': name!,
    if (trainingStartTime != null) 'trainingStartTime': trainingStartTime!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : CustomVoiceParams
/// - texttospeech:v1beta1 : CustomVoiceParams
class $CustomVoiceParams {
  /// The name of the AutoML model that synthesizes the custom voice.
  ///
  /// Required.
  core.String? model;

  /// The usage of the synthesized audio to be reported.
  ///
  /// Optional. Deprecated.
  /// Possible string values are:
  /// - "REPORTED_USAGE_UNSPECIFIED" : Request with reported usage unspecified
  /// will be rejected.
  /// - "REALTIME" : For scenarios where the synthesized audio is not
  /// downloadable and can only be used once. For example, real-time request in
  /// IVR system.
  /// - "OFFLINE" : For scenarios where the synthesized audio is downloadable
  /// and can be reused. For example, the synthesized audio is downloaded,
  /// stored in customer service system and played repeatedly.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? reportedUsage;

  $CustomVoiceParams({this.model, this.reportedUsage});

  $CustomVoiceParams.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        reportedUsage: json_['reportedUsage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (reportedUsage != null) 'reportedUsage': reportedUsage!,
  };
}

/// Used by:
///
/// - compute:alpha : CustomerEncryptionKey
/// - compute:beta : CustomerEncryptionKey
/// - compute:v1 : CustomerEncryptionKey
class $CustomerEncryptionKey00 {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  ///
  /// For example: "kmsKeyName":
  /// "projects/kms_project_id/locations/region/keyRings/
  /// key_region/cryptoKeys/key The fully-qualifed key name may be returned for
  /// resource GET requests. For example: "kmsKeyName":
  /// "projects/kms_project_id/locations/region/keyRings/
  /// key_region/cryptoKeys/key /cryptoKeyVersions/1
  core.String? kmsKeyName;

  /// The service account being used for the encryption request for the given
  /// KMS key.
  ///
  /// If absent, the Compute Engine default service account is used. For
  /// example: "kmsKeyServiceAccount": "name@project_id.iam.gserviceaccount.com/
  core.String? kmsKeyServiceAccount;

  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  ///
  /// You can provide either the rawKey or the rsaEncryptedKey. For example:
  /// "rawKey": "SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0="
  core.String? rawKey;

  /// Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
  /// customer-supplied encryption key to either encrypt or decrypt this
  /// resource.
  ///
  /// You can provide either the rawKey or the rsaEncryptedKey. For example:
  /// "rsaEncryptedKey":
  /// "ieCx/NcW06PcT7Ep1X6LUTc/hLvUDYyzSZPPVCVPTVEohpeHASqC8uw5TzyO9U+Fka9JFH
  /// z0mBibXUInrC/jEk014kCK/NPjYgEMOyssZ4ZINPKxlUh2zn1bV+MCaTICrdmuSBTWlUUiFoD
  /// D6PYznLwh8ZNdaheCeZ8ewEXgFQ8V+sDroLaN3Xs3MDTXQEMMoNUXMCZEIpg9Vtp9x2oe=="
  /// The key must meet the following requirements before you can provide it to
  /// Compute Engine: 1. The key is wrapped using a RSA public key certificate
  /// provided by Google. 2. After being wrapped, the key must be encoded in RFC
  /// 4648 base64 encoding. Gets the RSA public key certificate provided by
  /// Google at:
  /// https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem
  core.String? rsaEncryptedKey;

  /// The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
  /// encryption key that protects this resource.
  ///
  /// Output only.
  core.String? sha256;

  $CustomerEncryptionKey00({
    this.kmsKeyName,
    this.kmsKeyServiceAccount,
    this.rawKey,
    this.rsaEncryptedKey,
    this.sha256,
  });

  $CustomerEncryptionKey00.fromJson(core.Map json_)
    : this(
        kmsKeyName: json_['kmsKeyName'] as core.String?,
        kmsKeyServiceAccount: json_['kmsKeyServiceAccount'] as core.String?,
        rawKey: json_['rawKey'] as core.String?,
        rsaEncryptedKey: json_['rsaEncryptedKey'] as core.String?,
        sha256: json_['sha256'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
    if (kmsKeyServiceAccount != null)
      'kmsKeyServiceAccount': kmsKeyServiceAccount!,
    if (rawKey != null) 'rawKey': rawKey!,
    if (rsaEncryptedKey != null) 'rsaEncryptedKey': rsaEncryptedKey!,
    if (sha256 != null) 'sha256': sha256!,
  };
}

/// Used by:
///
/// - workstations:v1 : CustomerEncryptionKey
/// - workstations:v1beta : CustomerEncryptionKey
class $CustomerEncryptionKey01 {
  /// The name of the Google Cloud KMS encryption key.
  ///
  /// For example,
  /// `"projects/PROJECT_ID/locations/REGION/keyRings/KEY_RING/cryptoKeys/KEY_NAME"`.
  /// The key must be in the same region as the workstation configuration.
  ///
  /// Immutable.
  core.String? kmsKey;

  /// The service account to use with the specified KMS key.
  ///
  /// We recommend that you use a separate service account and follow KMS best
  /// practices. For more information, see
  /// [Separation of duties](https://cloud.google.com/kms/docs/separation-of-duties)
  /// and `gcloud kms keys add-iam-policy-binding`
  /// \[`--member`\](https://cloud.google.com/sdk/gcloud/reference/kms/keys/add-iam-policy-binding#--member).
  ///
  /// Immutable.
  core.String? kmsKeyServiceAccount;

  $CustomerEncryptionKey01({this.kmsKey, this.kmsKeyServiceAccount});

  $CustomerEncryptionKey01.fromJson(core.Map json_)
    : this(
        kmsKey: json_['kmsKey'] as core.String?,
        kmsKeyServiceAccount: json_['kmsKeyServiceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (kmsKeyServiceAccount != null)
      'kmsKeyServiceAccount': kmsKeyServiceAccount!,
  };
}

/// Used by:
///
/// - secretmanager:v1 : CustomerManagedEncryption
/// - secretmanager:v1beta2 : CustomerManagedEncryption
class $CustomerManagedEncryption {
  /// The resource name of the Cloud KMS CryptoKey used to encrypt secret
  /// payloads.
  ///
  /// For secrets using the UserManaged replication policy type, Cloud KMS
  /// CryptoKeys must reside in the same location as the replica location. For
  /// secrets using the Automatic replication policy type, Cloud KMS CryptoKeys
  /// must reside in `global`. The expected format is `projects / * /locations /
  /// * /keyRings / * /cryptoKeys / * `.
  ///
  /// Required.
  core.String? kmsKeyName;

  $CustomerManagedEncryption({this.kmsKeyName});

  $CustomerManagedEncryption.fromJson(core.Map json_)
    : this(kmsKeyName: json_['kmsKeyName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - secretmanager:v1 : CustomerManagedEncryptionStatus
/// - secretmanager:v1beta2 : CustomerManagedEncryptionStatus
class $CustomerManagedEncryptionStatus {
  /// The resource name of the Cloud KMS CryptoKeyVersion used to encrypt the
  /// secret payload, in the following format: `projects / * /locations / *
  /// /keyRings / * /cryptoKeys / * /versions / * `.
  ///
  /// Required.
  core.String? kmsKeyVersionName;

  $CustomerManagedEncryptionStatus({this.kmsKeyVersionName});

  $CustomerManagedEncryptionStatus.fromJson(core.Map json_)
    : this(kmsKeyVersionName: json_['kmsKeyVersionName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyVersionName != null) 'kmsKeyVersionName': kmsKeyVersionName!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : CustomerOnboardingStep
/// - cloudcontrolspartner:v1beta : CustomerOnboardingStep
class $CustomerOnboardingStep {
  /// Current state of the step
  ///
  /// Output only.
  /// Possible string values are:
  /// - "COMPLETION_STATE_UNSPECIFIED" : Unspecified completion state.
  /// - "PENDING" : Task started (has start date) but not yet completed.
  /// - "SUCCEEDED" : Succeeded state.
  /// - "FAILED" : Failed state.
  /// - "NOT_APPLICABLE" : Not applicable state.
  core.String? completionState;

  /// The completion time of the onboarding step
  core.String? completionTime;

  /// The starting time of the onboarding step
  core.String? startTime;

  /// The onboarding step
  /// Possible string values are:
  /// - "STEP_UNSPECIFIED" : Unspecified step
  /// - "KAJ_ENROLLMENT" : KAJ Enrollment
  /// - "CUSTOMER_ENVIRONMENT" : Customer Environment
  core.String? step;

  $CustomerOnboardingStep({
    this.completionState,
    this.completionTime,
    this.startTime,
    this.step,
  });

  $CustomerOnboardingStep.fromJson(core.Map json_)
    : this(
        completionState: json_['completionState'] as core.String?,
        completionTime: json_['completionTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completionState != null) 'completionState': completionState!,
    if (completionTime != null) 'completionTime': completionTime!,
    if (startTime != null) 'startTime': startTime!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : CutoverForecast
/// - vmmigration:v1alpha1 : CutoverForecast
class $CutoverForecast {
  /// Estimation of the CutoverJob duration.
  ///
  /// Output only.
  core.String? estimatedCutoverJobDuration;

  $CutoverForecast({this.estimatedCutoverJobDuration});

  $CutoverForecast.fromJson(core.Map json_)
    : this(
        estimatedCutoverJobDuration:
            json_['estimatedCutoverJobDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (estimatedCutoverJobDuration != null)
      'estimatedCutoverJobDuration': estimatedCutoverJobDuration!,
  };
}

/// Used by:
///
/// - container:v1 : DNSConfig
/// - container:v1beta1 : DNSConfig
class $DNSConfig {
  /// The domain used in Additive VPC scope.
  ///
  /// Optional.
  core.String? additiveVpcScopeDnsDomain;

  /// cluster_dns indicates which in-cluster DNS provider should be used.
  /// Possible string values are:
  /// - "PROVIDER_UNSPECIFIED" : Default value
  /// - "PLATFORM_DEFAULT" : Use GKE default DNS provider(kube-dns) for DNS
  /// resolution.
  /// - "CLOUD_DNS" : Use CloudDNS for DNS resolution.
  /// - "KUBE_DNS" : Use KubeDNS for DNS resolution.
  core.String? clusterDns;

  /// cluster_dns_domain is the suffix used for all cluster service records.
  core.String? clusterDnsDomain;

  /// cluster_dns_scope indicates the scope of access to cluster DNS records.
  /// Possible string values are:
  /// - "DNS_SCOPE_UNSPECIFIED" : Default value, will be inferred as cluster
  /// scope.
  /// - "CLUSTER_SCOPE" : DNS records are accessible from within the cluster.
  /// - "VPC_SCOPE" : DNS records are accessible from within the VPC.
  core.String? clusterDnsScope;

  $DNSConfig({
    this.additiveVpcScopeDnsDomain,
    this.clusterDns,
    this.clusterDnsDomain,
    this.clusterDnsScope,
  });

  $DNSConfig.fromJson(core.Map json_)
    : this(
        additiveVpcScopeDnsDomain:
            json_['additiveVpcScopeDnsDomain'] as core.String?,
        clusterDns: json_['clusterDns'] as core.String?,
        clusterDnsDomain: json_['clusterDnsDomain'] as core.String?,
        clusterDnsScope: json_['clusterDnsScope'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (additiveVpcScopeDnsDomain != null)
      'additiveVpcScopeDnsDomain': additiveVpcScopeDnsDomain!,
    if (clusterDns != null) 'clusterDns': clusterDns!,
    if (clusterDnsDomain != null) 'clusterDnsDomain': clusterDnsDomain!,
    if (clusterDnsScope != null) 'clusterDnsScope': clusterDnsScope!,
  };
}

/// Used by:
///
/// - container:v1 : DNSEndpointConfig
/// - container:v1beta1 : DNSEndpointConfig
class $DNSEndpointConfig {
  /// Controls whether user traffic is allowed over this endpoint.
  ///
  /// Note that GCP-managed services may still use the endpoint even if this is
  /// false.
  core.bool? allowExternalTraffic;

  /// The cluster's DNS endpoint configuration.
  ///
  /// A DNS format address. This is accessible from the public internet. Ex:
  /// uid.us-central1.gke.goog. Always present, but the behavior may change
  /// according to the value of DNSEndpointConfig.allow_external_traffic.
  ///
  /// Output only.
  core.String? endpoint;

  $DNSEndpointConfig({this.allowExternalTraffic, this.endpoint});

  $DNSEndpointConfig.fromJson(core.Map json_)
    : this(
        allowExternalTraffic: json_['allowExternalTraffic'] as core.bool?,
        endpoint: json_['endpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowExternalTraffic != null)
      'allowExternalTraffic': allowExternalTraffic!,
    if (endpoint != null) 'endpoint': endpoint!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : DSSEHint
/// - containeranalysis:v1alpha1 : DSSEHint
class $DSSEHint {
  /// The human readable name of this attestation authority, for example
  /// "cloudbuild-prod".
  ///
  /// Required.
  core.String? humanReadableName;

  $DSSEHint({this.humanReadableName});

  $DSSEHint.fromJson(core.Map json_)
    : this(humanReadableName: json_['humanReadableName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (humanReadableName != null) 'humanReadableName': humanReadableName!,
  };
}

/// Used by:
///
/// - composer:v1 : DagProcessorResource
/// - composer:v1beta1 : DagProcessorResource
class $DagProcessorResource {
  /// The number of DAG processors.
  ///
  /// If not provided or set to 0, a single DAG processor instance will be
  /// created.
  ///
  /// Optional.
  core.int? count;

  /// CPU request and limit for a single Airflow DAG processor replica.
  ///
  /// Optional.
  core.double? cpu;

  /// Memory (GB) request and limit for a single Airflow DAG processor replica.
  ///
  /// Optional.
  core.double? memoryGb;

  /// Storage (GB) request and limit for a single Airflow DAG processor replica.
  ///
  /// Optional.
  core.double? storageGb;

  $DagProcessorResource({this.count, this.cpu, this.memoryGb, this.storageGb});

  $DagProcessorResource.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.int?,
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        memoryGb: (json_['memoryGb'] as core.num?)?.toDouble(),
        storageGb: (json_['storageGb'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (cpu != null) 'cpu': cpu!,
    if (memoryGb != null) 'memoryGb': memoryGb!,
    if (storageGb != null) 'storageGb': storageGb!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : DailyResourceUsageAggregationStats
/// - migrationcenter:v1alpha1 : DailyResourceUsageAggregationStats
class $DailyResourceUsageAggregationStats {
  /// Average usage value.
  core.double? average;

  /// Median usage value.
  core.double? median;

  /// 95th percentile usage value.
  core.double? ninteyFifthPercentile;

  /// Peak usage value.
  core.double? peak;

  $DailyResourceUsageAggregationStats({
    this.average,
    this.median,
    this.ninteyFifthPercentile,
    this.peak,
  });

  $DailyResourceUsageAggregationStats.fromJson(core.Map json_)
    : this(
        average: (json_['average'] as core.num?)?.toDouble(),
        median: (json_['median'] as core.num?)?.toDouble(),
        ninteyFifthPercentile:
            (json_['ninteyFifthPercentile'] as core.num?)?.toDouble(),
        peak: (json_['peak'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (average != null) 'average': average!,
    if (median != null) 'median': median!,
    if (ninteyFifthPercentile != null)
      'ninteyFifthPercentile': ninteyFifthPercentile!,
    if (peak != null) 'peak': peak!,
  };
}

/// Used by:
///
/// - netapp:v1 : DailySchedule
/// - netapp:v1beta1 : DailySchedule
class $DailySchedule {
  /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
  core.double? hour;

  /// Set the minute of the hour to start the snapshot (0-59), defaults to the
  /// top of the hour (0).
  core.double? minute;

  /// The maximum number of Snapshots to keep for the hourly schedule
  core.double? snapshotsToKeep;

  $DailySchedule({this.hour, this.minute, this.snapshotsToKeep});

  $DailySchedule.fromJson(core.Map json_)
    : this(
        hour: (json_['hour'] as core.num?)?.toDouble(),
        minute: (json_['minute'] as core.num?)?.toDouble(),
        snapshotsToKeep: (json_['snapshotsToKeep'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hour != null) 'hour': hour!,
    if (minute != null) 'minute': minute!,
    if (snapshotsToKeep != null) 'snapshotsToKeep': snapshotsToKeep!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DataCacheConfig
/// - sqladmin:v1beta4 : DataCacheConfig
class $DataCacheConfig {
  /// Whether data cache is enabled for the instance.
  core.bool? dataCacheEnabled;

  $DataCacheConfig({this.dataCacheEnabled});

  $DataCacheConfig.fromJson(core.Map json_)
    : this(dataCacheEnabled: json_['dataCacheEnabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataCacheEnabled != null) 'dataCacheEnabled': dataCacheEnabled!,
  };
}

/// Used by:
///
/// - metastore:v1 : DataCatalogConfig
/// - metastore:v1alpha : DataCatalogConfig
/// - metastore:v1beta : DataCatalogConfig
class $DataCatalogConfig {
  /// Defines whether the metastore metadata should be synced to Data Catalog.
  ///
  /// The default value is to disable syncing metastore metadata to Data
  /// Catalog.
  ///
  /// Optional.
  core.bool? enabled;

  $DataCatalogConfig({this.enabled});

  $DataCatalogConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DataItem
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DataItem
class $DataItem {
  /// Timestamp when this DataItem was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your DataItems.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one DataItem(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the DataItem.
  ///
  /// Output only.
  core.String? name;

  /// The data that the DataItem represents (for example, an image or a text
  /// snippet).
  ///
  /// The schema of the payload is stored in the parent Dataset's metadata
  /// schema's dataItemSchemaUri field.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this DataItem was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $DataItem({
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  $DataItem.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        payload: json_['payload'],
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (payload != null) 'payload': payload!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : DataProvider
/// - analyticshub:v1beta1 : DataProvider
class $DataProvider {
  /// Name of the data provider.
  ///
  /// Optional.
  core.String? name;

  /// Email or URL of the data provider.
  ///
  /// Max Length: 1000 bytes.
  ///
  /// Optional.
  core.String? primaryContact;

  $DataProvider({this.name, this.primaryContact});

  $DataProvider.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        primaryContact: json_['primaryContact'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (primaryContact != null) 'primaryContact': primaryContact!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaDataRetentionSettings
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaDataRetentionSettings
class $DataRetentionSettings {
  /// The length of time that event-level data is retained.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RETENTION_DURATION_UNSPECIFIED" : Data retention time duration is not
  /// specified.
  /// - "TWO_MONTHS" : The data retention time duration is 2 months.
  /// - "FOURTEEN_MONTHS" : The data retention time duration is 14 months.
  /// - "TWENTY_SIX_MONTHS" : The data retention time duration is 26 months.
  /// Available to 360 properties only. Available for event data only.
  /// - "THIRTY_EIGHT_MONTHS" : The data retention time duration is 38 months.
  /// Available to 360 properties only. Available for event data only.
  /// - "FIFTY_MONTHS" : The data retention time duration is 50 months.
  /// Available to 360 properties only. Available for event data only.
  core.String? eventDataRetention;

  /// Resource name for this DataRetentionSetting resource.
  ///
  /// Format: properties/{property}/dataRetentionSettings
  ///
  /// Output only.
  core.String? name;

  /// If true, reset the retention period for the user identifier with every
  /// event from that user.
  core.bool? resetUserDataOnNewActivity;

  /// The length of time that user-level data is retained.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RETENTION_DURATION_UNSPECIFIED" : Data retention time duration is not
  /// specified.
  /// - "TWO_MONTHS" : The data retention time duration is 2 months.
  /// - "FOURTEEN_MONTHS" : The data retention time duration is 14 months.
  /// - "TWENTY_SIX_MONTHS" : The data retention time duration is 26 months.
  /// Available to 360 properties only. Available for event data only.
  /// - "THIRTY_EIGHT_MONTHS" : The data retention time duration is 38 months.
  /// Available to 360 properties only. Available for event data only.
  /// - "FIFTY_MONTHS" : The data retention time duration is 50 months.
  /// Available to 360 properties only. Available for event data only.
  core.String? userDataRetention;

  $DataRetentionSettings({
    this.eventDataRetention,
    this.name,
    this.resetUserDataOnNewActivity,
    this.userDataRetention,
  });

  $DataRetentionSettings.fromJson(core.Map json_)
    : this(
        eventDataRetention: json_['eventDataRetention'] as core.String?,
        name: json_['name'] as core.String?,
        resetUserDataOnNewActivity:
            json_['resetUserDataOnNewActivity'] as core.bool?,
        userDataRetention: json_['userDataRetention'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (eventDataRetention != null) 'eventDataRetention': eventDataRetention!,
    if (name != null) 'name': name!,
    if (resetUserDataOnNewActivity != null)
      'resetUserDataOnNewActivity': resetUserDataOnNewActivity!,
    if (userDataRetention != null) 'userDataRetention': userDataRetention!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaDataSharingSettings
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaDataSharingSettings
class $DataSharingSettings {
  /// Resource name.
  ///
  /// Format: accounts/{account}/dataSharingSettings Example:
  /// "accounts/1000/dataSharingSettings"
  ///
  /// Output only.
  core.String? name;

  /// This field is no longer used and always returns false.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? sharingWithGoogleAnySalesEnabled;

  /// Allows Google access to your Google Analytics account data, including
  /// account usage and configuration data, product spending, and users
  /// associated with your Google Analytics account, so that Google can help you
  /// make the most of Google products, providing you with insights, offers,
  /// recommendations, and optimization tips across Google Analytics and other
  /// Google products for business.
  ///
  /// This field maps to the "Recommendations for your business" field in the
  /// Google Analytics Admin UI.
  core.bool? sharingWithGoogleAssignedSalesEnabled;

  /// Allows Google to use the data to improve other Google products or
  /// services.
  ///
  /// This fields maps to the "Google products & services" field in the Google
  /// Analytics Admin UI.
  core.bool? sharingWithGoogleProductsEnabled;

  /// Allows Google technical support representatives access to your Google
  /// Analytics data and account when necessary to provide service and find
  /// solutions to technical issues.
  ///
  /// This field maps to the "Technical support" field in the Google Analytics
  /// Admin UI.
  core.bool? sharingWithGoogleSupportEnabled;

  /// Enable features like predictions, modeled data, and benchmarking that can
  /// provide you with richer business insights when you contribute aggregated
  /// measurement data.
  ///
  /// The data you share (including information about the property from which it
  /// is shared) is aggregated and de-identified before being used to generate
  /// business insights. This field maps to the "Modeling contributions &
  /// business insights" field in the Google Analytics Admin UI.
  core.bool? sharingWithOthersEnabled;

  $DataSharingSettings({
    this.name,
    this.sharingWithGoogleAnySalesEnabled,
    this.sharingWithGoogleAssignedSalesEnabled,
    this.sharingWithGoogleProductsEnabled,
    this.sharingWithGoogleSupportEnabled,
    this.sharingWithOthersEnabled,
  });

  $DataSharingSettings.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        sharingWithGoogleAnySalesEnabled:
            json_['sharingWithGoogleAnySalesEnabled'] as core.bool?,
        sharingWithGoogleAssignedSalesEnabled:
            json_['sharingWithGoogleAssignedSalesEnabled'] as core.bool?,
        sharingWithGoogleProductsEnabled:
            json_['sharingWithGoogleProductsEnabled'] as core.bool?,
        sharingWithGoogleSupportEnabled:
            json_['sharingWithGoogleSupportEnabled'] as core.bool?,
        sharingWithOthersEnabled:
            json_['sharingWithOthersEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (sharingWithGoogleAnySalesEnabled != null)
      'sharingWithGoogleAnySalesEnabled': sharingWithGoogleAnySalesEnabled!,
    if (sharingWithGoogleAssignedSalesEnabled != null)
      'sharingWithGoogleAssignedSalesEnabled':
          sharingWithGoogleAssignedSalesEnabled!,
    if (sharingWithGoogleProductsEnabled != null)
      'sharingWithGoogleProductsEnabled': sharingWithGoogleProductsEnabled!,
    if (sharingWithGoogleSupportEnabled != null)
      'sharingWithGoogleSupportEnabled': sharingWithGoogleSupportEnabled!,
    if (sharingWithOthersEnabled != null)
      'sharingWithOthersEnabled': sharingWithOthersEnabled!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DataStoreBillingEstimation
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDataStoreBillingEstimation
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDataStoreBillingEstimation
class $DataStoreBillingEstimation {
  /// Data size for structured data in terms of bytes.
  core.String? structuredDataSize;

  /// Last updated timestamp for structured data.
  core.String? structuredDataUpdateTime;

  /// Data size for unstructured data in terms of bytes.
  core.String? unstructuredDataSize;

  /// Last updated timestamp for unstructured data.
  core.String? unstructuredDataUpdateTime;

  /// Data size for websites in terms of bytes.
  core.String? websiteDataSize;

  /// Last updated timestamp for websites.
  core.String? websiteDataUpdateTime;

  $DataStoreBillingEstimation({
    this.structuredDataSize,
    this.structuredDataUpdateTime,
    this.unstructuredDataSize,
    this.unstructuredDataUpdateTime,
    this.websiteDataSize,
    this.websiteDataUpdateTime,
  });

  $DataStoreBillingEstimation.fromJson(core.Map json_)
    : this(
        structuredDataSize: json_['structuredDataSize'] as core.String?,
        structuredDataUpdateTime:
            json_['structuredDataUpdateTime'] as core.String?,
        unstructuredDataSize: json_['unstructuredDataSize'] as core.String?,
        unstructuredDataUpdateTime:
            json_['unstructuredDataUpdateTime'] as core.String?,
        websiteDataSize: json_['websiteDataSize'] as core.String?,
        websiteDataUpdateTime: json_['websiteDataUpdateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (structuredDataSize != null) 'structuredDataSize': structuredDataSize!,
    if (structuredDataUpdateTime != null)
      'structuredDataUpdateTime': structuredDataUpdateTime!,
    if (unstructuredDataSize != null)
      'unstructuredDataSize': unstructuredDataSize!,
    if (unstructuredDataUpdateTime != null)
      'unstructuredDataUpdateTime': unstructuredDataUpdateTime!,
    if (websiteDataSize != null) 'websiteDataSize': websiteDataSize!,
    if (websiteDataUpdateTime != null)
      'websiteDataUpdateTime': websiteDataUpdateTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnection
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnection
class $DataStoreConnection {
  /// The full name of the referenced data store.
  ///
  /// Formats:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
  /// `projects/{project}/locations/{location}/dataStores/{data_store}`
  core.String? dataStore;

  /// The type of the connected data store.
  /// Possible string values are:
  /// - "DATA_STORE_TYPE_UNSPECIFIED" : Not specified. This value indicates that
  /// the data store type is not specified, so it will not be used during
  /// search.
  /// - "PUBLIC_WEB" : A data store that contains public web content.
  /// - "UNSTRUCTURED" : A data store that contains unstructured private data.
  /// - "STRUCTURED" : A data store that contains structured data (for example
  /// FAQ).
  core.String? dataStoreType;

  /// The document processing mode for the data store connection.
  ///
  /// Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set
  /// it is considered as DOCUMENTS, as this is the legacy mode.
  /// Possible string values are:
  /// - "DOCUMENT_PROCESSING_MODE_UNSPECIFIED" : Not specified. This should be
  /// set for STRUCTURED type data stores. Due to legacy reasons this is
  /// considered as DOCUMENTS for STRUCTURED and PUBLIC_WEB data stores.
  /// - "DOCUMENTS" : Documents are processed as documents.
  /// - "CHUNKS" : Documents are converted to chunks.
  core.String? documentProcessingMode;

  $DataStoreConnection({
    this.dataStore,
    this.dataStoreType,
    this.documentProcessingMode,
  });

  $DataStoreConnection.fromJson(core.Map json_)
    : this(
        dataStore: json_['dataStore'] as core.String?,
        dataStoreType: json_['dataStoreType'] as core.String?,
        documentProcessingMode: json_['documentProcessingMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (dataStoreType != null) 'dataStoreType': dataStoreType!,
    if (documentProcessingMode != null)
      'documentProcessingMode': documentProcessingMode!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsAnswerPart
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsAnswerPart
class $DataStoreConnectionSignalsAnswerPart {
  /// Citations for this answer part.
  ///
  /// Indices of `search_snippets`.
  core.List<core.int>? supportingIndices;

  /// Substring of the answer.
  core.String? text;

  $DataStoreConnectionSignalsAnswerPart({this.supportingIndices, this.text});

  $DataStoreConnectionSignalsAnswerPart.fromJson(core.Map json_)
    : this(
        supportingIndices:
            (json_['supportingIndices'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (supportingIndices != null) 'supportingIndices': supportingIndices!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsGroundingSignals
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsGroundingSignals
class $DataStoreConnectionSignalsGroundingSignals {
  /// Represents the decision of the grounding check.
  /// Possible string values are:
  /// - "GROUNDING_DECISION_UNSPECIFIED" : Decision not specified.
  /// - "ACCEPTED_BY_GROUNDING" : Grounding have accepted the answer.
  /// - "REJECTED_BY_GROUNDING" : Grounding have rejected the answer.
  core.String? decision;

  /// Grounding score bucket setting.
  /// Possible string values are:
  /// - "GROUNDING_SCORE_BUCKET_UNSPECIFIED" : Score not specified.
  /// - "VERY_LOW" : We have very low confidence that the answer is grounded.
  /// - "LOW" : We have low confidence that the answer is grounded.
  /// - "MEDIUM" : We have medium confidence that the answer is grounded.
  /// - "HIGH" : We have high confidence that the answer is grounded.
  /// - "VERY_HIGH" : We have very high confidence that the answer is grounded.
  core.String? score;

  $DataStoreConnectionSignalsGroundingSignals({this.decision, this.score});

  $DataStoreConnectionSignalsGroundingSignals.fromJson(core.Map json_)
    : this(
        decision: json_['decision'] as core.String?,
        score: json_['score'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (decision != null) 'decision': decision!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsSafetySignals
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsSafetySignals
class $DataStoreConnectionSignalsSafetySignals {
  /// Specifies banned phrase match subject.
  /// Possible string values are:
  /// - "BANNED_PHRASE_MATCH_UNSPECIFIED" : No banned phrase check was executed.
  /// - "BANNED_PHRASE_MATCH_NONE" : All banned phrase checks led to no match.
  /// - "BANNED_PHRASE_MATCH_QUERY" : A banned phrase matched the query.
  /// - "BANNED_PHRASE_MATCH_RESPONSE" : A banned phrase matched the response.
  core.String? bannedPhraseMatch;

  /// Safety decision.
  /// Possible string values are:
  /// - "SAFETY_DECISION_UNSPECIFIED" : Decision not specified.
  /// - "ACCEPTED_BY_SAFETY_CHECK" : No manual or automatic safety check fired.
  /// - "REJECTED_BY_SAFETY_CHECK" : One ore more safety checks fired.
  core.String? decision;

  /// The matched banned phrase if there was a match.
  core.String? matchedBannedPhrase;

  $DataStoreConnectionSignalsSafetySignals({
    this.bannedPhraseMatch,
    this.decision,
    this.matchedBannedPhrase,
  });

  $DataStoreConnectionSignalsSafetySignals.fromJson(core.Map json_)
    : this(
        bannedPhraseMatch: json_['bannedPhraseMatch'] as core.String?,
        decision: json_['decision'] as core.String?,
        matchedBannedPhrase: json_['matchedBannedPhrase'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bannedPhraseMatch != null) 'bannedPhraseMatch': bannedPhraseMatch!,
    if (decision != null) 'decision': decision!,
    if (matchedBannedPhrase != null)
      'matchedBannedPhrase': matchedBannedPhrase!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsSearchSnippet
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsSearchSnippet
class $DataStoreConnectionSignalsSearchSnippet {
  /// Title of the enclosing document.
  core.String? documentTitle;

  /// Uri for the document.
  ///
  /// Present if specified for the document.
  core.String? documentUri;

  /// Metadata associated with the document.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Text included in the prompt.
  core.String? text;

  $DataStoreConnectionSignalsSearchSnippet({
    this.documentTitle,
    this.documentUri,
    this.metadata,
    this.text,
  });

  $DataStoreConnectionSignalsSearchSnippet.fromJson(core.Map json_)
    : this(
        documentTitle: json_['documentTitle'] as core.String?,
        documentUri: json_['documentUri'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentTitle != null) 'documentTitle': documentTitle!,
    if (documentUri != null) 'documentUri': documentUri!,
    if (metadata != null) 'metadata': metadata!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DataStoreServingConfigDataStore
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDataStoreServingConfigDataStore
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDataStoreServingConfigDataStore
class $DataStoreServingConfigDataStore {
  /// If set true, the DataStore will not be available for serving search
  /// requests.
  ///
  /// Optional.
  core.bool? disabledForServing;

  $DataStoreServingConfigDataStore({this.disabledForServing});

  $DataStoreServingConfigDataStore.fromJson(core.Map json_)
    : this(disabledForServing: json_['disabledForServing'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabledForServing != null) 'disabledForServing': disabledForServing!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaDataStreamAndroidAppStreamData
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaDataStreamAndroidAppStreamData
class $DataStreamAndroidAppStreamData {
  /// ID of the corresponding Android app in Firebase, if any.
  ///
  /// This ID can change if the Android app is deleted and recreated.
  ///
  /// Output only.
  core.String? firebaseAppId;

  /// The package name for the app being measured.
  ///
  /// Example: "com.example.myandroidapp"
  ///
  /// Immutable.
  core.String? packageName;

  $DataStreamAndroidAppStreamData({this.firebaseAppId, this.packageName});

  $DataStreamAndroidAppStreamData.fromJson(core.Map json_)
    : this(
        firebaseAppId: json_['firebaseAppId'] as core.String?,
        packageName: json_['packageName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (firebaseAppId != null) 'firebaseAppId': firebaseAppId!,
    if (packageName != null) 'packageName': packageName!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaDataStreamIosAppStreamData
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaDataStreamIosAppStreamData
class $DataStreamIosAppStreamData {
  /// The Apple App Store Bundle ID for the app Example: "com.example.myiosapp"
  ///
  /// Required. Immutable.
  core.String? bundleId;

  /// ID of the corresponding iOS app in Firebase, if any.
  ///
  /// This ID can change if the iOS app is deleted and recreated.
  ///
  /// Output only.
  core.String? firebaseAppId;

  $DataStreamIosAppStreamData({this.bundleId, this.firebaseAppId});

  $DataStreamIosAppStreamData.fromJson(core.Map json_)
    : this(
        bundleId: json_['bundleId'] as core.String?,
        firebaseAppId: json_['firebaseAppId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bundleId != null) 'bundleId': bundleId!,
    if (firebaseAppId != null) 'firebaseAppId': firebaseAppId!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaDataStreamWebStreamData
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaDataStreamWebStreamData
class $DataStreamWebStreamData {
  /// Domain name of the web app being measured, or empty.
  ///
  /// Example: "http://www.google.com", "https://www.google.com"
  core.String? defaultUri;

  /// ID of the corresponding web app in Firebase, if any.
  ///
  /// This ID can change if the web app is deleted and recreated.
  ///
  /// Output only.
  core.String? firebaseAppId;

  /// Analytics Measurement ID.
  ///
  /// Example: "G-1A2BCD345E"
  ///
  /// Output only.
  core.String? measurementId;

  $DataStreamWebStreamData({
    this.defaultUri,
    this.firebaseAppId,
    this.measurementId,
  });

  $DataStreamWebStreamData.fromJson(core.Map json_)
    : this(
        defaultUri: json_['defaultUri'] as core.String?,
        firebaseAppId: json_['firebaseAppId'] as core.String?,
        measurementId: json_['measurementId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultUri != null) 'defaultUri': defaultUri!,
    if (firebaseAppId != null) 'firebaseAppId': firebaseAppId!,
    if (measurementId != null) 'measurementId': measurementId!,
  };
}

/// Used by:
///
/// - composer:v1 : DatabaseConfig
/// - composer:v1beta1 : DatabaseConfig
class $DatabaseConfig {
  /// Cloud SQL machine type used by Airflow database.
  ///
  /// It has to be one of: db-n1-standard-2, db-n1-standard-4, db-n1-standard-8
  /// or db-n1-standard-16. If not specified, db-n1-standard-2 will be used.
  /// Supported for Cloud Composer environments in versions
  /// composer-1.*.*-airflow-*.*.*.
  ///
  /// Optional.
  core.String? machineType;

  /// The Compute Engine zone where the Airflow database is created.
  ///
  /// If zone is provided, it must be in the region selected for the
  /// environment. If zone is not provided, a zone is automatically selected.
  /// The zone can only be set during environment creation. Supported for Cloud
  /// Composer environments in versions composer-2.*.*-airflow-*.*.*.
  ///
  /// Optional.
  core.String? zone;

  $DatabaseConfig({this.machineType, this.zone});

  $DatabaseConfig.fromJson(core.Map json_)
    : this(
        machineType: json_['machineType'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineType != null) 'machineType': machineType!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : DatabaseDeploymentDetailsAggregatedStats
/// - migrationcenter:v1alpha1 : DatabaseDeploymentDetailsAggregatedStats
class $DatabaseDeploymentDetailsAggregatedStats {
  /// The number of databases in the deployment.
  ///
  /// Output only.
  core.int? databaseCount;

  $DatabaseDeploymentDetailsAggregatedStats({this.databaseCount});

  $DatabaseDeploymentDetailsAggregatedStats.fromJson(core.Map json_)
    : this(databaseCount: json_['databaseCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseCount != null) 'databaseCount': databaseCount!,
  };
}

/// Used by:
///
/// - metastore:v1 : DatabaseDump
/// - metastore:v1alpha : DatabaseDump
/// - metastore:v1beta : DatabaseDump
class $DatabaseDump {
  /// The type of the database.
  /// Possible string values are:
  /// - "DATABASE_TYPE_UNSPECIFIED" : The type of the source database is
  /// unknown.
  /// - "MYSQL" : The type of the source database is MySQL.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? databaseType;

  /// A Cloud Storage object or folder URI that specifies the source from which
  /// to import metadata.
  ///
  /// It must begin with gs://.
  ///
  /// Optional.
  core.String? gcsUri;

  /// The name of the source database.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? sourceDatabase;

  /// The type of the database dump.
  ///
  /// If unspecified, defaults to MYSQL.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type of the database dump is unknown.
  /// - "MYSQL" : Database dump is a MySQL dump file.
  /// - "AVRO" : Database dump contains Avro files.
  core.String? type;

  $DatabaseDump({
    this.databaseType,
    this.gcsUri,
    this.sourceDatabase,
    this.type,
  });

  $DatabaseDump.fromJson(core.Map json_)
    : this(
        databaseType: json_['databaseType'] as core.String?,
        gcsUri: json_['gcsUri'] as core.String?,
        sourceDatabase: json_['sourceDatabase'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseType != null) 'databaseType': databaseType!,
    if (gcsUri != null) 'gcsUri': gcsUri!,
    if (sourceDatabase != null) 'sourceDatabase': sourceDatabase!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DatabaseFlags
/// - sqladmin:v1beta4 : DatabaseFlags
class $DatabaseFlags {
  /// The name of the flag.
  ///
  /// These flags are passed at instance startup, so include both server options
  /// and system variables. Flags are specified with underscores, not hyphens.
  /// For more information, see
  /// [Configuring Database Flags](https://cloud.google.com/sql/docs/mysql/flags)
  /// in the Cloud SQL documentation.
  core.String? name;

  /// The value of the flag.
  ///
  /// Boolean flags are set to `on` for true and `off` for false. This field
  /// must be omitted if the flag doesn't take a value.
  core.String? value;

  $DatabaseFlags({this.name, this.value});

  $DatabaseFlags.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : DatabaseInstanceNetwork
/// - migrationcenter:v1alpha1 : DatabaseInstanceNetwork
class $DatabaseInstanceNetwork {
  /// The instance's host names.
  ///
  /// Optional.
  core.List<core.String>? hostNames;

  /// The instance's IP addresses.
  ///
  /// Optional.
  core.List<core.String>? ipAddresses;

  /// The instance's primary MAC address.
  ///
  /// Optional.
  core.String? primaryMacAddress;

  $DatabaseInstanceNetwork({
    this.hostNames,
    this.ipAddresses,
    this.primaryMacAddress,
  });

  $DatabaseInstanceNetwork.fromJson(core.Map json_)
    : this(
        hostNames:
            (json_['hostNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ipAddresses:
            (json_['ipAddresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        primaryMacAddress: json_['primaryMacAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostNames != null) 'hostNames': hostNames!,
    if (ipAddresses != null) 'ipAddresses': ipAddresses!,
    if (primaryMacAddress != null) 'primaryMacAddress': primaryMacAddress!,
  };
}

/// Used by:
///
/// - gkehub:v1 : DataplaneV2FeatureSpec
/// - gkehub:v1alpha : DataplaneV2FeatureSpec
/// - gkehub:v1beta : DataplaneV2FeatureSpec
class $DataplaneV2FeatureSpec {
  /// Enable dataplane-v2 based encryption for multiple clusters.
  core.bool? enableEncryption;

  $DataplaneV2FeatureSpec({this.enableEncryption});

  $DataplaneV2FeatureSpec.fromJson(core.Map json_)
    : this(enableEncryption: json_['enableEncryption'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableEncryption != null) 'enableEncryption': enableEncryption!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DatasetVersion
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DatasetVersion
class $DatasetVersion {
  /// Name of the associated BigQuery dataset.
  ///
  /// Output only.
  core.String? bigQueryDatasetName;

  /// Timestamp when this DatasetVersion was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the DatasetVersion.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Additional information about the DatasetVersion.
  ///
  /// Required. Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Reference to the public base model last used by the dataset version.
  ///
  /// Only set for prompt dataset versions.
  ///
  /// Output only.
  core.String? modelReference;

  /// Identifier.
  ///
  /// The resource name of the DatasetVersion. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this DatasetVersion was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $DatasetVersion({
    this.bigQueryDatasetName,
    this.createTime,
    this.displayName,
    this.etag,
    this.metadata,
    this.modelReference,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  $DatasetVersion.fromJson(core.Map json_)
    : this(
        bigQueryDatasetName: json_['bigQueryDatasetName'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        metadata: json_['metadata'],
        modelReference: json_['modelReference'] as core.String?,
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigQueryDatasetName != null)
      'bigQueryDatasetName': bigQueryDatasetName!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (metadata != null) 'metadata': metadata!,
    if (modelReference != null) 'modelReference': modelReference!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : Date
/// - admin:reports_v1 : Date
/// - admob:v1 : Date
/// - admob:v1beta : Date
/// - adsense:v2 : Date
/// - aiplatform:v1 : GoogleTypeDate
/// - aiplatform:v1beta1 : GoogleTypeDate
/// - alloydb:v1 : GoogleTypeDate
/// - alloydb:v1alpha : GoogleTypeDate
/// - alloydb:v1beta : GoogleTypeDate
/// - analyticsadmin:v1alpha : GoogleTypeDate
/// - androidmanagement:v1 : Date
/// - appengine:v1 : Date
/// - appengine:v1beta : Date
/// - billingbudgets:v1 : GoogleTypeDate
/// - billingbudgets:v1beta1 : GoogleTypeDate
/// - businessprofileperformance:v1 : Date
/// - chromemanagement:v1 : GoogleTypeDate
/// - chromepolicy:v1 : GoogleTypeDate
/// - chromeuxreport:v1 : Date
/// - classroom:v1 : Date
/// - cloudasset:v1 : Date
/// - cloudchannel:v1 : GoogleTypeDate
/// - clouddeploy:v1 : Date
/// - cloudfunctions:v2 : Date
/// - cloudfunctions:v2alpha : Date
/// - cloudfunctions:v2beta : Date
/// - composer:v1 : Date
/// - composer:v1beta1 : Date
/// - compute:alpha : Date
/// - compute:beta : Date
/// - container:v1beta1 : Date
/// - content:v2.1 : Date
/// - contentwarehouse:v1 : GoogleTypeDate
/// - discoveryengine:v1 : GoogleTypeDate
/// - discoveryengine:v1alpha : GoogleTypeDate
/// - discoveryengine:v1beta : GoogleTypeDate
/// - displayvideo:v2 : Date
/// - displayvideo:v3 : Date
/// - displayvideo:v4 : Date
/// - dlp:v2 : GoogleTypeDate
/// - documentai:v1 : GoogleTypeDate
/// - documentai:v1beta3 : GoogleTypeDate
/// - doubleclickbidmanager:v2 : Date
/// - drivelabels:v2 : GoogleTypeDate
/// - drivelabels:v2beta : GoogleTypeDate
/// - fcmdata:v1beta1 : GoogleTypeDate
/// - firebaseml:v2beta : Date
/// - gkebackup:v1 : Date
/// - looker:v1 : Date
/// - merchantapi:accounts_v1beta : Date
/// - merchantapi:reports_v1beta : Date
/// - migrationcenter:v1 : Date
/// - migrationcenter:v1alpha1 : Date
/// - mybusinessbusinessinformation:v1 : Date
/// - osconfig:v1 : Date
/// - osconfig:v1alpha : Date
/// - people:v1 : Date
/// - places:v1 : GoogleTypeDate
/// - policysimulator:v1 : GoogleTypeDate
/// - policysimulator:v1beta : GoogleTypeDate
/// - pollen:v1 : Date
/// - realtimebidding:v1 : Date
/// - retail:v2 : GoogleTypeDate
/// - retail:v2alpha : GoogleTypeDate
/// - retail:v2beta : GoogleTypeDate
/// - solar:v1 : Date
/// - storagetransfer:v1 : Date
/// - testing:v1 : Date
/// - travelimpactmodel:v1 : Date
class $Date {
  /// Day of a month.
  ///
  /// Must be from 1 to 31 and valid for the year and month, or 0 to specify a
  /// year by itself or a year and month where the day isn't significant.
  core.int? day;

  /// Month of a year.
  ///
  /// Must be from 1 to 12, or 0 to specify a year without a month and day.
  core.int? month;

  /// Year of the date.
  ///
  /// Must be from 1 to 9999, or 0 to specify a date without a year.
  core.int? year;

  $Date({this.day, this.month, this.year});

  $Date.fromJson(core.Map json_)
    : this(
        day: json_['day'] as core.int?,
        month: json_['month'] as core.int?,
        year: json_['year'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (day != null) 'day': day!,
    if (month != null) 'month': month!,
    if (year != null) 'year': year!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DayAndTimeAssignedTargetingOptionDetails
/// - displayvideo:v3 : DayAndTimeAssignedTargetingOptionDetails
/// - displayvideo:v4 : DayAndTimeAssignedTargetingOptionDetails
class $DayAndTimeAssignedTargetingOptionDetails {
  /// The day of the week for this day and time targeting setting.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DAY_OF_WEEK_UNSPECIFIED" : The day of the week is unspecified.
  /// - "MONDAY" : Monday
  /// - "TUESDAY" : Tuesday
  /// - "WEDNESDAY" : Wednesday
  /// - "THURSDAY" : Thursday
  /// - "FRIDAY" : Friday
  /// - "SATURDAY" : Saturday
  /// - "SUNDAY" : Sunday
  core.String? dayOfWeek;

  /// The end hour for day and time targeting.
  ///
  /// Must be between 1 (1 hour after start of day) and 24 (end of day).
  ///
  /// Required.
  core.int? endHour;

  /// The start hour for day and time targeting.
  ///
  /// Must be between 0 (start of day) and 23 (1 hour before end of day).
  ///
  /// Required.
  core.int? startHour;

  /// The mechanism used to determine which timezone to use for this day and
  /// time targeting setting.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TIME_ZONE_RESOLUTION_UNSPECIFIED" : Time zone resolution is either
  /// unspecific or unknown.
  /// - "TIME_ZONE_RESOLUTION_END_USER" : Times are resolved in the time zone of
  /// the user that saw the ad.
  /// - "TIME_ZONE_RESOLUTION_ADVERTISER" : Times are resolved in the time zone
  /// of the advertiser that served the ad.
  core.String? timeZoneResolution;

  $DayAndTimeAssignedTargetingOptionDetails({
    this.dayOfWeek,
    this.endHour,
    this.startHour,
    this.timeZoneResolution,
  });

  $DayAndTimeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        dayOfWeek: json_['dayOfWeek'] as core.String?,
        endHour: json_['endHour'] as core.int?,
        startHour: json_['startHour'] as core.int?,
        timeZoneResolution: json_['timeZoneResolution'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dayOfWeek != null) 'dayOfWeek': dayOfWeek!,
    if (endHour != null) 'endHour': endHour!,
    if (startHour != null) 'startHour': startHour!,
    if (timeZoneResolution != null) 'timeZoneResolution': timeZoneResolution!,
  };
}

/// Used by:
///
/// - connectors:v1 : DeadLetterConfig
/// - integrations:v1 : GoogleCloudConnectorsV1EventingConfigDeadLetterConfig
class $DeadLetterConfig {
  /// Project which has the topic given.
  ///
  /// Optional.
  core.String? projectId;

  /// Topic to push events which couldn't be processed.
  ///
  /// Optional.
  core.String? topic;

  $DeadLetterConfig({this.projectId, this.topic});

  $DeadLetterConfig.fromJson(core.Map json_)
    : this(
        projectId: json_['projectId'] as core.String?,
        topic: json_['topic'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (projectId != null) 'projectId': projectId!,
    if (topic != null) 'topic': topic!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : DealPausingInfo
/// - authorizedbuyersmarketplace:v1alpha : DealPausingInfo
class $DealPausingInfo {
  /// The reason for the pausing of the deal; empty for active deals.
  core.String? pauseReason;

  /// The party that first paused the deal; unspecified for active deals.
  /// Possible string values are:
  /// - "BUYER_SELLER_ROLE_UNSPECIFIED" : A placeholder for an undefined
  /// buyer/seller role.
  /// - "BUYER" : Specifies the role as buyer.
  /// - "SELLER" : Specifies the role as seller.
  core.String? pauseRole;

  /// Whether pausing is consented between buyer and seller for the deal.
  core.bool? pausingConsented;

  $DealPausingInfo({this.pauseReason, this.pauseRole, this.pausingConsented});

  $DealPausingInfo.fromJson(core.Map json_)
    : this(
        pauseReason: json_['pauseReason'] as core.String?,
        pauseRole: json_['pauseRole'] as core.String?,
        pausingConsented: json_['pausingConsented'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pauseReason != null) 'pauseReason': pauseReason!,
    if (pauseRole != null) 'pauseRole': pauseRole!,
    if (pausingConsented != null) 'pausingConsented': pausingConsented!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : DebugInfo
/// - deploymentmanager:v2 : DebugInfo
/// - deploymentmanager:v2beta : DebugInfo
class $DebugInfo00 {
  /// Additional debugging information provided by the server.
  core.String? detail;

  /// The stack trace entries indicating where the error occurred.
  core.List<core.String>? stackEntries;

  $DebugInfo00({this.detail, this.stackEntries});

  $DebugInfo00.fromJson(core.Map json_)
    : this(
        detail: json_['detail'] as core.String?,
        stackEntries:
            (json_['stackEntries'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (detail != null) 'detail': detail!,
    if (stackEntries != null) 'stackEntries': stackEntries!,
  };
}

/// Used by:
///
/// - cloudsearch:v1 : ResponseDebugInfo
/// - cloudsearch:v1 : ResultDebugInfo
class $DebugInfo01 {
  /// General debug info formatted for display.
  core.String? formattedDebugInfo;

  $DebugInfo01({this.formattedDebugInfo});

  $DebugInfo01.fromJson(core.Map json_)
    : this(formattedDebugInfo: json_['formattedDebugInfo'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (formattedDebugInfo != null) 'formattedDebugInfo': formattedDebugInfo!,
  };
}

/// Used by:
///
/// - appengine:v1 : DebugInstanceRequest
/// - appengine:v1beta : DebugInstanceRequest
class $DebugInstanceRequest {
  /// Public SSH key to add to the instance.
  ///
  /// Examples: \[USERNAME\]:ssh-rsa \[KEY_VALUE\] \[USERNAME\]
  /// \[USERNAME\]:ssh-rsa \[KEY_VALUE\] google-ssh
  /// {"userName":"\[USERNAME\]","expireOn":"\[EXPIRE_TIME\]"}For more
  /// information, see Adding and Removing SSH Keys
  /// (https://cloud.google.com/compute/docs/instances/adding-removing-ssh-keys).
  core.String? sshKey;

  $DebugInstanceRequest({this.sshKey});

  $DebugInstanceRequest.fromJson(core.Map json_)
    : this(sshKey: json_['sshKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sshKey != null) 'sshKey': sshKey!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1DebugToken
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaDebugToken
class $DebugToken {
  /// A human readable display name used to identify this debug token.
  ///
  /// Required.
  core.String? displayName;

  /// The relative resource name of the debug token, in the format: ```
  /// projects/{project_number}/apps/{app_id}/debugTokens/{debug_token_id} ```
  ///
  /// Required.
  core.String? name;

  /// Input only.
  ///
  /// Immutable. The secret token itself. Must be provided during creation, and
  /// must be a UUID4, case insensitive. This field is immutable once set, and
  /// cannot be provided during an UpdateDebugToken request. You can, however,
  /// delete this debug token using DeleteDebugToken to revoke it. For security
  /// reasons, this field will never be populated in any response.
  ///
  /// Required.
  core.String? token;

  /// Timestamp when this debug token was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  $DebugToken({this.displayName, this.name, this.token, this.updateTime});

  $DebugToken.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        token: json_['token'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (token != null) 'token': token!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - adsenseplatform:v1alpha : Decimal
/// - cloudbilling:v1beta : Decimal
/// - cloudchannel:v1 : GoogleTypeDecimal
/// - playdeveloperreporting:v1alpha1 : GoogleTypeDecimal
/// - playdeveloperreporting:v1beta1 : GoogleTypeDecimal
class $Decimal {
  /// The decimal value, as a string.
  ///
  /// The string representation consists of an optional sign, `+` (`U+002B`) or
  /// `-` (`U+002D`), followed by a sequence of zero or more decimal digits
  /// ("the integer"), optionally followed by a fraction, optionally followed by
  /// an exponent. An empty string **should** be interpreted as `0`. The
  /// fraction consists of a decimal point followed by zero or more decimal
  /// digits. The string must contain at least one digit in either the integer
  /// or the fraction. The number formed by the sign, the integer and the
  /// fraction is referred to as the significand. The exponent consists of the
  /// character `e` (`U+0065`) or `E` (`U+0045`) followed by one or more decimal
  /// digits. Services **should** normalize decimal values before storing them
  /// by: - Removing an explicitly-provided `+` sign (`+2.5` -\> `2.5`). -
  /// Replacing a zero-length integer value with `0` (`.5` -\> `0.5`). -
  /// Coercing the exponent character to upper-case, with explicit sign (`2.5e8`
  /// -\> `2.5E+8`). - Removing an explicitly-provided zero exponent (`2.5E0`
  /// -\> `2.5`). Services **may** perform additional normalization based on its
  /// own needs and the internal decimal implementation selected, such as
  /// shifting the decimal point and exponent value together (example: `2.5E-1`
  /// \<-\> `0.25`). Additionally, services **may** preserve trailing zeroes in
  /// the fraction to indicate increased precision, but are not required to do
  /// so. Note that only the `.` character is supported to divide the integer
  /// and the fraction; `,` **should not** be supported regardless of locale.
  /// Additionally, thousand separators **should not** be supported. If a
  /// service does support them, values **must** be normalized. The ENBF grammar
  /// is: DecimalString = '' | \[Sign\] Significand \[Exponent\]; Sign = '+' |
  /// '-'; Significand = Digits '.' | \[Digits\] '.' Digits; Exponent = ('e' |
  /// 'E') \[Sign\] Digits; Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' |
  /// '7' | '8' | '9' }; Services **should** clearly document the range of
  /// supported values, the maximum supported precision (total number of
  /// digits), and, if applicable, the scale (number of digits after the decimal
  /// point), as well as how it behaves when receiving out-of-bounds values.
  /// Services **may** choose to accept values passed as input even when the
  /// value has a higher precision or scale than the service supports, and
  /// **should** round the value to fit the supported scale. Alternatively, the
  /// service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC)
  /// if precision would be lost. Services **should** error with `400 Bad
  /// Request` (`INVALID_ARGUMENT` in gRPC) if the service receives a value
  /// outside of the supported range.
  core.String? value;

  $Decimal({this.value});

  $Decimal.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - container:v1 : DefaultComputeClassConfig
/// - container:v1beta1 : DefaultComputeClassConfig
class $DefaultComputeClassConfig {
  /// Enables default compute class.
  core.bool? enabled;

  $DefaultComputeClassConfig({this.enabled});

  $DefaultComputeClassConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - container:v1 : DefaultSnatStatus
/// - container:v1beta1 : DefaultSnatStatus
class $DefaultSnatStatus {
  /// Disables cluster default sNAT rules.
  core.bool? disabled;

  $DefaultSnatStatus({this.disabled});

  $DefaultSnatStatus.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : DeleteAssignedTargetingOptionsRequest
/// - displayvideo:v4 : DeleteAssignedTargetingOptionsRequest
class $DeleteAssignedTargetingOptionsRequest {
  /// The assigned targeting option IDs to delete.
  ///
  /// Required.
  core.List<core.String>? assignedTargetingOptionIds;

  /// Identifies the type of this assigned targeting option.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TARGETING_TYPE_UNSPECIFIED" : Default value when type is not specified
  /// or is unknown in this version.
  /// - "TARGETING_TYPE_CHANNEL" : Target a channel (a custom group of related
  /// websites or apps).
  /// - "TARGETING_TYPE_APP_CATEGORY" : Target an app category (for example,
  /// education or puzzle games).
  /// - "TARGETING_TYPE_APP" : Target a specific app (for example, Angry Birds).
  /// - "TARGETING_TYPE_URL" : Target a specific url (for example, quora.com).
  /// - "TARGETING_TYPE_DAY_AND_TIME" : Target ads during a chosen time period
  /// on a specific day.
  /// - "TARGETING_TYPE_AGE_RANGE" : Target ads to a specific age range (for
  /// example, 18-24).
  /// - "TARGETING_TYPE_REGIONAL_LOCATION_LIST" : Target ads to the specified
  /// regions on a regional location list.
  /// - "TARGETING_TYPE_PROXIMITY_LOCATION_LIST" : Target ads to the specified
  /// points of interest on a proximity location list.
  /// - "TARGETING_TYPE_GENDER" : Target ads to a specific gender (for example,
  /// female or male).
  /// - "TARGETING_TYPE_VIDEO_PLAYER_SIZE" : Target a specific video player size
  /// for video ads.
  /// - "TARGETING_TYPE_USER_REWARDED_CONTENT" : Target user rewarded content
  /// for video ads.
  /// - "TARGETING_TYPE_PARENTAL_STATUS" : Target ads to a specific parental
  /// status (for example, parent or not a parent).
  /// - "TARGETING_TYPE_CONTENT_INSTREAM_POSITION" : Target video or audio ads
  /// in a specific content instream position (for example, pre-roll, mid-roll,
  /// or post-roll).
  /// - "TARGETING_TYPE_CONTENT_OUTSTREAM_POSITION" : Target ads in a specific
  /// content outstream position.
  /// - "TARGETING_TYPE_DEVICE_TYPE" : Target ads to a specific device type (for
  /// example, tablet or connected TV).
  /// - "TARGETING_TYPE_AUDIENCE_GROUP" : Target ads to an audience or groups of
  /// audiences. Singleton field, at most one can exist on a single Lineitem at
  /// a time.
  /// - "TARGETING_TYPE_BROWSER" : Target ads to specific web browsers (for
  /// example, Chrome).
  /// - "TARGETING_TYPE_HOUSEHOLD_INCOME" : Target ads to a specific household
  /// income range (for example, top 10%).
  /// - "TARGETING_TYPE_ON_SCREEN_POSITION" : Target ads in a specific on screen
  /// position.
  /// - "TARGETING_TYPE_THIRD_PARTY_VERIFIER" : Filter web sites through third
  /// party verification (for example, IAS or DoubleVerify).
  /// - "TARGETING_TYPE_DIGITAL_CONTENT_LABEL_EXCLUSION" : Filter web sites by
  /// specific digital content label ratings (for example, DL-MA: suitable only
  /// for mature audiences).
  /// - "TARGETING_TYPE_SENSITIVE_CATEGORY_EXCLUSION" : Filter website content
  /// by sensitive categories (for example, adult).
  /// - "TARGETING_TYPE_ENVIRONMENT" : Target ads to a specific environment (for
  /// example, web or app).
  /// - "TARGETING_TYPE_CARRIER_AND_ISP" : Target ads to a specific network
  /// carrier or internet service provider (ISP) (for example, Comcast or
  /// Orange).
  /// - "TARGETING_TYPE_OPERATING_SYSTEM" : Target ads to a specific operating
  /// system (for example, macOS).
  /// - "TARGETING_TYPE_DEVICE_MAKE_MODEL" : Target ads to a specific device
  /// make or model (for example, Roku or Samsung).
  /// - "TARGETING_TYPE_KEYWORD" : Target ads to a specific keyword (for
  /// example, dog or retriever).
  /// - "TARGETING_TYPE_NEGATIVE_KEYWORD_LIST" : Target ads to a specific
  /// negative keyword list.
  /// - "TARGETING_TYPE_VIEWABILITY" : Target ads to a specific viewability (for
  /// example, 80% viewable).
  /// - "TARGETING_TYPE_CATEGORY" : Target ads to a specific content category
  /// (for example, arts & entertainment).
  /// - "TARGETING_TYPE_INVENTORY_SOURCE" : Purchase impressions from specific
  /// deals and auction packages.
  /// - "TARGETING_TYPE_LANGUAGE" : Target ads to a specific language (for
  /// example, English or Japanese).
  /// - "TARGETING_TYPE_AUTHORIZED_SELLER_STATUS" : Target ads to ads.txt
  /// authorized sellers. If no targeting option of this type is assigned, the
  /// resource uses the "Authorized Direct Sellers and Resellers" option by
  /// default.
  /// - "TARGETING_TYPE_GEO_REGION" : Target ads to a specific regional location
  /// (for example, a city or state).
  /// - "TARGETING_TYPE_INVENTORY_SOURCE_GROUP" : Purchase impressions from a
  /// group of deals and auction packages.
  /// - "TARGETING_TYPE_EXCHANGE" : Purchase impressions from specific
  /// exchanges.
  /// - "TARGETING_TYPE_SUB_EXCHANGE" : Purchase impressions from specific
  /// sub-exchanges.
  /// - "TARGETING_TYPE_POI" : Target ads around a specific point of interest,
  /// such as a notable building, a street address, or latitude/longitude
  /// coordinates.
  /// - "TARGETING_TYPE_BUSINESS_CHAIN" : Target ads around locations of a
  /// business chain within a specific geo region.
  /// - "TARGETING_TYPE_CONTENT_DURATION" : Target ads to a specific video
  /// content duration.
  /// - "TARGETING_TYPE_CONTENT_STREAM_TYPE" : Target ads to a specific video
  /// content stream type.
  /// - "TARGETING_TYPE_NATIVE_CONTENT_POSITION" : Target ads to a specific
  /// native content position.
  /// - "TARGETING_TYPE_OMID" : Target ads in an Open Measurement enabled
  /// inventory.
  /// - "TARGETING_TYPE_AUDIO_CONTENT_TYPE" : Target ads to a specific audio
  /// content type.
  /// - "TARGETING_TYPE_CONTENT_GENRE" : Target ads to a specific content genre.
  /// - "TARGETING_TYPE_YOUTUBE_VIDEO" : Target ads to a specific YouTube video.
  /// Targeting of this type cannot be created or updated using the API.
  /// Although this targeting is inherited by child resources, **inherited
  /// targeting of this type will not be retrieveable**.
  /// - "TARGETING_TYPE_YOUTUBE_CHANNEL" : Target ads to a specific YouTube
  /// channel. Targeting of this type cannot be created or updated using the
  /// API. Although this targeting is inherited by child resources, **inherited
  /// targeting of this type will not be retrieveable**.
  /// - "TARGETING_TYPE_SESSION_POSITION" : Target ads to a serve it in a
  /// certain position of a session. Only supported for Ad Group resources under
  /// YouTube Programmatic Reservation line items. Targeting of this type cannot
  /// be created or updated using the API.
  /// - "TARGETING_TYPE_CONTENT_THEME_EXCLUSION" : Filter website content by
  /// content themes (for example, religion). Only supported for Advertiser
  /// resources. Targeting of this type cannot be created or updated using the
  /// API. This targeting is only inherited by child YouTube and Demand Gen line
  /// item resources.
  core.String? targetingType;

  $DeleteAssignedTargetingOptionsRequest({
    this.assignedTargetingOptionIds,
    this.targetingType,
  });

  $DeleteAssignedTargetingOptionsRequest.fromJson(core.Map json_)
    : this(
        assignedTargetingOptionIds:
            (json_['assignedTargetingOptionIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetingType: json_['targetingType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignedTargetingOptionIds != null)
      'assignedTargetingOptionIds': assignedTargetingOptionIds!,
    if (targetingType != null) 'targetingType': targetingType!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeleteLabelPermissionRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeleteLabelPermissionRequest
class $DeleteLabelPermissionRequest {
  /// Label Permission resource name.
  ///
  /// Required.
  core.String? name;

  /// Set to `true` in order to use the user's admin credentials.
  ///
  /// The server will verify the user is an admin for the Label before allowing
  /// access.
  core.bool? useAdminAccess;

  $DeleteLabelPermissionRequest({this.name, this.useAdminAccess});

  $DeleteLabelPermissionRequest.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        useAdminAccess: json_['useAdminAccess'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (useAdminAccess != null) 'useAdminAccess': useAdminAccess!,
  };
}

/// Used by:
///
/// - gmailpostmastertools:v1 : DeliveryError
/// - gmailpostmastertools:v1beta1 : DeliveryError
class $DeliveryError {
  /// The class of delivery error.
  /// Possible string values are:
  /// - "DELIVERY_ERROR_CLASS_UNSPECIFIED" : The default value which should
  /// never be used explicitly.
  /// - "PERMANENT_ERROR" : Delivery of message has been rejected.
  /// - "TEMPORARY_ERROR" : Temporary failure of message delivery to the
  /// recipient.
  core.String? errorClass;

  /// The ratio of messages where the error occurred vs all authenticated
  /// traffic.
  core.double? errorRatio;

  /// The type of delivery error.
  /// Possible string values are:
  /// - "DELIVERY_ERROR_TYPE_UNSPECIFIED" : The default value which should never
  /// be used explicitly.
  /// - "RATE_LIMIT_EXCEEDED" : The Domain or IP is sending traffic at a
  /// suspiciously high rate, due to which temporary rate limits have been
  /// imposed. The limit will be lifted when Gmail is confident enough of the
  /// nature of the traffic.
  /// - "SUSPECTED_SPAM" : The traffic is suspected to be spam, by Gmail, for
  /// various reasons.
  /// - "CONTENT_SPAMMY" : The traffic is suspected to be spammy, specific to
  /// the content.
  /// - "BAD_ATTACHMENT" : Traffic contains attachments not supported by Gmail.
  /// - "BAD_DMARC_POLICY" : The sender domain has set up a DMARC rejection
  /// policy.
  /// - "LOW_IP_REPUTATION" : The IP reputation of the sending IP is very low.
  /// - "LOW_DOMAIN_REPUTATION" : The Domain reputation of the sending domain is
  /// very low.
  /// - "IP_IN_RBL" : The IP is listed in one or more public \[Real-time
  /// Blackhole Lists\](http://en.wikipedia.org/wiki/DNSBL). Work with the RBL
  /// to get your IP delisted.
  /// - "DOMAIN_IN_RBL" : The Domain is listed in one or more public \[Real-time
  /// Blackhole Lists\](http://en.wikipedia.org/wiki/DNSBL). Work with the RBL
  /// to get your domain delisted.
  /// - "BAD_PTR_RECORD" : The sending IP is missing a
  /// [PTR record](https://support.google.com/domains/answer/3251147#ptr).
  core.String? errorType;

  $DeliveryError({this.errorClass, this.errorRatio, this.errorType});

  $DeliveryError.fromJson(core.Map json_)
    : this(
        errorClass: json_['errorClass'] as core.String?,
        errorRatio: (json_['errorRatio'] as core.num?)?.toDouble(),
        errorType: json_['errorType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorClass != null) 'errorClass': errorClass!,
    if (errorRatio != null) 'errorRatio': errorRatio!,
    if (errorType != null) 'errorType': errorType!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelRequestDeleteFieldRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelRequestDeleteFieldRequest
class $DeltaUpdateLabelRequestDeleteFieldRequest {
  /// ID of the Field to delete.
  ///
  /// Required.
  core.String? id;

  $DeltaUpdateLabelRequestDeleteFieldRequest({this.id});

  $DeltaUpdateLabelRequestDeleteFieldRequest.fromJson(core.Map json_)
    : this(id: json_['id'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {if (id != null) 'id': id!};
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelRequestDeleteSelectionChoiceRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelRequestDeleteSelectionChoiceRequest
class $DeltaUpdateLabelRequestDeleteSelectionChoiceRequest {
  /// The Selection Field from which a Choice will be deleted.
  ///
  /// Required.
  core.String? fieldId;

  /// Choice to delete.
  ///
  /// Required.
  core.String? id;

  $DeltaUpdateLabelRequestDeleteSelectionChoiceRequest({this.fieldId, this.id});

  $DeltaUpdateLabelRequestDeleteSelectionChoiceRequest.fromJson(core.Map json_)
    : this(
        fieldId: json_['fieldId'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldId != null) 'fieldId': fieldId!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelRequestEnableFieldRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelRequestEnableFieldRequest
class $DeltaUpdateLabelRequestEnableFieldRequest {
  /// ID of the Field to enable.
  ///
  /// Required.
  core.String? id;

  $DeltaUpdateLabelRequestEnableFieldRequest({this.id});

  $DeltaUpdateLabelRequestEnableFieldRequest.fromJson(core.Map json_)
    : this(id: json_['id'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {if (id != null) 'id': id!};
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelRequestEnableSelectionChoiceRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelRequestEnableSelectionChoiceRequest
class $DeltaUpdateLabelRequestEnableSelectionChoiceRequest {
  /// The Selection Field in which a Choice will be enabled.
  ///
  /// Required.
  core.String? fieldId;

  /// Choice to enable.
  ///
  /// Required.
  core.String? id;

  $DeltaUpdateLabelRequestEnableSelectionChoiceRequest({this.fieldId, this.id});

  $DeltaUpdateLabelRequestEnableSelectionChoiceRequest.fromJson(core.Map json_)
    : this(
        fieldId: json_['fieldId'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldId != null) 'fieldId': fieldId!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseCreateFieldResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseCreateFieldResponse
class $DeltaUpdateLabelResponseCreateFieldResponse {
  /// The field of the created field.
  ///
  /// When left blank in a create request, a key will be autogenerated and can
  /// be identified here.
  core.String? id;

  /// The priority of the created field.
  ///
  /// The priority may change from what was specified to assure contiguous
  /// priorities between fields (1-n).
  core.int? priority;

  $DeltaUpdateLabelResponseCreateFieldResponse({this.id, this.priority});

  $DeltaUpdateLabelResponseCreateFieldResponse.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        priority: json_['priority'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (priority != null) 'priority': priority!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseCreateSelectionChoiceResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseCreateSelectionChoiceResponse
class $DeltaUpdateLabelResponseCreateSelectionChoiceResponse {
  /// The server-generated id of the field.
  core.String? fieldId;

  /// The server-generated ID of the created choice within the Field
  core.String? id;

  $DeltaUpdateLabelResponseCreateSelectionChoiceResponse({
    this.fieldId,
    this.id,
  });

  $DeltaUpdateLabelResponseCreateSelectionChoiceResponse.fromJson(
    core.Map json_,
  ) : this(
        fieldId: json_['fieldId'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldId != null) 'fieldId': fieldId!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseUpdateFieldPropertiesResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseUpdateFieldPropertiesResponse
class $DeltaUpdateLabelResponseUpdateFieldPropertiesResponse {
  /// The priority of the updated field.
  ///
  /// The priority may change from what was specified to assure contiguous
  /// priorities between fields (1-n).
  core.int? priority;

  $DeltaUpdateLabelResponseUpdateFieldPropertiesResponse({this.priority});

  $DeltaUpdateLabelResponseUpdateFieldPropertiesResponse.fromJson(
    core.Map json_,
  ) : this(priority: json_['priority'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (priority != null) 'priority': priority!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseUpdateSelectionChoicePropertiesResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseUpdateSelectionChoicePropertiesResponse
class $DeltaUpdateLabelResponseUpdateSelectionChoicePropertiesResponse {
  /// The priority of the updated choice.
  ///
  /// The priority may change from what was specified to assure contiguous
  /// priorities between choices (1-n).
  core.int? priority;

  $DeltaUpdateLabelResponseUpdateSelectionChoicePropertiesResponse({
    this.priority,
  });

  $DeltaUpdateLabelResponseUpdateSelectionChoicePropertiesResponse.fromJson(
    core.Map json_,
  ) : this(priority: json_['priority'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (priority != null) 'priority': priority!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DemoteMasterMySqlReplicaConfiguration
/// - sqladmin:v1beta4 : DemoteMasterMySqlReplicaConfiguration
class $DemoteMasterMySqlReplicaConfiguration {
  /// PEM representation of the trusted CA's x509 certificate.
  core.String? caCertificate;

  /// PEM representation of the replica's x509 certificate.
  core.String? clientCertificate;

  /// PEM representation of the replica's private key.
  ///
  /// The corresponding public key is encoded in the client's certificate. The
  /// format of the replica's private key can be either PKCS #1 or PKCS #8.
  core.String? clientKey;

  /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
  core.String? kind;

  /// The password for the replication connection.
  core.String? password;

  /// The username for the replication connection.
  core.String? username;

  $DemoteMasterMySqlReplicaConfiguration({
    this.caCertificate,
    this.clientCertificate,
    this.clientKey,
    this.kind,
    this.password,
    this.username,
  });

  $DemoteMasterMySqlReplicaConfiguration.fromJson(core.Map json_)
    : this(
        caCertificate: json_['caCertificate'] as core.String?,
        clientCertificate: json_['clientCertificate'] as core.String?,
        clientKey: json_['clientKey'] as core.String?,
        kind: json_['kind'] as core.String?,
        password: json_['password'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caCertificate != null) 'caCertificate': caCertificate!,
    if (clientCertificate != null) 'clientCertificate': clientCertificate!,
    if (clientKey != null) 'clientKey': clientKey!,
    if (kind != null) 'kind': kind!,
    if (password != null) 'password': password!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - language:v1 : DependencyEdge
/// - language:v1beta2 : DependencyEdge
class $DependencyEdge {
  /// Represents the head of this token in the dependency tree.
  ///
  /// This is the index of the token which has an arc going to this token. The
  /// index is the position of the token in the array of tokens returned by the
  /// API method. If this token is a root token, then the `head_token_index` is
  /// its own index.
  core.int? headTokenIndex;

  /// The parse label for the token.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown
  /// - "ABBREV" : Abbreviation modifier
  /// - "ACOMP" : Adjectival complement
  /// - "ADVCL" : Adverbial clause modifier
  /// - "ADVMOD" : Adverbial modifier
  /// - "AMOD" : Adjectival modifier of an NP
  /// - "APPOS" : Appositional modifier of an NP
  /// - "ATTR" : Attribute dependent of a copular verb
  /// - "AUX" : Auxiliary (non-main) verb
  /// - "AUXPASS" : Passive auxiliary
  /// - "CC" : Coordinating conjunction
  /// - "CCOMP" : Clausal complement of a verb or adjective
  /// - "CONJ" : Conjunct
  /// - "CSUBJ" : Clausal subject
  /// - "CSUBJPASS" : Clausal passive subject
  /// - "DEP" : Dependency (unable to determine)
  /// - "DET" : Determiner
  /// - "DISCOURSE" : Discourse
  /// - "DOBJ" : Direct object
  /// - "EXPL" : Expletive
  /// - "GOESWITH" : Goes with (part of a word in a text not well edited)
  /// - "IOBJ" : Indirect object
  /// - "MARK" : Marker (word introducing a subordinate clause)
  /// - "MWE" : Multi-word expression
  /// - "MWV" : Multi-word verbal expression
  /// - "NEG" : Negation modifier
  /// - "NN" : Noun compound modifier
  /// - "NPADVMOD" : Noun phrase used as an adverbial modifier
  /// - "NSUBJ" : Nominal subject
  /// - "NSUBJPASS" : Passive nominal subject
  /// - "NUM" : Numeric modifier of a noun
  /// - "NUMBER" : Element of compound number
  /// - "P" : Punctuation mark
  /// - "PARATAXIS" : Parataxis relation
  /// - "PARTMOD" : Participial modifier
  /// - "PCOMP" : The complement of a preposition is a clause
  /// - "POBJ" : Object of a preposition
  /// - "POSS" : Possession modifier
  /// - "POSTNEG" : Postverbal negative particle
  /// - "PRECOMP" : Predicate complement
  /// - "PRECONJ" : Preconjunt
  /// - "PREDET" : Predeterminer
  /// - "PREF" : Prefix
  /// - "PREP" : Prepositional modifier
  /// - "PRONL" : The relationship between a verb and verbal morpheme
  /// - "PRT" : Particle
  /// - "PS" : Associative or possessive marker
  /// - "QUANTMOD" : Quantifier phrase modifier
  /// - "RCMOD" : Relative clause modifier
  /// - "RCMODREL" : Complementizer in relative clause
  /// - "RDROP" : Ellipsis without a preceding predicate
  /// - "REF" : Referent
  /// - "REMNANT" : Remnant
  /// - "REPARANDUM" : Reparandum
  /// - "ROOT" : Root
  /// - "SNUM" : Suffix specifying a unit of number
  /// - "SUFF" : Suffix
  /// - "TMOD" : Temporal modifier
  /// - "TOPIC" : Topic marker
  /// - "VMOD" : Clause headed by an infinite form of the verb that modifies a
  /// noun
  /// - "VOCATIVE" : Vocative
  /// - "XCOMP" : Open clausal complement
  /// - "SUFFIX" : Name suffix
  /// - "TITLE" : Name title
  /// - "ADVPHMOD" : Adverbial phrase modifier
  /// - "AUXCAUS" : Causative auxiliary
  /// - "AUXVV" : Helper auxiliary
  /// - "DTMOD" : Rentaishi (Prenominal modifier)
  /// - "FOREIGN" : Foreign words
  /// - "KW" : Keyword
  /// - "LIST" : List for chains of comparable items
  /// - "NOMC" : Nominalized clause
  /// - "NOMCSUBJ" : Nominalized clausal subject
  /// - "NOMCSUBJPASS" : Nominalized clausal passive
  /// - "NUMC" : Compound of numeric modifier
  /// - "COP" : Copula
  /// - "DISLOCATED" : Dislocated relation (for fronted/topicalized elements)
  /// - "ASP" : Aspect marker
  /// - "GMOD" : Genitive modifier
  /// - "GOBJ" : Genitive object
  /// - "INFMOD" : Infinitival modifier
  /// - "MES" : Measure
  /// - "NCOMP" : Nominal complement of a noun
  core.String? label;

  $DependencyEdge({this.headTokenIndex, this.label});

  $DependencyEdge.fromJson(core.Map json_)
    : this(
        headTokenIndex: json_['headTokenIndex'] as core.int?,
        label: json_['label'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (headTokenIndex != null) 'headTokenIndex': headTokenIndex!,
    if (label != null) 'label': label!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DeployFlowRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DeployFlowRequest
class $DeployFlowRequest {
  /// The flow version to deploy.
  ///
  /// Format: `projects//locations//agents//flows//versions/`.
  ///
  /// Required.
  core.String? flowVersion;

  $DeployFlowRequest({this.flowVersion});

  $DeployFlowRequest.fromJson(core.Map json_)
    : this(flowVersion: json_['flowVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (flowVersion != null) 'flowVersion': flowVersion!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DeployRequestEndpointConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DeployRequestEndpointConfig
class $DeployRequestEndpointConfig {
  /// If true, the endpoint will be exposed through a dedicated DNS
  /// \[Endpoint.dedicated_endpoint_dns\].
  ///
  /// Your request to the dedicated DNS will be isolated from other users'
  /// traffic and will have better performance and reliability. Note: Once you
  /// enabled dedicated endpoint, you won't be able to send request to the
  /// shared DNS {region}-aiplatform.googleapis.com. The limitations will be
  /// removed soon.
  ///
  /// Optional.
  core.bool? dedicatedEndpointEnabled;

  /// The user-specified display name of the endpoint.
  ///
  /// If not set, a default name will be used.
  ///
  /// Optional.
  core.String? endpointDisplayName;

  $DeployRequestEndpointConfig({
    this.dedicatedEndpointEnabled,
    this.endpointDisplayName,
  });

  $DeployRequestEndpointConfig.fromJson(core.Map json_)
    : this(
        dedicatedEndpointEnabled:
            json_['dedicatedEndpointEnabled'] as core.bool?,
        endpointDisplayName: json_['endpointDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dedicatedEndpointEnabled != null)
      'dedicatedEndpointEnabled': dedicatedEndpointEnabled!,
    if (endpointDisplayName != null)
      'endpointDisplayName': endpointDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DeployedIndexAuthConfigAuthProvider
class $DeployedIndexAuthConfigAuthProvider {
  /// A list of allowed JWT issuers.
  ///
  /// Each entry must be a valid Google service account, in the following
  /// format: `service-account-name@project-id.iam.gserviceaccount.com`
  core.List<core.String>? allowedIssuers;

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  ///
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted.
  core.List<core.String>? audiences;

  $DeployedIndexAuthConfigAuthProvider({this.allowedIssuers, this.audiences});

  $DeployedIndexAuthConfigAuthProvider.fromJson(core.Map json_)
    : this(
        allowedIssuers:
            (json_['allowedIssuers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        audiences:
            (json_['audiences'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedIssuers != null) 'allowedIssuers': allowedIssuers!,
    if (audiences != null) 'audiences': audiences!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DeployedIndexRef
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DeployedIndexRef
class $DeployedIndexRef {
  /// The ID of the DeployedIndex in the above IndexEndpoint.
  ///
  /// Immutable.
  core.String? deployedIndexId;

  /// The display name of the DeployedIndex.
  ///
  /// Output only.
  core.String? displayName;

  /// A resource name of the IndexEndpoint.
  ///
  /// Immutable.
  core.String? indexEndpoint;

  $DeployedIndexRef({
    this.deployedIndexId,
    this.displayName,
    this.indexEndpoint,
  });

  $DeployedIndexRef.fromJson(core.Map json_)
    : this(
        deployedIndexId: json_['deployedIndexId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        indexEndpoint: json_['indexEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
    if (displayName != null) 'displayName': displayName!,
    if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DeployedModelRef
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DeployedModelRef
class $DeployedModelRef {
  /// The ID of the Checkpoint deployed in the DeployedModel.
  ///
  /// Immutable.
  core.String? checkpointId;

  /// An ID of a DeployedModel in the above Endpoint.
  ///
  /// Immutable.
  core.String? deployedModelId;

  /// A resource name of an Endpoint.
  ///
  /// Immutable.
  core.String? endpoint;

  $DeployedModelRef({this.checkpointId, this.deployedModelId, this.endpoint});

  $DeployedModelRef.fromJson(core.Map json_)
    : this(
        checkpointId: json_['checkpointId'] as core.String?,
        deployedModelId: json_['deployedModelId'] as core.String?,
        endpoint: json_['endpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (endpoint != null) 'endpoint': endpoint!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DeployedModelStatus
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DeployedModelStatus
class $DeployedModelStatus {
  /// The number of available replicas of the deployed model.
  ///
  /// Output only.
  core.int? availableReplicaCount;

  /// The time at which the status was last updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  /// The latest deployed model's status message (if any).
  ///
  /// Output only.
  core.String? message;

  $DeployedModelStatus({
    this.availableReplicaCount,
    this.lastUpdateTime,
    this.message,
  });

  $DeployedModelStatus.fromJson(core.Map json_)
    : this(
        availableReplicaCount: json_['availableReplicaCount'] as core.int?,
        lastUpdateTime: json_['lastUpdateTime'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (availableReplicaCount != null)
      'availableReplicaCount': availableReplicaCount!,
    if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DeploymentResult
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DeploymentResult
class $DeploymentResult {
  /// Results of test cases running before the deployment.
  ///
  /// Format: `projects//locations//agents//testCases//results/`.
  core.List<core.String>? deploymentTestResults;

  /// The name of the experiment triggered by this deployment.
  ///
  /// Format: projects//locations//agents//environments//experiments/.
  core.String? experiment;

  $DeploymentResult({this.deploymentTestResults, this.experiment});

  $DeploymentResult.fromJson(core.Map json_)
    : this(
        deploymentTestResults:
            (json_['deploymentTestResults'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        experiment: json_['experiment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deploymentTestResults != null)
      'deploymentTestResults': deploymentTestResults!,
    if (experiment != null) 'experiment': experiment!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : DeploymentsCancelPreviewRequest
/// - deploymentmanager:v2 : DeploymentsCancelPreviewRequest
/// - deploymentmanager:v2beta : DeploymentsCancelPreviewRequest
class $DeploymentsCancelPreviewRequest {
  /// Specifies a fingerprint for `cancelPreview()` requests.
  ///
  /// A fingerprint is a randomly generated value that must be provided in
  /// `cancelPreview()` requests to perform optimistic locking. This ensures
  /// optimistic concurrency so that the deployment does not have conflicting
  /// requests (e.g. if someone attempts to make a new update request while
  /// another user attempts to cancel a preview, this would prevent one of the
  /// requests). The fingerprint is initially generated by Deployment Manager
  /// and changes after every request to modify a deployment. To get the latest
  /// fingerprint value, perform a `get()` request on the deployment.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $DeploymentsCancelPreviewRequest({this.fingerprint});

  $DeploymentsCancelPreviewRequest.fromJson(core.Map json_)
    : this(fingerprint: json_['fingerprint'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : DeploymentsStopRequest
/// - deploymentmanager:v2 : DeploymentsStopRequest
/// - deploymentmanager:v2beta : DeploymentsStopRequest
class $DeploymentsStopRequest {
  /// Specifies a fingerprint for `stop()` requests.
  ///
  /// A fingerprint is a randomly generated value that must be provided in
  /// `stop()` requests to perform optimistic locking. This ensures optimistic
  /// concurrency so that the deployment does not have conflicting requests
  /// (e.g. if someone attempts to make a new update request while another user
  /// attempts to stop an ongoing update request, this would prevent a
  /// collision). The fingerprint is initially generated by Deployment Manager
  /// and changes after every request to modify a deployment. To get the latest
  /// fingerprint value, perform a `get()` request on the deployment.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $DeploymentsStopRequest({this.fingerprint});

  $DeploymentsStopRequest.fromJson(core.Map json_)
    : this(fingerprint: json_['fingerprint'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
  };
}

/// Used by:
///
/// - container:v1 : DesiredEnterpriseConfig
/// - container:v1beta1 : DesiredEnterpriseConfig
class $DesiredEnterpriseConfig {
  /// desired_tier specifies the desired tier of the cluster.
  /// Possible string values are:
  /// - "CLUSTER_TIER_UNSPECIFIED" : CLUSTER_TIER_UNSPECIFIED is when
  /// cluster_tier is not set.
  /// - "STANDARD" : STANDARD indicates a standard GKE cluster.
  /// - "ENTERPRISE" : ENTERPRISE indicates a GKE Enterprise cluster.
  core.String? desiredTier;

  $DesiredEnterpriseConfig({this.desiredTier});

  $DesiredEnterpriseConfig.fromJson(core.Map json_)
    : this(desiredTier: json_['desiredTier'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (desiredTier != null) 'desiredTier': desiredTier!,
  };
}

/// Used by:
///
/// - connectors:v1 : Destination
/// - integrations:v1 : GoogleCloudConnectorsV1Destination
class $Destination {
  /// For publicly routable host.
  core.String? host;

  /// The port is the target port number that is accepted by the destination.
  core.int? port;

  /// PSC service attachments.
  ///
  /// Format: projects / * /regions / * /serviceAttachments / *
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? serviceAttachment;

  $Destination({this.host, this.port, this.serviceAttachment});

  $Destination.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : DestinationDatasetReference
/// - analyticshub:v1beta1 : GoogleCloudBigqueryDataexchangeV1beta1DestinationDatasetReference
class $DestinationDatasetReference {
  /// A unique ID for this dataset, without the project name.
  ///
  /// The ID must contain only letters (a-z, A-Z), numbers (0-9), or underscores
  /// (_). The maximum length is 1,024 characters.
  ///
  /// Required.
  core.String? datasetId;

  /// The ID of the project containing this dataset.
  ///
  /// Required.
  core.String? projectId;

  $DestinationDatasetReference({this.datasetId, this.projectId});

  $DestinationDatasetReference.fromJson(core.Map json_)
    : this(
        datasetId: json_['datasetId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetId != null) 'datasetId': datasetId!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DestinationFeatureSetting
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DestinationFeatureSetting
class $DestinationFeatureSetting {
  /// Specify the field name in the export destination.
  ///
  /// If not specified, Feature ID is used.
  core.String? destinationField;

  /// The ID of the Feature to apply the setting to.
  ///
  /// Required.
  core.String? featureId;

  $DestinationFeatureSetting({this.destinationField, this.featureId});

  $DestinationFeatureSetting.fromJson(core.Map json_)
    : this(
        destinationField: json_['destinationField'] as core.String?,
        featureId: json_['featureId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationField != null) 'destinationField': destinationField!,
    if (featureId != null) 'featureId': featureId!,
  };
}

/// Used by:
///
/// - vision:v1 : DetectedBreak
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1TextAnnotationDetectedBreak
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1TextAnnotationDetectedBreak
class $DetectedBreak {
  /// True if break prepends the element.
  core.bool? isPrefix;

  /// Detected break type.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown break label type.
  /// - "SPACE" : Regular space.
  /// - "SURE_SPACE" : Sure space (very wide).
  /// - "EOL_SURE_SPACE" : Line-wrapping break.
  /// - "HYPHEN" : End-line hyphen that is not present in text; does not
  /// co-occur with `SPACE`, `LEADER_SPACE`, or `LINE_BREAK`.
  /// - "LINE_BREAK" : Line break that ends a paragraph.
  core.String? type;

  $DetectedBreak({this.isPrefix, this.type});

  $DetectedBreak.fromJson(core.Map json_)
    : this(
        isPrefix: json_['isPrefix'] as core.bool?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isPrefix != null) 'isPrefix': isPrefix!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - vision:v1 : DetectedLanguage
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1TextAnnotationDetectedLanguage
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1TextAnnotationDetectedLanguage
class $DetectedLanguage {
  /// Confidence of detected language.
  ///
  /// Range \[0, 1\].
  core.double? confidence;

  /// The BCP-47 language code, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  core.String? languageCode;

  $DetectedLanguage({this.confidence, this.languageCode});

  $DetectedLanguage.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1DeviceCheckConfig
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaDeviceCheckConfig
class $DeviceCheckConfig {
  /// The key identifier of a private key enabled with DeviceCheck, created in
  /// your Apple Developer account.
  ///
  /// Required.
  core.String? keyId;

  /// The relative resource name of the DeviceCheck configuration object, in the
  /// format: ``` projects/{project_number}/apps/{app_id}/deviceCheckConfig ```
  ///
  /// Required.
  core.String? name;

  /// Input only.
  ///
  /// The contents of the private key (`.p8`) file associated with the key
  /// specified by `key_id`. For security reasons, this field will never be
  /// populated in any response.
  ///
  /// Required.
  core.String? privateKey;

  /// Whether the `private_key` field was previously set.
  ///
  /// Since we will never return the `private_key` field, this field is the only
  /// way to find out whether it was previously set.
  ///
  /// Output only.
  core.bool? privateKeySet;

  /// Specifies the duration for which App Check tokens exchanged from
  /// DeviceCheck tokens will be valid.
  ///
  /// If unset, a default value of 1 hour is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $DeviceCheckConfig({
    this.keyId,
    this.name,
    this.privateKey,
    this.privateKeySet,
    this.tokenTtl,
  });

  $DeviceCheckConfig.fromJson(core.Map json_)
    : this(
        keyId: json_['keyId'] as core.String?,
        name: json_['name'] as core.String?,
        privateKey: json_['privateKey'] as core.String?,
        privateKeySet: json_['privateKeySet'] as core.bool?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (keyId != null) 'keyId': keyId!,
    if (name != null) 'name': name!,
    if (privateKey != null) 'privateKey': privateKey!,
    if (privateKeySet != null) 'privateKeySet': privateKeySet!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - androidpublisher:v3 : DeviceId
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1DeviceId
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1DeviceId
class $DeviceId {
  /// Value of Build.BRAND.
  core.String? buildBrand;

  /// Value of Build.DEVICE.
  core.String? buildDevice;

  $DeviceId({this.buildBrand, this.buildDevice});

  $DeviceId.fromJson(core.Map json_)
    : this(
        buildBrand: json_['buildBrand'] as core.String?,
        buildDevice: json_['buildDevice'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (buildBrand != null) 'buildBrand': buildBrand!,
    if (buildDevice != null) 'buildDevice': buildDevice!,
  };
}

/// Used by:
///
/// - jobs:v3 : DeviceInfo
/// - jobs:v3p1beta1 : DeviceInfo
class $DeviceInfo {
  /// Type of the device.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DEVICE_TYPE_UNSPECIFIED" : The device type isn't specified.
  /// - "WEB" : A desktop web browser, such as, Chrome, Firefox, Safari, or
  /// Internet Explorer)
  /// - "MOBILE_WEB" : A mobile device web browser, such as a phone or tablet
  /// with a Chrome browser.
  /// - "ANDROID" : An Android device native application.
  /// - "IOS" : An iOS device native application.
  /// - "BOT" : A bot, as opposed to a device operated by human beings, such as
  /// a web crawler.
  /// - "OTHER" : Other devices types.
  core.String? deviceType;

  /// A device-specific ID.
  ///
  /// The ID must be a unique identifier that distinguishes the device from
  /// other devices.
  ///
  /// Optional.
  core.String? id;

  $DeviceInfo({this.deviceType, this.id});

  $DeviceInfo.fromJson(core.Map json_)
    : this(
        deviceType: json_['deviceType'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceType != null) 'deviceType': deviceType!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DeviceMakeModelAssignedTargetingOptionDetails
/// - displayvideo:v3 : DeviceMakeModelAssignedTargetingOptionDetails
/// - displayvideo:v4 : DeviceMakeModelAssignedTargetingOptionDetails
class $DeviceMakeModelAssignedTargetingOptionDetails {
  /// The display name of the device make and model.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_DEVICE_MAKE_MODEL`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $DeviceMakeModelAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $DeviceMakeModelAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DeviceMakeModelTargetingOptionDetails
/// - displayvideo:v3 : DeviceMakeModelTargetingOptionDetails
/// - displayvideo:v4 : DeviceMakeModelTargetingOptionDetails
class $DeviceMakeModelTargetingOptionDetails {
  /// The display name of the device make and model.
  ///
  /// Output only.
  core.String? displayName;

  $DeviceMakeModelTargetingOptionDetails({this.displayName});

  $DeviceMakeModelTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DeviceTypeAssignedTargetingOptionDetails
/// - displayvideo:v3 : DeviceTypeAssignedTargetingOptionDetails
/// - displayvideo:v4 : DeviceTypeAssignedTargetingOptionDetails
class $DeviceTypeAssignedTargetingOptionDetails {
  /// The display name of the device type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DEVICE_TYPE_UNSPECIFIED" : Default value when device type is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real device type option.
  /// - "DEVICE_TYPE_COMPUTER" : Computer.
  /// - "DEVICE_TYPE_CONNECTED_TV" : Connected TV.
  /// - "DEVICE_TYPE_SMART_PHONE" : Smart phone.
  /// - "DEVICE_TYPE_TABLET" : Tablet.
  /// - "DEVICE_TYPE_CONNECTED_DEVICE" : Connected device.
  core.String? deviceType;

  /// Bid multiplier allows you to show your ads more or less frequently based
  /// on the device type.
  ///
  /// It will apply a multiplier on the original bid price. When this field is
  /// 0, it indicates this field is not applicable instead of multiplying 0 on
  /// the original bid price. For example, if the bid price without multiplier
  /// is $10.0 and the multiplier is 1.5 for Tablet, the resulting bid price for
  /// Tablet will be $15.0. Only applicable to YouTube and Partners line items.
  ///
  /// Output only.
  core.double? youtubeAndPartnersBidMultiplier;

  $DeviceTypeAssignedTargetingOptionDetails({
    this.deviceType,
    this.youtubeAndPartnersBidMultiplier,
  });

  $DeviceTypeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        deviceType: json_['deviceType'] as core.String?,
        youtubeAndPartnersBidMultiplier:
            (json_['youtubeAndPartnersBidMultiplier'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceType != null) 'deviceType': deviceType!,
    if (youtubeAndPartnersBidMultiplier != null)
      'youtubeAndPartnersBidMultiplier': youtubeAndPartnersBidMultiplier!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DeviceTypeTargetingOptionDetails
/// - displayvideo:v3 : DeviceTypeTargetingOptionDetails
/// - displayvideo:v4 : DeviceTypeTargetingOptionDetails
class $DeviceTypeTargetingOptionDetails {
  /// The device type that is used to be targeted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEVICE_TYPE_UNSPECIFIED" : Default value when device type is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real device type option.
  /// - "DEVICE_TYPE_COMPUTER" : Computer.
  /// - "DEVICE_TYPE_CONNECTED_TV" : Connected TV.
  /// - "DEVICE_TYPE_SMART_PHONE" : Smart phone.
  /// - "DEVICE_TYPE_TABLET" : Tablet.
  /// - "DEVICE_TYPE_CONNECTED_DEVICE" : Connected device.
  core.String? deviceType;

  $DeviceTypeTargetingOptionDetails({this.deviceType});

  $DeviceTypeTargetingOptionDetails.fromJson(core.Map json_)
    : this(deviceType: json_['deviceType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceType != null) 'deviceType': deviceType!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : Diagnostic
/// - deploymentmanager:v2beta : Diagnostic
class $Diagnostic {
  /// JsonPath expression on the resource that if non empty, indicates that this
  /// field needs to be extracted as a diagnostic.
  core.String? field;

  /// Level to record this diagnostic.
  /// Possible string values are:
  /// - "UNKNOWN"
  /// - "INFORMATION" : If level is informational, it only gets displayed as
  /// part of the resource.
  /// - "WARNING" : If level is warning, will end up in the resource as a
  /// warning.
  /// - "ERROR" : If level is error, it will indicate an error occurred after
  /// finishCondition is set, and this field will populate resource errors and
  /// operation errors.
  core.String? level;

  $Diagnostic({this.field, this.level});

  $Diagnostic.fromJson(core.Map json_)
    : this(
        field: json_['field'] as core.String?,
        level: json_['level'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (field != null) 'field': field!,
    if (level != null) 'level': level!,
  };
}

/// Used by:
///
/// - healthcare:v1 : DicomFilterConfig
/// - healthcare:v1beta1 : DicomFilterConfig
class $DicomFilterConfig {
  /// The Cloud Storage location of the filter configuration file.
  ///
  /// The `gcs_uri` must be in the format `gs://bucket/path/to/object`. The
  /// filter configuration file must contain a list of resource paths separated
  /// by newline characters (\n or \r\n). Each resource path must be in the
  /// format
  /// "/studies/{studyUID}\[/series/{seriesUID}\[/instances/{instanceUID}\]\]"
  /// The Cloud Healthcare API service account must have the
  /// `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage
  /// location.
  core.String? resourcePathsGcsUri;

  $DicomFilterConfig({this.resourcePathsGcsUri});

  $DicomFilterConfig.fromJson(core.Map json_)
    : this(resourcePathsGcsUri: json_['resourcePathsGcsUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePathsGcsUri != null)
      'resourcePathsGcsUri': resourcePathsGcsUri!,
  };
}

/// Used by:
///
/// - healthcare:v1 : GoogleCloudHealthcareV1DicomGcsSource
/// - healthcare:v1beta1 : GoogleCloudHealthcareV1beta1DicomGcsSource
class $DicomGcsSource {
  /// Points to a Cloud Storage URI containing file(s) with content only.
  ///
  /// The URI must be in the following format: `gs://{bucket_id}/{object_id}`.
  /// The URI can include wildcards in `object_id` and thus identify multiple
  /// files. Supported wildcards: * '*' to match 0 or more non-separator
  /// characters * '**' to match 0 or more characters (including separators).
  /// Must be used at the end of a path and with no other wildcards in the path.
  /// Can also be used with a file extension (such as .dcm), which imports all
  /// files with the extension in the specified directory and its
  /// sub-directories. For example, `gs://my-bucket/my-directory / * *.dcm`
  /// imports all files with .dcm extensions in `my-directory/` and its
  /// sub-directories. * '?' to match 1 character. All other URI formats are
  /// invalid. Files matching the wildcard are expected to contain content only,
  /// no metadata.
  core.String? uri;

  $DicomGcsSource({this.uri});

  $DicomGcsSource.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - healthcare:v1 : DicomNotificationConfig
/// - healthcare:v1beta1 : DicomNotificationConfig
class $DicomNotificationConfig {
  /// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that
  /// notifications of changes are published on.
  ///
  /// Supplied by the client. The notification is a `PubsubMessage` with the
  /// following fields: * `PubsubMessage.Data` contains the resource name. *
  /// `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed
  /// to be unique within the topic. * `PubsubMessage.PublishTime` is the time
  /// when the message was published. * `PubsubMessage.Attributes` contains the
  /// following attributes: * `action`: The name of the endpoint that generated
  /// the notification. Possible values are `StoreInstances`, `SetBlobSettings`,
  /// `ImportDicomData`, etc. * `lastUpdatedTime`: The latest timestamp when the
  /// DICOM instance was updated. * `storeName`: The resource name of the DICOM
  /// store, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}`.
  /// * `studyInstanceUID`: The study UID of the DICOM instance that was
  /// changed. * `seriesInstanceUID`: The series UID of the DICOM instance that
  /// was changed. * `sopInstanceUID`: The instance UID of the DICOM instance
  /// that was changed. * `versionId`: The version ID of the DICOM instance that
  /// was changed. * `modality`: The modality tag of the DICOM instance that was
  /// changed. * `previousStorageClass`: The storage class where the DICOM
  /// instance was previously stored if the storage class was changed. *
  /// `storageClass`: The storage class where the DICOM instance is currently
  /// stored. Note that notifications are only sent if the topic is non-empty.
  /// [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be
  /// scoped to a project. The Cloud Healthcare API service account,
  /// service-@gcp-sa-healthcare.iam.gserviceaccount.com, must have the
  /// `pubsub.topics.publish` permission (which is typically included in
  /// `roles/pubsub.publisher` role) on the given Pub/Sub topic. Not having
  /// adequate permissions causes the calls that send notifications to fail
  /// (https://cloud.google.com/healthcare-api/docs/permissions-healthcare-api-gcp-products#dicom_fhir_and_hl7v2_store_cloud_pubsub_permissions).
  /// If a notification can't be published to Pub/Sub, errors are logged to
  /// Cloud Logging. For more information, see
  /// [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare-api/docs/how-tos/logging).
  ///
  /// Required.
  core.String? pubsubTopic;

  $DicomNotificationConfig({this.pubsubTopic});

  $DicomNotificationConfig.fromJson(core.Map json_)
    : this(pubsubTopic: json_['pubsubTopic'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pubsubTopic != null) 'pubsubTopic': pubsubTopic!,
  };
}

/// Used by:
///
/// - healthcare:v1 : DicomStoreMetrics
/// - healthcare:v1beta1 : DicomStoreMetrics
class $DicomStoreMetrics {
  /// Total blob storage bytes for all instances in the store.
  core.String? blobStorageSizeBytes;

  /// Number of instances in the store.
  core.String? instanceCount;

  /// Resource name of the DICOM store, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}`.
  core.String? name;

  /// Number of series in the store.
  core.String? seriesCount;

  /// Total structured storage bytes for all instances in the store.
  core.String? structuredStorageSizeBytes;

  /// Number of studies in the store.
  core.String? studyCount;

  $DicomStoreMetrics({
    this.blobStorageSizeBytes,
    this.instanceCount,
    this.name,
    this.seriesCount,
    this.structuredStorageSizeBytes,
    this.studyCount,
  });

  $DicomStoreMetrics.fromJson(core.Map json_)
    : this(
        blobStorageSizeBytes: json_['blobStorageSizeBytes'] as core.String?,
        instanceCount: json_['instanceCount'] as core.String?,
        name: json_['name'] as core.String?,
        seriesCount: json_['seriesCount'] as core.String?,
        structuredStorageSizeBytes:
            json_['structuredStorageSizeBytes'] as core.String?,
        studyCount: json_['studyCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobStorageSizeBytes != null)
      'blobStorageSizeBytes': blobStorageSizeBytes!,
    if (instanceCount != null) 'instanceCount': instanceCount!,
    if (name != null) 'name': name!,
    if (seriesCount != null) 'seriesCount': seriesCount!,
    if (structuredStorageSizeBytes != null)
      'structuredStorageSizeBytes': structuredStorageSizeBytes!,
    if (studyCount != null) 'studyCount': studyCount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GdataDiffVersionResponse
/// - discoveryengine:v1alpha : GdataDiffVersionResponse
/// - discoveryengine:v1beta : GdataDiffVersionResponse
/// - firebaseappdistribution:v1 : GdataDiffVersionResponse
/// - walletobjects:v1 : DiffVersionResponse
class $DiffVersionResponse00 {
  /// The total size of the server object.
  core.String? objectSizeBytes;

  /// The version of the object stored at the server.
  core.String? objectVersion;

  $DiffVersionResponse00({this.objectSizeBytes, this.objectVersion});

  $DiffVersionResponse00.fromJson(core.Map json_)
    : this(
        objectSizeBytes: json_['objectSizeBytes'] as core.String?,
        objectVersion: json_['objectVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectSizeBytes != null) 'objectSizeBytes': objectSizeBytes!,
    if (objectVersion != null) 'objectVersion': objectVersion!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : DiffVersionResponse
/// - cloudsupport:v2beta : DiffVersionResponse
class $DiffVersionResponse01 {
  /// # gdata.* are outside protos with mising documentation
  core.String? objectSizeBytes;

  /// # gdata.* are outside protos with mising documentation
  core.String? objectVersion;

  $DiffVersionResponse01({this.objectSizeBytes, this.objectVersion});

  $DiffVersionResponse01.fromJson(core.Map json_)
    : this(
        objectSizeBytes: json_['objectSizeBytes'] as core.String?,
        objectVersion: json_['objectVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectSizeBytes != null) 'objectSizeBytes': objectSizeBytes!,
    if (objectVersion != null) 'objectVersion': objectVersion!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Digest
/// - containeranalysis:v1alpha1 : Digest
/// - containeranalysis:v1beta1 : Digest
class $Digest {
  /// `SHA1`, `SHA512` etc.
  core.String? algo;

  /// Value of the digest.
  core.String? digestBytes;
  core.List<core.int> get digestBytesAsBytes =>
      convert.base64.decode(digestBytes!);

  set digestBytesAsBytes(core.List<core.int> bytes_) {
    digestBytes = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Digest({this.algo, this.digestBytes});

  $Digest.fromJson(core.Map json_)
    : this(
        algo: json_['algo'] as core.String?,
        digestBytes: json_['digestBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algo != null) 'algo': algo!,
    if (digestBytes != null) 'digestBytes': digestBytes!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DigitalContentLabelAssignedTargetingOptionDetails
/// - displayvideo:v3 : DigitalContentLabelAssignedTargetingOptionDetails
/// - displayvideo:v4 : DigitalContentLabelAssignedTargetingOptionDetails
class $DigitalContentLabelAssignedTargetingOptionDetails {
  /// The display name of the digital content label rating tier to be EXCLUDED.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONTENT_RATING_TIER_UNSPECIFIED" : Content label is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real content rating.
  /// - "CONTENT_RATING_TIER_UNRATED" : Content that has not been labeled.
  /// - "CONTENT_RATING_TIER_GENERAL" : Content suitable for general audiences.
  /// - "CONTENT_RATING_TIER_PARENTAL_GUIDANCE" : Content suitable for most
  /// audiences with parental guidance.
  /// - "CONTENT_RATING_TIER_TEENS" : Content suitable for teen and older
  /// audiences.
  /// - "CONTENT_RATING_TIER_MATURE" : Content suitable only for mature
  /// audiences.
  /// - "CONTENT_RATING_TIER_FAMILIES" : Content suitable for family audiences.
  /// It is a subset of CONTENT_RATING_TIER_GENERAL. Only applicable to YouTube
  /// and Partners line items.
  core.String? excludedContentRatingTier;

  $DigitalContentLabelAssignedTargetingOptionDetails({
    this.excludedContentRatingTier,
  });

  $DigitalContentLabelAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        excludedContentRatingTier:
            json_['excludedContentRatingTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedContentRatingTier != null)
      'excludedContentRatingTier': excludedContentRatingTier!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DigitalContentLabelTargetingOptionDetails
/// - displayvideo:v3 : DigitalContentLabelTargetingOptionDetails
/// - displayvideo:v4 : DigitalContentLabelTargetingOptionDetails
class $DigitalContentLabelTargetingOptionDetails {
  /// An enum for the content label brand safety tiers.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_RATING_TIER_UNSPECIFIED" : Content label is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real content rating.
  /// - "CONTENT_RATING_TIER_UNRATED" : Content that has not been labeled.
  /// - "CONTENT_RATING_TIER_GENERAL" : Content suitable for general audiences.
  /// - "CONTENT_RATING_TIER_PARENTAL_GUIDANCE" : Content suitable for most
  /// audiences with parental guidance.
  /// - "CONTENT_RATING_TIER_TEENS" : Content suitable for teen and older
  /// audiences.
  /// - "CONTENT_RATING_TIER_MATURE" : Content suitable only for mature
  /// audiences.
  /// - "CONTENT_RATING_TIER_FAMILIES" : Content suitable for family audiences.
  /// It is a subset of CONTENT_RATING_TIER_GENERAL. Only applicable to YouTube
  /// and Partners line items.
  core.String? contentRatingTier;

  $DigitalContentLabelTargetingOptionDetails({this.contentRatingTier});

  $DigitalContentLabelTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentRatingTier: json_['contentRatingTier'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentRatingTier != null) 'contentRatingTier': contentRatingTier!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessOrderByDimensionOrderBy
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessOrderByDimensionOrderBy
/// - analyticsdata:v1beta : DimensionOrderBy
class $DimensionOrderBy {
  /// A dimension name in the request to order by.
  core.String? dimensionName;

  /// Controls the rule for dimension value ordering.
  /// Possible string values are:
  /// - "ORDER_TYPE_UNSPECIFIED" : Unspecified.
  /// - "ALPHANUMERIC" : Alphanumeric sort by Unicode code point. For example,
  /// "2" \< "A" \< "X" \< "b" \< "z".
  /// - "CASE_INSENSITIVE_ALPHANUMERIC" : Case insensitive alphanumeric sort by
  /// lower case Unicode code point. For example, "2" \< "A" \< "b" \< "X" \<
  /// "z".
  /// - "NUMERIC" : Dimension values are converted to numbers before sorting.
  /// For example in NUMERIC sort, "25" \< "100", and in `ALPHANUMERIC` sort,
  /// "100" \< "25". Non-numeric dimension values all have equal ordering value
  /// below all numeric values.
  core.String? orderType;

  $DimensionOrderBy({this.dimensionName, this.orderType});

  $DimensionOrderBy.fromJson(core.Map json_)
    : this(
        dimensionName: json_['dimensionName'] as core.String?,
        orderType: json_['orderType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensionName != null) 'dimensionName': dimensionName!,
    if (orderType != null) 'orderType': orderType!,
  };
}

/// Used by:
///
/// - analyticsdata:v1beta : DimensionValue
/// - analyticsdata:v1beta : V1betaAudienceDimensionValue
class $DimensionValue00 {
  /// Value as a string if the dimension type is a string.
  core.String? value;

  $DimensionValue00({this.value});

  $DimensionValue00.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dfareporting:v3.5 : DimensionValue
/// - dfareporting:v4 : DimensionValue
class $DimensionValue01 {
  /// The name of the dimension.
  core.String? dimensionName;

  /// The eTag of this response for caching purposes.
  core.String? etag;

  /// The ID associated with the value if available.
  core.String? id;

  /// The kind of resource this is, in this case dfareporting#dimensionValue.
  core.String? kind;

  /// Determines how the 'value' field is matched when filtering.
  ///
  /// If not specified, defaults to EXACT. If set to WILDCARD_EXPRESSION, '*' is
  /// allowed as a placeholder for variable length character sequences, and it
  /// can be escaped with a backslash. Note, only paid search dimensions
  /// ('dfa:paidSearch*') allow a matchType other than EXACT.
  /// Possible string values are:
  /// - "EXACT"
  /// - "BEGINS_WITH"
  /// - "CONTAINS"
  /// - "WILDCARD_EXPRESSION"
  core.String? matchType;

  /// The value of the dimension.
  core.String? value;

  $DimensionValue01({
    this.dimensionName,
    this.etag,
    this.id,
    this.kind,
    this.matchType,
    this.value,
  });

  $DimensionValue01.fromJson(core.Map json_)
    : this(
        dimensionName: json_['dimensionName'] as core.String?,
        etag: json_['etag'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        matchType: json_['matchType'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensionName != null) 'dimensionName': dimensionName!,
    if (etag != null) 'etag': etag!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (matchType != null) 'matchType': matchType!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1DimensionValue
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1DimensionValue
class $DimensionValue02 {
  /// Name of the dimension.
  core.String? dimension;

  /// Actual value, represented as an int64.
  core.String? int64Value;

  /// Actual value, represented as a string.
  core.String? stringValue;

  /// Human-friendly label for the value, always in English.
  ///
  /// For example, 'Spain' for the 'ES' country code. Whereas the dimension
  /// value is stable, this value label is subject to change. Do not assume that
  /// the (value, value_label) relationship is stable. For example, the ISO
  /// country code 'MK' changed its name recently to 'North Macedonia'.
  ///
  /// Optional.
  core.String? valueLabel;

  $DimensionValue02({
    this.dimension,
    this.int64Value,
    this.stringValue,
    this.valueLabel,
  });

  $DimensionValue02.fromJson(core.Map json_)
    : this(
        dimension: json_['dimension'] as core.String?,
        int64Value: json_['int64Value'] as core.String?,
        stringValue: json_['stringValue'] as core.String?,
        valueLabel: json_['valueLabel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimension != null) 'dimension': dimension!,
    if (int64Value != null) 'int64Value': int64Value!,
    if (stringValue != null) 'stringValue': stringValue!,
    if (valueLabel != null) 'valueLabel': valueLabel!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : Dimensions
/// - displayvideo:v3 : Dimensions
/// - displayvideo:v4 : Dimensions
class $Dimensions {
  /// The height in pixels.
  core.int? heightPixels;

  /// The width in pixels.
  core.int? widthPixels;

  $Dimensions({this.heightPixels, this.widthPixels});

  $Dimensions.fromJson(core.Map json_)
    : this(
        heightPixels: json_['heightPixels'] as core.int?,
        widthPixels: json_['widthPixels'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (heightPixels != null) 'heightPixels': heightPixels!,
    if (widthPixels != null) 'widthPixels': widthPixels!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DirectRawPredictRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DirectRawPredictRequest
class $DirectRawPredictRequest {
  /// The prediction input.
  core.String? input;
  core.List<core.int> get inputAsBytes => convert.base64.decode(input!);

  set inputAsBytes(core.List<core.int> bytes_) {
    input = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format: `/namespace.Service/Method/` Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  core.String? methodName;

  $DirectRawPredictRequest({this.input, this.methodName});

  $DirectRawPredictRequest.fromJson(core.Map json_)
    : this(
        input: json_['input'] as core.String?,
        methodName: json_['methodName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (input != null) 'input': input!,
    if (methodName != null) 'methodName': methodName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DirectRawPredictResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DirectRawPredictResponse
class $DirectRawPredictResponse {
  /// The prediction output.
  core.String? output;
  core.List<core.int> get outputAsBytes => convert.base64.decode(output!);

  set outputAsBytes(core.List<core.int> bytes_) {
    output = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $DirectRawPredictResponse({this.output});

  $DirectRawPredictResponse.fromJson(core.Map json_)
    : this(output: json_['output'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (output != null) 'output': output!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : DirectVpcEgressConnectionInfo
/// - networkmanagement:v1beta1 : DirectVpcEgressConnectionInfo
class $DirectVpcEgressConnectionInfo {
  /// URI of direct access network.
  core.String? networkUri;

  /// Region in which the Direct VPC egress is deployed.
  core.String? region;

  /// Selected starting IP address, from the selected IP range.
  core.String? selectedIpAddress;

  /// Selected IP range.
  core.String? selectedIpRange;

  /// URI of direct access subnetwork.
  core.String? subnetworkUri;

  $DirectVpcEgressConnectionInfo({
    this.networkUri,
    this.region,
    this.selectedIpAddress,
    this.selectedIpRange,
    this.subnetworkUri,
  });

  $DirectVpcEgressConnectionInfo.fromJson(core.Map json_)
    : this(
        networkUri: json_['networkUri'] as core.String?,
        region: json_['region'] as core.String?,
        selectedIpAddress: json_['selectedIpAddress'] as core.String?,
        selectedIpRange: json_['selectedIpRange'] as core.String?,
        subnetworkUri: json_['subnetworkUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (networkUri != null) 'networkUri': networkUri!,
    if (region != null) 'region': region!,
    if (selectedIpAddress != null) 'selectedIpAddress': selectedIpAddress!,
    if (selectedIpRange != null) 'selectedIpRange': selectedIpRange!,
    if (subnetworkUri != null) 'subnetworkUri': subnetworkUri!,
  };
}

/// Used by:
///
/// - dataform:v1beta1 : MakeDirectoryRequest
/// - dataform:v1beta1 : RemoveDirectoryRequest
class $DirectoryRequest {
  /// The directory's full path including directory name, relative to the
  /// workspace root.
  ///
  /// Required.
  core.String? path;

  $DirectoryRequest({this.path});

  $DirectoryRequest.fromJson(core.Map json_)
    : this(path: json_['path'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleCloudDataplexV1AssetDiscoverySpecCsvOptions
/// - dataplex:v1 : GoogleCloudDataplexV1ZoneDiscoverySpecCsvOptions
class $DiscoverySpecCsvOptions {
  /// The delimiter being used to separate values.
  ///
  /// This defaults to ','.
  ///
  /// Optional.
  core.String? delimiter;

  /// Whether to disable the inference of data type for CSV data.
  ///
  /// If true, all columns will be registered as strings.
  ///
  /// Optional.
  core.bool? disableTypeInference;

  /// The character encoding of the data.
  ///
  /// The default is UTF-8.
  ///
  /// Optional.
  core.String? encoding;

  /// The number of rows to interpret as header rows that should be skipped when
  /// reading data rows.
  ///
  /// Optional.
  core.int? headerRows;

  $DiscoverySpecCsvOptions({
    this.delimiter,
    this.disableTypeInference,
    this.encoding,
    this.headerRows,
  });

  $DiscoverySpecCsvOptions.fromJson(core.Map json_)
    : this(
        delimiter: json_['delimiter'] as core.String?,
        disableTypeInference: json_['disableTypeInference'] as core.bool?,
        encoding: json_['encoding'] as core.String?,
        headerRows: json_['headerRows'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (delimiter != null) 'delimiter': delimiter!,
    if (disableTypeInference != null)
      'disableTypeInference': disableTypeInference!,
    if (encoding != null) 'encoding': encoding!,
    if (headerRows != null) 'headerRows': headerRows!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleCloudDataplexV1AssetDiscoverySpecJsonOptions
/// - dataplex:v1 : GoogleCloudDataplexV1ZoneDiscoverySpecJsonOptions
class $DiscoverySpecJsonOptions {
  /// Whether to disable the inference of data type for Json data.
  ///
  /// If true, all columns will be registered as their primitive types (strings,
  /// number or boolean).
  ///
  /// Optional.
  core.bool? disableTypeInference;

  /// The character encoding of the data.
  ///
  /// The default is UTF-8.
  ///
  /// Optional.
  core.String? encoding;

  $DiscoverySpecJsonOptions({this.disableTypeInference, this.encoding});

  $DiscoverySpecJsonOptions.fromJson(core.Map json_)
    : this(
        disableTypeInference: json_['disableTypeInference'] as core.bool?,
        encoding: json_['encoding'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableTypeInference != null)
      'disableTypeInference': disableTypeInference!,
    if (encoding != null) 'encoding': encoding!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : Disk
/// - vmmigration:v1alpha1 : Disk
class $Disk {
  /// The disk's Logical Unit Number (LUN).
  core.int? lun;

  /// The disk name.
  core.String? name;

  /// The disk size in GB.
  core.int? sizeGb;

  $Disk({this.lun, this.name, this.sizeGb});

  $Disk.fromJson(core.Map json_)
    : this(
        lun: json_['lun'] as core.int?,
        name: json_['name'] as core.String?,
        sizeGb: json_['sizeGb'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lun != null) 'lun': lun!,
    if (name != null) 'name': name!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskAsyncReplication
/// - compute:beta : DiskAsyncReplication
/// - compute:v1 : DiskAsyncReplication
class $DiskAsyncReplication {
  /// URL of the DiskConsistencyGroupPolicy if replication was started on the
  /// disk as a member of a group.
  ///
  /// Output only.
  core.String? consistencyGroupPolicy;

  /// ID of the DiskConsistencyGroupPolicy if replication was started on the
  /// disk as a member of a group.
  ///
  /// Output only.
  core.String? consistencyGroupPolicyId;

  /// The other disk asynchronously replicated to or from the current disk.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// zones/zone/disks/disk
  core.String? disk;

  /// The unique ID of the other disk asynchronously replicated to or from the
  /// current disk.
  ///
  /// This value identifies the exact disk that was used to create this
  /// replication. For example, if you started replicating the persistent disk
  /// from a disk that was later deleted and recreated under the same name, the
  /// disk ID would identify the exact version of the disk that was used.
  ///
  /// Output only.
  core.String? diskId;

  $DiskAsyncReplication({
    this.consistencyGroupPolicy,
    this.consistencyGroupPolicyId,
    this.disk,
    this.diskId,
  });

  $DiskAsyncReplication.fromJson(core.Map json_)
    : this(
        consistencyGroupPolicy: json_['consistencyGroupPolicy'] as core.String?,
        consistencyGroupPolicyId:
            json_['consistencyGroupPolicyId'] as core.String?,
        disk: json_['disk'] as core.String?,
        diskId: json_['diskId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consistencyGroupPolicy != null)
      'consistencyGroupPolicy': consistencyGroupPolicy!,
    if (consistencyGroupPolicyId != null)
      'consistencyGroupPolicyId': consistencyGroupPolicyId!,
    if (disk != null) 'disk': disk!,
    if (diskId != null) 'diskId': diskId!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DiskEncryptionConfiguration
/// - sqladmin:v1beta4 : DiskEncryptionConfiguration
class $DiskEncryptionConfiguration {
  /// This is always `sql#diskEncryptionConfiguration`.
  core.String? kind;

  /// Resource name of KMS key for disk encryption
  core.String? kmsKeyName;

  $DiskEncryptionConfiguration({this.kind, this.kmsKeyName});

  $DiskEncryptionConfiguration.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        kmsKeyName: json_['kmsKeyName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DiskEncryptionStatus
/// - sqladmin:v1beta4 : DiskEncryptionStatus
class $DiskEncryptionStatus {
  /// This is always `sql#diskEncryptionStatus`.
  core.String? kind;

  /// KMS key version used to encrypt the Cloud SQL instance resource
  core.String? kmsKeyVersionName;

  $DiskEncryptionStatus({this.kind, this.kmsKeyVersionName});

  $DiskEncryptionStatus.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        kmsKeyVersionName: json_['kmsKeyVersionName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (kmsKeyVersionName != null) 'kmsKeyVersionName': kmsKeyVersionName!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : DiskImageDefaults
/// - vmmigration:v1alpha1 : DiskImageDefaults
class $DiskImageDefaults {
  /// The Image resource used when creating the disk.
  ///
  /// Required.
  core.String? sourceImage;

  $DiskImageDefaults({this.sourceImage});

  $DiskImageDefaults.fromJson(core.Map json_)
    : this(sourceImage: json_['sourceImage'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceImage != null) 'sourceImage': sourceImage!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskInstantiationConfig
/// - compute:beta : DiskInstantiationConfig
/// - compute:v1 : DiskInstantiationConfig
class $DiskInstantiationConfig {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool? autoDelete;

  /// The custom source image to be used to restore this disk when instantiating
  /// this instance template.
  core.String? customImage;

  /// Specifies the device name of the disk to which the configurations apply
  /// to.
  core.String? deviceName;

  /// Specifies whether to include the disk and what image to use.
  ///
  /// Possible values are: - source-image: to use the same image that was used
  /// to create the source instance's corresponding disk. Applicable to the boot
  /// disk and additional read-write disks. - source-image-family: to use the
  /// same image family that was used to create the source instance's
  /// corresponding disk. Applicable to the boot disk and additional read-write
  /// disks. - custom-image: to use a user-provided image url for disk creation.
  /// Applicable to the boot disk and additional read-write disks. -
  /// attach-read-only: to attach a read-only disk. Applicable to read-only
  /// disks. - do-not-include: to exclude a disk from the template. Applicable
  /// to additional read-write disks, local SSDs, and read-only disks.
  /// Possible string values are:
  /// - "ATTACH_READ_ONLY" : Attach the existing disk in read-only mode. The
  /// request will fail if the disk was attached in read-write mode on the
  /// source instance. Applicable to: read-only disks.
  /// - "BLANK" : Create a blank disk. The disk will be created unformatted.
  /// Applicable to: additional read-write disks, local SSDs.
  /// - "CUSTOM_IMAGE" : Use the custom image specified in the custom_image
  /// field. Applicable to: boot disk, additional read-write disks.
  /// - "DEFAULT" : Use the default instantiation option for the corresponding
  /// type of disk. For boot disk and any other R/W disks, new custom images
  /// will be created from each disk. For read-only disks, they will be attached
  /// in read-only mode. Local SSD disks will be created as blank volumes.
  /// - "DO_NOT_INCLUDE" : Do not include the disk in the instance template.
  /// Applicable to: additional read-write disks, local SSDs, read-only disks.
  /// - "SOURCE_IMAGE" : Use the same source image used for creation of the
  /// source instance's corresponding disk. The request will fail if the source
  /// VM's disk was created from a snapshot. Applicable to: boot disk,
  /// additional read-write disks.
  /// - "SOURCE_IMAGE_FAMILY" : Use the same source image family used for
  /// creation of the source instance's corresponding disk. The request will
  /// fail if the source image of the source disk does not belong to any image
  /// family. Applicable to: boot disk, additional read-write disks.
  core.String? instantiateFrom;

  $DiskInstantiationConfig({
    this.autoDelete,
    this.customImage,
    this.deviceName,
    this.instantiateFrom,
  });

  $DiskInstantiationConfig.fromJson(core.Map json_)
    : this(
        autoDelete: json_['autoDelete'] as core.bool?,
        customImage: json_['customImage'] as core.String?,
        deviceName: json_['deviceName'] as core.String?,
        instantiateFrom: json_['instantiateFrom'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoDelete != null) 'autoDelete': autoDelete!,
    if (customImage != null) 'customImage': customImage!,
    if (deviceName != null) 'deviceName': deviceName!,
    if (instantiateFrom != null) 'instantiateFrom': instantiateFrom!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskMoveRequest
/// - compute:beta : DiskMoveRequest
/// - compute:v1 : DiskMoveRequest
class $DiskMoveRequest {
  /// The URL of the destination zone to move the disk.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone -
  /// projects/project/zones/zone - zones/zone
  core.String? destinationZone;

  /// The URL of the target disk to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a disk: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// zones/zone/disks/disk
  core.String? targetDisk;

  $DiskMoveRequest({this.destinationZone, this.targetDisk});

  $DiskMoveRequest.fromJson(core.Map json_)
    : this(
        destinationZone: json_['destinationZone'] as core.String?,
        targetDisk: json_['targetDisk'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationZone != null) 'destinationZone': destinationZone!,
    if (targetDisk != null) 'targetDisk': targetDisk!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskParams
/// - compute:beta : DiskParams
/// - compute:v1 : DiskParams
class $DiskParams {
  /// Resource manager tags to be bound to the disk.
  ///
  /// Tag keys and values have the same definition as resource manager tags.
  /// Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the
  /// format `tagValues/456`. The field is ignored (both PUT & PATCH) when
  /// empty.
  core.Map<core.String, core.String>? resourceManagerTags;

  $DiskParams({this.resourceManagerTags});

  $DiskParams.fromJson(core.Map json_)
    : this(
        resourceManagerTags: (json_['resourceManagerTags']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceManagerTags != null)
      'resourceManagerTags': resourceManagerTags!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskResourceStatusAsyncReplicationStatus
/// - compute:beta : DiskResourceStatusAsyncReplicationStatus
/// - compute:v1 : DiskResourceStatusAsyncReplicationStatus
class $DiskResourceStatusAsyncReplicationStatus {
  ///
  /// Possible string values are:
  /// - "ACTIVE" : Replication is active.
  /// - "CREATED" : Secondary disk is created and is waiting for replication to
  /// start.
  /// - "STARTING" : Replication is starting.
  /// - "STATE_UNSPECIFIED"
  /// - "STOPPED" : Replication is stopped.
  /// - "STOPPING" : Replication is stopping.
  core.String? state;

  $DiskResourceStatusAsyncReplicationStatus({this.state});

  $DiskResourceStatusAsyncReplicationStatus.fromJson(core.Map json_)
    : this(state: json_['state'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DiskSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DiskSpec
class $DiskSpec {
  /// Size in GB of the boot disk (default is 100GB).
  core.int? bootDiskSizeGb;

  /// Type of the boot disk.
  ///
  /// For non-A3U machines, the default value is "pd-ssd", for A3U machines, the
  /// default value is "hyperdisk-balanced". Valid values: "pd-ssd" (Persistent
  /// Disk Solid State Drive), "pd-standard" (Persistent Disk Hard Disk Drive)
  /// or "hyperdisk-balanced".
  core.String? bootDiskType;

  $DiskSpec({this.bootDiskSizeGb, this.bootDiskType});

  $DiskSpec.fromJson(core.Map json_)
    : this(
        bootDiskSizeGb: json_['bootDiskSizeGb'] as core.int?,
        bootDiskType: json_['bootDiskType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bootDiskSizeGb != null) 'bootDiskSizeGb': bootDiskSizeGb!,
    if (bootDiskType != null) 'bootDiskType': bootDiskType!,
  };
}

/// Used by:
///
/// - appengine:v1 : DiskUtilization
/// - appengine:v1beta : DiskUtilization
class $DiskUtilization {
  /// Target bytes read per second.
  core.int? targetReadBytesPerSecond;

  /// Target ops read per seconds.
  core.int? targetReadOpsPerSecond;

  /// Target bytes written per second.
  core.int? targetWriteBytesPerSecond;

  /// Target ops written per second.
  core.int? targetWriteOpsPerSecond;

  $DiskUtilization({
    this.targetReadBytesPerSecond,
    this.targetReadOpsPerSecond,
    this.targetWriteBytesPerSecond,
    this.targetWriteOpsPerSecond,
  });

  $DiskUtilization.fromJson(core.Map json_)
    : this(
        targetReadBytesPerSecond:
            json_['targetReadBytesPerSecond'] as core.int?,
        targetReadOpsPerSecond: json_['targetReadOpsPerSecond'] as core.int?,
        targetWriteBytesPerSecond:
            json_['targetWriteBytesPerSecond'] as core.int?,
        targetWriteOpsPerSecond: json_['targetWriteOpsPerSecond'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetReadBytesPerSecond != null)
      'targetReadBytesPerSecond': targetReadBytesPerSecond!,
    if (targetReadOpsPerSecond != null)
      'targetReadOpsPerSecond': targetReadOpsPerSecond!,
    if (targetWriteBytesPerSecond != null)
      'targetWriteBytesPerSecond': targetWriteBytesPerSecond!,
    if (targetWriteOpsPerSecond != null)
      'targetWriteOpsPerSecond': targetWriteOpsPerSecond!,
  };
}

/// Used by:
///
/// - compute:alpha : DisksAddResourcePoliciesRequest
/// - compute:beta : DisksAddResourcePoliciesRequest
/// - compute:v1 : DisksAddResourcePoliciesRequest
class $DisksAddResourcePoliciesRequest {
  /// Full or relative path to the resource policy to be added to this disk.
  ///
  /// You can only specify one resource policy.
  core.List<core.String>? resourcePolicies;

  $DisksAddResourcePoliciesRequest({this.resourcePolicies});

  $DisksAddResourcePoliciesRequest.fromJson(core.Map json_)
    : this(
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : DisksMigrationVmTargetDetails
/// - vmmigration:v1alpha1 : DisksMigrationVmTargetDetails
class $DisksMigrationVmTargetDetails {
  /// The URI of the Compute Engine VM.
  ///
  /// Output only.
  core.String? vmUri;

  $DisksMigrationVmTargetDetails({this.vmUri});

  $DisksMigrationVmTargetDetails.fromJson(core.Map json_)
    : this(vmUri: json_['vmUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vmUri != null) 'vmUri': vmUri!,
  };
}

/// Used by:
///
/// - compute:alpha : DisksRemoveResourcePoliciesRequest
/// - compute:alpha : RegionDisksRemoveResourcePoliciesRequest
/// - compute:beta : DisksRemoveResourcePoliciesRequest
/// - compute:beta : RegionDisksRemoveResourcePoliciesRequest
/// - compute:v1 : DisksRemoveResourcePoliciesRequest
/// - compute:v1 : RegionDisksRemoveResourcePoliciesRequest
class $DisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String>? resourcePolicies;

  $DisksRemoveResourcePoliciesRequest({this.resourcePolicies});

  $DisksRemoveResourcePoliciesRequest.fromJson(core.Map json_)
    : this(
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
  };
}

/// Used by:
///
/// - compute:alpha : DisksResizeRequest
/// - compute:beta : DisksResizeRequest
/// - compute:v1 : DisksResizeRequest
class $DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String? sizeGb;

  $DisksResizeRequest({this.sizeGb});

  $DisksResizeRequest.fromJson(core.Map json_)
    : this(sizeGb: json_['sizeGb'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - compute:alpha : DisksStartAsyncReplicationRequest
/// - compute:alpha : RegionDisksStartAsyncReplicationRequest
/// - compute:beta : DisksStartAsyncReplicationRequest
/// - compute:beta : RegionDisksStartAsyncReplicationRequest
/// - compute:v1 : DisksStartAsyncReplicationRequest
/// - compute:v1 : RegionDisksStartAsyncReplicationRequest
class $DisksStartAsyncReplicationRequest {
  /// The secondary disk to start asynchronous replication to.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /disks/disk -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /disks/disk - projects/project/zones/zone/disks/disk -
  /// projects/project/regions/region/disks/disk - zones/zone/disks/disk -
  /// regions/region/disks/disk
  core.String? asyncSecondaryDisk;

  $DisksStartAsyncReplicationRequest({this.asyncSecondaryDisk});

  $DisksStartAsyncReplicationRequest.fromJson(core.Map json_)
    : this(asyncSecondaryDisk: json_['asyncSecondaryDisk'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (asyncSecondaryDisk != null) 'asyncSecondaryDisk': asyncSecondaryDisk!,
  };
}

/// Used by:
///
/// - compute:alpha : DisksStopGroupAsyncReplicationResource
/// - compute:beta : DisksStopGroupAsyncReplicationResource
/// - compute:v1 : DisksStopGroupAsyncReplicationResource
class $DisksStopGroupAsyncReplicationResource {
  /// The URL of the DiskConsistencyGroupPolicy for the group of disks to stop.
  ///
  /// This may be a full or partial URL, such as: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /resourcePolicies/resourcePolicy -
  /// projects/project/regions/region/resourcePolicies/resourcePolicy -
  /// regions/region/resourcePolicies/resourcePolicy
  core.String? resourcePolicy;

  $DisksStopGroupAsyncReplicationResource({this.resourcePolicy});

  $DisksStopGroupAsyncReplicationResource.fromJson(core.Map json_)
    : this(resourcePolicy: json_['resourcePolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicy != null) 'resourcePolicy': resourcePolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : DisplayDevice
/// - compute:beta : DisplayDevice
/// - compute:v1 : DisplayDevice
class $DisplayDevice {
  /// Defines whether the instance has Display enabled.
  core.bool? enableDisplay;

  $DisplayDevice({this.enableDisplay});

  $DisplayDevice.fromJson(core.Map json_)
    : this(enableDisplay: json_['enableDisplay'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableDisplay != null) 'enableDisplay': enableDisplay!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DisplayVideoSourceAd
/// - displayvideo:v3 : DisplayVideoSourceAd
/// - displayvideo:v4 : DisplayVideoSourceAd
class $DisplayVideoSourceAd {
  /// The ID of the source creative.
  core.String? creativeId;

  $DisplayVideoSourceAd({this.creativeId});

  $DisplayVideoSourceAd.fromJson(core.Map json_)
    : this(creativeId: json_['creativeId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (creativeId != null) 'creativeId': creativeId!,
  };
}

/// Used by:
///
/// - compute:alpha : DistributionPolicyZoneConfiguration
/// - compute:beta : DistributionPolicyZoneConfiguration
class $DistributionPolicyZoneConfiguration {
  /// The URL of the zone.
  ///
  /// The zone must exist in the region where the managed instance group is
  /// located.
  core.String? zone;

  $DistributionPolicyZoneConfiguration({this.zone});

  $DistributionPolicyZoneConfiguration.fromJson(core.Map json_)
    : this(zone: json_['zone'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : DnsCacheConfig
/// - container:v1beta1 : DnsCacheConfig
class $DnsCacheConfig {
  /// Whether NodeLocal DNSCache is enabled for this cluster.
  core.bool? enabled;

  $DnsCacheConfig({this.enabled});

  $DnsCacheConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - dns:v1 : DnsKeyDigest
/// - dns:v1beta2 : DnsKeyDigest
class $DnsKeyDigest {
  /// The base-16 encoded bytes of this digest.
  ///
  /// Suitable for use in a DS resource record.
  core.String? digest;

  /// Specifies the algorithm used to calculate this digest.
  /// Possible string values are:
  /// - "sha1"
  /// - "sha256"
  /// - "sha384"
  core.String? type;

  $DnsKeyDigest({this.digest, this.type});

  $DnsKeyDigest.fromJson(core.Map json_)
    : this(
        digest: json_['digest'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - dns:v1 : DnsKeySpec
/// - dns:v1beta2 : DnsKeySpec
class $DnsKeySpec {
  /// String mnemonic specifying the DNSSEC algorithm of this key.
  /// Possible string values are:
  /// - "rsasha1"
  /// - "rsasha256"
  /// - "rsasha512"
  /// - "ecdsap256sha256"
  /// - "ecdsap384sha384"
  core.String? algorithm;

  /// Length of the keys in bits.
  core.int? keyLength;

  /// Specifies whether this is a key signing key (KSK) or a zone signing key
  /// (ZSK).
  ///
  /// Key signing keys have the Secure Entry Point flag set and, when active,
  /// are only used to sign resource record sets of type DNSKEY. Zone signing
  /// keys do not have the Secure Entry Point flag set and are used to sign all
  /// other types of resource record sets.
  /// Possible string values are:
  /// - "keySigning"
  /// - "zoneSigning"
  core.String? keyType;
  core.String? kind;

  $DnsKeySpec({this.algorithm, this.keyLength, this.keyType, this.kind});

  $DnsKeySpec.fromJson(core.Map json_)
    : this(
        algorithm: json_['algorithm'] as core.String?,
        keyLength: json_['keyLength'] as core.int?,
        keyType: json_['keyType'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (keyLength != null) 'keyLength': keyLength!,
    if (keyType != null) 'keyType': keyType!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : DnsNameMapping
/// - sqladmin:v1beta4 : DnsNameMapping
class $DnsNameMapping {
  /// The connection type of the DNS name.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONNECTION_TYPE_UNSPECIFIED" : Unknown connection type.
  /// - "PUBLIC" : Public IP.
  /// - "PRIVATE_SERVICES_ACCESS" : Private services access (private IP).
  /// - "PRIVATE_SERVICE_CONNECT" : Private Service Connect.
  core.String? connectionType;

  /// The scope that the DNS name applies to.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DNS_SCOPE_UNSPECIFIED" : Unknown DNS scope.
  /// - "INSTANCE" : Indicates a instance-level DNS name.
  core.String? dnsScope;

  /// The DNS name.
  core.String? name;

  $DnsNameMapping({this.connectionType, this.dnsScope, this.name});

  $DnsNameMapping.fromJson(core.Map json_)
    : this(
        connectionType: json_['connectionType'] as core.String?,
        dnsScope: json_['dnsScope'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectionType != null) 'connectionType': connectionType!,
    if (dnsScope != null) 'dnsScope': dnsScope!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - datafusion:v1 : DnsPeering
/// - datafusion:v1beta1 : DnsPeering
class $DnsPeering {
  /// Optional description of the dns zone.
  ///
  /// Optional.
  core.String? description;

  /// The dns name suffix of the zone.
  ///
  /// Required.
  core.String? domain;

  /// Identifier.
  ///
  /// The resource name of the dns peering zone. Format:
  /// projects/{project}/locations/{location}/instances/{instance}/dnsPeerings/{dns_peering}
  core.String? name;

  /// Optional target network to which dns peering should happen.
  ///
  /// Optional.
  core.String? targetNetwork;

  /// Optional target project to which dns peering should happen.
  ///
  /// Optional.
  core.String? targetProject;

  $DnsPeering({
    this.description,
    this.domain,
    this.name,
    this.targetNetwork,
    this.targetProject,
  });

  $DnsPeering.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        domain: json_['domain'] as core.String?,
        name: json_['name'] as core.String?,
        targetNetwork: json_['targetNetwork'] as core.String?,
        targetProject: json_['targetProject'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (domain != null) 'domain': domain!,
    if (name != null) 'name': name!,
    if (targetNetwork != null) 'targetNetwork': targetNetwork!,
    if (targetProject != null) 'targetProject': targetProject!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DnsPeeringConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DnsPeeringConfig
class $DnsPeeringConfig {
  /// The DNS name suffix of the zone being peered to, e.g.,
  /// "my-internal-domain.corp.".
  ///
  /// Must end with a dot.
  ///
  /// Required.
  core.String? domain;

  /// The VPC network name in the target_project where the DNS zone specified by
  /// 'domain' is visible.
  ///
  /// Required.
  core.String? targetNetwork;

  /// The project ID hosting the Cloud DNS managed zone that contains the
  /// 'domain'.
  ///
  /// The Vertex AI Service Agent requires the dns.peer role on this project.
  ///
  /// Required.
  core.String? targetProject;

  $DnsPeeringConfig({this.domain, this.targetNetwork, this.targetProject});

  $DnsPeeringConfig.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        targetNetwork: json_['targetNetwork'] as core.String?,
        targetProject: json_['targetProject'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (targetNetwork != null) 'targetNetwork': targetNetwork!,
    if (targetProject != null) 'targetProject': targetProject!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : DnsRecord
/// - firebaseapphosting:v1beta : DnsRecord
class $DnsRecord {
  /// The domain the record pertains to, e.g. `foo.bar.com.`.
  ///
  /// Output only.
  core.String? domainName;

  /// The data of the record.
  ///
  /// The meaning of the value depends on record type: - A and AAAA: IP
  /// addresses for the domain. - CNAME: Another domain to check for records. -
  /// TXT: Arbitrary text strings associated with the domain. App Hosting uses
  /// TXT records to determine which Firebase projects have permission to act on
  /// the domain's behalf. - CAA: The record's flags, tag, and value, e.g. `0
  /// issue "pki.goog"`.
  ///
  /// Output only.
  core.String? rdata;

  /// An enum that indicates which state(s) this DNS record applies to.
  ///
  /// Populated for all records with an `ADD` or `REMOVE` required action.
  ///
  /// Output only.
  core.List<core.String>? relevantState;

  /// An enum that indicates the a required action for this record.
  ///
  /// Populated when the record is part of a required change in a `DnsUpdates`
  /// `discovered` or `desired` record set.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NONE" : No action necessary.
  /// - "ADD" : Add this record to your DNS records.
  /// - "REMOVE" : Remove this record from your DNS records.
  core.String? requiredAction;

  /// The record's type, which determines what data the record contains.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The record's type is unspecified. The message is
  /// invalid if this is unspecified.
  /// - "A" : An `A` record, as defined in
  /// [RFC 1035](https://tools.ietf.org/html/rfc1035). A records determine which
  /// IPv4 addresses a domain directs traffic towards.
  /// - "CNAME" : A `CNAME` record, as defined in
  /// [RFC 1035](https://tools.ietf.org/html/rfc1035). `CNAME` or Canonical Name
  /// records map a domain to a different, canonical domain. If a `CNAME` record
  /// is present, it should be the only record on the domain.
  /// - "TXT" : A `TXT` record, as defined in
  /// [RFC 1035](https://tools.ietf.org/html/rfc1035). `TXT` records hold
  /// arbitrary text data on a domain. Hosting uses `TXT` records to establish
  /// which Firebase Project has permission to act on a domain.
  /// - "AAAA" : An AAAA record, as defined in
  /// [RFC 3596](https://tools.ietf.org/html/rfc3596) AAAA records determine
  /// which IPv6 addresses a domain directs traffic towards.
  /// - "CAA" : A CAA record, as defined in
  /// [RFC 6844](https://tools.ietf.org/html/rfc6844). CAA, or Certificate
  /// Authority Authorization, records determine which Certificate Authorities
  /// (SSL certificate minting organizations) are authorized to mint a
  /// certificate for the domain. App Hosting uses `pki.goog` as its primary CA.
  /// CAA records cascade. A CAA record on `foo.com` also applies to
  /// `bar.foo.com` unless `bar.foo.com` has its own set of CAA records. CAA
  /// records are optional. If a domain and its parents have no CAA records, all
  /// CAs are authorized to mint certificates on its behalf. In general, App
  /// Hosting only asks you to modify CAA records when doing so is required to
  /// unblock SSL cert creation.
  core.String? type;

  $DnsRecord({
    this.domainName,
    this.rdata,
    this.relevantState,
    this.requiredAction,
    this.type,
  });

  $DnsRecord.fromJson(core.Map json_)
    : this(
        domainName: json_['domainName'] as core.String?,
        rdata: json_['rdata'] as core.String?,
        relevantState:
            (json_['relevantState'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        requiredAction: json_['requiredAction'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domainName != null) 'domainName': domainName!,
    if (rdata != null) 'rdata': rdata!,
    if (relevantState != null) 'relevantState': relevantState!,
    if (requiredAction != null) 'requiredAction': requiredAction!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentChunkedDocumentChunkChunkPageSpan
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentChunkedDocumentChunkChunkPageSpan
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentChunkedDocumentChunkChunkPageSpan
class $DocumentChunkedDocumentChunkChunkPageSpan {
  /// Page where chunk ends in the document.
  core.int? pageEnd;

  /// Page where chunk starts in the document.
  core.int? pageStart;

  $DocumentChunkedDocumentChunkChunkPageSpan({this.pageEnd, this.pageStart});

  $DocumentChunkedDocumentChunkChunkPageSpan.fromJson(core.Map json_)
    : this(
        pageEnd: json_['pageEnd'] as core.int?,
        pageStart: json_['pageStart'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageEnd != null) 'pageEnd': pageEnd!,
    if (pageStart != null) 'pageStart': pageStart!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentContent
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentContent
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentContent
class $DocumentContent {
  /// The MIME type of the content.
  ///
  /// Supported types: * `application/pdf` (PDF, only native PDFs are supported
  /// for now) * `text/html` (HTML) * `text/plain` (TXT) * `application/xml` or
  /// `text/xml` (XML) * `application/json` (JSON) *
  /// `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
  /// (DOCX) *
  /// `application/vnd.openxmlformats-officedocument.presentationml.presentation`
  /// (PPTX) *
  /// `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` (XLSX)
  /// * `application/vnd.ms-excel.sheet.macroenabled.12` (XLSM) The following
  /// types are supported only if layout parser is enabled in the data store: *
  /// `image/bmp` (BMP) * `image/gif` (GIF) * `image/jpeg` (JPEG) * `image/png`
  /// (PNG) * `image/tiff` (TIFF) See
  /// https://www.iana.org/assignments/media-types/media-types.xhtml.
  core.String? mimeType;

  /// The content represented as a stream of bytes.
  ///
  /// The maximum length is 1,000,000 bytes (1 MB / ~0.95 MiB). Note: As with
  /// all `bytes` fields, this field is represented as pure binary in Protocol
  /// Buffers and base64-encoded string in JSON. For example,
  /// `abc123!?$*&()'-=@~` should be represented as `YWJjMTIzIT8kKiYoKSctPUB+`
  /// in JSON. See
  /// https://developers.google.com/protocol-buffers/docs/proto3#json.
  core.String? rawBytes;
  core.List<core.int> get rawBytesAsBytes => convert.base64.decode(rawBytes!);

  set rawBytesAsBytes(core.List<core.int> bytes_) {
    rawBytes = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The URI of the content.
  ///
  /// Only Cloud Storage URIs (e.g. `gs://bucket-name/path/to/file`) are
  /// supported. The maximum file size is 2.5 MB for text-based formats, 200 MB
  /// for other formats.
  core.String? uri;

  $DocumentContent({this.mimeType, this.rawBytes, this.uri});

  $DocumentContent.fromJson(core.Map json_)
    : this(
        mimeType: json_['mimeType'] as core.String?,
        rawBytes: json_['rawBytes'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mimeType != null) 'mimeType': mimeType!,
    if (rawBytes != null) 'rawBytes': rawBytes!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - firestore:v1 : DocumentDelete
/// - firestore:v1beta1 : DocumentDelete
class $DocumentDelete {
  /// The resource name of the Document that was deleted.
  core.String? document;

  /// The read timestamp at which the delete was observed.
  ///
  /// Greater or equal to the `commit_time` of the delete.
  core.String? readTime;

  /// A set of target IDs for targets that previously matched this entity.
  core.List<core.int>? removedTargetIds;

  $DocumentDelete({this.document, this.readTime, this.removedTargetIds});

  $DocumentDelete.fromJson(core.Map json_)
    : this(
        document: json_['document'] as core.String?,
        readTime: json_['readTime'] as core.String?,
        removedTargetIds:
            (json_['removedTargetIds'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (readTime != null) 'readTime': readTime!,
    if (removedTargetIds != null) 'removedTargetIds': removedTargetIds!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan
class $DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan {
  /// Page where block ends in the document.
  core.int? pageEnd;

  /// Page where block starts in the document.
  core.int? pageStart;

  $DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan({
    this.pageEnd,
    this.pageStart,
  });

  $DocumentDocumentLayoutDocumentLayoutBlockLayoutPageSpan.fromJson(
    core.Map json_,
  ) : this(
        pageEnd: json_['pageEnd'] as core.int?,
        pageStart: json_['pageStart'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageEnd != null) 'pageEnd': pageEnd!,
    if (pageStart != null) 'pageStart': pageStart!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentEntityRelation
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentEntityRelation
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentEntityRelation
class $DocumentEntityRelation {
  /// Object entity id.
  core.String? objectId;

  /// Relationship description.
  core.String? relation;

  /// Subject entity id.
  core.String? subjectId;

  $DocumentEntityRelation({this.objectId, this.relation, this.subjectId});

  $DocumentEntityRelation.fromJson(core.Map json_)
    : this(
        objectId: json_['objectId'] as core.String?,
        relation: json_['relation'] as core.String?,
        subjectId: json_['subjectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectId != null) 'objectId': objectId!,
    if (relation != null) 'relation': relation!,
    if (subjectId != null) 'subjectId': subjectId!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentInfo
class $DocumentInfo {
  /// The conversion value associated with this Document.
  ///
  /// Must be set if UserEvent.event_type is "conversion". For example, a value
  /// of 1000 signifies that 1000 seconds were spent viewing a Document for the
  /// `watch` conversion type.
  ///
  /// Optional.
  core.double? conversionValue;

  /// The Document resource ID.
  core.String? id;

  /// Whether the referenced Document can be found in the data store.
  ///
  /// Output only.
  core.bool? joined;

  /// The Document resource full name, of the form:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/branches/{branch_id}/documents/{document_id}`
  core.String? name;

  /// The promotion IDs associated with this Document.
  ///
  /// Currently, this field is restricted to at most one ID.
  core.List<core.String>? promotionIds;

  /// Quantity of the Document associated with the user event.
  ///
  /// Defaults to 1. For example, this field is 2 if two quantities of the same
  /// Document are involved in a `add-to-cart` event. Required for events of the
  /// following event types: * `add-to-cart` * `purchase`
  core.int? quantity;

  /// The Document URI - only allowed for website data stores.
  core.String? uri;

  $DocumentInfo({
    this.conversionValue,
    this.id,
    this.joined,
    this.name,
    this.promotionIds,
    this.quantity,
    this.uri,
  });

  $DocumentInfo.fromJson(core.Map json_)
    : this(
        conversionValue: (json_['conversionValue'] as core.num?)?.toDouble(),
        id: json_['id'] as core.String?,
        joined: json_['joined'] as core.bool?,
        name: json_['name'] as core.String?,
        promotionIds:
            (json_['promotionIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        quantity: json_['quantity'] as core.int?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (conversionValue != null) 'conversionValue': conversionValue!,
    if (id != null) 'id': id!,
    if (joined != null) 'joined': joined!,
    if (name != null) 'name': name!,
    if (promotionIds != null) 'promotionIds': promotionIds!,
    if (quantity != null) 'quantity': quantity!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - firestore:v1 : DocumentMask
/// - firestore:v1beta1 : DocumentMask
class $DocumentMask {
  /// The list of field paths in the mask.
  ///
  /// See Document.fields for a field path syntax reference.
  core.List<core.String>? fieldPaths;

  $DocumentMask({this.fieldPaths});

  $DocumentMask.fromJson(core.Map json_)
    : this(
        fieldPaths:
            (json_['fieldPaths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldPaths != null) 'fieldPaths': fieldPaths!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : DocumentNote
/// - containeranalysis:v1beta1 : DocumentNote
class $DocumentNote {
  /// Compliance with the SPDX specification includes populating the SPDX fields
  /// therein with data related to such fields ("SPDX-Metadata")
  core.String? dataLicence;

  /// Provide a reference number that can be used to understand how to parse and
  /// interpret the rest of the file
  core.String? spdxVersion;

  $DocumentNote({this.dataLicence, this.spdxVersion});

  $DocumentNote.fromJson(core.Map json_)
    : this(
        dataLicence: json_['dataLicence'] as core.String?,
        spdxVersion: json_['spdxVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataLicence != null) 'dataLicence': dataLicence!,
    if (spdxVersion != null) 'spdxVersion': spdxVersion!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : DocumentOccurrence
/// - containeranalysis:v1beta1 : DocumentOccurrence
class $DocumentOccurrence {
  /// Identify when the SPDX file was originally created.
  ///
  /// The date is to be specified according to combined date and time in UTC
  /// format as specified in ISO 8601 standard
  core.String? createTime;

  /// A field for creators of the SPDX file to provide general comments about
  /// the creation of the SPDX file or any other relevant comment not included
  /// in the other fields
  core.String? creatorComment;

  /// Identify who (or what, in the case of a tool) created the SPDX file.
  ///
  /// If the SPDX file was created by an individual, indicate the person's name
  core.List<core.String>? creators;

  /// A field for creators of the SPDX file content to provide comments to the
  /// consumers of the SPDX document
  core.String? documentComment;

  /// Identify any external SPDX documents referenced within this SPDX document
  core.List<core.String>? externalDocumentRefs;

  /// Identify the current SPDX document which may be referenced in
  /// relationships by other files, packages internally and documents externally
  core.String? id;

  /// A field for creators of the SPDX file to provide the version of the SPDX
  /// License List used when the SPDX file was created
  core.String? licenseListVersion;

  /// Provide an SPDX document specific namespace as a unique absolute Uniform
  /// Resource Identifier (URI) as specified in RFC-3986, with the exception of
  /// the # delimiter
  core.String? namespace;

  /// Identify name of this document as designated by creator
  core.String? title;

  $DocumentOccurrence({
    this.createTime,
    this.creatorComment,
    this.creators,
    this.documentComment,
    this.externalDocumentRefs,
    this.id,
    this.licenseListVersion,
    this.namespace,
    this.title,
  });

  $DocumentOccurrence.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        creatorComment: json_['creatorComment'] as core.String?,
        creators:
            (json_['creators'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        documentComment: json_['documentComment'] as core.String?,
        externalDocumentRefs:
            (json_['externalDocumentRefs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
        licenseListVersion: json_['licenseListVersion'] as core.String?,
        namespace: json_['namespace'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (creatorComment != null) 'creatorComment': creatorComment!,
    if (creators != null) 'creators': creators!,
    if (documentComment != null) 'documentComment': documentComment!,
    if (externalDocumentRefs != null)
      'externalDocumentRefs': externalDocumentRefs!,
    if (id != null) 'id': id!,
    if (licenseListVersion != null) 'licenseListVersion': licenseListVersion!,
    if (namespace != null) 'namespace': namespace!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentOutputConfigGcsOutputConfigShardingConfig
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentOutputConfigGcsOutputConfigShardingConfig
class $DocumentOutputConfigGcsOutputConfigShardingConfig {
  /// The number of overlapping pages between consecutive shards.
  core.int? pagesOverlap;

  /// The number of pages per shard.
  core.int? pagesPerShard;

  $DocumentOutputConfigGcsOutputConfigShardingConfig({
    this.pagesOverlap,
    this.pagesPerShard,
  });

  $DocumentOutputConfigGcsOutputConfigShardingConfig.fromJson(core.Map json_)
    : this(
        pagesOverlap: json_['pagesOverlap'] as core.int?,
        pagesPerShard: json_['pagesPerShard'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pagesOverlap != null) 'pagesOverlap': pagesOverlap!,
    if (pagesPerShard != null) 'pagesPerShard': pagesPerShard!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageDetectedLanguage
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageDetectedLanguage
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageDetectedLanguage
class $DocumentPageDetectedLanguage {
  /// Confidence of detected language.
  ///
  /// Range `[0, 1]`.
  core.double? confidence;

  /// The \[BCP-47 language
  /// code\](https://www.unicode.org/reports/tr35/#Unicode_locale_identifier),
  /// such as `en-US` or `sr-Latn`.
  core.String? languageCode;

  $DocumentPageDetectedLanguage({this.confidence, this.languageCode});

  $DocumentPageDetectedLanguage.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageDimension
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageDimension
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageDimension
class $DocumentPageDimension {
  /// Page height.
  core.double? height;

  /// Dimension unit.
  core.String? unit;

  /// Page width.
  core.double? width;

  $DocumentPageDimension({this.height, this.unit, this.width});

  $DocumentPageDimension.fromJson(core.Map json_)
    : this(
        height: (json_['height'] as core.num?)?.toDouble(),
        unit: json_['unit'] as core.String?,
        width: (json_['width'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (height != null) 'height': height!,
    if (unit != null) 'unit': unit!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageImage
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageImage
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageImage
class $DocumentPageImage {
  /// Raw byte content of the image.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Height of the image in pixels.
  core.int? height;

  /// Encoding \[media type (MIME
  /// type)\](https://www.iana.org/assignments/media-types/media-types.xhtml)
  /// for the image.
  core.String? mimeType;

  /// Width of the image in pixels.
  core.int? width;

  $DocumentPageImage({this.content, this.height, this.mimeType, this.width});

  $DocumentPageImage.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        height: json_['height'] as core.int?,
        mimeType: json_['mimeType'] as core.String?,
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (height != null) 'height': height!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefect
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageImageQualityScoresDetectedDefect
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageImageQualityScoresDetectedDefect
class $DocumentPageImageQualityScoresDetectedDefect {
  /// Confidence of detected defect.
  ///
  /// Range `[0, 1]` where `1` indicates strong confidence that the defect
  /// exists.
  core.double? confidence;

  /// Name of the defect type.
  ///
  /// Supported values are: - `quality/defect_blurry` - `quality/defect_noisy` -
  /// `quality/defect_dark` - `quality/defect_faint` -
  /// `quality/defect_text_too_small` - `quality/defect_document_cutoff` -
  /// `quality/defect_text_cutoff` - `quality/defect_glare`
  core.String? type;

  $DocumentPageImageQualityScoresDetectedDefect({this.confidence, this.type});

  $DocumentPageImageQualityScoresDetectedDefect.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageMatrix
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageMatrix
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageMatrix
class $DocumentPageMatrix {
  /// Number of columns in the matrix.
  core.int? cols;

  /// The matrix data.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Number of rows in the matrix.
  core.int? rows;

  /// This encodes information about what data type the matrix uses.
  ///
  /// For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list of
  /// OpenCV primitive data types, please refer to
  /// https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html
  core.int? type;

  $DocumentPageMatrix({this.cols, this.data, this.rows, this.type});

  $DocumentPageMatrix.fromJson(core.Map json_)
    : this(
        cols: json_['cols'] as core.int?,
        data: json_['data'] as core.String?,
        rows: json_['rows'] as core.int?,
        type: json_['type'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cols != null) 'cols': cols!,
    if (data != null) 'data': data!,
    if (rows != null) 'rows': rows!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreak
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentPageTokenDetectedBreak
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentPageTokenDetectedBreak
class $DocumentPageTokenDetectedBreak {
  /// Detected break type.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified break type.
  /// - "SPACE" : A single whitespace.
  /// - "WIDE_SPACE" : A wider whitespace.
  /// - "HYPHEN" : A hyphen that indicates that a token has been split across
  /// lines.
  core.String? type;

  $DocumentPageTokenDetectedBreak({this.type});

  $DocumentPageTokenDetectedBreak.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig
class $DocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig {
  /// The token size limit for each chunk.
  ///
  /// Supported values: 100-500 (inclusive). Default value: 500.
  core.int? chunkSize;

  /// Whether to include appending different levels of headings to chunks from
  /// the middle of the document to prevent context loss.
  ///
  /// Default value: False.
  core.bool? includeAncestorHeadings;

  $DocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig({
    this.chunkSize,
    this.includeAncestorHeadings,
  });

  $DocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig.fromJson(
    core.Map json_,
  ) : this(
        chunkSize: json_['chunkSize'] as core.int?,
        includeAncestorHeadings: json_['includeAncestorHeadings'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkSize != null) 'chunkSize': chunkSize!,
    if (includeAncestorHeadings != null)
      'includeAncestorHeadings': includeAncestorHeadings!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentProcessingConfigParsingConfigLayoutParsingConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigLayoutParsingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentProcessingConfigParsingConfigLayoutParsingConfig
class $DocumentProcessingConfigParsingConfigLayoutParsingConfig {
  /// If true, the processed document will be made available for the
  /// GetProcessedDocument API.
  ///
  /// Optional.
  core.bool? enableGetProcessedDocument;

  /// If true, the LLM based annotation is added to the image during parsing.
  ///
  /// Optional.
  core.bool? enableImageAnnotation;

  /// If true, the LLM based annotation is added to the table during parsing.
  ///
  /// Optional.
  core.bool? enableTableAnnotation;

  /// List of HTML classes to exclude from the parsed content.
  ///
  /// Optional.
  core.List<core.String>? excludeHtmlClasses;

  /// List of HTML elements to exclude from the parsed content.
  ///
  /// Optional.
  core.List<core.String>? excludeHtmlElements;

  /// List of HTML ids to exclude from the parsed content.
  ///
  /// Optional.
  core.List<core.String>? excludeHtmlIds;

  /// Contains the required structure types to extract from the document.
  ///
  /// Supported values: * `shareholder-structure`
  ///
  /// Optional.
  core.List<core.String>? structuredContentTypes;

  $DocumentProcessingConfigParsingConfigLayoutParsingConfig({
    this.enableGetProcessedDocument,
    this.enableImageAnnotation,
    this.enableTableAnnotation,
    this.excludeHtmlClasses,
    this.excludeHtmlElements,
    this.excludeHtmlIds,
    this.structuredContentTypes,
  });

  $DocumentProcessingConfigParsingConfigLayoutParsingConfig.fromJson(
    core.Map json_,
  ) : this(
        enableGetProcessedDocument:
            json_['enableGetProcessedDocument'] as core.bool?,
        enableImageAnnotation: json_['enableImageAnnotation'] as core.bool?,
        enableTableAnnotation: json_['enableTableAnnotation'] as core.bool?,
        excludeHtmlClasses:
            (json_['excludeHtmlClasses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludeHtmlElements:
            (json_['excludeHtmlElements'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludeHtmlIds:
            (json_['excludeHtmlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        structuredContentTypes:
            (json_['structuredContentTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableGetProcessedDocument != null)
      'enableGetProcessedDocument': enableGetProcessedDocument!,
    if (enableImageAnnotation != null)
      'enableImageAnnotation': enableImageAnnotation!,
    if (enableTableAnnotation != null)
      'enableTableAnnotation': enableTableAnnotation!,
    if (excludeHtmlClasses != null) 'excludeHtmlClasses': excludeHtmlClasses!,
    if (excludeHtmlElements != null)
      'excludeHtmlElements': excludeHtmlElements!,
    if (excludeHtmlIds != null) 'excludeHtmlIds': excludeHtmlIds!,
    if (structuredContentTypes != null)
      'structuredContentTypes': structuredContentTypes!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentProcessingConfigParsingConfigOcrParsingConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigOcrParsingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentProcessingConfigParsingConfigOcrParsingConfig
class $DocumentProcessingConfigParsingConfigOcrParsingConfig {
  /// This field is deprecated.
  ///
  /// To use the additional enhanced document elements processing, please switch
  /// to `layout_parsing_config`.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? enhancedDocumentElements;

  /// If true, will use native text instead of OCR text on pages containing
  /// native text.
  core.bool? useNativeText;

  $DocumentProcessingConfigParsingConfigOcrParsingConfig({
    this.enhancedDocumentElements,
    this.useNativeText,
  });

  $DocumentProcessingConfigParsingConfigOcrParsingConfig.fromJson(
    core.Map json_,
  ) : this(
        enhancedDocumentElements:
            (json_['enhancedDocumentElements'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        useNativeText: json_['useNativeText'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enhancedDocumentElements != null)
      'enhancedDocumentElements': enhancedDocumentElements!,
    if (useNativeText != null) 'useNativeText': useNativeText!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentProvenanceParent
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentProvenanceParent
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentProvenanceParent
class $DocumentProvenanceParent {
  /// The id of the parent provenance.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? id;

  /// The index of the parent item in the corresponding item list (eg.
  ///
  /// list of entities, properties within entities, etc.) in the parent
  /// revision.
  core.int? index;

  /// The index of the index into current revision's parent_ids list.
  core.int? revision;

  $DocumentProvenanceParent({this.id, this.index, this.revision});

  $DocumentProvenanceParent.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.int?,
        index: json_['index'] as core.int?,
        revision: json_['revision'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (index != null) 'index': index!,
    if (revision != null) 'revision': revision!,
  };
}

/// Used by:
///
/// - firestore:v1 : DocumentRemove
/// - firestore:v1beta1 : DocumentRemove
class $DocumentRemove {
  /// The resource name of the Document that has gone out of view.
  core.String? document;

  /// The read timestamp at which the remove was observed.
  ///
  /// Greater or equal to the `commit_time` of the change/delete/remove.
  core.String? readTime;

  /// A set of target IDs for targets that previously matched this document.
  core.List<core.int>? removedTargetIds;

  $DocumentRemove({this.document, this.readTime, this.removedTargetIds});

  $DocumentRemove.fromJson(core.Map json_)
    : this(
        document: json_['document'] as core.String?,
        readTime: json_['readTime'] as core.String?,
        removedTargetIds:
            (json_['removedTargetIds'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (readTime != null) 'readTime': readTime!,
    if (removedTargetIds != null) 'removedTargetIds': removedTargetIds!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentRevisionHumanReview
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentRevisionHumanReview
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentRevisionHumanReview
class $DocumentRevisionHumanReview {
  /// Human review state.
  ///
  /// e.g. `requested`, `succeeded`, `rejected`.
  core.String? state;

  /// A message providing more details about the current state of processing.
  ///
  /// For example, the rejection reason when the state is `rejected`.
  core.String? stateMessage;

  $DocumentRevisionHumanReview({this.state, this.stateMessage});

  $DocumentRevisionHumanReview.fromJson(core.Map json_)
    : this(
        state: json_['state'] as core.String?,
        stateMessage: json_['stateMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
    if (stateMessage != null) 'stateMessage': stateMessage!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentSchemaEntityTypeEnumValues
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentSchemaEntityTypeEnumValues
class $DocumentSchemaEntityTypeEnumValues {
  /// The individual values that this enum values type can include.
  core.List<core.String>? values;

  $DocumentSchemaEntityTypeEnumValues({this.values});

  $DocumentSchemaEntityTypeEnumValues.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentSchemaMetadata
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentSchemaMetadata
class $DocumentSchemaMetadata {
  /// If true, on a given page, there can be multiple `document` annotations
  /// covering it.
  core.bool? documentAllowMultipleLabels;

  /// If true, a `document` entity type can be applied to subdocument
  /// (splitting).
  ///
  /// Otherwise, it can only be applied to the entire document (classification).
  core.bool? documentSplitter;

  /// If set, all the nested entities must be prefixed with the parents.
  core.bool? prefixedNamingOnProperties;

  /// If set, we will skip the naming format validation in the schema.
  ///
  /// So the string values in `DocumentSchema.EntityType.name` and
  /// `DocumentSchema.EntityType.Property.name` will not be checked.
  core.bool? skipNamingValidation;

  $DocumentSchemaMetadata({
    this.documentAllowMultipleLabels,
    this.documentSplitter,
    this.prefixedNamingOnProperties,
    this.skipNamingValidation,
  });

  $DocumentSchemaMetadata.fromJson(core.Map json_)
    : this(
        documentAllowMultipleLabels:
            json_['documentAllowMultipleLabels'] as core.bool?,
        documentSplitter: json_['documentSplitter'] as core.bool?,
        prefixedNamingOnProperties:
            json_['prefixedNamingOnProperties'] as core.bool?,
        skipNamingValidation: json_['skipNamingValidation'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentAllowMultipleLabels != null)
      'documentAllowMultipleLabels': documentAllowMultipleLabels!,
    if (documentSplitter != null) 'documentSplitter': documentSplitter!,
    if (prefixedNamingOnProperties != null)
      'prefixedNamingOnProperties': prefixedNamingOnProperties!,
    if (skipNamingValidation != null)
      'skipNamingValidation': skipNamingValidation!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentShardInfo
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentShardInfo
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentShardInfo
class $DocumentShardInfo {
  /// Total number of shards.
  core.String? shardCount;

  /// The 0-based index of this shard.
  core.String? shardIndex;

  /// The index of the first character in Document.text in the overall document
  /// global text.
  core.String? textOffset;

  $DocumentShardInfo({this.shardCount, this.shardIndex, this.textOffset});

  $DocumentShardInfo.fromJson(core.Map json_)
    : this(
        shardCount: json_['shardCount'] as core.String?,
        shardIndex: json_['shardIndex'] as core.String?,
        textOffset: json_['textOffset'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (shardCount != null) 'shardCount': shardCount!,
    if (shardIndex != null) 'shardIndex': shardIndex!,
    if (textOffset != null) 'textOffset': textOffset!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentStyleFontSize
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentStyleFontSize
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentStyleFontSize
class $DocumentStyleFontSize {
  /// Font size for the text.
  core.double? size;

  /// Unit for the font size.
  ///
  /// Follows CSS naming (such as `in`, `px`, and `pt`).
  core.String? unit;

  $DocumentStyleFontSize({this.size, this.unit});

  $DocumentStyleFontSize.fromJson(core.Map json_)
    : this(
        size: (json_['size'] as core.num?)?.toDouble(),
        unit: json_['unit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (size != null) 'size': size!,
    if (unit != null) 'unit': unit!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1DocumentTextAnchorTextSegment
/// - documentai:v1 : GoogleCloudDocumentaiV1DocumentTextAnchorTextSegment
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DocumentTextAnchorTextSegment
class $DocumentTextAnchorTextSegment {
  /// TextSegment half open end UTF-8 char index in the Document.text.
  core.String? endIndex;

  /// TextSegment start UTF-8 char index in the Document.text.
  core.String? startIndex;

  $DocumentTextAnchorTextSegment({this.endIndex, this.startIndex});

  $DocumentTextAnchorTextSegment.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.String?,
        startIndex: json_['startIndex'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (startIndex != null) 'startIndex': startIndex!,
  };
}

/// Used by:
///
/// - translate:v3 : DocumentTranslation
/// - translate:v3beta1 : DocumentTranslation
class $DocumentTranslation {
  /// The array of translated documents.
  ///
  /// It is expected to be size 1 for now. We may produce multiple translated
  /// documents in the future for other type of file formats.
  core.List<core.String>? byteStreamOutputs;

  /// The detected language for the input document.
  ///
  /// If the user did not provide the source language for the input document,
  /// this field will have the language code automatically detected. If the
  /// source language was passed, auto-detection of the language does not occur
  /// and this field is empty.
  core.String? detectedLanguageCode;

  /// The translated document's mime type.
  core.String? mimeType;

  $DocumentTranslation({
    this.byteStreamOutputs,
    this.detectedLanguageCode,
    this.mimeType,
  });

  $DocumentTranslation.fromJson(core.Map json_)
    : this(
        byteStreamOutputs:
            (json_['byteStreamOutputs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        detectedLanguageCode: json_['detectedLanguageCode'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (byteStreamOutputs != null) 'byteStreamOutputs': byteStreamOutputs!,
    if (detectedLanguageCode != null)
      'detectedLanguageCode': detectedLanguageCode!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : DocumentationRule
/// - serviceusage:v1 : DocumentationRule
/// - serviceusage:v1beta1 : DocumentationRule
class $DocumentationRule {
  /// Deprecation description of the selected element(s).
  ///
  /// It can be provided if an element is marked as `deprecated`.
  core.String? deprecationDescription;

  /// Description of the selected proto element (e.g. a message, a method, a
  /// 'service' definition, or a field).
  ///
  /// Defaults to leading & trailing comments taken from the proto source
  /// definition of the proto element.
  core.String? description;

  /// String of comma or space separated case-sensitive words for which
  /// method/field name replacement will be disabled.
  core.String? disableReplacementWords;

  /// The selector is a comma-separated list of patterns for any element such as
  /// a method, a field, an enum value.
  ///
  /// Each pattern is a qualified name of the element which may end in "*",
  /// indicating a wildcard. Wildcards are only allowed at the end and for a
  /// whole component of the qualified name, i.e. "foo.*" is ok, but not
  /// "foo.b*" or "foo.*.bar". A wildcard will match one or more components. To
  /// specify a default for all applicable elements, the whole pattern "*" is
  /// used.
  core.String? selector;

  $DocumentationRule({
    this.deprecationDescription,
    this.description,
    this.disableReplacementWords,
    this.selector,
  });

  $DocumentationRule.fromJson(core.Map json_)
    : this(
        deprecationDescription: json_['deprecationDescription'] as core.String?,
        description: json_['description'] as core.String?,
        disableReplacementWords:
            json_['disableReplacementWords'] as core.String?,
        selector: json_['selector'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deprecationDescription != null)
      'deprecationDescription': deprecationDescription!,
    if (description != null) 'description': description!,
    if (disableReplacementWords != null)
      'disableReplacementWords': disableReplacementWords!,
    if (selector != null) 'selector': selector!,
  };
}

/// Used by:
///
/// - firestore:v1 : DocumentsTarget
/// - firestore:v1beta1 : DocumentsTarget
class $DocumentsTarget {
  /// The names of the documents to retrieve.
  ///
  /// In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// The request will fail if any of the document is not a child resource of
  /// the given `database`. Duplicate names will be elided.
  core.List<core.String>? documents;

  $DocumentsTarget({this.documents});

  $DocumentsTarget.fromJson(core.Map json_)
    : this(
        documents:
            (json_['documents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documents != null) 'documents': documents!,
  };
}

/// Used by:
///
/// - gmailpostmastertools:v1 : Domain
/// - gmailpostmastertools:v1beta1 : Domain
class $Domain {
  /// Timestamp when the user registered this domain.
  ///
  /// Assigned by the server.
  core.String? createTime;

  /// The resource name of the Domain.
  ///
  /// Domain names have the form `domains/{domain_name}`, where domain_name is
  /// the fully qualified domain name (i.e., mymail.mydomain.com).
  core.String? name;

  /// Users permission for this domain.
  ///
  /// Assigned by the server.
  /// Possible string values are:
  /// - "PERMISSION_UNSPECIFIED" : The default value and should never be used
  /// explicitly.
  /// - "OWNER" : User has read access to the domain and can share access with
  /// others.
  /// - "READER" : User has read access to the domain.
  /// - "NONE" : User doesn't have permission to access information about the
  /// domain. User did not verify ownership of domain nor was access granted by
  /// other domain owners.
  core.String? permission;

  $Domain({this.createTime, this.name, this.permission});

  $Domain.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        permission: json_['permission'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (permission != null) 'permission': permission!,
  };
}

/// Used by:
///
/// - workstations:v1 : DomainConfig
/// - workstations:v1beta : DomainConfig
class $DomainConfig {
  /// Domain used by Workstations for HTTP ingress.
  ///
  /// Immutable.
  core.String? domain;

  $DomainConfig({this.domain});

  $DomainConfig.fromJson(core.Map json_)
    : this(domain: json_['domain'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
  };
}

/// Used by:
///
/// - domains:v1 : DomainForwarding
/// - domains:v1alpha2 : DomainForwarding
/// - domains:v1beta1 : DomainForwarding
class $DomainForwarding {
  /// If true, forwards the path after the domain name to the same path at the
  /// new address.
  core.bool? pathForwarding;

  /// The PEM-encoded certificate chain.
  core.String? pemCertificate;

  /// The redirect type.
  /// Possible string values are:
  /// - "REDIRECT_TYPE_UNSPECIFIED" : Redirect Type is unspecified.
  /// - "TEMPORARY" : 301 redirect. Allows to propagate changes to the
  /// forwarding address quickly.
  /// - "PERMANENT" : 302 redirect. Allows browsers to cache the forwarding
  /// address. This may help the address resolve more quickly. Changes may take
  /// longer to propagate
  core.String? redirectType;

  /// If true, the forwarding works also over HTTPS.
  core.bool? sslEnabled;

  /// The subdomain of the registered domain that is being forwarded.
  ///
  /// E.g. `www.example.com`, `example.com` (i.e. the registered domain itself)
  /// or `*.example.com` (i.e. all subdomains).
  core.String? subdomain;

  /// The target of the domain forwarding, i.e. the path to redirect the
  /// `subdomain` to.
  core.String? targetUri;

  $DomainForwarding({
    this.pathForwarding,
    this.pemCertificate,
    this.redirectType,
    this.sslEnabled,
    this.subdomain,
    this.targetUri,
  });

  $DomainForwarding.fromJson(core.Map json_)
    : this(
        pathForwarding: json_['pathForwarding'] as core.bool?,
        pemCertificate: json_['pemCertificate'] as core.String?,
        redirectType: json_['redirectType'] as core.String?,
        sslEnabled: json_['sslEnabled'] as core.bool?,
        subdomain: json_['subdomain'] as core.String?,
        targetUri: json_['targetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pathForwarding != null) 'pathForwarding': pathForwarding!,
    if (pemCertificate != null) 'pemCertificate': pemCertificate!,
    if (redirectType != null) 'redirectType': redirectType!,
    if (sslEnabled != null) 'sslEnabled': sslEnabled!,
    if (subdomain != null) 'subdomain': subdomain!,
    if (targetUri != null) 'targetUri': targetUri!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : DomainJoinMachineRequest
/// - managedidentities:v1alpha1 : DomainJoinMachineRequest
class $DomainJoinMachineRequest {
  /// force if True, forces domain join even if the computer account already
  /// exists.
  ///
  /// Optional.
  core.bool? force;

  /// OU name where the VM needs to be domain joined
  ///
  /// Optional.
  core.String? ouName;

  /// Full instance id token of compute engine VM to verify instance identity.
  ///
  /// More about this:
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity#request_signature
  ///
  /// Required.
  core.String? vmIdToken;

  $DomainJoinMachineRequest({this.force, this.ouName, this.vmIdToken});

  $DomainJoinMachineRequest.fromJson(core.Map json_)
    : this(
        force: json_['force'] as core.bool?,
        ouName: json_['ouName'] as core.String?,
        vmIdToken: json_['vmIdToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (force != null) 'force': force!,
    if (ouName != null) 'ouName': ouName!,
    if (vmIdToken != null) 'vmIdToken': vmIdToken!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : DomainJoinMachineResponse
/// - managedidentities:v1alpha1 : DomainJoinMachineResponse
class $DomainJoinMachineResponse {
  /// Offline domain join blob as the response
  core.String? domainJoinBlob;

  $DomainJoinMachineResponse({this.domainJoinBlob});

  $DomainJoinMachineResponse.fromJson(core.Map json_)
    : this(domainJoinBlob: json_['domainJoinBlob'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (domainJoinBlob != null) 'domainJoinBlob': domainJoinBlob!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DoubleArray
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DoubleArray
class $DoubleArray {
  /// A list of double values.
  core.List<core.double>? values;

  $DoubleArray({this.values});

  $DoubleArray.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DoubleList
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDoubleList
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDoubleList
class $DoubleList00 {
  /// Double values.
  core.List<core.double>? values;

  $DoubleList00({this.values});

  $DoubleList00.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2DoubleList
/// - retail:v2alpha : GoogleCloudRetailV2alphaDoubleList
/// - retail:v2beta : GoogleCloudRetailV2betaDoubleList
class $DoubleList01 {
  /// The list of double values.
  core.List<core.double>? values;

  $DoubleList01({this.values});

  $DoubleList01.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : DoubleRange
/// - trafficdirector:v3 : DoubleRange
class $DoubleRange {
  /// end of the range (exclusive)
  core.double? end;

  /// start of the range (inclusive)
  core.double? start;

  $DoubleRange({this.end, this.start});

  $DoubleRange.fromJson(core.Map json_)
    : this(
        end: (json_['end'] as core.num?)?.toDouble(),
        start: (json_['start'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (end != null) 'end': end!,
    if (start != null) 'start': start!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DoubleVerifyAppStarRating
/// - displayvideo:v3 : DoubleVerifyAppStarRating
/// - displayvideo:v4 : DoubleVerifyAppStarRating
class $DoubleVerifyAppStarRating {
  /// Avoid bidding on apps with insufficient star ratings.
  core.bool? avoidInsufficientStarRating;

  /// Avoid bidding on apps with the star ratings.
  /// Possible string values are:
  /// - "APP_STAR_RATE_UNSPECIFIED" : This enum is only a placeholder and it
  /// doesn't specify any app star rating options.
  /// - "APP_STAR_RATE_1_POINT_5_LESS" : Official Apps with rating \< 1.5 Stars.
  /// - "APP_STAR_RATE_2_LESS" : Official Apps with rating \< 2 Stars.
  /// - "APP_STAR_RATE_2_POINT_5_LESS" : Official Apps with rating \< 2.5 Stars.
  /// - "APP_STAR_RATE_3_LESS" : Official Apps with rating \< 3 Stars.
  /// - "APP_STAR_RATE_3_POINT_5_LESS" : Official Apps with rating \< 3.5 Stars.
  /// - "APP_STAR_RATE_4_LESS" : Official Apps with rating \< 4 Stars.
  /// - "APP_STAR_RATE_4_POINT_5_LESS" : Official Apps with rating \< 4.5 Stars.
  core.String? avoidedStarRating;

  $DoubleVerifyAppStarRating({
    this.avoidInsufficientStarRating,
    this.avoidedStarRating,
  });

  $DoubleVerifyAppStarRating.fromJson(core.Map json_)
    : this(
        avoidInsufficientStarRating:
            json_['avoidInsufficientStarRating'] as core.bool?,
        avoidedStarRating: json_['avoidedStarRating'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avoidInsufficientStarRating != null)
      'avoidInsufficientStarRating': avoidInsufficientStarRating!,
    if (avoidedStarRating != null) 'avoidedStarRating': avoidedStarRating!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DoubleVerifyBrandSafetyCategories
/// - displayvideo:v3 : DoubleVerifyBrandSafetyCategories
/// - displayvideo:v4 : DoubleVerifyBrandSafetyCategories
class $DoubleVerifyBrandSafetyCategories {
  /// Unknown or unrateable.
  core.bool? avoidUnknownBrandSafetyCategory;

  /// Brand safety high severity avoidance categories.
  core.List<core.String>? avoidedHighSeverityCategories;

  /// Brand safety medium severity avoidance categories.
  core.List<core.String>? avoidedMediumSeverityCategories;

  $DoubleVerifyBrandSafetyCategories({
    this.avoidUnknownBrandSafetyCategory,
    this.avoidedHighSeverityCategories,
    this.avoidedMediumSeverityCategories,
  });

  $DoubleVerifyBrandSafetyCategories.fromJson(core.Map json_)
    : this(
        avoidUnknownBrandSafetyCategory:
            json_['avoidUnknownBrandSafetyCategory'] as core.bool?,
        avoidedHighSeverityCategories:
            (json_['avoidedHighSeverityCategories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        avoidedMediumSeverityCategories:
            (json_['avoidedMediumSeverityCategories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avoidUnknownBrandSafetyCategory != null)
      'avoidUnknownBrandSafetyCategory': avoidUnknownBrandSafetyCategory!,
    if (avoidedHighSeverityCategories != null)
      'avoidedHighSeverityCategories': avoidedHighSeverityCategories!,
    if (avoidedMediumSeverityCategories != null)
      'avoidedMediumSeverityCategories': avoidedMediumSeverityCategories!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DoubleVerifyDisplayViewability
/// - displayvideo:v3 : DoubleVerifyDisplayViewability
/// - displayvideo:v4 : DoubleVerifyDisplayViewability
class $DoubleVerifyDisplayViewability {
  /// Target web and app inventory to maximize IAB viewable rate.
  /// Possible string values are:
  /// - "IAB_VIEWED_RATE_UNSPECIFIED" : This enum is only a placeholder and it
  /// doesn't specify any IAB viewed rate options.
  /// - "IAB_VIEWED_RATE_80_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 80% or higher.
  /// - "IAB_VIEWED_RATE_75_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 75% or higher.
  /// - "IAB_VIEWED_RATE_70_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 70% or higher.
  /// - "IAB_VIEWED_RATE_65_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 65% or higher.
  /// - "IAB_VIEWED_RATE_60_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 60% or higher.
  /// - "IAB_VIEWED_RATE_55_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 55% or higher.
  /// - "IAB_VIEWED_RATE_50_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 50% or higher.
  /// - "IAB_VIEWED_RATE_40_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 40% or higher.
  /// - "IAB_VIEWED_RATE_30_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 30% or higher.
  core.String? iab;

  /// Target web and app inventory to maximize 100% viewable duration.
  /// Possible string values are:
  /// - "AVERAGE_VIEW_DURATION_UNSPECIFIED" : This enum is only a placeholder
  /// and it doesn't specify any average view duration options.
  /// - "AVERAGE_VIEW_DURATION_5_SEC" : Target web and app inventory to maximize
  /// 100% viewable duration 5 seconds or more.
  /// - "AVERAGE_VIEW_DURATION_10_SEC" : Target web and app inventory to
  /// maximize 100% viewable duration 10 seconds or more.
  /// - "AVERAGE_VIEW_DURATION_15_SEC" : Target web and app inventory to
  /// maximize 100% viewable duration 15 seconds or more.
  core.String? viewableDuring;

  $DoubleVerifyDisplayViewability({this.iab, this.viewableDuring});

  $DoubleVerifyDisplayViewability.fromJson(core.Map json_)
    : this(
        iab: json_['iab'] as core.String?,
        viewableDuring: json_['viewableDuring'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (iab != null) 'iab': iab!,
    if (viewableDuring != null) 'viewableDuring': viewableDuring!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DoubleVerifyFraudInvalidTraffic
/// - displayvideo:v3 : DoubleVerifyFraudInvalidTraffic
/// - displayvideo:v4 : DoubleVerifyFraudInvalidTraffic
class $DoubleVerifyFraudInvalidTraffic {
  /// Insufficient Historical Fraud & IVT Stats.
  core.bool? avoidInsufficientOption;

  /// Avoid Sites and Apps with historical Fraud & IVT.
  /// Possible string values are:
  /// - "FRAUD_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any fraud and invalid traffic options.
  /// - "AD_IMPRESSION_FRAUD_100" : 100% Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_50" : 50% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_25" : 25% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_10" : 10% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_8" : 8% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_6" : 6% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_4" : 4% or Higher Fraud & IVT.
  /// - "AD_IMPRESSION_FRAUD_2" : 2% or Higher Fraud & IVT.
  core.String? avoidedFraudOption;

  $DoubleVerifyFraudInvalidTraffic({
    this.avoidInsufficientOption,
    this.avoidedFraudOption,
  });

  $DoubleVerifyFraudInvalidTraffic.fromJson(core.Map json_)
    : this(
        avoidInsufficientOption: json_['avoidInsufficientOption'] as core.bool?,
        avoidedFraudOption: json_['avoidedFraudOption'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avoidInsufficientOption != null)
      'avoidInsufficientOption': avoidInsufficientOption!,
    if (avoidedFraudOption != null) 'avoidedFraudOption': avoidedFraudOption!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DoubleVerifyVideoViewability
/// - displayvideo:v3 : DoubleVerifyVideoViewability
/// - displayvideo:v4 : DoubleVerifyVideoViewability
class $DoubleVerifyVideoViewability {
  /// Target inventory to maximize impressions with 400x300 or greater player
  /// size.
  /// Possible string values are:
  /// - "PLAYER_SIZE_400X300_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any impressions options.
  /// - "PLAYER_SIZE_400X300_95" : Sites with 95%+ of impressions.
  /// - "PLAYER_SIZE_400X300_70" : Sites with 70%+ of impressions.
  /// - "PLAYER_SIZE_400X300_25" : Sites with 25%+ of impressions.
  /// - "PLAYER_SIZE_400X300_5" : Sites with 5%+ of impressions.
  core.String? playerImpressionRate;

  /// Target web inventory to maximize IAB viewable rate.
  /// Possible string values are:
  /// - "VIDEO_IAB_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any video IAB viewable rate options.
  /// - "IAB_VIEWABILITY_80_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 80% or higher.
  /// - "IAB_VIEWABILITY_75_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 75% or higher.
  /// - "IAB_VIEWABILITY_70_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 70% or higher.
  /// - "IAB_VIEWABILITY_65_PERCENT_HIHGER" : Target web and app inventory to
  /// maximize IAB viewable rate 65% or higher.
  /// - "IAB_VIEWABILITY_60_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 60% or higher.
  /// - "IAB_VIEWABILITY_55_PERCENT_HIHGER" : Target web and app inventory to
  /// maximize IAB viewable rate 55% or higher.
  /// - "IAB_VIEWABILITY_50_PERCENT_HIGHER" : Target web and app inventory to
  /// maximize IAB viewable rate 50% or higher.
  /// - "IAB_VIEWABILITY_40_PERCENT_HIHGER" : Target web and app inventory to
  /// maximize IAB viewable rate 40% or higher.
  /// - "IAB_VIEWABILITY_30_PERCENT_HIHGER" : Target web and app inventory to
  /// maximize IAB viewable rate 30% or higher.
  core.String? videoIab;

  /// Target web inventory to maximize fully viewable rate.
  /// Possible string values are:
  /// - "VIDEO_VIEWABLE_RATE_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any video viewable rate options.
  /// - "VIEWED_PERFORMANCE_40_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 40% or higher.
  /// - "VIEWED_PERFORMANCE_35_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 35% or higher.
  /// - "VIEWED_PERFORMANCE_30_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 30% or higher.
  /// - "VIEWED_PERFORMANCE_25_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 25% or higher.
  /// - "VIEWED_PERFORMANCE_20_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 20% or higher.
  /// - "VIEWED_PERFORMANCE_10_PERCENT_HIGHER" : Target web inventory to
  /// maximize fully viewable rate 10% or higher.
  core.String? videoViewableRate;

  $DoubleVerifyVideoViewability({
    this.playerImpressionRate,
    this.videoIab,
    this.videoViewableRate,
  });

  $DoubleVerifyVideoViewability.fromJson(core.Map json_)
    : this(
        playerImpressionRate: json_['playerImpressionRate'] as core.String?,
        videoIab: json_['videoIab'] as core.String?,
        videoViewableRate: json_['videoViewableRate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (playerImpressionRate != null)
      'playerImpressionRate': playerImpressionRate!,
    if (videoIab != null) 'videoIab': videoIab!,
    if (videoViewableRate != null) 'videoViewableRate': videoViewableRate!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GdataDownloadParameters
/// - discoveryengine:v1alpha : GdataDownloadParameters
/// - discoveryengine:v1beta : GdataDownloadParameters
/// - firebaseappdistribution:v1 : GdataDownloadParameters
/// - walletobjects:v1 : DownloadParameters
class $DownloadParameters00 {
  /// A boolean to be returned in the response to Scotty.
  ///
  /// Allows/disallows gzip encoding of the payload content when the server
  /// thinks it's advantageous (hence, does not guarantee compression) which
  /// allows Scotty to GZip the response to the client.
  core.bool? allowGzipCompression;

  /// Determining whether or not Apiary should skip the inclusion of any
  /// Content-Range header on its response to Scotty.
  core.bool? ignoreRange;

  $DownloadParameters00({this.allowGzipCompression, this.ignoreRange});

  $DownloadParameters00.fromJson(core.Map json_)
    : this(
        allowGzipCompression: json_['allowGzipCompression'] as core.bool?,
        ignoreRange: json_['ignoreRange'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowGzipCompression != null)
      'allowGzipCompression': allowGzipCompression!,
    if (ignoreRange != null) 'ignoreRange': ignoreRange!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : DownloadParameters
/// - cloudsupport:v2beta : DownloadParameters
class $DownloadParameters01 {
  /// # gdata.* are outside protos with mising documentation
  core.bool? allowGzipCompression;

  /// # gdata.* are outside protos with mising documentation
  core.bool? ignoreRange;

  $DownloadParameters01({this.allowGzipCompression, this.ignoreRange});

  $DownloadParameters01.fromJson(core.Map json_)
    : this(
        allowGzipCompression: json_['allowGzipCompression'] as core.bool?,
        ignoreRange: json_['ignoreRange'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowGzipCompression != null)
      'allowGzipCompression': allowGzipCompression!,
    if (ignoreRange != null) 'ignoreRange': ignoreRange!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminDrainedMachine
/// - gkeonprem:v1 : BareMetalDrainedMachine
class $DrainedMachine {
  /// Drained machine IP address.
  core.String? nodeIp;

  $DrainedMachine({this.nodeIp});

  $DrainedMachine.fromJson(core.Map json_)
    : this(nodeIp: json_['nodeIp'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeIp != null) 'nodeIp': nodeIp!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminDrainingMachine
/// - gkeonprem:v1 : BareMetalDrainingMachine
class $DrainingMachine {
  /// Draining machine IP address.
  core.String? nodeIp;

  /// The count of pods yet to drain.
  core.int? podCount;

  $DrainingMachine({this.nodeIp, this.podCount});

  $DrainingMachine.fromJson(core.Map json_)
    : this(
        nodeIp: json_['nodeIp'] as core.String?,
        podCount: json_['podCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeIp != null) 'nodeIp': nodeIp!,
    if (podCount != null) 'podCount': podCount!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : DropInfo
/// - networkmanagement:v1beta1 : DropInfo
class $DropInfo {
  /// Cause that the packet is dropped.
  /// Possible string values are:
  /// - "CAUSE_UNSPECIFIED" : Cause is unspecified.
  /// - "UNKNOWN_EXTERNAL_ADDRESS" : Destination external address cannot be
  /// resolved to a known target. If the address is used in a Google Cloud
  /// project, provide the project ID as test input.
  /// - "FOREIGN_IP_DISALLOWED" : A Compute Engine instance can only send or
  /// receive a packet with a foreign IP address if ip_forward is enabled.
  /// - "FIREWALL_RULE" : Dropped due to a firewall rule, unless allowed due to
  /// connection tracking.
  /// - "NO_ROUTE" : Dropped due to no matching routes.
  /// - "ROUTE_BLACKHOLE" : Dropped due to invalid route. Route's next hop is a
  /// blackhole.
  /// - "ROUTE_WRONG_NETWORK" : Packet is sent to a wrong (unintended) network.
  /// Example: you trace a packet from VM1:Network1 to VM2:Network2, however,
  /// the route configured in Network1 sends the packet destined for VM2's IP
  /// address to Network3.
  /// - "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED" : Route's next hop IP address
  /// cannot be resolved to a GCP resource.
  /// - "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND" : Route's next hop resource is not
  /// found.
  /// - "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK" : Route's next hop instance
  /// doesn't have a NIC in the route's network.
  /// - "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP" : Route's next hop IP address
  /// is not a primary IP address of the next hop instance.
  /// - "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH" : Route's next hop
  /// forwarding rule doesn't match next hop IP address.
  /// - "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED" : Route's next hop VPN
  /// tunnel is down (does not have valid IKE SAs).
  /// - "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID" : Route's next hop
  /// forwarding rule type is invalid (it's not a forwarding rule of the
  /// internal passthrough load balancer).
  /// - "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS" : Packet is sent from
  /// the Internet or Google service to the private IPv6 address.
  /// - "NO_ROUTE_FROM_EXTERNAL_IPV6_SOURCE_TO_PRIVATE_IPV6_ADDRESS" : Packet is
  /// sent from the external IPv6 source address of an instance to the private
  /// IPv6 address of an instance.
  /// - "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH" : The packet does not match a
  /// policy-based VPN tunnel local selector.
  /// - "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH" : The packet does not match a
  /// policy-based VPN tunnel remote selector.
  /// - "PRIVATE_TRAFFIC_TO_INTERNET" : Packet with internal destination address
  /// sent to the internet gateway.
  /// - "PRIVATE_GOOGLE_ACCESS_DISALLOWED" : Endpoint with only an internal IP
  /// address tries to access Google API and services, but Private Google Access
  /// is not enabled in the subnet or is not applicable.
  /// - "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED" : Source endpoint
  /// tries to access Google API and services through the VPN tunnel to another
  /// network, but Private Google Access needs to be enabled in the source
  /// endpoint network.
  /// - "NO_EXTERNAL_ADDRESS" : Endpoint with only an internal IP address tries
  /// to access external hosts, but there is no matching Cloud NAT gateway in
  /// the subnet.
  /// - "UNKNOWN_INTERNAL_ADDRESS" : Destination internal address cannot be
  /// resolved to a known target. If this is a shared VPC scenario, verify if
  /// the service project ID is provided as test input. Otherwise, verify if the
  /// IP address is being used in the project.
  /// - "FORWARDING_RULE_MISMATCH" : Forwarding rule's protocol and ports do not
  /// match the packet header.
  /// - "FORWARDING_RULE_NO_INSTANCES" : Forwarding rule does not have backends
  /// configured.
  /// - "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK" : Firewalls block
  /// the health check probes to the backends and cause the backends to be
  /// unavailable for traffic from the load balancer. For more details, see
  /// [Health check firewall rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
  /// - "INGRESS_FIREWALL_TAGS_UNSUPPORTED_BY_DIRECT_VPC_EGRESS" : Matching
  /// ingress firewall rules by network tags for packets sent via serverless VPC
  /// direct egress is unsupported. Behavior is undefined.
  /// https://cloud.google.com/run/docs/configuring/vpc-direct-vpc#limitations
  /// - "INSTANCE_NOT_RUNNING" : Packet is sent from or to a Compute Engine
  /// instance that is not in a running state.
  /// - "GKE_CLUSTER_NOT_RUNNING" : Packet sent from or to a GKE cluster that is
  /// not in running state.
  /// - "CLOUD_SQL_INSTANCE_NOT_RUNNING" : Packet sent from or to a Cloud SQL
  /// instance that is not in running state.
  /// - "REDIS_INSTANCE_NOT_RUNNING" : Packet sent from or to a Redis Instance
  /// that is not in running state.
  /// - "REDIS_CLUSTER_NOT_RUNNING" : Packet sent from or to a Redis Cluster
  /// that is not in running state.
  /// - "TRAFFIC_TYPE_BLOCKED" : The type of traffic is blocked and the user
  /// cannot configure a firewall rule to enable it. See
  /// [Always blocked traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic)
  /// for more details.
  /// - "GKE_MASTER_UNAUTHORIZED_ACCESS" : Access to Google Kubernetes Engine
  /// cluster master's endpoint is not authorized. See
  /// [Access to the cluster endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
  /// for more details.
  /// - "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS" : Access to the Cloud SQL
  /// instance endpoint is not authorized. See
  /// [Authorizing with authorized networks](https://cloud.google.com/sql/docs/mysql/authorize-networks)
  /// for more details.
  /// - "DROPPED_INSIDE_GKE_SERVICE" : Packet was dropped inside Google
  /// Kubernetes Engine Service.
  /// - "DROPPED_INSIDE_CLOUD_SQL_SERVICE" : Packet was dropped inside Cloud SQL
  /// Service.
  /// - "GOOGLE_MANAGED_SERVICE_NO_PEERING" : Packet was dropped because there
  /// is no peering between the originating network and the Google Managed
  /// Services Network.
  /// - "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT" : Packet was dropped because
  /// the Google-managed service uses Private Service Connect (PSC), but the PSC
  /// endpoint is not found in the project.
  /// - "GKE_PSC_ENDPOINT_MISSING" : Packet was dropped because the GKE cluster
  /// uses Private Service Connect (PSC), but the PSC endpoint is not found in
  /// the project.
  /// - "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS" : Packet was dropped because the
  /// Cloud SQL instance has neither a private nor a public IP address.
  /// - "GKE_CONTROL_PLANE_REGION_MISMATCH" : Packet was dropped because a GKE
  /// cluster private endpoint is unreachable from a region different from the
  /// cluster's region.
  /// - "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION" : Packet sent from a
  /// public GKE cluster control plane to a private IP address.
  /// - "GKE_CONTROL_PLANE_NO_ROUTE" : Packet was dropped because there is no
  /// route from a GKE cluster control plane to a destination network.
  /// - "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC" : Packet sent
  /// from a Cloud SQL instance to an external IP address is not allowed. The
  /// Cloud SQL instance is not configured to send packets to external IP
  /// addresses.
  /// - "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION" : Packet sent from a
  /// Cloud SQL instance with only a public IP address to a private IP address.
  /// - "CLOUD_SQL_INSTANCE_NO_ROUTE" : Packet was dropped because there is no
  /// route from a Cloud SQL instance to a destination network.
  /// - "CLOUD_SQL_CONNECTOR_REQUIRED" : Packet was dropped because the Cloud
  /// SQL instance requires all connections to use Cloud SQL connectors and to
  /// target the Cloud SQL proxy port (3307).
  /// - "CLOUD_FUNCTION_NOT_ACTIVE" : Packet could be dropped because the Cloud
  /// Function is not in an active status.
  /// - "VPC_CONNECTOR_NOT_SET" : Packet could be dropped because no VPC
  /// connector is set.
  /// - "VPC_CONNECTOR_NOT_RUNNING" : Packet could be dropped because the VPC
  /// connector is not in a running state.
  /// - "VPC_CONNECTOR_SERVERLESS_TRAFFIC_BLOCKED" : Packet could be dropped
  /// because the traffic from the serverless service to the VPC connector is
  /// not allowed.
  /// - "VPC_CONNECTOR_HEALTH_CHECK_TRAFFIC_BLOCKED" : Packet could be dropped
  /// because the health check traffic to the VPC connector is not allowed.
  /// - "FORWARDING_RULE_REGION_MISMATCH" : Packet could be dropped because it
  /// was sent from a different region to a regional forwarding without global
  /// access.
  /// - "PSC_CONNECTION_NOT_ACCEPTED" : The Private Service Connect endpoint is
  /// in a project that is not approved to connect to the service.
  /// - "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK" : The packet is sent to the
  /// Private Service Connect endpoint over the peering, but
  /// [it's not supported](https://cloud.google.com/vpc/docs/configure-private-service-connect-services#on-premises).
  /// - "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS" : The packet is sent to the
  /// Private Service Connect backend (network endpoint group), but the producer
  /// PSC forwarding rule does not have global access enabled.
  /// - "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS" : The packet is sent
  /// to the Private Service Connect backend (network endpoint group), but the
  /// producer PSC forwarding rule has multiple ports specified.
  /// - "CLOUD_SQL_PSC_NEG_UNSUPPORTED" : The packet is sent to the Private
  /// Service Connect backend (network endpoint group) targeting a Cloud SQL
  /// service attachment, but this configuration is not supported.
  /// - "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT" : No NAT subnets are defined
  /// for the PSC service attachment.
  /// - "PSC_TRANSITIVITY_NOT_PROPAGATED" : PSC endpoint is accessed via NCC,
  /// but PSC transitivity configuration is not yet propagated.
  /// - "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED" : The packet sent from the hybrid
  /// NEG proxy matches a non-dynamic route, but such a configuration is not
  /// supported.
  /// - "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED" : The packet sent from the
  /// hybrid NEG proxy matches a dynamic route with a next hop in a different
  /// region, but such a configuration is not supported.
  /// - "CLOUD_RUN_REVISION_NOT_READY" : Packet sent from a Cloud Run revision
  /// that is not ready.
  /// - "DROPPED_INSIDE_PSC_SERVICE_PRODUCER" : Packet was dropped inside
  /// Private Service Connect service producer.
  /// - "LOAD_BALANCER_HAS_NO_PROXY_SUBNET" : Packet sent to a load balancer,
  /// which requires a proxy-only subnet and the subnet is not found.
  /// - "CLOUD_NAT_NO_ADDRESSES" : Packet sent to Cloud Nat without active NAT
  /// IPs.
  /// - "ROUTING_LOOP" : Packet is stuck in a routing loop.
  /// - "DROPPED_INSIDE_GOOGLE_MANAGED_SERVICE" : Packet is dropped inside a
  /// Google-managed service due to being delivered in return trace to an
  /// endpoint that doesn't match the endpoint the packet was sent from in
  /// forward trace. Used only for return traces.
  /// - "LOAD_BALANCER_BACKEND_INVALID_NETWORK" : Packet is dropped due to a
  /// load balancer backend instance not having a network interface in the
  /// network expected by the load balancer.
  /// - "BACKEND_SERVICE_NAMED_PORT_NOT_DEFINED" : Packet is dropped due to a
  /// backend service named port not being defined on the instance group level.
  /// - "DESTINATION_IS_PRIVATE_NAT_IP_RANGE" : Packet is dropped due to a
  /// destination IP range being part of a Private NAT IP range.
  /// - "DROPPED_INSIDE_REDIS_INSTANCE_SERVICE" : Generic drop cause for a
  /// packet being dropped inside a Redis Instance service project.
  /// - "REDIS_INSTANCE_UNSUPPORTED_PORT" : Packet is dropped due to an
  /// unsupported port being used to connect to a Redis Instance. Port 6379
  /// should be used to connect to a Redis Instance.
  /// - "REDIS_INSTANCE_CONNECTING_FROM_PUPI_ADDRESS" : Packet is dropped due to
  /// connecting from PUPI address to a PSA based Redis Instance.
  /// - "REDIS_INSTANCE_NO_ROUTE_TO_DESTINATION_NETWORK" : Packet is dropped due
  /// to no route to the destination network.
  /// - "REDIS_INSTANCE_NO_EXTERNAL_IP" : Redis Instance does not have an
  /// external IP address.
  /// - "REDIS_INSTANCE_UNSUPPORTED_PROTOCOL" : Packet is dropped due to an
  /// unsupported protocol being used to connect to a Redis Instance. Only TCP
  /// connections are accepted by a Redis Instance.
  /// - "DROPPED_INSIDE_REDIS_CLUSTER_SERVICE" : Generic drop cause for a packet
  /// being dropped inside a Redis Cluster service project.
  /// - "REDIS_CLUSTER_UNSUPPORTED_PORT" : Packet is dropped due to an
  /// unsupported port being used to connect to a Redis Cluster. Ports 6379 and
  /// 11000 to 13047 should be used to connect to a Redis Cluster.
  /// - "REDIS_CLUSTER_NO_EXTERNAL_IP" : Redis Cluster does not have an external
  /// IP address.
  /// - "REDIS_CLUSTER_UNSUPPORTED_PROTOCOL" : Packet is dropped due to an
  /// unsupported protocol being used to connect to a Redis Cluster. Only TCP
  /// connections are accepted by a Redis Cluster.
  /// - "NO_ADVERTISED_ROUTE_TO_GCP_DESTINATION" : Packet from the non-GCP
  /// (on-prem) or unknown GCP network is dropped due to the destination IP
  /// address not belonging to any IP prefix advertised via BGP by the Cloud
  /// Router.
  /// - "NO_TRAFFIC_SELECTOR_TO_GCP_DESTINATION" : Packet from the non-GCP
  /// (on-prem) or unknown GCP network is dropped due to the destination IP
  /// address not belonging to any IP prefix included to the local traffic
  /// selector of the VPN tunnel.
  /// - "NO_KNOWN_ROUTE_FROM_PEERED_NETWORK_TO_DESTINATION" : Packet from the
  /// unknown peered network is dropped due to no known route from the source
  /// network to the destination IP address.
  /// - "PRIVATE_NAT_TO_PSC_ENDPOINT_UNSUPPORTED" : Sending packets processed by
  /// the Private NAT Gateways to the Private Service Connect endpoints is not
  /// supported.
  /// - "PSC_PORT_MAPPING_PORT_MISMATCH" : Packet is sent to the PSC port
  /// mapping service, but its destination port does not match any port mapping
  /// rules.
  /// - "PSC_PORT_MAPPING_WITHOUT_PSC_CONNECTION_UNSUPPORTED" : Sending packets
  /// directly to the PSC port mapping service without going through the PSC
  /// connection is not supported.
  /// - "UNSUPPORTED_ROUTE_MATCHED_FOR_NAT64_DESTINATION" : Packet with
  /// destination IP address within the reserved NAT64 range is dropped due to
  /// matching a route of an unsupported type.
  /// - "TRAFFIC_FROM_HYBRID_ENDPOINT_TO_INTERNET_DISALLOWED" : Packet could be
  /// dropped because hybrid endpoint like a VPN gateway or Interconnect is not
  /// allowed to send traffic to the Internet.
  /// - "NO_MATCHING_NAT64_GATEWAY" : Packet with destination IP address within
  /// the reserved NAT64 range is dropped due to no matching NAT gateway in the
  /// subnet.
  /// - "LOAD_BALANCER_BACKEND_IP_VERSION_MISMATCH" : Packet is dropped due to
  /// being sent to a backend of a passthrough load balancer that doesn't use
  /// the same IP version as the frontend.
  /// - "NO_KNOWN_ROUTE_FROM_NCC_NETWORK_TO_DESTINATION" : Packet from the
  /// unknown NCC network is dropped due to no known route from the source
  /// network to the destination IP address.
  /// - "CLOUD_NAT_PROTOCOL_UNSUPPORTED" : Packet is dropped by Cloud NAT due to
  /// using an unsupported protocol.
  core.String? cause;

  /// Destination IP address of the dropped packet (if relevant).
  core.String? destinationIp;

  /// Region of the dropped packet (if relevant).
  core.String? region;

  /// URI of the resource that caused the drop.
  core.String? resourceUri;

  /// Source IP address of the dropped packet (if relevant).
  core.String? sourceIp;

  $DropInfo({
    this.cause,
    this.destinationIp,
    this.region,
    this.resourceUri,
    this.sourceIp,
  });

  $DropInfo.fromJson(core.Map json_)
    : this(
        cause: json_['cause'] as core.String?,
        destinationIp: json_['destinationIp'] as core.String?,
        region: json_['region'] as core.String?,
        resourceUri: json_['resourceUri'] as core.String?,
        sourceIp: json_['sourceIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cause != null) 'cause': cause!,
    if (destinationIp != null) 'destinationIp': destinationIp!,
    if (region != null) 'region': region!,
    if (resourceUri != null) 'resourceUri': resourceUri!,
    if (sourceIp != null) 'sourceIp': sourceIp!,
  };
}

/// Used by:
///
/// - domains:v1 : DsRecord
/// - domains:v1alpha2 : DsRecord
/// - domains:v1beta1 : DsRecord
class $DsRecord {
  /// The algorithm used to generate the referenced DNSKEY.
  /// Possible string values are:
  /// - "ALGORITHM_UNSPECIFIED" : The algorithm is unspecified.
  /// - "RSAMD5" : RSA/MD5. Cannot be used for new deployments.
  /// - "DH" : Diffie-Hellman. Cannot be used for new deployments.
  /// - "DSA" : DSA/SHA1. Not recommended for new deployments.
  /// - "ECC" : ECC. Not recommended for new deployments.
  /// - "RSASHA1" : RSA/SHA-1. Not recommended for new deployments.
  /// - "DSANSEC3SHA1" : DSA-NSEC3-SHA1. Not recommended for new deployments.
  /// - "RSASHA1NSEC3SHA1" : RSA/SHA1-NSEC3-SHA1. Not recommended for new
  /// deployments.
  /// - "RSASHA256" : RSA/SHA-256.
  /// - "RSASHA512" : RSA/SHA-512.
  /// - "ECCGOST" : GOST R 34.10-2001.
  /// - "ECDSAP256SHA256" : ECDSA Curve P-256 with SHA-256.
  /// - "ECDSAP384SHA384" : ECDSA Curve P-384 with SHA-384.
  /// - "ED25519" : Ed25519.
  /// - "ED448" : Ed448.
  /// - "INDIRECT" : Reserved for Indirect Keys. Cannot be used for new
  /// deployments.
  /// - "PRIVATEDNS" : Private algorithm. Cannot be used for new deployments.
  /// - "PRIVATEOID" : Private algorithm OID. Cannot be used for new
  /// deployments.
  core.String? algorithm;

  /// The digest generated from the referenced DNSKEY.
  core.String? digest;

  /// The hash function used to generate the digest of the referenced DNSKEY.
  /// Possible string values are:
  /// - "DIGEST_TYPE_UNSPECIFIED" : The DigestType is unspecified.
  /// - "SHA1" : SHA-1. Not recommended for new deployments.
  /// - "SHA256" : SHA-256.
  /// - "GOST3411" : GOST R 34.11-94.
  /// - "SHA384" : SHA-384.
  core.String? digestType;

  /// The key tag of the record.
  ///
  /// Must be set in range 0 -- 65535.
  core.int? keyTag;

  $DsRecord({this.algorithm, this.digest, this.digestType, this.keyTag});

  $DsRecord.fromJson(core.Map json_)
    : this(
        algorithm: json_['algorithm'] as core.String?,
        digest: json_['digest'] as core.String?,
        digestType: json_['digestType'] as core.String?,
        keyTag: json_['keyTag'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (digest != null) 'digest': digest!,
    if (digestType != null) 'digestType': digestType!,
    if (keyTag != null) 'keyTag': keyTag!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : DsaPublicKeyInfo
/// - cloudidentity:v1beta1 : DsaPublicKeyInfo
class $DsaPublicKeyInfo {
  /// Key size in bits (size of parameter P).
  core.int? keySize;

  $DsaPublicKeyInfo({this.keySize});

  $DsaPublicKeyInfo.fromJson(core.Map json_)
    : this(keySize: json_['keySize'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (keySize != null) 'keySize': keySize!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DtmfInput
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DtmfInput
class $DtmfInput {
  /// The dtmf digits.
  core.String? digits;

  /// The finish digit (if any).
  core.String? finishDigit;

  $DtmfInput({this.digits, this.finishDigit});

  $DtmfInput.fromJson(core.Map json_)
    : this(
        digits: json_['digits'] as core.String?,
        finishDigit: json_['finishDigit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digits != null) 'digits': digits!,
    if (finishDigit != null) 'finishDigit': finishDigit!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2DtmfParameters
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1DtmfParameters
class $DtmfParameters {
  /// Indicates whether DTMF input can be handled in the next request.
  core.bool? acceptsDtmfInput;

  $DtmfParameters({this.acceptsDtmfInput});

  $DtmfParameters.fromJson(core.Map json_)
    : this(acceptsDtmfInput: json_['acceptsDtmfInput'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptsDtmfInput != null) 'acceptsDtmfInput': acceptsDtmfInput!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DuplicateLineItemRequest
/// - displayvideo:v3 : DuplicateLineItemRequest
/// - displayvideo:v4 : DuplicateLineItemRequest
class $DuplicateLineItemRequest {
  /// The display name of the new line item.
  ///
  /// Must be UTF-8 encoded with a maximum size of 240 bytes.
  core.String? targetDisplayName;

  $DuplicateLineItemRequest({this.targetDisplayName});

  $DuplicateLineItemRequest.fromJson(core.Map json_)
    : this(targetDisplayName: json_['targetDisplayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetDisplayName != null) 'targetDisplayName': targetDisplayName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : DuplicateLineItemResponse
/// - displayvideo:v3 : DuplicateLineItemResponse
/// - displayvideo:v4 : DuplicateLineItemResponse
class $DuplicateLineItemResponse {
  /// The ID of the created line item.
  core.String? duplicateLineItemId;

  $DuplicateLineItemResponse({this.duplicateLineItemId});

  $DuplicateLineItemResponse.fromJson(core.Map json_)
    : this(duplicateLineItemId: json_['duplicateLineItemId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (duplicateLineItemId != null)
      'duplicateLineItemId': duplicateLineItemId!,
  };
}

/// Used by:
///
/// - compute:alpha : Duration
/// - compute:beta : Duration
/// - compute:v1 : Duration
class $Duration {
  /// Span of time that's a fraction of a second at nanosecond resolution.
  ///
  /// Durations less than one second are represented with a 0 `seconds` field
  /// and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
  core.int? nanos;

  /// Span of time at a resolution of a second.
  ///
  /// Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are
  /// computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year *
  /// 10000 years
  core.String? seconds;

  $Duration({this.nanos, this.seconds});

  $Duration.fromJson(core.Map json_)
    : this(
        nanos: json_['nanos'] as core.int?,
        seconds: json_['seconds'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nanos != null) 'nanos': nanos!,
    if (seconds != null) 'seconds': seconds!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : DynamicGroupStatus
/// - cloudidentity:v1beta1 : DynamicGroupStatus
class $DynamicGroupStatus {
  /// Status of the dynamic group.
  /// Possible string values are:
  /// - "STATUS_UNSPECIFIED" : Default.
  /// - "UP_TO_DATE" : The dynamic group is up-to-date.
  /// - "UPDATING_MEMBERSHIPS" : The dynamic group has just been created and
  /// memberships are being updated.
  /// - "INVALID_QUERY" : Group is in an unrecoverable state and its memberships
  /// can't be updated.
  core.String? status;

  /// The latest time at which the dynamic group is guaranteed to be in the
  /// given status.
  ///
  /// If status is `UP_TO_DATE`, the latest time at which the dynamic group was
  /// confirmed to be up-to-date. If status is `UPDATING_MEMBERSHIPS`, the time
  /// at which dynamic group was created.
  core.String? statusTime;

  $DynamicGroupStatus({this.status, this.statusTime});

  $DynamicGroupStatus.fromJson(core.Map json_)
    : this(
        status: json_['status'] as core.String?,
        statusTime: json_['statusTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (status != null) 'status': status!,
    if (statusTime != null) 'statusTime': statusTime!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : DynamicListenerState
/// - trafficdirector:v3 : DynamicListenerState
class $DynamicListenerState {
  /// The timestamp when the Listener was last successfully updated.
  core.String? lastUpdated;

  /// The listener config.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? listener;

  /// This is the per-resource version information.
  ///
  /// This version is currently taken from the :ref:`version_info ` field at the
  /// time that the listener was loaded. In the future, discrete per-listener
  /// versions may be supported by the API.
  core.String? versionInfo;

  $DynamicListenerState({this.lastUpdated, this.listener, this.versionInfo});

  $DynamicListenerState.fromJson(core.Map json_)
    : this(
        lastUpdated: json_['lastUpdated'] as core.String?,
        listener:
            json_.containsKey('listener')
                ? json_['listener'] as core.Map<core.String, core.dynamic>
                : null,
        versionInfo: json_['versionInfo'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastUpdated != null) 'lastUpdated': lastUpdated!,
    if (listener != null) 'listener': listener!,
    if (versionInfo != null) 'versionInfo': versionInfo!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1DynamicRetrievalConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DynamicRetrievalConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1DynamicRetrievalConfig
class $DynamicRetrievalConfig {
  /// The threshold to be used in dynamic retrieval.
  ///
  /// If not set, a system default value is used.
  ///
  /// Optional.
  core.double? dynamicThreshold;

  /// The mode of the predictor to be used in dynamic retrieval.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Always trigger retrieval.
  /// - "MODE_DYNAMIC" : Run retrieval only when system decides it is necessary.
  core.String? mode;

  $DynamicRetrievalConfig({this.dynamicThreshold, this.mode});

  $DynamicRetrievalConfig.fromJson(core.Map json_)
    : this(
        dynamicThreshold: (json_['dynamicThreshold'] as core.num?)?.toDouble(),
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dynamicThreshold != null) 'dynamicThreshold': dynamicThreshold!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - gkehub:v1 : EdgeCluster
/// - gkehub:v1alpha : EdgeCluster
/// - gkehub:v1beta : EdgeCluster
class $EdgeCluster {
  /// Self-link of the Google Cloud resource for the Edge Cluster.
  ///
  /// For example:
  /// //edgecontainer.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
  ///
  /// Immutable.
  core.String? resourceLink;

  $EdgeCluster({this.resourceLink});

  $EdgeCluster.fromJson(core.Map json_)
    : this(resourceLink: json_['resourceLink'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceLink != null) 'resourceLink': resourceLink!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : EdgeLocation
/// - networkmanagement:v1beta1 : EdgeLocation
class $EdgeLocation {
  /// Name of the metropolitan area.
  core.String? metropolitanArea;

  $EdgeLocation({this.metropolitanArea});

  $EdgeLocation.fromJson(core.Map json_)
    : this(metropolitanArea: json_['metropolitanArea'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (metropolitanArea != null) 'metropolitanArea': metropolitanArea!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : EditGuaranteedOrderReadAccessorsRequest
/// - displayvideo:v3 : EditGuaranteedOrderReadAccessorsRequest
/// - displayvideo:v4 : EditGuaranteedOrderReadAccessorsRequest
class $EditGuaranteedOrderReadAccessorsRequest {
  /// The advertisers to add as read accessors to the guaranteed order.
  core.List<core.String>? addedAdvertisers;

  /// The partner context in which the change is being made.
  ///
  /// Required.
  core.String? partnerId;

  /// Whether to give all advertisers of the read/write accessor partner read
  /// access to the guaranteed order.
  ///
  /// Only applicable if read_write_partner_id is set in the guaranteed order.
  core.bool? readAccessInherited;

  /// The advertisers to remove as read accessors to the guaranteed order.
  core.List<core.String>? removedAdvertisers;

  $EditGuaranteedOrderReadAccessorsRequest({
    this.addedAdvertisers,
    this.partnerId,
    this.readAccessInherited,
    this.removedAdvertisers,
  });

  $EditGuaranteedOrderReadAccessorsRequest.fromJson(core.Map json_)
    : this(
        addedAdvertisers:
            (json_['addedAdvertisers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        partnerId: json_['partnerId'] as core.String?,
        readAccessInherited: json_['readAccessInherited'] as core.bool?,
        removedAdvertisers:
            (json_['removedAdvertisers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addedAdvertisers != null) 'addedAdvertisers': addedAdvertisers!,
    if (partnerId != null) 'partnerId': partnerId!,
    if (readAccessInherited != null)
      'readAccessInherited': readAccessInherited!,
    if (removedAdvertisers != null) 'removedAdvertisers': removedAdvertisers!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : EditGuaranteedOrderReadAccessorsResponse
/// - displayvideo:v3 : EditGuaranteedOrderReadAccessorsResponse
/// - displayvideo:v4 : EditGuaranteedOrderReadAccessorsResponse
class $EditGuaranteedOrderReadAccessorsResponse {
  /// Whether all advertisers of read_write_partner_id have read access to the
  /// guaranteed order.
  core.bool? readAccessInherited;

  /// The IDs of advertisers with read access to the guaranteed order.
  core.List<core.String>? readAdvertiserIds;

  $EditGuaranteedOrderReadAccessorsResponse({
    this.readAccessInherited,
    this.readAdvertiserIds,
  });

  $EditGuaranteedOrderReadAccessorsResponse.fromJson(core.Map json_)
    : this(
        readAccessInherited: json_['readAccessInherited'] as core.bool?,
        readAdvertiserIds:
            (json_['readAdvertiserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (readAccessInherited != null)
      'readAccessInherited': readAccessInherited!,
    if (readAdvertiserIds != null) 'readAdvertiserIds': readAdvertiserIds!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate
/// - displayvideo:v3 : EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate
/// - displayvideo:v4 : EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate
class $EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate {
  /// The advertisers to add.
  core.List<core.String>? addedAdvertisers;

  /// The advertisers to remove.
  core.List<core.String>? removedAdvertisers;

  $EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate({
    this.addedAdvertisers,
    this.removedAdvertisers,
  });

  $EditInventorySourceReadWriteAccessorsRequestAdvertisersUpdate.fromJson(
    core.Map json_,
  ) : this(
        addedAdvertisers:
            (json_['addedAdvertisers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        removedAdvertisers:
            (json_['removedAdvertisers'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addedAdvertisers != null) 'addedAdvertisers': addedAdvertisers!,
    if (removedAdvertisers != null) 'removedAdvertisers': removedAdvertisers!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpSecuritygatewaysV1EgressPolicy
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpSecuritygatewaysV1alphaEgressPolicy
class $EgressPolicy {
  /// List of the regions where the application sends traffic.
  ///
  /// Required.
  core.List<core.String>? regions;

  $EgressPolicy({this.regions});

  $EgressPolicy.fromJson(core.Map json_)
    : this(
        regions:
            (json_['regions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (regions != null) 'regions': regions!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : EgressSource
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1EgressSource
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1EgressSource
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1EgressSource
class $EgressSource {
  /// An AccessLevel resource name that allows protected resources inside the
  /// ServicePerimeters to access outside the ServicePerimeter boundaries.
  ///
  /// AccessLevels listed must be in the same policy as this ServicePerimeter.
  /// Referencing a nonexistent AccessLevel will cause an error. If an
  /// AccessLevel name is not specified, only resources within the perimeter can
  /// be accessed through Google Cloud calls with request origins within the
  /// perimeter. Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a
  /// single `*` is specified for `access_level`, then all EgressSources will be
  /// allowed.
  core.String? accessLevel;

  /// A Google Cloud resource from the service perimeter that you want to allow
  /// to access data outside the perimeter.
  ///
  /// This field supports only projects. The project format is
  /// `projects/{project_number}`. You can't use `*` in this field to allow all
  /// Google Cloud resources.
  core.String? resource;

  $EgressSource({this.accessLevel, this.resource});

  $EgressSource.fromJson(core.Map json_)
    : this(
        accessLevel: json_['accessLevel'] as core.String?,
        resource: json_['resource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessLevel != null) 'accessLevel': accessLevel!,
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : EkmMetadata
/// - cloudcontrolspartner:v1beta : EkmMetadata
class $EkmMetadata {
  /// Endpoint for sending requests to the EKM for key provisioning during
  /// Assured Workload creation.
  core.String? ekmEndpointUri;

  /// The Cloud EKM partner.
  /// Possible string values are:
  /// - "EKM_SOLUTION_UNSPECIFIED" : Unspecified EKM solution
  /// - "FORTANIX" : EKM Partner Fortanix
  /// - "FUTUREX" : EKM Partner FutureX
  /// - "THALES" : EKM Partner Thales
  /// - "VIRTRU" : This enum value is never used.
  core.String? ekmSolution;

  $EkmMetadata({this.ekmEndpointUri, this.ekmSolution});

  $EkmMetadata.fromJson(core.Map json_)
    : this(
        ekmEndpointUri: json_['ekmEndpointUri'] as core.String?,
        ekmSolution: json_['ekmSolution'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ekmEndpointUri != null) 'ekmEndpointUri': ekmEndpointUri!,
    if (ekmSolution != null) 'ekmSolution': ekmSolution!,
  };
}

/// Used by:
///
/// - domains:v1 : EmailForwarding
/// - domains:v1alpha2 : EmailForwarding
/// - domains:v1beta1 : EmailForwarding
class $EmailForwarding {
  /// An alias recipient email that forwards emails to the
  /// `target_email_address`.
  ///
  /// For example, `admin@example.com` or `*@example.com` (wildcard alias
  /// forwards all the emails under the registered domain).
  core.String? alias;

  /// Target email that receives emails sent to the `alias`.
  core.String? targetEmailAddress;

  $EmailForwarding({this.alias, this.targetEmailAddress});

  $EmailForwarding.fromJson(core.Map json_)
    : this(
        alias: json_['alias'] as core.String?,
        targetEmailAddress: json_['targetEmailAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alias != null) 'alias': alias!,
    if (targetEmailAddress != null) 'targetEmailAddress': targetEmailAddress!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEmbeddingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEmbeddingConfig
class $EmbeddingConfig {
  /// Full field path in the schema mapped as embedding field.
  core.String? fieldPath;

  $EmbeddingConfig({this.fieldPath});

  $EmbeddingConfig.fromJson(core.Map json_)
    : this(fieldPath: json_['fieldPath'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldPath != null) 'fieldPath': fieldPath!,
  };
}

/// Used by:
///
/// - accessapproval:v1 : DismissApprovalRequestMessage
/// - accessapproval:v1 : Empty
/// - accessapproval:v1 : InvalidateApprovalRequestMessage
/// - accesscontextmanager:v1 : CancelOperationRequest
/// - accesscontextmanager:v1 : Empty
/// - addressvalidation:v1 : GoogleMapsAddressvalidationV1ProvideValidationFeedbackResponse
/// - adexchangebuyer2:v2beta1 : CancelNegotiationRequest
/// - adexchangebuyer2:v2beta1 : CompleteSetupRequest
/// - adexchangebuyer2:v2beta1 : Empty
/// - adexchangebuyer2:v2beta1 : ResumeProposalRequest
/// - adexchangebuyer2:v2beta1 : StopWatchingCreativeRequest
/// - admin:directory_v1 : ChangeChromeOsDeviceStatusSucceeded
/// - admin:directory_v1 : Empty
/// - adsense:v2 : Empty
/// - adsenseplatform:v1 : CloseAccountRequest
/// - adsenseplatform:v1 : CloseAccountResponse
/// - adsenseplatform:v1 : Empty
/// - adsenseplatform:v1 : RequestSiteReviewResponse
/// - adsenseplatform:v1alpha : CloseAccountRequest
/// - adsenseplatform:v1alpha : CloseAccountResponse
/// - adsenseplatform:v1alpha : Empty
/// - adsenseplatform:v1alpha : RequestSiteReviewResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1AddContextChildrenResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1AddExecutionEventsResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelBatchPredictionJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelCustomJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelDataLabelingJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelNasJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelPipelineJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelTrainingPipelineRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CancelTuningJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1DirectUploadSource
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExactMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExternalApiSimpleSearchParams
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureOnlineStoreOptimized
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewIndexConfigBruteForceConfig
/// - aiplatform:v1 : GoogleCloudAiplatformV1ListOptimalTrialsRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookExecutionJobWorkbenchRuntime
/// - aiplatform:v1 : GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1PauseScheduleRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagManagedDbConfigBasic
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagManagedDbConfigScaled
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagManagedDbConfigUnprovisioned
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagVectorDbConfigRagManagedDbKNN
/// - aiplatform:v1 : GoogleCloudAiplatformV1RebootPersistentResourceRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1RemoveContextChildrenResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1RemoveDatapointsResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1RubricBasedInstructionFollowingSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1StartNotebookRuntimeRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1StopNotebookRuntimeRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1StopTrialRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1SyncFeatureViewRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolCallValidSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolCodeExecution
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolNameMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKeyMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryAnyOrderMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryExactMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryInOrderMatchSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryPrecisionSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryRecallSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest
/// - aiplatform:v1 : GoogleCloudAiplatformV1UpsertDatapointsResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1UrlContext
/// - aiplatform:v1 : GoogleCloudAiplatformV1WriteFeatureValuesResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse
/// - aiplatform:v1 : GoogleCloudAiplatformV1WriteTensorboardRunDataResponse
/// - aiplatform:v1 : GoogleProtobufEmpty
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AddContextChildrenResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AddExecutionEventsResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AppendEventResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelBatchPredictionJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelCustomJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelDataLabelingJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelHyperparameterTuningJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelNasJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelPipelineJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelTrainingPipelineRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CancelTuningJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CheckTrialEarlyStoppingStateRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1DirectUploadSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExactMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExternalApiSimpleSearchParams
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureOnlineStoreOptimized
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewIndexConfigBruteForceConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigBruteForceConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ListOptimalTrialsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookExecutionJobWorkbenchRuntime
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PauseModelDeploymentMonitoringJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PauseScheduleRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigDocumentCorpus
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagManagedDbConfigBasic
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagManagedDbConfigScaled
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagManagedDbConfigUnprovisioned
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbKNN
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RebootPersistentResourceRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RemoveContextChildrenResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RemoveDatapointsResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReportExecutionEventResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ResumeModelDeploymentMonitoringJobRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StartNotebookRuntimeRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StopNotebookRuntimeRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StopTrialRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethodLastEntry
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SyncFeatureViewRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolCallValidSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolCodeExecution
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolNameMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKeyMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryExactMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryPrecisionSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryRecallSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UpgradeNotebookRuntimeRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UpsertDatapointsResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UrlContext
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1WriteFeatureValuesResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1WriteTensorboardRunDataResponse
/// - aiplatform:v1beta1 : GoogleProtobufEmpty
/// - alertcenter:v1beta1 : Empty
/// - alloydb:v1 : CancelOperationRequest
/// - alloydb:v1 : Empty
/// - alloydb:v1 : SqlImportOptions
/// - alloydb:v1alpha : CancelOperationRequest
/// - alloydb:v1alpha : Empty
/// - alloydb:v1alpha : SqlImportOptions
/// - alloydb:v1beta : Empty
/// - alloydb:v1beta : SqlImportOptions
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAcknowledgeUserDataCollectionResponse
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaApproveDisplayVideo360AdvertiserLinkProposalRequest
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaArchiveAudienceRequest
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaArchiveCustomDimensionRequest
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaArchiveCustomMetricRequest
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaCancelDisplayVideo360AdvertiserLinkProposalRequest
/// - analyticsadmin:v1alpha : GoogleProtobufEmpty
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAcknowledgeUserDataCollectionResponse
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaArchiveCustomDimensionRequest
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaArchiveCustomMetricRequest
/// - analyticsadmin:v1beta : GoogleProtobufEmpty
/// - analyticsdata:v1beta : EmptyFilter
/// - analyticshub:v1 : DefaultExchangeConfig
/// - analyticshub:v1 : Empty
/// - analyticshub:v1 : PubsubWrapper
/// - analyticshub:v1 : RefreshSubscriptionRequest
/// - analyticshub:v1 : RevokeSubscriptionResponse
/// - analyticshub:v1 : TextConfig
/// - analyticshub:v1beta1 : Empty
/// - analyticshub:v1beta1 : SubscribeListingResponse
/// - androiddeviceprovisioning:v1 : Empty
/// - androidmanagement:v1 : Empty
/// - androidmanagement:v1 : StopLostModeParams
/// - androidpublisher:v3 : AddTargetingResponse
/// - androidpublisher:v3 : CancelAppRecoveryRequest
/// - androidpublisher:v3 : CancelAppRecoveryResponse
/// - androidpublisher:v3 : DeployAppRecoveryRequest
/// - androidpublisher:v3 : DeployAppRecoveryResponse
/// - androidpublisher:v3 : DeveloperInitiatedCancellation
/// - androidpublisher:v3 : ExternalTransactionTestPurchase
/// - androidpublisher:v3 : FullRefund
/// - androidpublisher:v3 : MigrateBasePlanPricesResponse
/// - androidpublisher:v3 : OneTimeCode
/// - androidpublisher:v3 : OneTimeProductOfferNoPriceOverrideOptions
/// - androidpublisher:v3 : OtherRecurringProduct
/// - androidpublisher:v3 : OtherRegionsSubscriptionOfferPhaseFreePriceOverride
/// - androidpublisher:v3 : PaidAppDetails
/// - androidpublisher:v3 : PendingCancellation
/// - androidpublisher:v3 : RegionalSubscriptionOfferPhaseFreePriceOverride
/// - androidpublisher:v3 : RentOfferDetails
/// - androidpublisher:v3 : RentalDetails
/// - androidpublisher:v3 : ReplacementCancellation
/// - androidpublisher:v3 : RevocationContextFullRefund
/// - androidpublisher:v3 : RevocationContextProratedRefund
/// - androidpublisher:v3 : RevokeSubscriptionPurchaseResponse
/// - androidpublisher:v3 : SafetyLabelsUpdateResponse
/// - androidpublisher:v3 : SystemInitiatedCancellation
/// - androidpublisher:v3 : TargetingRuleScopeAnySubscriptionInApp
/// - androidpublisher:v3 : TargetingRuleScopeThisSubscription
/// - androidpublisher:v3 : TestPurchase
/// - apigateway:v1 : ApigatewayCancelOperationRequest
/// - apigateway:v1 : Empty
/// - apigateway:v1beta : ApigatewayCancelOperationRequest
/// - apigateway:v1beta : Empty
/// - apigee:v1 : GoogleCloudApigeeV1ActivateNatAddressRequest
/// - apigee:v1 : GoogleCloudApigeeV1BatchComputeSecurityAssessmentResultsRequestIncludeAll
/// - apigee:v1 : GoogleCloudApigeeV1DisableSecurityActionRequest
/// - apigee:v1 : GoogleCloudApigeeV1EnableSecurityActionRequest
/// - apigee:v1 : GoogleCloudApigeeV1ExpireDeveloperSubscriptionRequest
/// - apigee:v1 : GoogleCloudApigeeV1GenerateDownloadUrlRequest
/// - apigee:v1 : GoogleCloudApigeeV1GenerateUploadUrlRequest
/// - apigee:v1 : GoogleCloudApigeeV1GetSyncAuthorizationRequest
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigAbuse
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigAuthorization
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigCORS
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigMTLS
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigMediation
/// - apigee:v1 : GoogleCloudApigeeV1ProfileConfigThreat
/// - apigee:v1 : GoogleCloudApigeeV1ReportInstanceStatusResponse
/// - apigee:v1 : GoogleCloudApigeeV1SecurityActionAllow
/// - apigee:v1 : GoogleProtobufEmpty
/// - apigeeregistry:v1 : CancelOperationRequest
/// - apigeeregistry:v1 : Empty
/// - apihub:v1 : Empty
/// - apihub:v1 : GoogleCloudApihubV1DisablePluginRequest
/// - apihub:v1 : GoogleCloudApihubV1EnablePluginRequest
/// - apihub:v1 : GoogleCloudApihubV1LintSpecRequest
/// - apihub:v1 : GoogleLongrunningCancelOperationRequest
/// - apikeys:v2 : V2UndeleteKeyRequest
/// - apim:v1alpha : CancelOperationRequest
/// - apim:v1alpha : DisableObservationJobRequest
/// - apim:v1alpha : Empty
/// - apim:v1alpha : EnableObservationJobRequest
/// - appengine:v1 : Empty
/// - appengine:v1 : RepairApplicationRequest
/// - appengine:v1alpha : Empty
/// - appengine:v1beta : Empty
/// - appengine:v1beta : RepairApplicationRequest
/// - apphub:v1 : CancelOperationRequest
/// - apphub:v1 : DetachServiceProjectAttachmentRequest
/// - apphub:v1 : DetachServiceProjectAttachmentResponse
/// - apphub:v1 : Empty
/// - apphub:v1alpha : CancelOperationRequest
/// - apphub:v1alpha : DetachServiceProjectAttachmentRequest
/// - apphub:v1alpha : DetachServiceProjectAttachmentResponse
/// - apphub:v1alpha : Empty
/// - area120tables:v1alpha1 : Empty
/// - artifactregistry:v1 : DownloadFileResponse
/// - artifactregistry:v1 : Empty
/// - artifactregistry:v1 : UploadAptArtifactRequest
/// - artifactregistry:v1 : UploadGoModuleRequest
/// - artifactregistry:v1 : UploadGoogetArtifactRequest
/// - artifactregistry:v1 : UploadYumArtifactRequest
/// - artifactregistry:v1beta1 : Empty
/// - artifactregistry:v1beta2 : DownloadFileResponse
/// - artifactregistry:v1beta2 : Empty
/// - artifactregistry:v1beta2 : UploadAptArtifactRequest
/// - artifactregistry:v1beta2 : UploadYumArtifactRequest
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1AcknowledgeViolationResponse
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1EnableComplianceUpdatesResponse
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1EnableResourceMonitoringResponse
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1RestrictAllowedResourcesResponse
/// - assuredworkloads:v1 : GoogleProtobufEmpty
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1AcknowledgeViolationResponse
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1EnableComplianceUpdatesResponse
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1EnableResourceMonitoringResponse
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1RestrictAllowedResourcesResponse
/// - assuredworkloads:v1beta1 : GoogleProtobufEmpty
/// - authorizedbuyersmarketplace:v1 : ActivateClientRequest
/// - authorizedbuyersmarketplace:v1 : ActivateClientUserRequest
/// - authorizedbuyersmarketplace:v1 : CancelNegotiationRequest
/// - authorizedbuyersmarketplace:v1 : DeactivateClientRequest
/// - authorizedbuyersmarketplace:v1 : DeactivateClientUserRequest
/// - authorizedbuyersmarketplace:v1 : Empty
/// - authorizedbuyersmarketplace:v1 : ResumeFinalizedDealRequest
/// - authorizedbuyersmarketplace:v1 : SetReadyToServeRequest
/// - authorizedbuyersmarketplace:v1 : SubscribeAuctionPackageRequest
/// - authorizedbuyersmarketplace:v1 : UnsubscribeAuctionPackageRequest
/// - authorizedbuyersmarketplace:v1alpha : ActivateClientRequest
/// - authorizedbuyersmarketplace:v1alpha : ActivateClientUserRequest
/// - authorizedbuyersmarketplace:v1alpha : ActivateDataSegmentRequest
/// - authorizedbuyersmarketplace:v1alpha : CancelNegotiationRequest
/// - authorizedbuyersmarketplace:v1alpha : DeactivateClientRequest
/// - authorizedbuyersmarketplace:v1alpha : DeactivateClientUserRequest
/// - authorizedbuyersmarketplace:v1alpha : DeactivateDataSegmentRequest
/// - authorizedbuyersmarketplace:v1alpha : Empty
/// - authorizedbuyersmarketplace:v1alpha : ResumeFinalizedDealRequest
/// - authorizedbuyersmarketplace:v1alpha : SetReadyToServeRequest
/// - authorizedbuyersmarketplace:v1alpha : SubscribeAuctionPackageRequest
/// - authorizedbuyersmarketplace:v1alpha : UnsubscribeAuctionPackageRequest
/// - authorizedbuyersmarketplace:v1beta : ActivateDataSegmentRequest
/// - authorizedbuyersmarketplace:v1beta : DeactivateDataSegmentRequest
/// - backupdr:v1 : CancelOperationRequest
/// - backupdr:v1 : Empty
/// - baremetalsolution:v2 : DisableHyperthreadingRequest
/// - baremetalsolution:v2 : DisableInteractiveSerialConsoleRequest
/// - baremetalsolution:v2 : Empty
/// - baremetalsolution:v2 : EnableHyperthreadingRequest
/// - baremetalsolution:v2 : EnableInteractiveSerialConsoleRequest
/// - baremetalsolution:v2 : EvictLunRequest
/// - baremetalsolution:v2 : EvictVolumeRequest
/// - baremetalsolution:v2 : ResetInstanceRequest
/// - baremetalsolution:v2 : RestoreVolumeSnapshotRequest
/// - baremetalsolution:v2 : StartInstanceRequest
/// - baremetalsolution:v2 : StopInstanceRequest
/// - batch:v1 : CancelOperationRequest
/// - batch:v1 : Empty
/// - beyondcorp:v1 : Empty
/// - beyondcorp:v1 : GoogleLongrunningCancelOperationRequest
/// - beyondcorp:v1alpha : Empty
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpSaasplatformSubscriptionsV1alphaRestartSubscriptionResponse
/// - beyondcorp:v1alpha : GoogleLongrunningCancelOperationRequest
/// - bigqueryconnection:v1 : Empty
/// - bigqueryconnection:v1beta1 : Empty
/// - bigquerydatapolicy:v1 : Empty
/// - bigquerydatatransfer:v1 : CheckValidCredsRequest
/// - bigquerydatatransfer:v1 : Empty
/// - bigquerydatatransfer:v1 : ManualSchedule
/// - bigqueryreservation:v1 : Empty
/// - bigtableadmin:v2 : DataBoostReadLocalWrites
/// - bigtableadmin:v2 : Empty
/// - bigtableadmin:v2 : GenerateConsistencyTokenRequest
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeAggregateHyperLogLogPlusPlusUniqueCount
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeAggregateMax
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeAggregateMin
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeAggregateSum
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeBool
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeDate
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeFloat32
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeFloat64
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeInt64EncodingOrderedCodeBytes
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeStructEncodingOrderedCodeBytes
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeStructEncodingSingleton
/// - bigtableadmin:v2 : RowAffinity
/// - bigtableadmin:v2 : StandardReadRemoteWrites
/// - bigtableadmin:v2 : UndeleteTableRequest
/// - billingbudgets:v1 : GoogleCloudBillingBudgetsV1LastPeriodAmount
/// - billingbudgets:v1 : GoogleProtobufEmpty
/// - billingbudgets:v1beta1 : GoogleCloudBillingBudgetsV1beta1LastPeriodAmount
/// - billingbudgets:v1beta1 : GoogleProtobufEmpty
/// - binaryauthorization:v1 : Empty
/// - binaryauthorization:v1beta1 : Empty
/// - blockchainnodeengine:v1 : CancelOperationRequest
/// - blockchainnodeengine:v1 : GoogleProtobufEmpty
/// - books:v1 : Empty
/// - certificatemanager:v1 : CancelOperationRequest
/// - certificatemanager:v1 : Empty
/// - chat:v1 : CompleteImportSpaceRequest
/// - chat:v1 : Empty
/// - chat:v1 : GoogleAppsCardV1Divider
/// - checks:v1alpha : CancelOperationRequest
/// - checks:v1alpha : Empty
/// - chromemanagement:v1 : GoogleChromeManagementV1TelemetryAudioSevereUnderrunEvent
/// - chromemanagement:v1 : GoogleProtobufEmpty
/// - chromepolicy:v1 : GoogleChromePolicyVersionsV1RemoveCertificateResponse
/// - chromepolicy:v1 : GoogleChromePolicyVersionsV1RemoveNetworkResponse
/// - chromepolicy:v1 : GoogleProtobufEmpty
/// - classroom:v1 : Empty
/// - classroom:v1 : ReclaimStudentSubmissionRequest
/// - classroom:v1 : ReturnStudentSubmissionRequest
/// - classroom:v1 : TeacherContext
/// - classroom:v1 : TurnInStudentSubmissionRequest
/// - cloudasset:v1 : Empty
/// - cloudasset:v1 : GoogleCloudAssetV1BooleanConstraint
/// - cloudasset:v1 : GoogleCloudOrgpolicyV1RestoreDefault
/// - cloudasset:v1beta1 : GoogleCloudOrgpolicyV1RestoreDefault
/// - cloudasset:v1p5beta1 : GoogleCloudOrgpolicyV1RestoreDefault
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountpricesV1betaDefaultPrice
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountpricesV1betaFixedPrice
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountpricesV1betaListPriceAsCeiling
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountpricesV1betaMergedPrice
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskugroupskusV1betaGeoTaxonomyGlobal
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskusV1betaGeoTaxonomyGlobal
/// - cloudbilling:v1beta : GoogleCloudBillingSkugroupskusV1betaGeoTaxonomyGlobal
/// - cloudbuild:v1 : CancelOperationRequest
/// - cloudbuild:v1 : Empty
/// - cloudbuild:v1 : ReceiveTriggerWebhookResponse
/// - cloudbuild:v2 : CancelOperationRequest
/// - cloudbuild:v2 : Empty
/// - cloudbuild:v2 : FetchReadTokenRequest
/// - cloudbuild:v2 : FetchReadWriteTokenRequest
/// - cloudchannel:v1 : GoogleLongrunningCancelOperationRequest
/// - cloudchannel:v1 : GoogleProtobufEmpty
/// - cloudcontrolspartner:v1 : Empty
/// - cloudcontrolspartner:v1beta : Empty
/// - clouddeploy:v1 : AbandonReleaseRequest
/// - clouddeploy:v1 : AbandonReleaseResponse
/// - clouddeploy:v1 : AdvanceChildRolloutJob
/// - clouddeploy:v1 : AdvanceRolloutResponse
/// - clouddeploy:v1 : ApproveRolloutResponse
/// - clouddeploy:v1 : CancelAutomationRunRequest
/// - clouddeploy:v1 : CancelAutomationRunResponse
/// - clouddeploy:v1 : CancelOperationRequest
/// - clouddeploy:v1 : CancelRolloutResponse
/// - clouddeploy:v1 : CreateChildRolloutJob
/// - clouddeploy:v1 : DeployJob
/// - clouddeploy:v1 : Empty
/// - clouddeploy:v1 : IgnoreJobResponse
/// - clouddeploy:v1 : RetryJobResponse
/// - clouddeploy:v1 : TerminateJobRunResponse
/// - clouddeploy:v1 : VerifyJob
/// - clouderrorreporting:v1beta1 : DeleteEventsResponse
/// - clouderrorreporting:v1beta1 : ReportErrorEventResponse
/// - cloudfunctions:v1 : AutomaticUpdatePolicy
/// - cloudfunctions:v1 : Retry
/// - cloudfunctions:v2 : AbortFunctionUpgradeRequest
/// - cloudfunctions:v2 : AutomaticUpdatePolicy
/// - cloudfunctions:v2 : CommitFunctionUpgradeRequest
/// - cloudfunctions:v2 : DetachFunctionRequest
/// - cloudfunctions:v2 : GenerateDownloadUrlRequest
/// - cloudfunctions:v2 : RedirectFunctionUpgradeTrafficRequest
/// - cloudfunctions:v2 : RollbackFunctionUpgradeTrafficRequest
/// - cloudfunctions:v2alpha : AbortFunctionUpgradeRequest
/// - cloudfunctions:v2alpha : AutomaticUpdatePolicy
/// - cloudfunctions:v2alpha : CommitFunctionUpgradeRequest
/// - cloudfunctions:v2alpha : DetachFunctionRequest
/// - cloudfunctions:v2alpha : GenerateDownloadUrlRequest
/// - cloudfunctions:v2alpha : RedirectFunctionUpgradeTrafficRequest
/// - cloudfunctions:v2alpha : RollbackFunctionUpgradeTrafficRequest
/// - cloudfunctions:v2beta : AbortFunctionUpgradeRequest
/// - cloudfunctions:v2beta : AutomaticUpdatePolicy
/// - cloudfunctions:v2beta : CommitFunctionUpgradeRequest
/// - cloudfunctions:v2beta : DetachFunctionRequest
/// - cloudfunctions:v2beta : GenerateDownloadUrlRequest
/// - cloudfunctions:v2beta : RedirectFunctionUpgradeTrafficRequest
/// - cloudfunctions:v2beta : RollbackFunctionUpgradeTrafficRequest
/// - cloudidentity:v1 : CancelUserInvitationRequest
/// - cloudidentity:v1 : SendUserInvitationRequest
/// - cloudidentity:v1beta1 : CancelUserInvitationRequest
/// - cloudidentity:v1beta1 : SendUserInvitationRequest
/// - cloudkms:v1 : DestroyCryptoKeyVersionRequest
/// - cloudkms:v1 : RestoreCryptoKeyVersionRequest
/// - cloudkms:v1 : VerifyConnectivityResponse
/// - cloudresourcemanager:v1 : BooleanConstraint
/// - cloudresourcemanager:v1 : Empty
/// - cloudresourcemanager:v1 : GetAncestryRequest
/// - cloudresourcemanager:v1 : RestoreDefault
/// - cloudresourcemanager:v1 : UndeleteProjectRequest
/// - cloudresourcemanager:v1beta1 : Empty
/// - cloudresourcemanager:v1beta1 : GetAncestryRequest
/// - cloudresourcemanager:v1beta1 : UndeleteProjectRequest
/// - cloudresourcemanager:v2 : UndeleteFolderRequest
/// - cloudresourcemanager:v2beta1 : UndeleteFolderRequest
/// - cloudresourcemanager:v3 : Empty
/// - cloudresourcemanager:v3 : UndeleteFolderRequest
/// - cloudresourcemanager:v3 : UndeleteProjectRequest
/// - cloudscheduler:v1 : CancelOperationRequest
/// - cloudscheduler:v1 : Empty
/// - cloudscheduler:v1 : PauseJobRequest
/// - cloudscheduler:v1 : ResumeJobRequest
/// - cloudscheduler:v1 : RunJobRequest
/// - cloudscheduler:v1beta1 : Empty
/// - cloudscheduler:v1beta1 : PauseJobRequest
/// - cloudscheduler:v1beta1 : ResumeJobRequest
/// - cloudsearch:v1 : InitializeCustomerRequest
/// - cloudsearch:v1 : QuerySuggestion
/// - cloudsearch:v1 : RemoveActivityResponse
/// - cloudshell:v1 : CancelOperationRequest
/// - cloudshell:v1 : Empty
/// - cloudsupport:v2 : CloseCaseRequest
/// - cloudsupport:v2beta : CloseCaseRequest
/// - cloudtasks:v2 : Empty
/// - cloudtasks:v2 : PauseQueueRequest
/// - cloudtasks:v2 : PurgeQueueRequest
/// - cloudtasks:v2 : ResumeQueueRequest
/// - cloudtasks:v2beta2 : Empty
/// - cloudtasks:v2beta2 : PauseQueueRequest
/// - cloudtasks:v2beta2 : PullTarget
/// - cloudtasks:v2beta2 : PurgeQueueRequest
/// - cloudtasks:v2beta2 : ResumeQueueRequest
/// - cloudtasks:v2beta3 : Empty
/// - cloudtasks:v2beta3 : PauseQueueRequest
/// - cloudtasks:v2beta3 : PurgeQueueRequest
/// - cloudtasks:v2beta3 : ResumeQueueRequest
/// - cloudtrace:v1 : Empty
/// - cloudtrace:v2 : Empty
/// - cloudtrace:v2beta1 : Empty
/// - composer:v1 : DatabaseFailoverRequest
/// - composer:v1 : Empty
/// - composer:v1 : RestartWebServerRequest
/// - composer:v1beta1 : DatabaseFailoverRequest
/// - composer:v1beta1 : Empty
/// - composer:v1beta1 : RestartWebServerRequest
/// - compute:alpha : InterconnectApplicationAwareInterconnectStrictPriorityPolicy
/// - compute:alpha : ResourcePolicyDiskConsistencyGroupPolicy
/// - compute:beta : InterconnectApplicationAwareInterconnectStrictPriorityPolicy
/// - compute:beta : ResourcePolicyDiskConsistencyGroupPolicy
/// - compute:v1 : ResourcePolicyDiskConsistencyGroupPolicy
/// - config:v1 : CancelOperationRequest
/// - config:v1 : Empty
/// - config:v1 : ExportPreviewResultRequest
/// - config:v1 : ExportRevisionStatefileRequest
/// - config:v1 : LockDeploymentRequest
/// - connectors:v1 : CancelOperationRequest
/// - connectors:v1 : DeprecateCustomConnectorVersionRequest
/// - connectors:v1 : Empty
/// - connectors:v1 : ListenEventResponse
/// - connectors:v1 : RefreshConnectionSchemaMetadataRequest
/// - connectors:v1 : RepairEventingRequest
/// - connectors:v1 : RetryEventSubscriptionRequest
/// - connectors:v1 : WithdrawCustomConnectorVersionRequest
/// - connectors:v2 : Empty
/// - contactcenteraiplatform:v1alpha1 : CancelOperationRequest
/// - contactcenteraiplatform:v1alpha1 : Early
/// - contactcenteraiplatform:v1alpha1 : Empty
/// - contactcenteraiplatform:v1alpha1 : Normal
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1AppealAssessmentRequest
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1DeployQaScorecardRevisionRequest
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1FinalizeAssessmentRequest
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1HoldData
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1InterruptionData
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1NoteAssessmentNote
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1PublishAssessmentRequest
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1SilenceData
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1UndeployQaScorecardRevisionRequest
/// - contactcenterinsights:v1 : GoogleProtobufEmpty
/// - container:v1 : CompleteNodePoolUpgradeRequest
/// - container:v1 : Empty
/// - container:v1 : SecondaryBootDiskUpdateStrategy
/// - container:v1beta1 : CompleteNodePoolUpgradeRequest
/// - container:v1beta1 : Empty
/// - container:v1beta1 : Master
/// - container:v1beta1 : SecondaryBootDiskUpdateStrategy
/// - containeranalysis:v1 : CloudStorageLocation
/// - containeranalysis:v1 : Empty
/// - containeranalysis:v1 : SecretNote
/// - containeranalysis:v1alpha1 : Empty
/// - containeranalysis:v1alpha1 : SecretNote
/// - containeranalysis:v1beta1 : Empty
/// - containeranalysis:v1beta1 : ExportSBOMRequest
/// - containeranalysis:v1beta1 : GeneratePackagesSummaryRequest
/// - content:v2.1 : InputFieldCheckboxInput
/// - content:v2.1 : UndeleteConversionSourceRequest
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1DateTimeTypeOptions
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1FloatTypeOptions
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1IntegerTypeOptions
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1MapTypeOptions
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1TextTypeOptions
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1TimestampTypeOptions
/// - contentwarehouse:v1 : GoogleProtobufEmpty
/// - css:v1 : Empty
/// - datacatalog:v1 : Empty
/// - datacatalog:v1 : GoogleCloudDatacatalogV1PhysicalSchemaCsvSchema
/// - datacatalog:v1 : GoogleCloudDatacatalogV1PhysicalSchemaOrcSchema
/// - datacatalog:v1 : GoogleCloudDatacatalogV1PhysicalSchemaParquetSchema
/// - datacatalog:v1 : GoogleCloudDatacatalogV1StarEntryRequest
/// - datacatalog:v1 : GoogleCloudDatacatalogV1StarEntryResponse
/// - datacatalog:v1 : GoogleCloudDatacatalogV1UnstarEntryRequest
/// - datacatalog:v1 : GoogleCloudDatacatalogV1UnstarEntryResponse
/// - datacatalog:v1beta1 : Empty
/// - dataflow:v1b3 : DeleteSnapshotResponse
/// - dataflow:v1b3 : ResourceUtilizationReportResponse
/// - dataflow:v1b3 : SendDebugCaptureResponse
/// - dataflow:v1b3 : WorkerShutdownNoticeResponse
/// - dataform:v1beta1 : ActionSimpleLoadMode
/// - dataform:v1beta1 : CancelWorkflowInvocationRequest
/// - dataform:v1beta1 : CancelWorkflowInvocationResponse
/// - dataform:v1beta1 : CommitWorkspaceChangesResponse
/// - dataform:v1beta1 : DeleteFile
/// - dataform:v1beta1 : Empty
/// - dataform:v1beta1 : InstallNpmPackagesRequest
/// - dataform:v1beta1 : InstallNpmPackagesResponse
/// - dataform:v1beta1 : MakeDirectoryResponse
/// - dataform:v1beta1 : MoveDirectoryResponse
/// - dataform:v1beta1 : MoveFileResponse
/// - dataform:v1beta1 : PullGitCommitsResponse
/// - dataform:v1beta1 : PushGitCommitsResponse
/// - dataform:v1beta1 : RemoveDirectoryResponse
/// - dataform:v1beta1 : RemoveFileResponse
/// - dataform:v1beta1 : ResetWorkspaceChangesResponse
/// - dataform:v1beta1 : SimpleLoadMode
/// - dataform:v1beta1 : WriteFileResponse
/// - datafusion:v1 : CancelOperationRequest
/// - datafusion:v1 : Empty
/// - datafusion:v1 : RestartInstanceRequest
/// - datafusion:v1beta1 : CancelOperationRequest
/// - datafusion:v1beta1 : Empty
/// - datafusion:v1beta1 : RemoveIamPolicyRequest
/// - datafusion:v1beta1 : RemoveIamPolicyResponse
/// - datafusion:v1beta1 : RestartInstanceRequest
/// - datafusion:v1beta1 : UpgradeInstanceRequest
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1OperatorFeedbackMetadata
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1PauseEvaluationJobRequest
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1RequesterFeedbackMetadata
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1ResumeEvaluationJobRequest
/// - datalabeling:v1beta1 : GoogleProtobufEmpty
/// - datalineage:v1 : GoogleLongrunningCancelOperationRequest
/// - datalineage:v1 : GoogleProtobufEmpty
/// - datamigration:v1 : CancelOperationRequest
/// - datamigration:v1 : DemoteDestinationRequest
/// - datamigration:v1 : Empty
/// - datamigration:v1 : LogMiner
/// - datamigration:v1 : OracleAsmLogFileAccess
/// - datamigration:v1 : RollbackConversionWorkspaceRequest
/// - datamigration:v1 : StaticIpConnectivity
/// - datamigration:v1 : StaticServiceIpConnectivity
/// - datamigration:v1 : StopMigrationJobRequest
/// - datamigration:v1beta1 : CancelOperationRequest
/// - datamigration:v1beta1 : Empty
/// - datamigration:v1beta1 : PromoteMigrationJobRequest
/// - datamigration:v1beta1 : RestartMigrationJobRequest
/// - datamigration:v1beta1 : ResumeMigrationJobRequest
/// - datamigration:v1beta1 : StartMigrationJobRequest
/// - datamigration:v1beta1 : StaticIpConnectivity
/// - datamigration:v1beta1 : StopMigrationJobRequest
/// - datamigration:v1beta1 : VerifyMigrationJobRequest
/// - datapipelines:v1 : GoogleCloudDatapipelinesV1RunPipelineRequest
/// - datapipelines:v1 : GoogleCloudDatapipelinesV1StopPipelineRequest
/// - datapipelines:v1 : GoogleProtobufEmpty
/// - dataplex:v1 : Empty
/// - dataplex:v1 : GoogleCloudDataplexV1ActionInvalidDataOrganization
/// - dataplex:v1 : GoogleCloudDataplexV1ActionMissingData
/// - dataplex:v1 : GoogleCloudDataplexV1ActionMissingResource
/// - dataplex:v1 : GoogleCloudDataplexV1ActionUnauthorizedResource
/// - dataplex:v1 : GoogleCloudDataplexV1CancelJobRequest
/// - dataplex:v1 : GoogleCloudDataplexV1CancelMetadataJobRequest
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualityRuleNonNullExpectation
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualityRuleUniquenessExpectation
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualitySpecPostScanActionsJobEndTrigger
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualitySpecPostScanActionsJobFailureTrigger
/// - dataplex:v1 : GoogleCloudDataplexV1GenerateDataQualityRulesRequest
/// - dataplex:v1 : GoogleCloudDataplexV1RunDataScanRequest
/// - dataplex:v1 : GoogleCloudDataplexV1TriggerOnDemand
/// - dataplex:v1 : GoogleLongrunningCancelOperationRequest
/// - dataportability:v1 : CancelPortabilityArchiveRequest
/// - dataportability:v1 : CancelPortabilityArchiveResponse
/// - dataportability:v1 : CheckAccessTypeRequest
/// - dataportability:v1 : Empty
/// - dataportability:v1 : ResetAuthorizationRequest
/// - dataportability:v1 : RetryPortabilityArchiveRequest
/// - dataportability:v1beta : CancelPortabilityArchiveRequest
/// - dataportability:v1beta : CancelPortabilityArchiveResponse
/// - dataportability:v1beta : CheckAccessTypeRequest
/// - dataportability:v1beta : Empty
/// - dataportability:v1beta : ResetAuthorizationRequest
/// - dataportability:v1beta : RetryPortabilityArchiveRequest
/// - dataproc:v1 : CancelJobRequest
/// - dataproc:v1 : Empty
/// - dataproc:v1 : SparkConnectConfig
/// - dataproc:v1 : WriteSessionSparkApplicationContextResponse
/// - dataproc:v1 : WriteSparkApplicationContextResponse
/// - datastore:v1 : Empty
/// - datastore:v1 : ReserveIdsResponse
/// - datastore:v1 : RollbackResponse
/// - datastore:v1beta3 : ReserveIdsResponse
/// - datastore:v1beta3 : RollbackResponse
/// - datastream:v1 : AppendOnly
/// - datastream:v1 : AvroFileFormat
/// - datastream:v1 : BackfillNoneStrategy
/// - datastream:v1 : BasicEncryption
/// - datastream:v1 : BigQueryProfile
/// - datastream:v1 : BinaryLogPosition
/// - datastream:v1 : CancelOperationRequest
/// - datastream:v1 : DropLargeObjects
/// - datastream:v1 : Empty
/// - datastream:v1 : EncryptionNotEnforced
/// - datastream:v1 : Gtid
/// - datastream:v1 : LogMiner
/// - datastream:v1 : Merge
/// - datastream:v1 : MostRecentStartPosition
/// - datastream:v1 : NextAvailableStartPosition
/// - datastream:v1 : OracleAsmLogFileAccess
/// - datastream:v1 : SqlServerChangeTables
/// - datastream:v1 : SqlServerTransactionLogs
/// - datastream:v1 : SrvConnectionFormat
/// - datastream:v1 : StartBackfillJobRequest
/// - datastream:v1 : StaticServiceIpConnectivity
/// - datastream:v1 : StopBackfillJobRequest
/// - datastream:v1 : StreamLargeObjects
/// - datastream:v1alpha1 : AvroFileFormat
/// - datastream:v1alpha1 : BackfillNoneStrategy
/// - datastream:v1alpha1 : CancelOperationRequest
/// - datastream:v1alpha1 : DropLargeObjects
/// - datastream:v1alpha1 : Empty
/// - datastream:v1alpha1 : FetchErrorsRequest
/// - datastream:v1alpha1 : NoConnectivitySettings
/// - datastream:v1alpha1 : StaticServiceIpConnectivity
/// - developerconnect:v1 : CancelOperationRequest
/// - developerconnect:v1 : Empty
/// - developerconnect:v1 : FetchAccessTokenRequest
/// - developerconnect:v1 : FetchReadTokenRequest
/// - developerconnect:v1 : FetchReadWriteTokenRequest
/// - dialogflow:v2 : GoogleCloudDialogflowV2CompleteConversationRequest
/// - dialogflow:v2 : GoogleCloudDialogflowV2DeployConversationModelRequest
/// - dialogflow:v2 : GoogleCloudDialogflowV2TrainAgentRequest
/// - dialogflow:v2 : GoogleCloudDialogflowV2UndeployConversationModelRequest
/// - dialogflow:v2 : GoogleProtobufEmpty
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1CompleteConversationRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageRbmSuggestedActionRbmSuggestedActionShareLocation
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ResponseMessageEndInteraction
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1TrainAgentRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1UndeletePhoneNumberRequest
/// - dialogflow:v2beta1 : GoogleProtobufEmpty
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageEndInteraction
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageKnowledgeInfoCard
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RestorePlaybookVersionRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RestoreToolVersionRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RunContinuousTestRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3StartExperimentRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3StopExperimentRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolDataStoreToolFallbackPrompt
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3TrainFlowRequest
/// - dialogflow:v3 : GoogleProtobufEmpty
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ActionSTT
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ActionTTS
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageEndInteraction
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageKnowledgeInfoCard
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RestorePlaybookVersionRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RestoreToolVersionRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RunContinuousTestRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1StartExperimentRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1StopExperimentRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolDataStoreToolFallbackPrompt
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1TrainFlowRequest
/// - dialogflow:v3beta1 : GoogleProtobufEmpty
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1BatchVerifyTargetSitesRequest
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DisableAdvancedSiteSearchRequest
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1DocumentProcessingConfigParsingConfigDigitalParsingConfig
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EnableAdvancedSiteSearchRequest
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PurgeCompletionSuggestionsRequest
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PurgeSuggestionDenyListEntriesRequest
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1StreamAssistRequestToolsSpecImageGenerationSpec
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1StreamAssistRequestToolsSpecVideoGenerationSpec
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1StreamAssistRequestToolsSpecWebGroundingSpec
/// - discoveryengine:v1 : GoogleLongrunningCancelOperationRequest
/// - discoveryengine:v1 : GoogleProtobufEmpty
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaBatchVerifyTargetSitesRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDisableAdvancedSiteSearchRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigDigitalParsingConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEnableAdvancedSiteSearchRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineSimilarDocumentsEngineConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPauseEngineRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPurgeCompletionSuggestionsRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPurgeSuggestionDenyListEntriesRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaRemoveSuggestionResponse
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaResumeEngineRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecImageGenerationSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVideoGenerationSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecWebGroundingSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaTuneEngineRequest
/// - discoveryengine:v1alpha : GoogleLongrunningCancelOperationRequest
/// - discoveryengine:v1alpha : GoogleProtobufEmpty
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaBatchVerifyTargetSitesRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDisableAdvancedSiteSearchRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaDocumentProcessingConfigParsingConfigDigitalParsingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEnableAdvancedSiteSearchRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPauseEngineRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPurgeCompletionSuggestionsRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPurgeSuggestionDenyListEntriesRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaRemoveSuggestionResponse
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaResumeEngineRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaStreamAssistRequestToolsSpecImageGenerationSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaStreamAssistRequestToolsSpecVideoGenerationSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaStreamAssistRequestToolsSpecWebGroundingSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaTuneEngineRequest
/// - discoveryengine:v1beta : GoogleLongrunningCancelOperationRequest
/// - discoveryengine:v1beta : GoogleProtobufEmpty
/// - displayvideo:v2 : ActivateManualTriggerRequest
/// - displayvideo:v2 : DeactivateManualTriggerRequest
/// - displayvideo:v2 : Empty
/// - displayvideo:v3 : Empty
/// - displayvideo:v4 : Empty
/// - dlp:v2 : GooglePrivacyDlpV2ActivateJobTriggerRequest
/// - dlp:v2 : GooglePrivacyDlpV2AllInfoTypes
/// - dlp:v2 : GooglePrivacyDlpV2AllOtherBigQueryTables
/// - dlp:v2 : GooglePrivacyDlpV2AllOtherDatabaseResources
/// - dlp:v2 : GooglePrivacyDlpV2AllOtherResources
/// - dlp:v2 : GooglePrivacyDlpV2AllText
/// - dlp:v2 : GooglePrivacyDlpV2CancelDlpJobRequest
/// - dlp:v2 : GooglePrivacyDlpV2CloudSqlIamCredential
/// - dlp:v2 : GooglePrivacyDlpV2Disabled
/// - dlp:v2 : GooglePrivacyDlpV2FinishDlpJobRequest
/// - dlp:v2 : GooglePrivacyDlpV2GlobalProcessing
/// - dlp:v2 : GooglePrivacyDlpV2HybridInspectResponse
/// - dlp:v2 : GooglePrivacyDlpV2JobNotificationEmails
/// - dlp:v2 : GooglePrivacyDlpV2LeaveUntransformed
/// - dlp:v2 : GooglePrivacyDlpV2Manual
/// - dlp:v2 : GooglePrivacyDlpV2MultiRegionProcessing
/// - dlp:v2 : GooglePrivacyDlpV2PublishFindingsToCloudDataCatalog
/// - dlp:v2 : GooglePrivacyDlpV2PublishSummaryToCscc
/// - dlp:v2 : GooglePrivacyDlpV2PublishToChronicle
/// - dlp:v2 : GooglePrivacyDlpV2PublishToSecurityCommandCenter
/// - dlp:v2 : GooglePrivacyDlpV2PublishToStackdriver
/// - dlp:v2 : GooglePrivacyDlpV2RedactConfig
/// - dlp:v2 : GooglePrivacyDlpV2ReplaceWithInfoTypeConfig
/// - dlp:v2 : GooglePrivacyDlpV2SecretsDiscoveryTarget
/// - dlp:v2 : GooglePrivacyDlpV2SurrogateType
/// - dlp:v2 : GooglePrivacyDlpV2ThrowError
/// - dlp:v2 : GoogleProtobufEmpty
/// - dns:v1 : ResourceRecordSetsDeleteResponse
/// - docs:v1 : EmbeddedDrawingProperties
/// - docs:v1 : EmbeddedDrawingPropertiesSuggestionState
/// - documentai:v1 : GoogleCloudDocumentaiV1DeployProcessorVersionRequest
/// - documentai:v1 : GoogleCloudDocumentaiV1DisableProcessorRequest
/// - documentai:v1 : GoogleCloudDocumentaiV1EnableProcessorRequest
/// - documentai:v1 : GoogleCloudDocumentaiV1UndeployProcessorVersionRequest
/// - documentai:v1 : GoogleProtobufEmpty
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DatasetSpannerIndexingConfig
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DatasetUnmanagedDatasetConfig
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DeployProcessorVersionRequest
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3DisableProcessorRequest
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3EnableProcessorRequest
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3UndeployProcessorVersionRequest
/// - documentai:v1beta3 : GoogleProtobufEmpty
/// - domains:v1 : ResetAuthorizationCodeRequest
/// - domains:v1alpha2 : ResetAuthorizationCodeRequest
/// - domains:v1beta1 : ResetAuthorizationCodeRequest
/// - doubleclicksearch:v2 : IdMappingFile
/// - driveactivity:v2 : Administrator
/// - driveactivity:v2 : AnonymousUser
/// - driveactivity:v2 : Anyone
/// - driveactivity:v2 : DeletedUser
/// - driveactivity:v2 : DriveFile
/// - driveactivity:v2 : Edit
/// - driveactivity:v2 : Legacy
/// - driveactivity:v2 : New
/// - driveactivity:v2 : NoConsolidation
/// - driveactivity:v2 : UnknownUser
/// - driveactivity:v2 : Upload
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseDeleteFieldResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseDeleteSelectionChoiceResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseDisableFieldResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseDisableSelectionChoiceResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseEnableFieldResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseEnableSelectionChoiceResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseUpdateFieldTypeResponse
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2DeltaUpdateLabelResponseUpdateLabelPropertiesResponse
/// - drivelabels:v2 : GoogleProtobufEmpty
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseDeleteFieldResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseDeleteSelectionChoiceResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseDisableFieldResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseDisableSelectionChoiceResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseEnableFieldResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseEnableSelectionChoiceResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseUpdateFieldTypeResponse
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaDeltaUpdateLabelResponseUpdateLabelPropertiesResponse
/// - drivelabels:v2beta : GoogleProtobufEmpty
/// - essentialcontacts:v1 : GoogleProtobufEmpty
/// - eventarc:v1 : Empty
/// - eventarc:v1 : GoogleCloudEventarcV1PipelineMessagePayloadFormatJsonFormat
/// - eventarc:v1 : GoogleLongrunningCancelOperationRequest
/// - factchecktools:v1alpha1 : GoogleProtobufEmpty
/// - file:v1 : CancelOperationRequest
/// - file:v1 : Empty
/// - file:v1beta1 : CancelOperationRequest
/// - file:v1beta1 : Empty
/// - firebase:v1beta1 : Empty
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1GenerateAppAttestChallengeRequest
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1GeneratePlayIntegrityChallengeRequest
/// - firebaseappcheck:v1 : GoogleProtobufEmpty
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaGenerateAppAttestChallengeRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaGeneratePlayIntegrityChallengeRequest
/// - firebaseappcheck:v1beta : GoogleProtobufEmpty
/// - firebaseappdistribution:v1 : GoogleFirebaseAppdistroV1DistributeReleaseResponse
/// - firebaseappdistribution:v1 : GoogleLongrunningCancelOperationRequest
/// - firebaseappdistribution:v1 : GoogleProtobufEmpty
/// - firebaseappdistribution:v1alpha : GoogleFirebaseAppdistroV1alphaCancelReleaseTestResponse
/// - firebaseappdistribution:v1alpha : GoogleFirebaseAppdistroV1alphaCreateReleaseNotesResponse
/// - firebaseappdistribution:v1alpha : GoogleFirebaseAppdistroV1alphaEnableAccessOnReleaseResponse
/// - firebaseappdistribution:v1alpha : GoogleProtobufEmpty
/// - firebaseapphosting:v1 : CancelOperationRequest
/// - firebaseapphosting:v1 : Empty
/// - firebaseapphosting:v1beta : Empty
/// - firebasedatabase:v1beta : DisableDatabaseInstanceRequest
/// - firebasedatabase:v1beta : ReenableDatabaseInstanceRequest
/// - firebasedatabase:v1beta : UndeleteDatabaseInstanceRequest
/// - firebasedataconnect:v1 : CancelOperationRequest
/// - firebasedataconnect:v1 : Empty
/// - firebasedataconnect:v1beta : CancelOperationRequest
/// - firebasedataconnect:v1beta : Empty
/// - firebasehosting:v1 : CancelOperationRequest
/// - firebasehosting:v1 : Empty
/// - firebasehosting:v1beta1 : Empty
/// - firebaseml:v1 : CancelOperationRequest
/// - firebaseml:v1 : Empty
/// - firebaseml:v1beta2 : Empty
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ExternalApiSimpleSearchParams
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ToolCodeExecution
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1UrlContext
/// - firebaserules:v1 : Empty
/// - firebasestorage:v1beta : AddFirebaseRequest
/// - firebasestorage:v1beta : Empty
/// - firebasestorage:v1beta : RemoveFirebaseRequest
/// - firestore:v1 : Empty
/// - firestore:v1 : GoogleFirestoreAdminV1DailyRecurrence
/// - firestore:v1 : GoogleFirestoreAdminV1DisableUserCredsRequest
/// - firestore:v1 : GoogleFirestoreAdminV1EnableUserCredsRequest
/// - firestore:v1 : GoogleFirestoreAdminV1FlatIndex
/// - firestore:v1 : GoogleFirestoreAdminV1GoogleDefaultEncryptionOptions
/// - firestore:v1 : GoogleFirestoreAdminV1ResetUserPasswordRequest
/// - firestore:v1 : GoogleFirestoreAdminV1SourceEncryptionOptions
/// - firestore:v1 : GoogleLongrunningCancelOperationRequest
/// - firestore:v1beta1 : Empty
/// - firestore:v1beta2 : Empty
/// - forms:v1 : Empty
/// - forms:v1 : PageBreakItem
/// - forms:v1 : RenewWatchRequest
/// - forms:v1 : TextItem
/// - gkebackup:v1 : Empty
/// - gkebackup:v1 : GoogleLongrunningCancelOperationRequest
/// - gkehub:v1 : AppDevExperienceFeatureSpec
/// - gkehub:v1 : CancelOperationRequest
/// - gkehub:v1 : Empty
/// - gkehub:v1 : FleetObservabilityMembershipSpec
/// - gkehub:v1 : FleetObservabilityMembershipState
/// - gkehub:v1 : RBACRoleBindingActuationFeatureState
/// - gkehub:v1 : ScopeFeatureSpec
/// - gkehub:v1alpha : AppDevExperienceFeatureSpec
/// - gkehub:v1alpha : CancelOperationRequest
/// - gkehub:v1alpha : Empty
/// - gkehub:v1alpha : FleetObservabilityMembershipSpec
/// - gkehub:v1alpha : FleetObservabilityMembershipState
/// - gkehub:v1alpha : NamespaceActuationFeatureState
/// - gkehub:v1alpha : NamespaceActuationMembershipSpec
/// - gkehub:v1alpha : NamespaceActuationMembershipState
/// - gkehub:v1alpha : RBACRoleBindingActuationFeatureState
/// - gkehub:v1beta : AppDevExperienceFeatureSpec
/// - gkehub:v1beta : CancelOperationRequest
/// - gkehub:v1beta : Empty
/// - gkehub:v1beta : FleetObservabilityMembershipSpec
/// - gkehub:v1beta : FleetObservabilityMembershipState
/// - gkehub:v1beta : RBACRoleBindingActuationFeatureState
/// - gkehub:v1beta : ScopeFeatureSpec
/// - gkehub:v1beta1 : CancelOperationRequest
/// - gkehub:v1beta1 : Empty
/// - gkehub:v2 : CancelOperationRequest
/// - gkehub:v2 : Empty
/// - gkehub:v2 : RBACRoleBindingActuationSpec
/// - gkehub:v2alpha : CancelOperationRequest
/// - gkehub:v2alpha : Empty
/// - gkehub:v2alpha : RBACRoleBindingActuationSpec
/// - gkehub:v2beta : CancelOperationRequest
/// - gkehub:v2beta : Empty
/// - gkehub:v2beta : RBACRoleBindingActuationSpec
/// - gkeonprem:v1 : CancelOperationRequest
/// - gkeonprem:v1 : Empty
/// - gmail:v1 : DisableCseKeyPairRequest
/// - gmail:v1 : EnableCseKeyPairRequest
/// - gmail:v1 : ObliterateCseKeyPairRequest
/// - healthcare:v1 : ArchiveUserDataMappingRequest
/// - healthcare:v1 : ArchiveUserDataMappingResponse
/// - healthcare:v1 : CancelOperationRequest
/// - healthcare:v1 : Empty
/// - healthcare:v1 : RedactConfig
/// - healthcare:v1 : ReplaceWithInfoTypeConfig
/// - healthcare:v1beta1 : ArchiveUserDataMappingRequest
/// - healthcare:v1beta1 : ArchiveUserDataMappingResponse
/// - healthcare:v1beta1 : CancelOperationRequest
/// - healthcare:v1beta1 : CharacterMaskField
/// - healthcare:v1beta1 : CleanDescriptorsOption
/// - healthcare:v1beta1 : CleanTextField
/// - healthcare:v1beta1 : CleanTextTag
/// - healthcare:v1beta1 : ContextualDeidConfig
/// - healthcare:v1beta1 : CryptoHashField
/// - healthcare:v1beta1 : DateShiftField
/// - healthcare:v1beta1 : DeleteTag
/// - healthcare:v1beta1 : Empty
/// - healthcare:v1beta1 : KeepExtensionsConfig
/// - healthcare:v1beta1 : KeepField
/// - healthcare:v1beta1 : KeepTag
/// - healthcare:v1beta1 : RecurseTag
/// - healthcare:v1beta1 : RedactConfig
/// - healthcare:v1beta1 : RegenUidTag
/// - healthcare:v1beta1 : RemoveField
/// - healthcare:v1beta1 : RemoveTag
/// - healthcare:v1beta1 : ReplaceWithInfoTypeConfig
/// - healthcare:v1beta1 : ResetTag
/// - homegraph:v1 : Empty
/// - homegraph:v1 : RequestSyncDevicesResponse
/// - iam:v1 : DisableServiceAccountRequest
/// - iam:v1 : Empty
/// - iam:v1 : EnableServiceAccountKeyRequest
/// - iam:v1 : EnableServiceAccountRequest
/// - iam:v1 : UndeleteOauthClientRequest
/// - iam:v1 : UndeleteServiceAccountRequest
/// - iam:v1 : UndeleteWorkforcePoolProviderKeyRequest
/// - iam:v1 : UndeleteWorkforcePoolProviderRequest
/// - iam:v1 : UndeleteWorkforcePoolProviderScimTenantRequest
/// - iam:v1 : UndeleteWorkforcePoolProviderScimTokenRequest
/// - iam:v1 : UndeleteWorkforcePoolRequest
/// - iam:v1 : UndeleteWorkforcePoolSubjectRequest
/// - iam:v1 : UndeleteWorkloadIdentityPoolManagedIdentityRequest
/// - iam:v1 : UndeleteWorkloadIdentityPoolNamespaceRequest
/// - iam:v1 : UndeleteWorkloadIdentityPoolProviderKeyRequest
/// - iam:v1 : UndeleteWorkloadIdentityPoolProviderRequest
/// - iam:v1 : UndeleteWorkloadIdentityPoolRequest
/// - iap:v1 : Empty
/// - iap:v1 : ResetIdentityAwareProxyClientSecretRequest
/// - iap:v1 : ValidateIapAttributeExpressionResponse
/// - identitytoolkit:v1 : GoogleCloudIdentitytoolkitV1TotpInfo
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitAdminV2InitializeIdentityPlatformRequest
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitAdminV2InitializeIdentityPlatformResponse
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitV2FinalizeMfaTotpEnrollmentResponseInfo
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitV2RevokeTokenResponse
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitV2StartMfaTotpEnrollmentRequestInfo
/// - identitytoolkit:v2 : GoogleProtobufEmpty
/// - ids:v1 : CancelOperationRequest
/// - ids:v1 : Empty
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaDeprovisionClientRequest
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaExecuteTestCasesRequest
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaProvisionClientPostProcessorResponse
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaPublishIntegrationVersionResponse
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaResolveSuspensionResponse
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaTakeoverEditLockRequest
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaTakeoverTestCaseEditLockRequest
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaUnpublishIntegrationVersionRequest
/// - integrations:v1 : GoogleProtobufEmpty
/// - jobs:v3 : Empty
/// - jobs:v3p1beta1 : Empty
/// - jobs:v4 : Empty
/// - keep:v1 : Empty
/// - keep:v1 : Family
/// - language:v1 : ClassificationModelOptionsV1Model
/// - language:v1beta2 : ClassificationModelOptionsV1Model
/// - licensing:v1 : Empty
/// - lifesciences:v2beta : CancelOperationRequest
/// - lifesciences:v2beta : Empty
/// - logging:v2 : CancelOperationRequest
/// - logging:v2 : Empty
/// - logging:v2 : UndeleteBucketRequest
/// - logging:v2 : WriteLogEntriesResponse
/// - looker:v1 : CancelOperationRequest
/// - looker:v1 : Empty
/// - looker:v1 : RestartInstanceRequest
/// - managedidentities:v1 : CancelOperationRequest
/// - managedidentities:v1 : CheckMigrationPermissionRequest
/// - managedidentities:v1 : DisableMigrationRequest
/// - managedidentities:v1 : Empty
/// - managedidentities:v1 : ResetAdminPasswordRequest
/// - managedidentities:v1alpha1 : CancelOperationRequest
/// - managedidentities:v1alpha1 : CheckMigrationPermissionRequest
/// - managedidentities:v1alpha1 : DisableMigrationRequest
/// - managedidentities:v1alpha1 : Empty
/// - managedidentities:v1alpha1 : ResetAdminPasswordRequest
/// - managedidentities:v1beta1 : CancelOperationRequest
/// - managedidentities:v1beta1 : CheckMigrationPermissionRequest
/// - managedidentities:v1beta1 : DisableMigrationRequest
/// - managedidentities:v1beta1 : Empty
/// - managedidentities:v1beta1 : ResetAdminPasswordRequest
/// - managedkafka:v1 : CancelOperationRequest
/// - managedkafka:v1 : Empty
/// - managedkafka:v1 : PauseConnectorRequest
/// - managedkafka:v1 : PauseConnectorResponse
/// - managedkafka:v1 : RestartConnectorRequest
/// - managedkafka:v1 : RestartConnectorResponse
/// - managedkafka:v1 : ResumeConnectorRequest
/// - managedkafka:v1 : ResumeConnectorResponse
/// - managedkafka:v1 : StopConnectorRequest
/// - managedkafka:v1 : StopConnectorResponse
/// - manufacturers:v1 : Empty
/// - marketingplatformadmin:v1alpha : Empty
/// - marketingplatformadmin:v1alpha : SetPropertyServiceLevelResponse
/// - meet:v2 : Empty
/// - meet:v2 : EndActiveConferenceRequest
/// - memcache:v1 : CancelOperationRequest
/// - memcache:v1 : Empty
/// - memcache:v1beta2 : CancelOperationRequest
/// - memcache:v1beta2 : Empty
/// - merchantapi:accounts_v1beta : AccountAggregation
/// - merchantapi:accounts_v1beta : AccountManagement
/// - merchantapi:accounts_v1beta : ApproveAccountServiceRequest
/// - merchantapi:accounts_v1beta : CampaignsManagement
/// - merchantapi:accounts_v1beta : DisableProgramRequest
/// - merchantapi:accounts_v1beta : Empty
/// - merchantapi:accounts_v1beta : EnableProgramRequest
/// - merchantapi:accounts_v1beta : LocalListingManagement
/// - merchantapi:accounts_v1beta : ProductsManagement
/// - merchantapi:accounts_v1beta : RejectAccountServiceRequest
/// - merchantapi:accounts_v1beta : RequestInventoryVerificationRequest
/// - merchantapi:accounts_v1beta : UnclaimHomepageRequest
/// - merchantapi:accounts_v1beta : UnregisterGcpRequest
/// - merchantapi:conversions_v1beta : Empty
/// - merchantapi:conversions_v1beta : UndeleteConversionSourceRequest
/// - merchantapi:datasources_v1beta : Empty
/// - merchantapi:datasources_v1beta : FetchDataSourceRequest
/// - merchantapi:datasources_v1beta : MerchantReviewDataSource
/// - merchantapi:datasources_v1beta : ProductReviewDataSource
/// - merchantapi:inventories_v1beta : Empty
/// - merchantapi:issueresolution_v1beta : CheckboxInput
/// - merchantapi:lfp_v1beta : Empty
/// - merchantapi:notifications_v1beta : Empty
/// - merchantapi:products_v1beta : Empty
/// - merchantapi:reviews_v1beta : Empty
/// - metastore:v1 : CancelMigrationRequest
/// - metastore:v1 : CancelOperationRequest
/// - metastore:v1 : CompleteMigrationRequest
/// - metastore:v1 : Empty
/// - metastore:v1alpha : CancelMigrationRequest
/// - metastore:v1alpha : CancelOperationRequest
/// - metastore:v1alpha : CompleteMigrationRequest
/// - metastore:v1alpha : Empty
/// - metastore:v1beta : CancelMigrationRequest
/// - metastore:v1beta : CancelOperationRequest
/// - metastore:v1beta : CompleteMigrationRequest
/// - metastore:v1beta : Empty
/// - migrationcenter:v1 : AggregationCount
/// - migrationcenter:v1 : AggregationFrequency
/// - migrationcenter:v1 : AggregationSum
/// - migrationcenter:v1 : AwsRds
/// - migrationcenter:v1 : CancelOperationRequest
/// - migrationcenter:v1 : CascadeLogicalDBsRule
/// - migrationcenter:v1 : Empty
/// - migrationcenter:v1 : ReportAssetFramesResponse
/// - migrationcenter:v1alpha1 : AggregationCount
/// - migrationcenter:v1alpha1 : AggregationFrequency
/// - migrationcenter:v1alpha1 : AggregationSum
/// - migrationcenter:v1alpha1 : AssetsExportJobInventory
/// - migrationcenter:v1alpha1 : AwsRds
/// - migrationcenter:v1alpha1 : CancelOperationRequest
/// - migrationcenter:v1alpha1 : CascadeLogicalDBsRule
/// - migrationcenter:v1alpha1 : ComputeEngineSoleTenantMigrationTarget
/// - migrationcenter:v1alpha1 : Empty
/// - migrationcenter:v1alpha1 : GoogleKubernetesEngineMigrationTarget
/// - migrationcenter:v1alpha1 : ReportAssetFramesResponse
/// - migrationcenter:v1alpha1 : VmwareEngineMigrationTarget
/// - ml:v1 : GoogleCloudMlV1__CancelJobRequest
/// - ml:v1 : GoogleCloudMlV1__CheckTrialEarlyStoppingStateRequest
/// - ml:v1 : GoogleCloudMlV1__ListOptimalTrialsRequest
/// - ml:v1 : GoogleCloudMlV1__SetDefaultVersionRequest
/// - ml:v1 : GoogleCloudMlV1__StopTrialRequest
/// - ml:v1 : GoogleProtobuf__Empty
/// - monitoring:v1 : Empty
/// - monitoring:v3 : AvailabilityCriteria
/// - monitoring:v3 : Custom
/// - monitoring:v3 : Empty
/// - monitoring:v3 : SendNotificationChannelVerificationCodeRequest
/// - mybusinessaccountmanagement:v1 : AcceptInvitationRequest
/// - mybusinessaccountmanagement:v1 : DeclineInvitationRequest
/// - mybusinessaccountmanagement:v1 : Empty
/// - mybusinessbusinessinformation:v1 : Empty
/// - mybusinessplaceactions:v1 : Empty
/// - mybusinessqanda:v1 : Empty
/// - mybusinessverifications:v1 : ResolveOwnershipConflict
/// - mybusinessverifications:v1 : WaitForVoiceOfMerchant
/// - netapp:v1 : CancelOperationRequest
/// - netapp:v1 : EncryptVolumesRequest
/// - netapp:v1 : GoogleProtobufEmpty
/// - netapp:v1 : ResumeReplicationRequest
/// - netapp:v1 : ReverseReplicationDirectionRequest
/// - netapp:v1 : SwitchActiveReplicaZoneRequest
/// - netapp:v1 : SyncReplicationRequest
/// - netapp:v1 : VerifyKmsConfigRequest
/// - netapp:v1beta1 : CancelOperationRequest
/// - netapp:v1beta1 : EncryptVolumesRequest
/// - netapp:v1beta1 : GoogleProtobufEmpty
/// - netapp:v1beta1 : ResumeReplicationRequest
/// - netapp:v1beta1 : ReverseReplicationDirectionRequest
/// - netapp:v1beta1 : SwitchActiveReplicaZoneRequest
/// - netapp:v1beta1 : SyncReplicationRequest
/// - netapp:v1beta1 : VerifyKmsConfigRequest
/// - networkconnectivity:v1 : Empty
/// - networkconnectivity:v1 : GoogleLongrunningCancelOperationRequest
/// - networkconnectivity:v1alpha1 : Empty
/// - networkconnectivity:v1alpha1 : GoogleLongrunningCancelOperationRequest
/// - networkmanagement:v1 : CancelOperationRequest
/// - networkmanagement:v1 : Empty
/// - networkmanagement:v1 : RerunConnectivityTestRequest
/// - networkmanagement:v1beta1 : CancelOperationRequest
/// - networkmanagement:v1beta1 : Empty
/// - networkmanagement:v1beta1 : RerunConnectivityTestRequest
/// - networksecurity:v1 : AuthzPolicyCustomProviderCloudIap
/// - networksecurity:v1 : CancelOperationRequest
/// - networksecurity:v1 : Empty
/// - networksecurity:v1beta1 : AuthzPolicyCustomProviderCloudIap
/// - networksecurity:v1beta1 : CancelOperationRequest
/// - networksecurity:v1beta1 : Empty
/// - networkservices:v1 : CancelOperationRequest
/// - networkservices:v1 : Empty
/// - networkservices:v1beta1 : CancelOperationRequest
/// - networkservices:v1beta1 : Empty
/// - notebooks:v1 : BootImage
/// - notebooks:v1 : CancelOperationRequest
/// - notebooks:v1 : Empty
/// - notebooks:v1 : ResetInstanceRequest
/// - notebooks:v1 : StartInstanceRequest
/// - notebooks:v1 : StopInstanceRequest
/// - notebooks:v1 : TriggerScheduleRequest
/// - notebooks:v2 : CancelOperationRequest
/// - notebooks:v2 : Empty
/// - notebooks:v2 : ResetInstanceRequest
/// - notebooks:v2 : StartInstanceRequest
/// - notebooks:v2 : StopInstanceRequest
/// - notebooks:v2 : UpgradeInstanceRequest
/// - observability:v1 : CancelOperationRequest
/// - observability:v1 : Empty
/// - ondemandscanning:v1 : Empty
/// - ondemandscanning:v1beta1 : Empty
/// - oracledatabase:v1 : CancelOperationRequest
/// - oracledatabase:v1 : Empty
/// - oracledatabase:v1 : RestartAutonomousDatabaseRequest
/// - oracledatabase:v1 : StartAutonomousDatabaseRequest
/// - oracledatabase:v1 : StopAutonomousDatabaseRequest
/// - orgpolicy:v2 : GoogleProtobufEmpty
/// - osconfig:v1 : CancelOperationRequest
/// - osconfig:v1 : CancelPatchJobRequest
/// - osconfig:v1 : Empty
/// - osconfig:v1 : GooSettings
/// - osconfig:v1 : PausePatchDeploymentRequest
/// - osconfig:v1 : ResumePatchDeploymentRequest
/// - osconfig:v1alpha : CancelOperationRequest
/// - osconfig:v1alpha : Empty
/// - osconfig:v1beta : CancelPatchJobRequest
/// - osconfig:v1beta : Empty
/// - osconfig:v1beta : GooSettings
/// - osconfig:v1beta : PausePatchDeploymentRequest
/// - osconfig:v1beta : ResumePatchDeploymentRequest
/// - osconfig:v2 : CancelOperationRequest
/// - osconfig:v2 : Empty
/// - osconfig:v2beta : CancelOperationRequest
/// - osconfig:v2beta : Empty
/// - oslogin:v1 : Empty
/// - oslogin:v1alpha : Empty
/// - oslogin:v1beta : Empty
/// - parallelstore:v1 : CancelOperationRequest
/// - parallelstore:v1 : GoogleProtobufEmpty
/// - parallelstore:v1beta : GoogleProtobufEmpty
/// - parametermanager:v1 : Empty
/// - paymentsresellersubscription:v1 : GoogleCloudPaymentsResellerSubscriptionV1ResumeSubscriptionRequest
/// - paymentsresellersubscription:v1 : GoogleCloudPaymentsResellerSubscriptionV1SuspendSubscriptionRequest
/// - paymentsresellersubscription:v1 : GoogleCloudPaymentsResellerSubscriptionV1UndoCancelSubscriptionRequest
/// - people:v1 : Empty
/// - playgrouping:v1alpha1 : VerifyTokenResponse
/// - playintegrity:v1 : WriteDeviceRecallResponse
/// - privateca:v1 : CancelOperationRequest
/// - privateca:v1 : Empty
/// - privateca:v1beta1 : CancelOperationRequest
/// - privateca:v1beta1 : Empty
/// - prod_tt_sasportal:v1alpha1 : SasPortalEmpty
/// - prod_tt_sasportal:v1alpha1 : SasPortalGenerateSecretRequest
/// - prod_tt_sasportal:v1alpha1 : SasPortalValidateInstallerResponse
/// - pubsub:v1 : AvroFormat
/// - pubsub:v1 : DetachSubscriptionResponse
/// - pubsub:v1 : Empty
/// - pubsub:v1 : PubSubAvroFormat
/// - pubsub:v1 : PubsubWrapper
/// - pubsub:v1 : SeekResponse
/// - pubsub:v1 : TextConfig
/// - pubsub:v1 : ValidateMessageResponse
/// - pubsub:v1 : ValidateSchemaResponse
/// - pubsub:v1beta1a : Empty
/// - pubsub:v1beta2 : Empty
/// - pubsublite:v1 : CancelOperationRequest
/// - pubsublite:v1 : CommitCursorResponse
/// - pubsublite:v1 : Empty
/// - rapidmigrationassessment:v1 : CancelOperationRequest
/// - rapidmigrationassessment:v1 : Empty
/// - readerrevenuesubscriptionlinking:v1 : DeleteReaderResponse
/// - realtimebidding:v1 : ActivatePretargetingConfigRequest
/// - realtimebidding:v1 : CloseUserListRequest
/// - realtimebidding:v1 : Empty
/// - realtimebidding:v1 : OpenUserListRequest
/// - realtimebidding:v1 : SuspendPretargetingConfigRequest
/// - realtimebidding:v1 : WatchCreativesRequest
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1AddIpOverrideResponse
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1AnnotateAssessmentResponse
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1ExpressKeySettings
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1FirewallActionAllowAction
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1FirewallActionBlockAction
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1FirewallActionIncludeRecaptchaScriptAction
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1FirewallActionRedirectAction
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1RemoveIpOverrideResponse
/// - recaptchaenterprise:v1 : GoogleCloudRecaptchaenterpriseV1ReorderFirewallPoliciesResponse
/// - recaptchaenterprise:v1 : GoogleProtobufEmpty
/// - recommendationengine:v1beta1 : GoogleProtobufEmpty
/// - redis:v1 : Empty
/// - redis:v1beta1 : Empty
/// - retail:v2 : GoogleCloudRetailV2PauseModelRequest
/// - retail:v2 : GoogleCloudRetailV2ResumeModelRequest
/// - retail:v2 : GoogleCloudRetailV2TuneModelRequest
/// - retail:v2 : GoogleProtobufEmpty
/// - retail:v2alpha : GoogleCloudRetailV2alphaAcceptTermsRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaPauseModelRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaResumeModelRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaTuneModelRequest
/// - retail:v2alpha : GoogleProtobufEmpty
/// - retail:v2beta : GoogleCloudRetailV2betaPauseModelRequest
/// - retail:v2beta : GoogleCloudRetailV2betaResumeModelRequest
/// - retail:v2beta : GoogleCloudRetailV2betaTuneModelRequest
/// - retail:v2beta : GoogleProtobufEmpty
/// - run:v1 : CancelExecutionRequest
/// - run:v1 : Empty
/// - run:v2 : GoogleCloudRunV2DockerBuild
/// - run:v2 : GoogleProtobufEmpty
/// - runtimeconfig:v1 : CancelOperationRequest
/// - runtimeconfig:v1 : Empty
/// - runtimeconfig:v1beta1 : Empty
/// - saasservicemgmt:v1beta1 : Deprovision
/// - saasservicemgmt:v1beta1 : Empty
/// - safebrowsing:v4 : GoogleProtobufEmpty
/// - sasportal:v1alpha1 : SasPortalEmpty
/// - sasportal:v1alpha1 : SasPortalGenerateSecretRequest
/// - sasportal:v1alpha1 : SasPortalValidateInstallerResponse
/// - script:v1 : Empty
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__EnhancedCpc
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__FrequencyCapEntry
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__ManualCpa
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__ManualCpm
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__SearchAds360ProductAdInfo
/// - searchads360:v0 : GoogleAdsSearchads360V0Common__TargetCpm
/// - secretmanager:v1 : Empty
/// - secretmanager:v1beta1 : Automatic
/// - secretmanager:v1beta1 : DestroySecretVersionRequest
/// - secretmanager:v1beta1 : DisableSecretVersionRequest
/// - secretmanager:v1beta1 : Empty
/// - secretmanager:v1beta1 : EnableSecretVersionRequest
/// - secretmanager:v1beta2 : Empty
/// - securesourcemanager:v1 : CancelOperationRequest
/// - securesourcemanager:v1 : ClosePullRequestRequest
/// - securesourcemanager:v1 : Empty
/// - securesourcemanager:v1 : MergePullRequestRequest
/// - securesourcemanager:v1 : OpenPullRequestRequest
/// - securitycenter:v1 : Empty
/// - securitycenter:v1 : RunAssetDiscoveryRequest
/// - securitycenter:v1beta1 : CancelOperationRequest
/// - securitycenter:v1beta1 : Empty
/// - securitycenter:v1beta1 : RunAssetDiscoveryRequest
/// - securityposture:v1 : CancelOperationRequest
/// - securityposture:v1 : Empty
/// - serviceconsumermanagement:v1 : CancelOperationRequest
/// - serviceconsumermanagement:v1 : Empty
/// - servicedirectory:v1 : Empty
/// - servicedirectory:v1beta1 : Empty
/// - servicemanagement:v1 : DeleteServiceStrategy
/// - servicenetworking:v1 : CancelOperationRequest
/// - servicenetworking:v1 : Empty
/// - serviceusage:v1 : CancelOperationRequest
/// - serviceusage:v1 : Empty
/// - serviceusage:v1 : EnableServiceRequest
/// - serviceusage:v1beta1 : DisableServiceRequest
/// - serviceusage:v1beta1 : EnableServiceRequest
/// - sheets:v4 : ClearValuesRequest
/// - spanner:v1 : AddSplitPointsResponse
/// - spanner:v1 : DualRegionQuorum
/// - spanner:v1 : Empty
/// - spanner:v1 : FullBackupSpec
/// - spanner:v1 : IncrementalBackupSpec
/// - spanner:v1 : PartitionedDml
/// - speech:v1 : Empty
/// - speech:v1p1beta1 : Empty
/// - sqladmin:v1 : Empty
/// - sqladmin:v1 : SqlInstancesResetReplicaSizeRequest
/// - sqladmin:v1beta4 : Empty
/// - sqladmin:v1beta4 : SqlInstancesResetReplicaSizeRequest
/// - storagebatchoperations:v1 : CancelJobResponse
/// - storagebatchoperations:v1 : CancelOperationRequest
/// - storagebatchoperations:v1 : Empty
/// - storagetransfer:v1 : CancelOperationRequest
/// - storagetransfer:v1 : Empty
/// - storagetransfer:v1 : PauseTransferOperationRequest
/// - storagetransfer:v1 : ResumeTransferOperationRequest
/// - streetviewpublish:v1 : Empty
/// - testing:v1 : CancelDeviceSessionRequest
/// - testing:v1 : Empty
/// - testing:v1 : GoogleAuto
/// - testing:v1 : LauncherActivityIntent
/// - testing:v1 : NoActivityIntent
/// - texttospeech:v1 : CancelOperationRequest
/// - texttospeech:v1 : Empty
/// - toolresults:v1beta3 : AndroidTestLoop
/// - toolresults:v1beta3 : IosRoboTest
/// - toolresults:v1beta3 : MatrixDimensionDefinition
/// - toolresults:v1beta3 : StepSummary
/// - tpu:v1 : Empty
/// - tpu:v1 : StartNodeRequest
/// - tpu:v1 : StopNodeRequest
/// - tpu:v1alpha1 : Empty
/// - tpu:v1alpha1 : StartNodeRequest
/// - tpu:v1alpha1 : StopNodeRequest
/// - tpu:v2 : AcceptedData
/// - tpu:v2 : ActiveData
/// - tpu:v2 : CreatingData
/// - tpu:v2 : DeletingData
/// - tpu:v2 : Empty
/// - tpu:v2 : GenerateServiceIdentityRequest
/// - tpu:v2 : ProvisioningData
/// - tpu:v2 : ResetQueuedResourceRequest
/// - tpu:v2 : Spot
/// - tpu:v2 : StartNodeRequest
/// - tpu:v2 : StopNodeRequest
/// - tpu:v2 : SuspendedData
/// - tpu:v2 : SuspendingData
/// - tpu:v2alpha1 : AcceptedData
/// - tpu:v2alpha1 : ActiveData
/// - tpu:v2alpha1 : BestEffort
/// - tpu:v2alpha1 : CreatingData
/// - tpu:v2alpha1 : DeletingData
/// - tpu:v2alpha1 : Empty
/// - tpu:v2alpha1 : GenerateServiceIdentityRequest
/// - tpu:v2alpha1 : PerformMaintenanceRequest
/// - tpu:v2alpha1 : ProvisioningData
/// - tpu:v2alpha1 : ResetQueuedResourceRequest
/// - tpu:v2alpha1 : Spot
/// - tpu:v2alpha1 : StartNodeRequest
/// - tpu:v2alpha1 : StopNodeRequest
/// - tpu:v2alpha1 : SuspendedData
/// - tpu:v2alpha1 : SuspendingData
/// - trafficdirector:v2 : NullMatch
/// - trafficdirector:v3 : NullMatch
/// - transcoder:v1 : Aes128Encryption
/// - transcoder:v1 : Clearkey
/// - transcoder:v1 : Empty
/// - transcoder:v1 : Fairplay
/// - transcoder:v1 : H264ColorFormatHLG
/// - transcoder:v1 : H264ColorFormatSDR
/// - transcoder:v1 : H265ColorFormatHDR10
/// - transcoder:v1 : H265ColorFormatHLG
/// - transcoder:v1 : H265ColorFormatSDR
/// - transcoder:v1 : Playready
/// - transcoder:v1 : SampleAesEncryption
/// - transcoder:v1 : Vp9ColorFormatHLG
/// - transcoder:v1 : Vp9ColorFormatSDR
/// - transcoder:v1 : Widevine
/// - translate:v3 : CancelOperationRequest
/// - translate:v3 : Empty
/// - translate:v3beta1 : CancelOperationRequest
/// - translate:v3beta1 : Empty
/// - vault:v1 : CancelOperationRequest
/// - vault:v1 : CloseMatterRequest
/// - vault:v1 : Empty
/// - vault:v1 : GeminiOptions
/// - vault:v1 : HeldCalendarQuery
/// - vault:v1 : ReopenMatterRequest
/// - vault:v1 : UndeleteMatterRequest
/// - verifiedaccess:v1 : Empty
/// - verifiedaccess:v2 : Empty
/// - videointelligence:v1 : GoogleLongrunning_CancelOperationRequest
/// - videointelligence:v1 : GoogleProtobuf_Empty
/// - vision:v1 : CancelOperationRequest
/// - vision:v1 : Empty
/// - vmmigration:v1 : AdaptingOSStep
/// - vmmigration:v1 : CancelCloneJobRequest
/// - vmmigration:v1 : CancelCutoverJobRequest
/// - vmmigration:v1 : CancelImageImportJobRequest
/// - vmmigration:v1 : CancelOperationRequest
/// - vmmigration:v1 : CreatingImageStep
/// - vmmigration:v1 : DataDiskImageImport
/// - vmmigration:v1 : DisksMigrationDisksTargetDefaults
/// - vmmigration:v1 : DisksMigrationDisksTargetDetails
/// - vmmigration:v1 : Empty
/// - vmmigration:v1 : ExtendMigrationRequest
/// - vmmigration:v1 : FinalizeMigrationRequest
/// - vmmigration:v1 : InitializingImageImportStep
/// - vmmigration:v1 : InitializingReplicationStep
/// - vmmigration:v1 : InstantiatingMigratedVMStep
/// - vmmigration:v1 : LoadingImageSourceFilesStep
/// - vmmigration:v1 : PauseMigrationRequest
/// - vmmigration:v1 : PostProcessingStep
/// - vmmigration:v1 : PreparingVMDisksStep
/// - vmmigration:v1 : ResumeMigrationRequest
/// - vmmigration:v1 : ShuttingDownSourceVMStep
/// - vmmigration:v1 : SkipOsAdaptation
/// - vmmigration:v1 : StartMigrationRequest
/// - vmmigration:v1alpha1 : AdaptingOSStep
/// - vmmigration:v1alpha1 : CancelCloneJobRequest
/// - vmmigration:v1alpha1 : CancelCutoverJobRequest
/// - vmmigration:v1alpha1 : CancelImageImportJobRequest
/// - vmmigration:v1alpha1 : CancelOperationRequest
/// - vmmigration:v1alpha1 : CreatingImageStep
/// - vmmigration:v1alpha1 : DataDiskImageImport
/// - vmmigration:v1alpha1 : DisksMigrationDisksTargetDefaults
/// - vmmigration:v1alpha1 : DisksMigrationDisksTargetDetails
/// - vmmigration:v1alpha1 : Empty
/// - vmmigration:v1alpha1 : ExtendMigrationRequest
/// - vmmigration:v1alpha1 : FinalizeMigrationRequest
/// - vmmigration:v1alpha1 : InitializingImageImportStep
/// - vmmigration:v1alpha1 : InitializingReplicationStep
/// - vmmigration:v1alpha1 : InstantiatingMigratedVMStep
/// - vmmigration:v1alpha1 : LoadingImageSourceFilesStep
/// - vmmigration:v1alpha1 : PauseMigrationRequest
/// - vmmigration:v1alpha1 : PostProcessingStep
/// - vmmigration:v1alpha1 : PreparingVMDisksStep
/// - vmmigration:v1alpha1 : ResumeMigrationRequest
/// - vmmigration:v1alpha1 : ShuttingDownSourceVMStep
/// - vmmigration:v1alpha1 : SkipOsAdaptation
/// - vmmigration:v1alpha1 : StartMigrationRequest
/// - vmwareengine:v1 : Empty
/// - walletobjects:v1 : SetPassUpdateNoticeResponse
/// - walletobjects:v1 : TransitObjectUploadRotatingBarcodeValuesResponse
/// - webrisk:v1 : GoogleLongrunningCancelOperationRequest
/// - webrisk:v1 : GoogleProtobufEmpty
/// - websecurityscanner:v1 : Empty
/// - websecurityscanner:v1 : StartScanRunRequest
/// - websecurityscanner:v1 : StopScanRunRequest
/// - websecurityscanner:v1alpha : Empty
/// - websecurityscanner:v1alpha : StartScanRunRequest
/// - websecurityscanner:v1alpha : StopScanRunRequest
/// - websecurityscanner:v1beta : Empty
/// - websecurityscanner:v1beta : StartScanRunRequest
/// - websecurityscanner:v1beta : StopScanRunRequest
/// - workflowexecutions:v1 : CancelExecutionRequest
/// - workflowexecutions:v1 : DeleteExecutionHistoryRequest
/// - workflowexecutions:v1 : Empty
/// - workflowexecutions:v1beta : CancelExecutionRequest
/// - workflows:v1 : Empty
/// - workflows:v1beta : Empty
/// - workloadmanager:v1 : CancelOperationRequest
/// - workloadmanager:v1 : Empty
/// - workloadmanager:v1 : WriteInsightResponse
/// - workspaceevents:v1 : ReactivateSubscriptionRequest
/// - workstations:v1 : CancelOperationRequest
/// - workstations:v1 : GoogleProtobufEmpty
/// - workstations:v1beta : CancelOperationRequest
/// - workstations:v1beta : GoogleProtobufEmpty
/// - youtube:v3 : TestItemTestItemSnippet
/// - youtube:v3 : TokenPagination
/// - youtube:v3 : VideoProjectDetails
/// - youtubereporting:v1 : Empty
class $Empty {
  $Empty();

  $Empty.fromJson(
    // ignore: avoid_unused_constructor_parameters
    core.Map json_,
  );

  core.Map<core.String, core.dynamic> toJson() => {};
}

/// Used by:
///
/// - vmmigration:v1 : Encryption
/// - vmmigration:v1alpha1 : Encryption
class $Encryption {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  ///
  /// Required.
  core.String? kmsKey;

  $Encryption({this.kmsKey});

  $Encryption.fromJson(core.Map json_)
    : this(kmsKey: json_['kmsKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
  };
}

/// Used by:
///
/// - alloydb:v1 : EncryptionConfig
/// - alloydb:v1alpha : EncryptionConfig
/// - alloydb:v1beta : EncryptionConfig
/// - datamigration:v1 : EncryptionConfig
class $EncryptionConfig00 {
  /// The fully-qualified resource name of the KMS key.
  ///
  /// Each Cloud KMS key is regionalized and has the following format:
  /// projects/\[PROJECT\]/locations/\[REGION\]/keyRings/\[RING\]/cryptoKeys/\[KEY_NAME\]
  core.String? kmsKeyName;

  $EncryptionConfig00({this.kmsKeyName});

  $EncryptionConfig00.fromJson(core.Map json_)
    : this(kmsKeyName: json_['kmsKeyName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - composer:v1 : EncryptionConfig
/// - composer:v1beta1 : EncryptionConfig
class $EncryptionConfig01 {
  /// Customer-managed Encryption Key available through Google's Key Management
  /// Service.
  ///
  /// Cannot be updated. If not specified, Google-managed key will be used.
  ///
  /// Optional.
  core.String? kmsKeyName;

  $EncryptionConfig01({this.kmsKeyName});

  $EncryptionConfig01.fromJson(core.Map json_)
    : this(kmsKeyName: json_['kmsKeyName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : EncryptionConfig
/// - metastore:v1beta : EncryptionConfig
class $EncryptionConfig02 {
  /// The fully qualified customer provided Cloud KMS key name to use for
  /// customer data encryption, in the following
  /// format:projects/{project_number}/locations/{location_id}/keyRings/{key_ring_id}/cryptoKeys/{crypto_key_id}.
  ///
  /// Optional.
  core.String? kmsKey;

  /// The list of fully qualified customer provided Cloud KMS key names for the
  /// multi-regional service.
  ///
  /// Each key must be in the following
  /// format:projects/{project_number}/locations/{location_id}/keyRings/{key_ring_id}/cryptoKeys/{crypto_key_id}.
  ///
  /// Optional.
  core.List<core.String>? kmsKeys;

  $EncryptionConfig02({this.kmsKey, this.kmsKeys});

  $EncryptionConfig02.fromJson(core.Map json_)
    : this(
        kmsKey: json_['kmsKey'] as core.String?,
        kmsKeys:
            (json_['kmsKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (kmsKeys != null) 'kmsKeys': kmsKeys!,
  };
}

/// Used by:
///
/// - alloydb:v1 : EncryptionInfo
/// - alloydb:v1alpha : EncryptionInfo
/// - alloydb:v1beta : EncryptionInfo
class $EncryptionInfo00 {
  /// Type of encryption.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Encryption type not specified. Defaults to
  /// GOOGLE_DEFAULT_ENCRYPTION.
  /// - "GOOGLE_DEFAULT_ENCRYPTION" : The data is encrypted at rest with a key
  /// that is fully managed by Google. No key version will be populated. This is
  /// the default state.
  /// - "CUSTOMER_MANAGED_ENCRYPTION" : The data is encrypted at rest with a key
  /// that is managed by the customer. KMS key versions will be populated.
  core.String? encryptionType;

  /// Cloud KMS key versions that are being used to protect the database or the
  /// backup.
  ///
  /// Output only.
  core.List<core.String>? kmsKeyVersions;

  $EncryptionInfo00({this.encryptionType, this.kmsKeyVersions});

  $EncryptionInfo00.fromJson(core.Map json_)
    : this(
        encryptionType: json_['encryptionType'] as core.String?,
        kmsKeyVersions:
            (json_['kmsKeyVersions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encryptionType != null) 'encryptionType': encryptionType!,
    if (kmsKeyVersions != null) 'kmsKeyVersions': kmsKeyVersions!,
  };
}

/// Used by:
///
/// - redis:v1 : EncryptionInfo
/// - redis:v1beta1 : EncryptionInfo
class $EncryptionInfo01 {
  /// Type of encryption.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Encryption type not specified. Defaults to
  /// GOOGLE_DEFAULT_ENCRYPTION.
  /// - "GOOGLE_DEFAULT_ENCRYPTION" : The data is encrypted at rest with a key
  /// that is fully managed by Google. No key version will be populated. This is
  /// the default state.
  /// - "CUSTOMER_MANAGED_ENCRYPTION" : The data is encrypted at rest with a key
  /// that is managed by the customer. KMS key versions will be populated.
  core.String? encryptionType;

  /// The state of the primary version of the KMS key perceived by the system.
  ///
  /// This field is not populated in backups.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "KMS_KEY_STATE_UNSPECIFIED" : The default value. This value is unused.
  /// - "ENABLED" : The KMS key is enabled and correctly configured.
  /// - "PERMISSION_DENIED" : Permission denied on the KMS key.
  /// - "DISABLED" : The KMS key is disabled.
  /// - "DESTROYED" : The KMS key is destroyed.
  /// - "DESTROY_SCHEDULED" : The KMS key is scheduled to be destroyed.
  /// - "EKM_KEY_UNREACHABLE_DETECTED" : The EKM key is unreachable.
  /// - "BILLING_DISABLED" : Billing is disabled for the project.
  /// - "UNKNOWN_FAILURE" : All other unknown failures.
  core.String? kmsKeyPrimaryState;

  /// KMS key versions that are being used to protect the data at-rest.
  ///
  /// Output only.
  core.List<core.String>? kmsKeyVersions;

  /// The most recent time when the encryption info was updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  $EncryptionInfo01({
    this.encryptionType,
    this.kmsKeyPrimaryState,
    this.kmsKeyVersions,
    this.lastUpdateTime,
  });

  $EncryptionInfo01.fromJson(core.Map json_)
    : this(
        encryptionType: json_['encryptionType'] as core.String?,
        kmsKeyPrimaryState: json_['kmsKeyPrimaryState'] as core.String?,
        kmsKeyVersions:
            (json_['kmsKeyVersions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        lastUpdateTime: json_['lastUpdateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encryptionType != null) 'encryptionType': encryptionType!,
    if (kmsKeyPrimaryState != null) 'kmsKeyPrimaryState': kmsKeyPrimaryState!,
    if (kmsKeyVersions != null) 'kmsKeyVersions': kmsKeyVersions!,
    if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
  };
}

/// Used by:
///
/// - connectors:v1 : EncryptionKey
/// - integrations:v1 : GoogleCloudConnectorsV1EncryptionKey
class $EncryptionKey {
  /// The \[KMS key name\] with which the content of the Operation is encrypted.
  ///
  /// The expected format: `projects / * /locations / * /keyRings / *
  /// /cryptoKeys / * `. Will be empty string if google managed.
  ///
  /// Optional.
  core.String? kmsKeyName;

  /// Type.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Value type is not specified.
  /// - "GOOGLE_MANAGED" : Google Managed.
  /// - "CUSTOMER_MANAGED" : Customer Managed.
  core.String? type;

  $EncryptionKey({this.kmsKeyName, this.type});

  $EncryptionKey.fromJson(core.Map json_)
    : this(
        kmsKeyName: json_['kmsKeyName'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1EncryptionSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1EncryptionSpec
class $EncryptionSpec00 {
  /// The Cloud KMS resource identifier of the customer managed encryption key
  /// used to protect a resource.
  ///
  /// Has the form:
  /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
  /// The key needs to be in the same region as where the compute resource is
  /// created.
  ///
  /// Required.
  core.String? kmsKeyName;

  $EncryptionSpec00({this.kmsKeyName});

  $EncryptionSpec00.fromJson(core.Map json_)
    : this(kmsKeyName: json_['kmsKeyName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2EncryptionSpec
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1EncryptionSpec
class $EncryptionSpec01 {
  /// The name of customer-managed encryption key that is used to secure a
  /// resource and its sub-resources.
  ///
  /// If empty, the resource is secured by the default Google encryption key.
  /// Only the key in the same location as this resource is allowed to be used
  /// for encryption. Format:
  /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}`
  ///
  /// Required.
  core.String? kmsKey;

  /// The resource name of the encryption key specification resource.
  ///
  /// Format: projects/{project}/locations/{location}/encryptionSpec
  ///
  /// Immutable.
  core.String? name;

  $EncryptionSpec01({this.kmsKey, this.name});

  $EncryptionSpec01.fromJson(core.Map json_)
    : this(
        kmsKey: json_['kmsKey'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : Endpoint
/// - serviceusage:v1 : Endpoint
/// - serviceusage:v1beta1 : Endpoint
class $Endpoint {
  /// Aliases for this endpoint, these will be served by the same UrlMap as the
  /// parent endpoint, and will be provisioned in the GCP stack for the Regional
  /// Endpoints.
  core.List<core.String>? aliases;

  /// Allowing
  /// [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing), aka
  /// cross-domain traffic, would allow the backends served from this endpoint
  /// to receive and respond to HTTP OPTIONS requests.
  ///
  /// The response will be used by the browser to determine whether the
  /// subsequent cross-origin request is allowed to proceed.
  core.bool? allowCors;

  /// The canonical name of this endpoint.
  core.String? name;

  /// The specification of an Internet routable address of API frontend that
  /// will handle requests to this
  /// [API Endpoint](https://cloud.google.com/apis/design/glossary).
  ///
  /// It should be either a valid IPv4 address or a fully-qualified domain name.
  /// For example, "8.8.8.8" or "myservice.appspot.com".
  core.String? target;

  $Endpoint({this.aliases, this.allowCors, this.name, this.target});

  $Endpoint.fromJson(core.Map json_)
    : this(
        aliases:
            (json_['aliases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowCors: json_['allowCors'] as core.bool?,
        name: json_['name'] as core.String?,
        target: json_['target'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aliases != null) 'aliases': aliases!,
    if (allowCors != null) 'allowCors': allowCors!,
    if (name != null) 'name': name!,
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptEndpointGroupAssociationLocationDetails
/// - networksecurity:v1 : MirroringEndpointGroupAssociationLocationDetails
/// - networksecurity:v1beta1 : InterceptEndpointGroupAssociationLocationDetails
/// - networksecurity:v1beta1 : MirroringEndpointGroupAssociationLocationDetails
class $EndpointGroupAssociationLocationDetails {
  /// The cloud location, e.g. "us-central1-a" or "asia-south1".
  ///
  /// Output only.
  core.String? location;

  /// The current state of the association in this location.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "ACTIVE" : The association is ready and in sync with the linked endpoint
  /// group.
  /// - "OUT_OF_SYNC" : The association is out of sync with the linked endpoint
  /// group. In most cases, this is a result of a transient issue within the
  /// system (e.g. an inaccessible location) and the system is expected to
  /// recover automatically.
  core.String? state;

  $EndpointGroupAssociationLocationDetails({this.location, this.state});

  $EndpointGroupAssociationLocationDetails.fromJson(core.Map json_)
    : this(
        location: json_['location'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (location != null) 'location': location!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : EndpointInfo
/// - networkmanagement:v1beta1 : EndpointInfo
class $EndpointInfo {
  /// Destination IP address.
  core.String? destinationIp;

  /// URI of the network where this packet is sent to.
  core.String? destinationNetworkUri;

  /// Destination port.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? destinationPort;

  /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
  core.String? protocol;

  /// URI of the source telemetry agent this packet originates from.
  core.String? sourceAgentUri;

  /// Source IP address.
  core.String? sourceIp;

  /// URI of the network where this packet originates from.
  core.String? sourceNetworkUri;

  /// Source port.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? sourcePort;

  $EndpointInfo({
    this.destinationIp,
    this.destinationNetworkUri,
    this.destinationPort,
    this.protocol,
    this.sourceAgentUri,
    this.sourceIp,
    this.sourceNetworkUri,
    this.sourcePort,
  });

  $EndpointInfo.fromJson(core.Map json_)
    : this(
        destinationIp: json_['destinationIp'] as core.String?,
        destinationNetworkUri: json_['destinationNetworkUri'] as core.String?,
        destinationPort: json_['destinationPort'] as core.int?,
        protocol: json_['protocol'] as core.String?,
        sourceAgentUri: json_['sourceAgentUri'] as core.String?,
        sourceIp: json_['sourceIp'] as core.String?,
        sourceNetworkUri: json_['sourceNetworkUri'] as core.String?,
        sourcePort: json_['sourcePort'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationIp != null) 'destinationIp': destinationIp!,
    if (destinationNetworkUri != null)
      'destinationNetworkUri': destinationNetworkUri!,
    if (destinationPort != null) 'destinationPort': destinationPort!,
    if (protocol != null) 'protocol': protocol!,
    if (sourceAgentUri != null) 'sourceAgentUri': sourceAgentUri!,
    if (sourceIp != null) 'sourceIp': sourceIp!,
    if (sourceNetworkUri != null) 'sourceNetworkUri': sourceNetworkUri!,
    if (sourcePort != null) 'sourcePort': sourcePort!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpSecuritygatewaysV1EndpointMatcher
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpSecuritygatewaysV1alphaEndpointMatcher
class $EndpointMatcher {
  /// Hostname of the application.
  ///
  /// Required.
  core.String? hostname;

  /// Ports of the application.
  ///
  /// Optional.
  core.List<core.int>? ports;

  $EndpointMatcher({this.hostname, this.ports});

  $EndpointMatcher.fromJson(core.Map json_)
    : this(
        hostname: json_['hostname'] as core.String?,
        ports:
            (json_['ports'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostname != null) 'hostname': hostname!,
    if (ports != null) 'ports': ports!,
  };
}

/// Used by:
///
/// - appengine:v1 : EndpointsApiService
/// - appengine:v1beta : EndpointsApiService
class $EndpointsApiService {
  /// Endpoints service configuration ID as specified by the Service Management
  /// API.
  ///
  /// For example "2016-09-19r1".By default, the rollout strategy for Endpoints
  /// is RolloutStrategy.FIXED. This means that Endpoints starts up with a
  /// particular configuration ID. When a new configuration is rolled out,
  /// Endpoints must be given the new configuration ID. The config_id field is
  /// used to give the configuration ID and is required in this case.Endpoints
  /// also has a rollout strategy called RolloutStrategy.MANAGED. When using
  /// this, Endpoints fetches the latest configuration and does not need the
  /// configuration ID. In this case, config_id must be omitted.
  core.String? configId;

  /// Enable or disable trace sampling.
  ///
  /// By default, this is set to false for enabled.
  core.bool? disableTraceSampling;

  /// Endpoints service name which is the name of the "service" resource in the
  /// Service Management API.
  ///
  /// For example "myapi.endpoints.myproject.cloud.goog"
  core.String? name;

  /// Endpoints rollout strategy.
  ///
  /// If FIXED, config_id must be specified. If MANAGED, config_id must be
  /// omitted.
  /// Possible string values are:
  /// - "UNSPECIFIED_ROLLOUT_STRATEGY" : Not specified. Defaults to FIXED.
  /// - "FIXED" : Endpoints service configuration ID will be fixed to the
  /// configuration ID specified by config_id.
  /// - "MANAGED" : Endpoints service configuration ID will be updated with each
  /// rollout.
  core.String? rolloutStrategy;

  $EndpointsApiService({
    this.configId,
    this.disableTraceSampling,
    this.name,
    this.rolloutStrategy,
  });

  $EndpointsApiService.fromJson(core.Map json_)
    : this(
        configId: json_['configId'] as core.String?,
        disableTraceSampling: json_['disableTraceSampling'] as core.bool?,
        name: json_['name'] as core.String?,
        rolloutStrategy: json_['rolloutStrategy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configId != null) 'configId': configId!,
    if (disableTraceSampling != null)
      'disableTraceSampling': disableTraceSampling!,
    if (name != null) 'name': name!,
    if (rolloutStrategy != null) 'rolloutStrategy': rolloutStrategy!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineChatEngineConfigAgentCreationConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfigAgentCreationConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineChatEngineConfigAgentCreationConfig
class $EngineChatEngineConfigAgentCreationConfig {
  /// Name of the company, organization or other entity that the agent
  /// represents.
  ///
  /// Used for knowledge connector LLM prompt and for knowledge search.
  core.String? business;

  /// The default language of the agent as a language tag.
  ///
  /// See
  /// [Language Support](https://cloud.google.com/dialogflow/docs/reference/language)
  /// for a list of the currently supported language codes.
  ///
  /// Required.
  core.String? defaultLanguageCode;

  /// Agent location for Agent creation, supported values: global/us/eu.
  ///
  /// If not provided, us Engine will create Agent using us-central-1 by
  /// default; eu Engine will create Agent using eu-west-1 by default.
  core.String? location;

  /// The time zone of the agent from the
  /// [time zone database](https://www.iana.org/time-zones), e.g.,
  /// America/New_York, Europe/Paris.
  ///
  /// Required.
  core.String? timeZone;

  $EngineChatEngineConfigAgentCreationConfig({
    this.business,
    this.defaultLanguageCode,
    this.location,
    this.timeZone,
  });

  $EngineChatEngineConfigAgentCreationConfig.fromJson(core.Map json_)
    : this(
        business: json_['business'] as core.String?,
        defaultLanguageCode: json_['defaultLanguageCode'] as core.String?,
        location: json_['location'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (business != null) 'business': business!,
    if (defaultLanguageCode != null)
      'defaultLanguageCode': defaultLanguageCode!,
    if (location != null) 'location': location!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineChatEngineMetadata
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineChatEngineMetadata
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineChatEngineMetadata
class $EngineChatEngineMetadata {
  /// The resource name of a Dialogflow agent, that this Chat Engine refers to.
  ///
  /// Format: `projects//locations//agents/`.
  core.String? dialogflowAgent;

  $EngineChatEngineMetadata({this.dialogflowAgent});

  $EngineChatEngineMetadata.fromJson(core.Map json_)
    : this(dialogflowAgent: json_['dialogflowAgent'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dialogflowAgent != null) 'dialogflowAgent': dialogflowAgent!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineCommonConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineCommonConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineCommonConfig
class $EngineCommonConfig {
  /// The name of the company, business or entity that is associated with the
  /// engine.
  ///
  /// Setting this may help improve LLM related features.
  core.String? companyName;

  $EngineCommonConfig({this.companyName});

  $EngineCommonConfig.fromJson(core.Map json_)
    : this(companyName: json_['companyName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (companyName != null) 'companyName': companyName!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineMediaRecommendationEngineConfigMostPopularFeatureConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigMostPopularFeatureConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineMediaRecommendationEngineConfigMostPopularFeatureConfig
class $EngineMediaRecommendationEngineConfigMostPopularFeatureConfig {
  /// The time window of which the engine is queried at training and prediction
  /// time.
  ///
  /// Positive integers only. The value translates to the last X days of events.
  /// Currently required for the `most-popular-items` engine.
  core.String? timeWindowDays;

  $EngineMediaRecommendationEngineConfigMostPopularFeatureConfig({
    this.timeWindowDays,
  });

  $EngineMediaRecommendationEngineConfigMostPopularFeatureConfig.fromJson(
    core.Map json_,
  ) : this(timeWindowDays: json_['timeWindowDays'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeWindowDays != null) 'timeWindowDays': timeWindowDays!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineMediaRecommendationEngineConfigOptimizationObjectiveConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig
class $EngineMediaRecommendationEngineConfigOptimizationObjectiveConfig {
  /// The name of the field to target.
  ///
  /// Currently supported values: `watch-percentage`, `watch-time`.
  ///
  /// Required.
  core.String? targetField;

  /// The threshold to be applied to the target (e.g., 0.5).
  ///
  /// Required.
  core.double? targetFieldValueFloat;

  $EngineMediaRecommendationEngineConfigOptimizationObjectiveConfig({
    this.targetField,
    this.targetFieldValueFloat,
  });

  $EngineMediaRecommendationEngineConfigOptimizationObjectiveConfig.fromJson(
    core.Map json_,
  ) : this(
        targetField: json_['targetField'] as core.String?,
        targetFieldValueFloat:
            (json_['targetFieldValueFloat'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetField != null) 'targetField': targetField!,
    if (targetFieldValueFloat != null)
      'targetFieldValueFloat': targetFieldValueFloat!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig
class $EngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig {
  /// The type of event with which the engine is queried at prediction time.
  ///
  /// If set to `generic`, only `view-item`, `media-play`,and `media-complete`
  /// will be used as `context-event` in engine training. If set to
  /// `view-home-page`, `view-home-page` will also be used as `context-events`
  /// in addition to `view-item`, `media-play`, and `media-complete`. Currently
  /// supported for the `recommended-for-you` engine. Currently supported
  /// values: `view-home-page`, `generic`.
  core.String? contextEventType;

  $EngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig({
    this.contextEventType,
  });

  $EngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig.fromJson(
    core.Map json_,
  ) : this(contextEventType: json_['contextEventType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contextEventType != null) 'contextEventType': contextEventType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1EngineSearchEngineConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEngineSearchEngineConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEngineSearchEngineConfig
class $EngineSearchEngineConfig {
  /// The add-on that this search engine enables.
  core.List<core.String>? searchAddOns;

  /// The search feature tier of this engine.
  ///
  /// Different tiers might have different pricing. To learn more, check the
  /// pricing documentation. Defaults to SearchTier.SEARCH_TIER_STANDARD if not
  /// specified.
  /// Possible string values are:
  /// - "SEARCH_TIER_UNSPECIFIED" : Default value when the enum is unspecified.
  /// This is invalid to use.
  /// - "SEARCH_TIER_STANDARD" : Standard tier.
  /// - "SEARCH_TIER_ENTERPRISE" : Enterprise tier.
  core.String? searchTier;

  $EngineSearchEngineConfig({this.searchAddOns, this.searchTier});

  $EngineSearchEngineConfig.fromJson(core.Map json_)
    : this(
        searchAddOns:
            (json_['searchAddOns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        searchTier: json_['searchTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchAddOns != null) 'searchAddOns': searchAddOns!,
    if (searchTier != null) 'searchTier': searchTier!,
  };
}

/// Used by:
///
/// - connectors:v1 : EnrichmentConfig
/// - integrations:v1 : GoogleCloudConnectorsV1EnrichmentConfig
class $EnrichmentConfig {
  /// Append ACL to the event.
  ///
  /// Optional.
  core.bool? appendAcl;

  $EnrichmentConfig({this.appendAcl});

  $EnrichmentConfig.fromJson(core.Map json_)
    : this(appendAcl: json_['appendAcl'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (appendAcl != null) 'appendAcl': appendAcl!,
  };
}

/// Used by:
///
/// - container:v1 : EnterpriseConfig
/// - container:v1beta1 : EnterpriseConfig
class $EnterpriseConfig {
  /// cluster_tier indicates the effective tier of the cluster.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLUSTER_TIER_UNSPECIFIED" : CLUSTER_TIER_UNSPECIFIED is when
  /// cluster_tier is not set.
  /// - "STANDARD" : STANDARD indicates a standard GKE cluster.
  /// - "ENTERPRISE" : ENTERPRISE indicates a GKE Enterprise cluster.
  core.String? clusterTier;

  /// desired_tier specifies the desired tier of the cluster.
  /// Possible string values are:
  /// - "CLUSTER_TIER_UNSPECIFIED" : CLUSTER_TIER_UNSPECIFIED is when
  /// cluster_tier is not set.
  /// - "STANDARD" : STANDARD indicates a standard GKE cluster.
  /// - "ENTERPRISE" : ENTERPRISE indicates a GKE Enterprise cluster.
  core.String? desiredTier;

  $EnterpriseConfig({this.clusterTier, this.desiredTier});

  $EnterpriseConfig.fromJson(core.Map json_)
    : this(
        clusterTier: json_['clusterTier'] as core.String?,
        desiredTier: json_['desiredTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterTier != null) 'clusterTier': clusterTier!,
    if (desiredTier != null) 'desiredTier': desiredTier!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1EnterpriseWebSearch
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1EnterpriseWebSearch
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1EnterpriseWebSearch
class $EnterpriseWebSearch {
  /// List of domains to be excluded from the search results.
  ///
  /// The default limit is 2000 domains.
  ///
  /// Optional.
  core.List<core.String>? excludeDomains;

  $EnterpriseWebSearch({this.excludeDomains});

  $EnterpriseWebSearch.fromJson(core.Map json_)
    : this(
        excludeDomains:
            (json_['excludeDomains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludeDomains != null) 'excludeDomains': excludeDomains!,
  };
}

/// Used by:
///
/// - datamigration:v1 : DatabaseInstanceEntity
/// - datamigration:v1 : SchemaEntity
class $Entity00 {
  /// Custom engine specific features.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? customFeatures;

  $Entity00({this.customFeatures});

  $Entity00.fromJson(core.Map json_)
    : this(
        customFeatures:
            json_.containsKey('customFeatures')
                ? json_['customFeatures'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customFeatures != null) 'customFeatures': customFeatures!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Entity
/// - healthcare:v1beta1 : Entity
class $Entity01 {
  /// entity_id is a first class field entity_id uniquely identifies this
  /// concept and its meta-vocabulary.
  ///
  /// For example, "UMLS/C0000970".
  core.String? entityId;

  /// preferred_term is the preferred term for this concept.
  ///
  /// For example, "Acetaminophen". For ad hoc entities formed by normalization,
  /// this is the most popular unnormalized string.
  core.String? preferredTerm;

  /// Vocabulary codes are first-class fields and differentiated from the
  /// concept unique identifier (entity_id).
  ///
  /// vocabulary_codes contains the representation of this concept in particular
  /// vocabularies, such as ICD-10, SNOMED-CT and RxNORM. These are prefixed by
  /// the name of the vocabulary, followed by the unique code within that
  /// vocabulary. For example, "RXNORM/A10334543".
  core.List<core.String>? vocabularyCodes;

  $Entity01({this.entityId, this.preferredTerm, this.vocabularyCodes});

  $Entity01.fromJson(core.Map json_)
    : this(
        entityId: json_['entityId'] as core.String?,
        preferredTerm: json_['preferredTerm'] as core.String?,
        vocabularyCodes:
            (json_['vocabularyCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityId != null) 'entityId': entityId!,
    if (preferredTerm != null) 'preferredTerm': preferredTerm!,
    if (vocabularyCodes != null) 'vocabularyCodes': vocabularyCodes!,
  };
}

/// Used by:
///
/// - datastore:v1 : GoogleDatastoreAdminV1EntityFilter
/// - datastore:v1beta1 : GoogleDatastoreAdminV1beta1EntityFilter
class $EntityFilter {
  /// If empty, then this represents all kinds.
  core.List<core.String>? kinds;

  /// An empty list represents all namespaces.
  ///
  /// This is the preferred usage for projects that don't use namespaces. An
  /// empty string element represents the default namespace. This should be used
  /// if the project has data in non-default namespaces, but doesn't want to
  /// include them. Each namespace in this list must be unique.
  core.List<core.String>? namespaceIds;

  $EntityFilter({this.kinds, this.namespaceIds});

  $EntityFilter.fromJson(core.Map json_)
    : this(
        kinds:
            (json_['kinds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        namespaceIds:
            (json_['namespaceIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kinds != null) 'kinds': kinds!,
    if (namespaceIds != null) 'namespaceIds': namespaceIds!,
  };
}

/// Used by:
///
/// - healthcare:v1 : EntityMentionRelationship
/// - healthcare:v1beta1 : EntityMentionRelationship
class $EntityMentionRelationship {
  /// The model's confidence in this annotation.
  ///
  /// A number between 0 and 1.
  core.double? confidence;

  /// object_id is the id of the object entity mention.
  core.String? objectId;

  /// subject_id is the id of the subject entity mention.
  core.String? subjectId;

  $EntityMentionRelationship({this.confidence, this.objectId, this.subjectId});

  $EntityMentionRelationship.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        objectId: json_['objectId'] as core.String?,
        subjectId: json_['subjectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (objectId != null) 'objectId': objectId!,
    if (subjectId != null) 'subjectId': subjectId!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2EntityTypeEntity
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1EntityTypeEntity
class $EntityTypeEntity00 {
  /// A collection of value synonyms.
  ///
  /// For example, if the entity type is *vegetable*, and `value` is
  /// *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity
  /// types: * This collection must contain exactly one synonym equal to
  /// `value`.
  ///
  /// Required.
  core.List<core.String>? synonyms;

  /// The primary value associated with this entity entry.
  ///
  /// For example, if the entity type is *vegetable*, the value could be
  /// *scallions*. For `KIND_MAP` entity types: * A reference value to be used
  /// in place of synonyms. For `KIND_LIST` entity types: * A string that can
  /// contain references to other entity types (with or without aliases).
  ///
  /// Required.
  core.String? value;

  $EntityTypeEntity00({this.synonyms, this.value});

  $EntityTypeEntity00.fromJson(core.Map json_)
    : this(
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (synonyms != null) 'synonyms': synonyms!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3EntityTypeEntity
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1EntityTypeEntity
class $EntityTypeEntity01 {
  /// A collection of value synonyms.
  ///
  /// For example, if the entity type is *vegetable*, and `value` is
  /// *scallions*, a synonym could be *green onions*. For `KIND_LIST` entity
  /// types: * This collection must contain exactly one synonym equal to
  /// `value`.
  ///
  /// Required.
  core.List<core.String>? synonyms;

  /// The primary value associated with this entity entry.
  ///
  /// For example, if the entity type is *vegetable*, the value could be
  /// *scallions*. For `KIND_MAP` entity types: * A canonical value to be used
  /// in place of synonyms. For `KIND_LIST` entity types: * A string that can
  /// contain references to other entity types (with or without aliases).
  ///
  /// Required.
  core.String? value;

  $EntityTypeEntity01({this.synonyms, this.value});

  $EntityTypeEntity01.fromJson(core.Map json_)
    : this(
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (synonyms != null) 'synonyms': synonyms!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3EntityTypeExcludedPhrase
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1EntityTypeExcludedPhrase
class $EntityTypeExcludedPhrase {
  /// The word or phrase to be excluded.
  ///
  /// Required.
  core.String? value;

  $EntityTypeExcludedPhrase({this.value});

  $EntityTypeExcludedPhrase.fromJson(core.Map json_)
    : this(value: json_['value'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - toolresults:v1beta3 : EnvironmentDimensionValueEntry
/// - toolresults:v1beta3 : StepDimensionValueEntry
/// - toolresults:v1beta3 : StepLabelsEntry
class $Entry00 {
  core.String? key;
  core.String? value;

  $Entry00({this.key, this.value});

  $Entry00.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - speech:v1 : Entry
/// - speech:v1p1beta1 : Entry
class $Entry01 {
  /// Whether the search is case sensitive.
  core.bool? caseSensitive;

  /// What to replace with.
  ///
  /// Max length is 100 characters.
  core.String? replace;

  /// What to replace.
  ///
  /// Max length is 100 characters.
  core.String? search;

  $Entry01({this.caseSensitive, this.replace, this.search});

  $Entry01.fromJson(core.Map json_)
    : this(
        caseSensitive: json_['caseSensitive'] as core.bool?,
        replace: json_['replace'] as core.String?,
        search: json_['search'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseSensitive != null) 'caseSensitive': caseSensitive!,
    if (replace != null) 'replace': replace!,
    if (search != null) 'search': search!,
  };
}

/// Used by:
///
/// - appengine:v1 : Entrypoint
/// - appengine:v1beta : Entrypoint
class $Entrypoint {
  /// The format should be a shell command that can be fed to bash -c.
  core.String? shell;

  $Entrypoint({this.shell});

  $Entrypoint.fromJson(core.Map json_)
    : this(shell: json_['shell'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (shell != null) 'shell': shell!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1EnvVar
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1EnvVar
class $EnvVar {
  /// Name of the environment variable.
  ///
  /// Must be a valid C identifier.
  ///
  /// Required.
  core.String? name;

  /// Variables that reference a $(VAR_NAME) are expanded using the previous
  /// defined environment variables in the container and any service environment
  /// variables.
  ///
  /// If a variable cannot be resolved, the reference in the input string will
  /// be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie:
  /// $$(VAR_NAME). Escaped references will never be expanded, regardless of
  /// whether the variable exists or not.
  ///
  /// Required.
  core.String? value;

  $EnvVar({this.name, this.value});

  $EnvVar.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : EnvelopeSignature
/// - containeranalysis:v1beta1 : EnvelopeSignature
/// - ondemandscanning:v1 : EnvelopeSignature
/// - ondemandscanning:v1beta1 : EnvelopeSignature
class $EnvelopeSignature {
  core.String? keyid;
  core.String? sig;
  core.List<core.int> get sigAsBytes => convert.base64.decode(sig!);

  set sigAsBytes(core.List<core.int> bytes_) {
    sig = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $EnvelopeSignature({this.keyid, this.sig});

  $EnvelopeSignature.fromJson(core.Map json_)
    : this(
        keyid: json_['keyid'] as core.String?,
        sig: json_['sig'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (keyid != null) 'keyid': keyid!,
    if (sig != null) 'sig': sig!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : EnvironmentAssignedTargetingOptionDetails
/// - displayvideo:v3 : EnvironmentAssignedTargetingOptionDetails
/// - displayvideo:v4 : EnvironmentAssignedTargetingOptionDetails
class $EnvironmentAssignedTargetingOptionDetails {
  /// The serving environment.
  ///
  /// Required.
  /// Possible string values are:
  /// - "ENVIRONMENT_UNSPECIFIED" : Default value when environment is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real environment option.
  /// - "ENVIRONMENT_WEB_OPTIMIZED" : Target inventory displayed in browsers.
  /// This includes inventory that was designed for the device it was viewed on,
  /// such as mobile websites viewed on a mobile device.
  /// ENVIRONMENT_WEB_NOT_OPTIMIZED, if targeted, should be deleted prior to the
  /// deletion of this targeting option.
  /// - "ENVIRONMENT_WEB_NOT_OPTIMIZED" : Target inventory displayed in
  /// browsers. This includes inventory that was not designed for the device but
  /// viewed on it, such as websites optimized for desktop but viewed on a
  /// mobile device. ENVIRONMENT_WEB_OPTIMIZED should be targeted prior to the
  /// addition of this targeting option.
  /// - "ENVIRONMENT_APP" : Target inventory displayed in apps.
  core.String? environment;

  $EnvironmentAssignedTargetingOptionDetails({this.environment});

  $EnvironmentAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(environment: json_['environment'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2EnvironmentHistoryEntry
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1EnvironmentHistoryEntry
class $EnvironmentHistoryEntry {
  /// The agent version loaded into this environment history entry.
  core.String? agentVersion;

  /// The creation time of this environment history entry.
  core.String? createTime;

  /// The developer-provided description for this environment history entry.
  core.String? description;

  $EnvironmentHistoryEntry({
    this.agentVersion,
    this.createTime,
    this.description,
  });

  $EnvironmentHistoryEntry.fromJson(core.Map json_)
    : this(
        agentVersion: json_['agentVersion'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentVersion != null) 'agentVersion': agentVersion!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : EnvironmentTargetingOptionDetails
/// - displayvideo:v3 : EnvironmentTargetingOptionDetails
/// - displayvideo:v4 : EnvironmentTargetingOptionDetails
class $EnvironmentTargetingOptionDetails {
  /// The serving environment.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ENVIRONMENT_UNSPECIFIED" : Default value when environment is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real environment option.
  /// - "ENVIRONMENT_WEB_OPTIMIZED" : Target inventory displayed in browsers.
  /// This includes inventory that was designed for the device it was viewed on,
  /// such as mobile websites viewed on a mobile device.
  /// ENVIRONMENT_WEB_NOT_OPTIMIZED, if targeted, should be deleted prior to the
  /// deletion of this targeting option.
  /// - "ENVIRONMENT_WEB_NOT_OPTIMIZED" : Target inventory displayed in
  /// browsers. This includes inventory that was not designed for the device but
  /// viewed on it, such as websites optimized for desktop but viewed on a
  /// mobile device. ENVIRONMENT_WEB_OPTIMIZED should be targeted prior to the
  /// addition of this targeting option.
  /// - "ENVIRONMENT_APP" : Target inventory displayed in apps.
  core.String? environment;

  $EnvironmentTargetingOptionDetails({this.environment});

  $EnvironmentTargetingOptionDetails.fromJson(core.Map json_)
    : this(environment: json_['environment'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3EnvironmentTestCasesConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1EnvironmentTestCasesConfig
class $EnvironmentTestCasesConfig {
  /// Whether to run test cases in TestCasesConfig.test_cases periodically.
  ///
  /// Default false. If set to true, run once a day.
  core.bool? enableContinuousRun;

  /// Whether to run test cases in TestCasesConfig.test_cases before deploying a
  /// flow version to the environment.
  ///
  /// Default false.
  core.bool? enablePredeploymentRun;

  /// A list of test case names to run.
  ///
  /// They should be under the same agent. Format of each test case name:
  /// `projects//locations//agents//testCases/`
  core.List<core.String>? testCases;

  $EnvironmentTestCasesConfig({
    this.enableContinuousRun,
    this.enablePredeploymentRun,
    this.testCases,
  });

  $EnvironmentTestCasesConfig.fromJson(core.Map json_)
    : this(
        enableContinuousRun: json_['enableContinuousRun'] as core.bool?,
        enablePredeploymentRun: json_['enablePredeploymentRun'] as core.bool?,
        testCases:
            (json_['testCases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableContinuousRun != null)
      'enableContinuousRun': enableContinuousRun!,
    if (enablePredeploymentRun != null)
      'enablePredeploymentRun': enablePredeploymentRun!,
    if (testCases != null) 'testCases': testCases!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : EnvironmentVariable
/// - firebaseapphosting:v1beta : EnvironmentVariable
class $EnvironmentVariable {
  /// Where this variable should be made available.
  ///
  /// If left unspecified, will be available in both BUILD and BACKEND.
  ///
  /// Optional.
  core.List<core.String>? availability;

  /// A fully qualified secret version.
  ///
  /// The value of the secret will be accessed once while building the
  /// application and once per cold start of the container at runtime. The
  /// service account used by Cloud Build and by Cloud Run must each have the
  /// `secretmanager.versions.access` permission on the secret.
  core.String? secret;

  /// A plaintext value.
  ///
  /// This value is encrypted at rest, but all project readers can view the
  /// value when reading your backend configuration.
  core.String? value;

  /// The name of the environment variable.
  ///
  /// - Must be a valid environment variable name (e.g. A-Z or underscores). -
  /// May not start with "FIREBASE" or "GOOGLE". - May not be a reserved
  /// environment variable for KNative/Cloud Run
  ///
  /// Required.
  core.String? variable;

  $EnvironmentVariable({
    this.availability,
    this.secret,
    this.value,
    this.variable,
  });

  $EnvironmentVariable.fromJson(core.Map json_)
    : this(
        availability:
            (json_['availability'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        secret: json_['secret'] as core.String?,
        value: json_['value'] as core.String?,
        variable: json_['variable'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (availability != null) 'availability': availability!,
    if (secret != null) 'secret': secret!,
    if (value != null) 'value': value!,
    if (variable != null) 'variable': variable!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3EnvironmentVersionConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1EnvironmentVersionConfig
class $EnvironmentVersionConfig {
  /// Flow, playbook and tool versions are supported.
  ///
  /// Format for flow version: projects//locations//agents//flows//versions/.
  /// Format for playbook version:
  /// projects//locations//agents//playbooks//versions/. Format for tool
  /// version: projects//locations//agents//tools//versions/.
  ///
  /// Required.
  core.String? version;

  $EnvironmentVersionConfig({this.version});

  $EnvironmentVersionConfig.fromJson(core.Map json_)
    : this(version: json_['version'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - container:v1 : EphemeralStorageLocalSsdConfig
/// - container:v1beta1 : EphemeralStorageLocalSsdConfig
class $EphemeralStorageLocalSsdConfig {
  /// Number of local SSDs to use for GKE Data Cache.
  core.int? dataCacheCount;

  /// Number of local SSDs to use to back ephemeral storage.
  ///
  /// Uses NVMe interfaces. A zero (or unset) value has different meanings
  /// depending on machine type being used: 1. For pre-Gen3 machines, which
  /// support flexible numbers of local ssds, zero (or unset) means to disable
  /// using local SSDs as ephemeral storage. The limit for this value is
  /// dependent upon the maximum number of disk available on a machine per zone.
  /// See:
  /// https://{$universe.dns_names.final_documentation_domain}/compute/docs/disks/local-ssd
  /// for more information. 2. For Gen3 machines which dictate a specific number
  /// of local ssds, zero (or unset) means to use the default number of local
  /// ssds that goes with that machine type. For example, for a
  /// c3-standard-8-lssd machine, 2 local ssds would be provisioned. For
  /// c3-standard-8 (which doesn't support local ssds), 0 will be provisioned.
  /// See
  /// https://{$universe.dns_names.final_documentation_domain}/compute/docs/disks/local-ssd#choose_number_local_ssds
  /// for more info.
  core.int? localSsdCount;

  $EphemeralStorageLocalSsdConfig({this.dataCacheCount, this.localSsdCount});

  $EphemeralStorageLocalSsdConfig.fromJson(core.Map json_)
    : this(
        dataCacheCount: json_['dataCacheCount'] as core.int?,
        localSsdCount: json_['localSsdCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataCacheCount != null) 'dataCacheCount': dataCacheCount!,
    if (localSsdCount != null) 'localSsdCount': localSsdCount!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementConfigSyncError
/// - gkehub:v1 : ConfigManagementInstallError
/// - gkehub:v1alpha : ConfigManagementConfigSyncError
/// - gkehub:v1alpha : ConfigManagementInstallError
/// - gkehub:v1beta : ConfigManagementConfigSyncError
/// - gkehub:v1beta : ConfigManagementInstallError
/// - gkehub:v2 : ConfigManagementConfigSyncError
/// - gkehub:v2alpha : ConfigManagementConfigSyncError
/// - gkehub:v2beta : ConfigManagementConfigSyncError
class $Error00 {
  /// A string representing the user facing error message
  core.String? errorMessage;

  $Error00({this.errorMessage});

  $Error00.fromJson(core.Map json_)
    : this(errorMessage: json_['errorMessage'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
  };
}

/// Used by:
///
/// - datastream:v1 : Error
/// - datastream:v1alpha1 : Error
class $Error01 {
  /// Additional information about the error.
  core.Map<core.String, core.String>? details;

  /// The time when the error occurred.
  core.String? errorTime;

  /// A unique identifier for this specific error, allowing it to be traced
  /// throughout the system in logs and API responses.
  core.String? errorUuid;

  /// A message containing more information about the error that occurred.
  core.String? message;

  /// A title that explains the reason for the error.
  core.String? reason;

  $Error01({
    this.details,
    this.errorTime,
    this.errorUuid,
    this.message,
    this.reason,
  });

  $Error01.fromJson(core.Map json_)
    : this(
        details: (json_['details'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        errorTime: json_['errorTime'] as core.String?,
        errorUuid: json_['errorUuid'] as core.String?,
        message: json_['message'] as core.String?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (errorTime != null) 'errorTime': errorTime!,
    if (errorUuid != null) 'errorUuid': errorUuid!,
    if (message != null) 'message': message!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotationAttributedItem
class $ErrorAnalysisAnnotationAttributedItem {
  /// The unique ID for each annotation.
  ///
  /// Used by FE to allocate the annotation in DB.
  core.String? annotationResourceName;

  /// The distance of this item to the annotation.
  core.double? distance;

  $ErrorAnalysisAnnotationAttributedItem({
    this.annotationResourceName,
    this.distance,
  });

  $ErrorAnalysisAnnotationAttributedItem.fromJson(core.Map json_)
    : this(
        annotationResourceName: json_['annotationResourceName'] as core.String?,
        distance: (json_['distance'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationResourceName != null)
      'annotationResourceName': annotationResourceName!,
    if (distance != null) 'distance': distance!,
  };
}

/// Used by:
///
/// - appengine:v1 : ErrorHandler
/// - appengine:v1beta : ErrorHandler
class $ErrorHandler {
  /// Error condition this handler applies to.
  /// Possible string values are:
  /// - "ERROR_CODE_UNSPECIFIED" : Not specified. ERROR_CODE_DEFAULT is assumed.
  /// - "ERROR_CODE_DEFAULT" : All other error types.
  /// - "ERROR_CODE_OVER_QUOTA" : Application has exceeded a resource quota.
  /// - "ERROR_CODE_DOS_API_DENIAL" : Client blocked by the application's Denial
  /// of Service protection configuration.
  /// - "ERROR_CODE_TIMEOUT" : Deadline reached before the application responds.
  core.String? errorCode;

  /// MIME type of file.
  ///
  /// Defaults to text/html.
  core.String? mimeType;

  /// Static file content to be served for this error.
  core.String? staticFile;

  $ErrorHandler({this.errorCode, this.mimeType, this.staticFile});

  $ErrorHandler.fromJson(core.Map json_)
    : this(
        errorCode: json_['errorCode'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
        staticFile: json_['staticFile'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorCode != null) 'errorCode': errorCode!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (staticFile != null) 'staticFile': staticFile!,
  };
}

/// Used by:
///
/// - compute:alpha : ErrorInfo
/// - compute:beta : ErrorInfo
/// - compute:v1 : ErrorInfo
/// - deploymentmanager:alpha : ErrorInfo
/// - deploymentmanager:v2 : ErrorInfo
/// - deploymentmanager:v2beta : ErrorInfo
class $ErrorInfo {
  /// The logical grouping to which the "reason" belongs.
  ///
  /// The error domain is typically the registered service name of the tool or
  /// product that generates the error. Example: "pubsub.googleapis.com". If the
  /// error is generated by some common infrastructure, the error domain must be
  /// a globally unique value that identifies the infrastructure. For Google API
  /// infrastructure, the error domain is "googleapis.com".
  core.String? domain;

  /// Additional structured details about this error.
  ///
  /// Keys must match a regular expression of `a-z+` but should ideally be
  /// lowerCamelCase. Also, they must be limited to 64 characters in length.
  /// When identifying the current value of an exceeded limit, the units should
  /// be contained in the key, not the value. For example, rather than
  /// `{"instanceLimit": "100/request"}`, should be returned as,
  /// `{"instanceLimitPerRequest": "100"}`, if the client exceeds the number of
  /// instances that can be created in a single (batch) request.
  core.Map<core.String, core.String>? metadatas;

  /// The reason of the error.
  ///
  /// This is a constant value that identifies the proximate cause of the error.
  /// Error reasons are unique within a particular domain of errors. This should
  /// be at most 63 characters and match a regular expression of `A-Z+[A-Z0-9]`,
  /// which represents UPPER_SNAKE_CASE.
  core.String? reason;

  $ErrorInfo({this.domain, this.metadatas, this.reason});

  $ErrorInfo.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        metadatas: (json_['metadatas'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (metadatas != null) 'metadatas': metadatas!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : Escalation
/// - cloudsupport:v2beta : Escalation
class $Escalation {
  /// A free text description to accompany the `reason` field above.
  ///
  /// Provides additional context on why the case is being escalated.
  ///
  /// Required.
  core.String? justification;

  /// The reason why the Case is being escalated.
  ///
  /// Required.
  /// Possible string values are:
  /// - "REASON_UNSPECIFIED" : The escalation reason is in an unknown state or
  /// has not been specified.
  /// - "RESOLUTION_TIME" : The case is taking too long to resolve.
  /// - "TECHNICAL_EXPERTISE" : The support agent does not have the expertise
  /// required to successfully resolve the issue.
  /// - "BUSINESS_IMPACT" : The issue is having a significant business impact.
  core.String? reason;

  $Escalation({this.justification, this.reason});

  $Escalation.fromJson(core.Map json_)
    : this(
        justification: json_['justification'] as core.String?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (justification != null) 'justification': justification!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - netapp:v1 : EstablishPeeringRequest
/// - netapp:v1beta1 : EstablishPeeringRequest
class $EstablishPeeringRequest {
  /// Name of the user's local source cluster to be peered with the destination
  /// cluster.
  ///
  /// Required.
  core.String? peerClusterName;

  /// List of IPv4 ip addresses to be used for peering.
  ///
  /// Optional.
  core.List<core.String>? peerIpAddresses;

  /// Name of the user's local source vserver svm to be peered with the
  /// destination vserver svm.
  ///
  /// Required.
  core.String? peerSvmName;

  /// Name of the user's local source volume to be peered with the destination
  /// volume.
  ///
  /// Required.
  core.String? peerVolumeName;

  $EstablishPeeringRequest({
    this.peerClusterName,
    this.peerIpAddresses,
    this.peerSvmName,
    this.peerVolumeName,
  });

  $EstablishPeeringRequest.fromJson(core.Map json_)
    : this(
        peerClusterName: json_['peerClusterName'] as core.String?,
        peerIpAddresses:
            (json_['peerIpAddresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        peerSvmName: json_['peerSvmName'] as core.String?,
        peerVolumeName: json_['peerVolumeName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (peerClusterName != null) 'peerClusterName': peerClusterName!,
    if (peerIpAddresses != null) 'peerIpAddresses': peerIpAddresses!,
    if (peerSvmName != null) 'peerSvmName': peerSvmName!,
    if (peerVolumeName != null) 'peerVolumeName': peerVolumeName!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1EvaluationCounters
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3EvaluationCounters
class $EvaluationCounters {
  /// How many documents were used in the evaluation.
  core.int? evaluatedDocumentsCount;

  /// How many documents were not included in the evaluation as Document AI
  /// failed to process them.
  core.int? failedDocumentsCount;

  /// How many documents were sent for evaluation.
  core.int? inputDocumentsCount;

  /// How many documents were not included in the evaluation as they didn't pass
  /// validation.
  core.int? invalidDocumentsCount;

  $EvaluationCounters({
    this.evaluatedDocumentsCount,
    this.failedDocumentsCount,
    this.inputDocumentsCount,
    this.invalidDocumentsCount,
  });

  $EvaluationCounters.fromJson(core.Map json_)
    : this(
        evaluatedDocumentsCount: json_['evaluatedDocumentsCount'] as core.int?,
        failedDocumentsCount: json_['failedDocumentsCount'] as core.int?,
        inputDocumentsCount: json_['inputDocumentsCount'] as core.int?,
        invalidDocumentsCount: json_['invalidDocumentsCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (evaluatedDocumentsCount != null)
      'evaluatedDocumentsCount': evaluatedDocumentsCount!,
    if (failedDocumentsCount != null)
      'failedDocumentsCount': failedDocumentsCount!,
    if (inputDocumentsCount != null)
      'inputDocumentsCount': inputDocumentsCount!,
    if (invalidDocumentsCount != null)
      'invalidDocumentsCount': invalidDocumentsCount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpecQuerySetSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaEvaluationEvaluationSpecQuerySetSpec
class $EvaluationEvaluationSpecQuerySetSpec {
  /// The full resource name of the SampleQuerySet used for the evaluation, in
  /// the format of
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sampleQuerySet}`.
  ///
  /// Optional.
  core.String? sampleQuerySet;

  $EvaluationEvaluationSpecQuerySetSpec({this.sampleQuerySet});

  $EvaluationEvaluationSpecQuerySetSpec.fromJson(core.Map json_)
    : this(sampleQuerySet: json_['sampleQuerySet'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sampleQuerySet != null) 'sampleQuerySet': sampleQuerySet!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1EvaluationMetrics
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3EvaluationMetrics
class $EvaluationMetrics {
  /// The calculated f1 score.
  core.double? f1Score;

  /// The amount of false negatives.
  core.int? falseNegativesCount;

  /// The amount of false positives.
  core.int? falsePositivesCount;

  /// The amount of documents with a ground truth occurrence.
  core.int? groundTruthDocumentCount;

  /// The amount of occurrences in ground truth documents.
  core.int? groundTruthOccurrencesCount;

  /// The calculated precision.
  core.double? precision;

  /// The amount of documents with a predicted occurrence.
  core.int? predictedDocumentCount;

  /// The amount of occurrences in predicted documents.
  core.int? predictedOccurrencesCount;

  /// The calculated recall.
  core.double? recall;

  /// The amount of documents that had an occurrence of this label.
  core.int? totalDocumentsCount;

  /// The amount of true positives.
  core.int? truePositivesCount;

  $EvaluationMetrics({
    this.f1Score,
    this.falseNegativesCount,
    this.falsePositivesCount,
    this.groundTruthDocumentCount,
    this.groundTruthOccurrencesCount,
    this.precision,
    this.predictedDocumentCount,
    this.predictedOccurrencesCount,
    this.recall,
    this.totalDocumentsCount,
    this.truePositivesCount,
  });

  $EvaluationMetrics.fromJson(core.Map json_)
    : this(
        f1Score: (json_['f1Score'] as core.num?)?.toDouble(),
        falseNegativesCount: json_['falseNegativesCount'] as core.int?,
        falsePositivesCount: json_['falsePositivesCount'] as core.int?,
        groundTruthDocumentCount:
            json_['groundTruthDocumentCount'] as core.int?,
        groundTruthOccurrencesCount:
            json_['groundTruthOccurrencesCount'] as core.int?,
        precision: (json_['precision'] as core.num?)?.toDouble(),
        predictedDocumentCount: json_['predictedDocumentCount'] as core.int?,
        predictedOccurrencesCount:
            json_['predictedOccurrencesCount'] as core.int?,
        recall: (json_['recall'] as core.num?)?.toDouble(),
        totalDocumentsCount: json_['totalDocumentsCount'] as core.int?,
        truePositivesCount: json_['truePositivesCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (f1Score != null) 'f1Score': f1Score!,
    if (falseNegativesCount != null)
      'falseNegativesCount': falseNegativesCount!,
    if (falsePositivesCount != null)
      'falsePositivesCount': falsePositivesCount!,
    if (groundTruthDocumentCount != null)
      'groundTruthDocumentCount': groundTruthDocumentCount!,
    if (groundTruthOccurrencesCount != null)
      'groundTruthOccurrencesCount': groundTruthOccurrencesCount!,
    if (precision != null) 'precision': precision!,
    if (predictedDocumentCount != null)
      'predictedDocumentCount': predictedDocumentCount!,
    if (predictedOccurrencesCount != null)
      'predictedOccurrencesCount': predictedOccurrencesCount!,
    if (recall != null) 'recall': recall!,
    if (totalDocumentsCount != null)
      'totalDocumentsCount': totalDocumentsCount!,
    if (truePositivesCount != null) 'truePositivesCount': truePositivesCount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Event
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Event
class $Event {
  /// The relative resource name of the Artifact in the Event.
  ///
  /// Required.
  core.String? artifact;

  /// Time the Event occurred.
  ///
  /// Output only.
  core.String? eventTime;

  /// The relative resource name of the Execution in the Event.
  ///
  /// Output only.
  core.String? execution;

  /// The labels with user-defined metadata to annotate Events.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Event (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// The type of the Event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified whether input or output of the
  /// Execution.
  /// - "INPUT" : An input of the Execution.
  /// - "OUTPUT" : An output of the Execution.
  core.String? type;

  $Event({
    this.artifact,
    this.eventTime,
    this.execution,
    this.labels,
    this.type,
  });

  $Event.fromJson(core.Map json_)
    : this(
        artifact: json_['artifact'] as core.String?,
        eventTime: json_['eventTime'] as core.String?,
        execution: json_['execution'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifact != null) 'artifact': artifact!,
    if (eventTime != null) 'eventTime': eventTime!,
    if (execution != null) 'execution': execution!,
    if (labels != null) 'labels': labels!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : EventFilter
/// - cloudfunctions:v2alpha : EventFilter
/// - cloudfunctions:v2beta : EventFilter
class $EventFilter {
  /// The name of a CloudEvents attribute.
  ///
  /// Required.
  core.String? attribute;

  /// The operator used for matching the events with the value of the filter.
  ///
  /// If not specified, only events that have an exact key-value pair specified
  /// in the filter are matched. The only allowed value is `match-path-pattern`.
  ///
  /// Optional.
  core.String? operator;

  /// The value for the attribute.
  ///
  /// Required.
  core.String? value;

  $EventFilter({this.attribute, this.operator, this.value});

  $EventFilter.fromJson(core.Map json_)
    : this(
        attribute: json_['attribute'] as core.String?,
        operator: json_['operator'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attribute != null) 'attribute': attribute!,
    if (operator != null) 'operator': operator!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2EventInput
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1EventInput
class $EventInput00 {
  /// The language of this query.
  ///
  /// See
  /// [Language Support](https://cloud.google.com/dialogflow/docs/reference/language)
  /// for a list of the currently supported language codes. Note that queries in
  /// the same session do not necessarily need to specify the same language.
  /// This field is ignored when used in the context of a
  /// WebhookResponse.followup_event_input field, because the language was
  /// already defined in the originating detect intent request.
  ///
  /// Required.
  core.String? languageCode;

  /// The unique identifier of the event.
  ///
  /// Required.
  core.String? name;

  /// The collection of parameters associated with the event.
  ///
  /// Depending on your protocol or client library language, this is a map,
  /// associative array, symbol table, dictionary, or JSON object composed of a
  /// collection of (MapKey, MapValue) pairs: * MapKey type: string * MapKey
  /// value: parameter name * MapValue type: If parameter's entity type is a
  /// composite entity then use map, otherwise, depending on the parameter value
  /// type, it could be one of string, number, boolean, null, list or map. *
  /// MapValue value: If parameter's entity type is a composite entity then use
  /// map from composite entity property names to property values, otherwise,
  /// use parameter value.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? parameters;

  $EventInput00({this.languageCode, this.name, this.parameters});

  $EventInput00.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        name: json_['name'] as core.String?,
        parameters:
            json_.containsKey('parameters')
                ? json_['parameters'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (name != null) 'name': name!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3EventInput
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1EventInput
class $EventInput01 {
  /// Name of the event.
  core.String? event;

  $EventInput01({this.event});

  $EventInput01.fromJson(core.Map json_)
    : this(event: json_['event'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (event != null) 'event': event!,
  };
}

/// Used by:
///
/// - datafusion:v1 : EventPublishConfig
/// - datafusion:v1beta1 : EventPublishConfig
class $EventPublishConfig {
  /// Option to enable Event Publishing.
  ///
  /// Required.
  core.bool? enabled;

  /// The resource name of the Pub/Sub topic.
  ///
  /// Format: projects/{project_id}/topics/{topic_id}
  ///
  /// Required.
  core.String? topic;

  $EventPublishConfig({this.enabled, this.topic});

  $EventPublishConfig.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        topic: json_['topic'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (topic != null) 'topic': topic!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoBooleanParameterArray
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoBooleanParameterArray
class $EventbusProtoBooleanParameterArray {
  core.List<core.bool>? booleanValues;

  $EventbusProtoBooleanParameterArray({this.booleanValues});

  $EventbusProtoBooleanParameterArray.fromJson(core.Map json_)
    : this(
        booleanValues:
            (json_['booleanValues'] as core.List?)
                ?.map((value) => value as core.bool)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (booleanValues != null) 'booleanValues': booleanValues!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoDoubleParameterArray
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoDoubleParameterArray
class $EventbusProtoDoubleParameterArray {
  core.List<core.double>? doubleValues;

  $EventbusProtoDoubleParameterArray({this.doubleValues});

  $EventbusProtoDoubleParameterArray.fromJson(core.Map json_)
    : this(
        doubleValues:
            (json_['doubleValues'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doubleValues != null) 'doubleValues': doubleValues!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoIntParameterArray
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoIntParameterArray
class $EventbusProtoIntParameterArray {
  core.List<core.String>? intValues;

  $EventbusProtoIntParameterArray({this.intValues});

  $EventbusProtoIntParameterArray.fromJson(core.Map json_)
    : this(
        intValues:
            (json_['intValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (intValues != null) 'intValues': intValues!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoProtoParameterArray
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoProtoParameterArray
class $EventbusProtoProtoParameterArray {
  ///
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? protoValues;

  $EventbusProtoProtoParameterArray({this.protoValues});

  $EventbusProtoProtoParameterArray.fromJson(core.Map json_)
    : this(
        protoValues:
            (json_['protoValues'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (protoValues != null) 'protoValues': protoValues!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoSerializedObjectParameter
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoSerializedObjectParameter
class $EventbusProtoSerializedObjectParameter {
  core.String? objectValue;
  core.List<core.int> get objectValueAsBytes =>
      convert.base64.decode(objectValue!);

  set objectValueAsBytes(core.List<core.int> bytes_) {
    objectValue = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $EventbusProtoSerializedObjectParameter({this.objectValue});

  $EventbusProtoSerializedObjectParameter.fromJson(core.Map json_)
    : this(objectValue: json_['objectValue'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectValue != null) 'objectValue': objectValue!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmEventbusProtoStringParameterArray
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoStringParameterArray
class $EventbusProtoStringParameterArray {
  core.List<core.String>? stringValues;

  $EventbusProtoStringParameterArray({this.stringValues});

  $EventbusProtoStringParameterArray.fromJson(core.Map json_)
    : this(
        stringValues:
            (json_['stringValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (stringValues != null) 'stringValues': stringValues!,
  };
}

/// Used by:
///
/// - connectors:v1 : EventingStatus
/// - integrations:v1 : GoogleCloudConnectorsV1EventingStatus
class $EventingStatus {
  /// Description of error if State is set to "ERROR".
  ///
  /// Output only.
  core.String? description;

  /// State.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default state.
  /// - "ACTIVE" : Eventing is enabled and ready to receive events.
  /// - "ERROR" : Eventing is not active due to an error.
  /// - "INGRESS_ENDPOINT_REQUIRED" : Ingress endpoint required.
  core.String? state;

  $EventingStatus({this.description, this.state});

  $EventingStatus.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - container:v1 : EvictionGracePeriod
/// - container:v1beta1 : EvictionGracePeriod
class $EvictionGracePeriod {
  /// Grace period for eviction due to imagefs available signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? imagefsAvailable;

  /// Grace period for eviction due to imagefs inodes free signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? imagefsInodesFree;

  /// Grace period for eviction due to memory available signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? memoryAvailable;

  /// Grace period for eviction due to nodefs available signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? nodefsAvailable;

  /// Grace period for eviction due to nodefs inodes free signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? nodefsInodesFree;

  /// Grace period for eviction due to pid available signal.
  ///
  /// Sample format: "10s". Must be \>= 0. See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? pidAvailable;

  $EvictionGracePeriod({
    this.imagefsAvailable,
    this.imagefsInodesFree,
    this.memoryAvailable,
    this.nodefsAvailable,
    this.nodefsInodesFree,
    this.pidAvailable,
  });

  $EvictionGracePeriod.fromJson(core.Map json_)
    : this(
        imagefsAvailable: json_['imagefsAvailable'] as core.String?,
        imagefsInodesFree: json_['imagefsInodesFree'] as core.String?,
        memoryAvailable: json_['memoryAvailable'] as core.String?,
        nodefsAvailable: json_['nodefsAvailable'] as core.String?,
        nodefsInodesFree: json_['nodefsInodesFree'] as core.String?,
        pidAvailable: json_['pidAvailable'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (imagefsAvailable != null) 'imagefsAvailable': imagefsAvailable!,
    if (imagefsInodesFree != null) 'imagefsInodesFree': imagefsInodesFree!,
    if (memoryAvailable != null) 'memoryAvailable': memoryAvailable!,
    if (nodefsAvailable != null) 'nodefsAvailable': nodefsAvailable!,
    if (nodefsInodesFree != null) 'nodefsInodesFree': nodefsInodesFree!,
    if (pidAvailable != null) 'pidAvailable': pidAvailable!,
  };
}

/// Used by:
///
/// - container:v1 : EvictionMinimumReclaim
/// - container:v1beta1 : EvictionMinimumReclaim
class $EvictionMinimumReclaim {
  /// Minimum reclaim for eviction due to imagefs available signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? imagefsAvailable;

  /// Minimum reclaim for eviction due to imagefs inodes free signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? imagefsInodesFree;

  /// Minimum reclaim for eviction due to memory available signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? memoryAvailable;

  /// Minimum reclaim for eviction due to nodefs available signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? nodefsAvailable;

  /// Minimum reclaim for eviction due to nodefs inodes free signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? nodefsInodesFree;

  /// Minimum reclaim for eviction due to pid available signal.
  ///
  /// Only take percentage value for now. Sample format: "10%". Must be \<=10%.
  /// See
  /// https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals
  ///
  /// Optional.
  core.String? pidAvailable;

  $EvictionMinimumReclaim({
    this.imagefsAvailable,
    this.imagefsInodesFree,
    this.memoryAvailable,
    this.nodefsAvailable,
    this.nodefsInodesFree,
    this.pidAvailable,
  });

  $EvictionMinimumReclaim.fromJson(core.Map json_)
    : this(
        imagefsAvailable: json_['imagefsAvailable'] as core.String?,
        imagefsInodesFree: json_['imagefsInodesFree'] as core.String?,
        memoryAvailable: json_['memoryAvailable'] as core.String?,
        nodefsAvailable: json_['nodefsAvailable'] as core.String?,
        nodefsInodesFree: json_['nodefsInodesFree'] as core.String?,
        pidAvailable: json_['pidAvailable'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (imagefsAvailable != null) 'imagefsAvailable': imagefsAvailable!,
    if (imagefsInodesFree != null) 'imagefsInodesFree': imagefsInodesFree!,
    if (memoryAvailable != null) 'memoryAvailable': memoryAvailable!,
    if (nodefsAvailable != null) 'nodefsAvailable': nodefsAvailable!,
    if (nodefsInodesFree != null) 'nodefsInodesFree': nodefsInodesFree!,
    if (pidAvailable != null) 'pidAvailable': pidAvailable!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExactMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExactMatchMetricValue
class $ExactMatchMetricValue {
  /// Exact match score.
  ///
  /// Output only.
  core.double? score;

  $ExactMatchMetricValue({this.score});

  $ExactMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExamplesRestrictionsNamespace
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExamplesRestrictionsNamespace
class $ExamplesRestrictionsNamespace {
  /// The list of allowed tags.
  core.List<core.String>? allow;

  /// The list of deny tags.
  core.List<core.String>? deny;

  /// The namespace name.
  core.String? namespaceName;

  $ExamplesRestrictionsNamespace({this.allow, this.deny, this.namespaceName});

  $ExamplesRestrictionsNamespace.fromJson(core.Map json_)
    : this(
        allow:
            (json_['allow'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        deny:
            (json_['deny'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        namespaceName: json_['namespaceName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allow != null) 'allow': allow!,
    if (deny != null) 'deny': deny!,
    if (namespaceName != null) 'namespaceName': namespaceName!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeAppAttestAssertionRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeAppAttestAssertionRequest
class $ExchangeAppAttestAssertionRequest {
  /// The artifact returned by a previous call to ExchangeAppAttestAttestation.
  ///
  /// Required.
  core.String? artifact;
  core.List<core.int> get artifactAsBytes => convert.base64.decode(artifact!);

  set artifactAsBytes(core.List<core.int> bytes_) {
    artifact = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The CBOR-encoded assertion returned by the client-side App Attest API.
  ///
  /// Required.
  core.String? assertion;
  core.List<core.int> get assertionAsBytes => convert.base64.decode(assertion!);

  set assertionAsBytes(core.List<core.int> bytes_) {
    assertion = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// A one-time challenge returned by an immediately prior call to
  /// GenerateAppAttestChallenge.
  ///
  /// Required.
  core.String? challenge;
  core.List<core.int> get challengeAsBytes => convert.base64.decode(challenge!);

  set challengeAsBytes(core.List<core.int> bytes_) {
    challenge = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  $ExchangeAppAttestAssertionRequest({
    this.artifact,
    this.assertion,
    this.challenge,
    this.limitedUse,
  });

  $ExchangeAppAttestAssertionRequest.fromJson(core.Map json_)
    : this(
        artifact: json_['artifact'] as core.String?,
        assertion: json_['assertion'] as core.String?,
        challenge: json_['challenge'] as core.String?,
        limitedUse: json_['limitedUse'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifact != null) 'artifact': artifact!,
    if (assertion != null) 'assertion': assertion!,
    if (challenge != null) 'challenge': challenge!,
    if (limitedUse != null) 'limitedUse': limitedUse!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeAppAttestAttestationRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeAppAttestAttestationRequest
class $ExchangeAppAttestAttestationRequest {
  /// The App Attest statement returned by the client-side App Attest API.
  ///
  /// This is a base64url encoded CBOR object in the JSON response.
  ///
  /// Required.
  core.String? attestationStatement;
  core.List<core.int> get attestationStatementAsBytes =>
      convert.base64.decode(attestationStatement!);

  set attestationStatementAsBytes(core.List<core.int> bytes_) {
    attestationStatement = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// A one-time challenge returned by an immediately prior call to
  /// GenerateAppAttestChallenge.
  ///
  /// Required.
  core.String? challenge;
  core.List<core.int> get challengeAsBytes => convert.base64.decode(challenge!);

  set challengeAsBytes(core.List<core.int> bytes_) {
    challenge = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The key ID generated by App Attest for the client app.
  ///
  /// Required.
  core.String? keyId;
  core.List<core.int> get keyIdAsBytes => convert.base64.decode(keyId!);

  set keyIdAsBytes(core.List<core.int> bytes_) {
    keyId = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  $ExchangeAppAttestAttestationRequest({
    this.attestationStatement,
    this.challenge,
    this.keyId,
    this.limitedUse,
  });

  $ExchangeAppAttestAttestationRequest.fromJson(core.Map json_)
    : this(
        attestationStatement: json_['attestationStatement'] as core.String?,
        challenge: json_['challenge'] as core.String?,
        keyId: json_['keyId'] as core.String?,
        limitedUse: json_['limitedUse'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attestationStatement != null)
      'attestationStatement': attestationStatement!,
    if (challenge != null) 'challenge': challenge!,
    if (keyId != null) 'keyId': keyId!,
    if (limitedUse != null) 'limitedUse': limitedUse!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ExchangeAssignedTargetingOptionDetails
/// - displayvideo:v3 : ExchangeAssignedTargetingOptionDetails
/// - displayvideo:v4 : ExchangeAssignedTargetingOptionDetails
class $ExchangeAssignedTargetingOptionDetails {
  /// The enum value for the exchange.
  ///
  /// Required.
  /// Possible string values are:
  /// - "EXCHANGE_UNSPECIFIED" : Exchange is not specified or is unknown in this
  /// version.
  /// - "EXCHANGE_GOOGLE_AD_MANAGER" : Google Ad Manager.
  /// - "EXCHANGE_APPNEXUS" : AppNexus.
  /// - "EXCHANGE_BRIGHTROLL" : BrightRoll Exchange for Video from Yahoo!.
  /// - "EXCHANGE_ADFORM" : Adform.
  /// - "EXCHANGE_ADMETA" : Admeta.
  /// - "EXCHANGE_ADMIXER" : Admixer.
  /// - "EXCHANGE_ADSMOGO" : AdsMogo.
  /// - "EXCHANGE_ADSWIZZ" : AdsWizz.
  /// - "EXCHANGE_BIDSWITCH" : BidSwitch.
  /// - "EXCHANGE_BRIGHTROLL_DISPLAY" : BrightRoll Exchange for Display from
  /// Yahoo!.
  /// - "EXCHANGE_CADREON" : Cadreon.
  /// - "EXCHANGE_DAILYMOTION" : Dailymotion.
  /// - "EXCHANGE_FIVE" : Five.
  /// - "EXCHANGE_FLUCT" : Fluct.
  /// - "EXCHANGE_FREEWHEEL" : FreeWheel SSP.
  /// - "EXCHANGE_GENIEE" : Geniee.
  /// - "EXCHANGE_GUMGUM" : GumGum.
  /// - "EXCHANGE_IMOBILE" : i-mobile.
  /// - "EXCHANGE_IBILLBOARD" : iBILLBOARD.
  /// - "EXCHANGE_IMPROVE_DIGITAL" : Improve Digital.
  /// - "EXCHANGE_INDEX" : Index Exchange.
  /// - "EXCHANGE_KARGO" : Kargo.
  /// - "EXCHANGE_MICROAD" : MicroAd.
  /// - "EXCHANGE_MOPUB" : MoPub.
  /// - "EXCHANGE_NEND" : Nend.
  /// - "EXCHANGE_ONE_BY_AOL_DISPLAY" : ONE by AOL: Display Market Place.
  /// - "EXCHANGE_ONE_BY_AOL_MOBILE" : ONE by AOL: Mobile.
  /// - "EXCHANGE_ONE_BY_AOL_VIDEO" : ONE by AOL: Video.
  /// - "EXCHANGE_OOYALA" : Ooyala.
  /// - "EXCHANGE_OPENX" : OpenX.
  /// - "EXCHANGE_PERMODO" : Permodo.
  /// - "EXCHANGE_PLATFORMONE" : Platform One.
  /// - "EXCHANGE_PLATFORMID" : PlatformId.
  /// - "EXCHANGE_PUBMATIC" : PubMatic.
  /// - "EXCHANGE_PULSEPOINT" : PulsePoint.
  /// - "EXCHANGE_REVENUEMAX" : RevenueMax.
  /// - "EXCHANGE_RUBICON" : Rubicon.
  /// - "EXCHANGE_SMARTCLIP" : SmartClip.
  /// - "EXCHANGE_SMARTRTB" : SmartRTB+.
  /// - "EXCHANGE_SMARTSTREAMTV" : SmartstreamTv.
  /// - "EXCHANGE_SOVRN" : Sovrn.
  /// - "EXCHANGE_SPOTXCHANGE" : SpotXchange.
  /// - "EXCHANGE_STROER" : Strer SSP.
  /// - "EXCHANGE_TEADSTV" : TeadsTv.
  /// - "EXCHANGE_TELARIA" : Telaria.
  /// - "EXCHANGE_TVN" : TVN.
  /// - "EXCHANGE_UNITED" : United.
  /// - "EXCHANGE_YIELDLAB" : Yieldlab.
  /// - "EXCHANGE_YIELDMO" : Yieldmo.
  /// - "EXCHANGE_UNRULYX" : UnrulyX.
  /// - "EXCHANGE_OPEN8" : Open8.
  /// - "EXCHANGE_TRITON" : Triton.
  /// - "EXCHANGE_TRIPLELIFT" : TripleLift.
  /// - "EXCHANGE_TABOOLA" : Taboola.
  /// - "EXCHANGE_INMOBI" : InMobi.
  /// - "EXCHANGE_SMAATO" : Smaato.
  /// - "EXCHANGE_AJA" : Aja.
  /// - "EXCHANGE_SUPERSHIP" : Supership.
  /// - "EXCHANGE_NEXSTAR_DIGITAL" : Nexstar Digital.
  /// - "EXCHANGE_WAZE" : Waze.
  /// - "EXCHANGE_SOUNDCAST" : SoundCast.
  /// - "EXCHANGE_SHARETHROUGH" : Sharethrough.
  /// - "EXCHANGE_FYBER" : Fyber.
  /// - "EXCHANGE_RED_FOR_PUBLISHERS" : Red For Publishers.
  /// - "EXCHANGE_MEDIANET" : Media.net.
  /// - "EXCHANGE_TAPJOY" : Tapjoy.
  /// - "EXCHANGE_VISTAR" : Vistar.
  /// - "EXCHANGE_DAX" : DAX.
  /// - "EXCHANGE_JCD" : JCD.
  /// - "EXCHANGE_PLACE_EXCHANGE" : Place Exchange.
  /// - "EXCHANGE_APPLOVIN" : AppLovin.
  /// - "EXCHANGE_CONNATIX" : Connatix.
  /// - "EXCHANGE_RESET_DIGITAL" : Reset Digital.
  /// - "EXCHANGE_HIVESTACK" : Hivestack.
  /// - "EXCHANGE_DRAX" : Drax.
  /// - "EXCHANGE_APPLOVIN_GBID" : AppLovin MAX.
  /// - "EXCHANGE_FYBER_GBID" : DT Fairbid.
  /// - "EXCHANGE_UNITY_GBID" : Unity LevelPlay.
  /// - "EXCHANGE_CHARTBOOST_GBID" : Chartboost Mediation.
  /// - "EXCHANGE_ADMOST_GBID" : AdMost.
  /// - "EXCHANGE_TOPON_GBID" : TopOn.
  /// - "EXCHANGE_NETFLIX" : Netflix.
  /// - "EXCHANGE_CORE" : Core.
  /// - "EXCHANGE_COMMERCE_GRID" : Commerce Grid.
  /// - "EXCHANGE_SPOTIFY" : Spotify.
  /// - "EXCHANGE_TUBI" : Tubi.
  core.String? exchange;

  $ExchangeAssignedTargetingOptionDetails({this.exchange});

  $ExchangeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(exchange: json_['exchange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (exchange != null) 'exchange': exchange!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ExchangeConfigEnabledExchange
/// - displayvideo:v3 : ExchangeConfigEnabledExchange
/// - displayvideo:v4 : ExchangeConfigEnabledExchange
class $ExchangeConfigEnabledExchange {
  /// The enabled exchange.
  /// Possible string values are:
  /// - "EXCHANGE_UNSPECIFIED" : Exchange is not specified or is unknown in this
  /// version.
  /// - "EXCHANGE_GOOGLE_AD_MANAGER" : Google Ad Manager.
  /// - "EXCHANGE_APPNEXUS" : AppNexus.
  /// - "EXCHANGE_BRIGHTROLL" : BrightRoll Exchange for Video from Yahoo!.
  /// - "EXCHANGE_ADFORM" : Adform.
  /// - "EXCHANGE_ADMETA" : Admeta.
  /// - "EXCHANGE_ADMIXER" : Admixer.
  /// - "EXCHANGE_ADSMOGO" : AdsMogo.
  /// - "EXCHANGE_ADSWIZZ" : AdsWizz.
  /// - "EXCHANGE_BIDSWITCH" : BidSwitch.
  /// - "EXCHANGE_BRIGHTROLL_DISPLAY" : BrightRoll Exchange for Display from
  /// Yahoo!.
  /// - "EXCHANGE_CADREON" : Cadreon.
  /// - "EXCHANGE_DAILYMOTION" : Dailymotion.
  /// - "EXCHANGE_FIVE" : Five.
  /// - "EXCHANGE_FLUCT" : Fluct.
  /// - "EXCHANGE_FREEWHEEL" : FreeWheel SSP.
  /// - "EXCHANGE_GENIEE" : Geniee.
  /// - "EXCHANGE_GUMGUM" : GumGum.
  /// - "EXCHANGE_IMOBILE" : i-mobile.
  /// - "EXCHANGE_IBILLBOARD" : iBILLBOARD.
  /// - "EXCHANGE_IMPROVE_DIGITAL" : Improve Digital.
  /// - "EXCHANGE_INDEX" : Index Exchange.
  /// - "EXCHANGE_KARGO" : Kargo.
  /// - "EXCHANGE_MICROAD" : MicroAd.
  /// - "EXCHANGE_MOPUB" : MoPub.
  /// - "EXCHANGE_NEND" : Nend.
  /// - "EXCHANGE_ONE_BY_AOL_DISPLAY" : ONE by AOL: Display Market Place.
  /// - "EXCHANGE_ONE_BY_AOL_MOBILE" : ONE by AOL: Mobile.
  /// - "EXCHANGE_ONE_BY_AOL_VIDEO" : ONE by AOL: Video.
  /// - "EXCHANGE_OOYALA" : Ooyala.
  /// - "EXCHANGE_OPENX" : OpenX.
  /// - "EXCHANGE_PERMODO" : Permodo.
  /// - "EXCHANGE_PLATFORMONE" : Platform One.
  /// - "EXCHANGE_PLATFORMID" : PlatformId.
  /// - "EXCHANGE_PUBMATIC" : PubMatic.
  /// - "EXCHANGE_PULSEPOINT" : PulsePoint.
  /// - "EXCHANGE_REVENUEMAX" : RevenueMax.
  /// - "EXCHANGE_RUBICON" : Rubicon.
  /// - "EXCHANGE_SMARTCLIP" : SmartClip.
  /// - "EXCHANGE_SMARTRTB" : SmartRTB+.
  /// - "EXCHANGE_SMARTSTREAMTV" : SmartstreamTv.
  /// - "EXCHANGE_SOVRN" : Sovrn.
  /// - "EXCHANGE_SPOTXCHANGE" : SpotXchange.
  /// - "EXCHANGE_STROER" : Strer SSP.
  /// - "EXCHANGE_TEADSTV" : TeadsTv.
  /// - "EXCHANGE_TELARIA" : Telaria.
  /// - "EXCHANGE_TVN" : TVN.
  /// - "EXCHANGE_UNITED" : United.
  /// - "EXCHANGE_YIELDLAB" : Yieldlab.
  /// - "EXCHANGE_YIELDMO" : Yieldmo.
  /// - "EXCHANGE_UNRULYX" : UnrulyX.
  /// - "EXCHANGE_OPEN8" : Open8.
  /// - "EXCHANGE_TRITON" : Triton.
  /// - "EXCHANGE_TRIPLELIFT" : TripleLift.
  /// - "EXCHANGE_TABOOLA" : Taboola.
  /// - "EXCHANGE_INMOBI" : InMobi.
  /// - "EXCHANGE_SMAATO" : Smaato.
  /// - "EXCHANGE_AJA" : Aja.
  /// - "EXCHANGE_SUPERSHIP" : Supership.
  /// - "EXCHANGE_NEXSTAR_DIGITAL" : Nexstar Digital.
  /// - "EXCHANGE_WAZE" : Waze.
  /// - "EXCHANGE_SOUNDCAST" : SoundCast.
  /// - "EXCHANGE_SHARETHROUGH" : Sharethrough.
  /// - "EXCHANGE_FYBER" : Fyber.
  /// - "EXCHANGE_RED_FOR_PUBLISHERS" : Red For Publishers.
  /// - "EXCHANGE_MEDIANET" : Media.net.
  /// - "EXCHANGE_TAPJOY" : Tapjoy.
  /// - "EXCHANGE_VISTAR" : Vistar.
  /// - "EXCHANGE_DAX" : DAX.
  /// - "EXCHANGE_JCD" : JCD.
  /// - "EXCHANGE_PLACE_EXCHANGE" : Place Exchange.
  /// - "EXCHANGE_APPLOVIN" : AppLovin.
  /// - "EXCHANGE_CONNATIX" : Connatix.
  /// - "EXCHANGE_RESET_DIGITAL" : Reset Digital.
  /// - "EXCHANGE_HIVESTACK" : Hivestack.
  /// - "EXCHANGE_DRAX" : Drax.
  /// - "EXCHANGE_APPLOVIN_GBID" : AppLovin MAX.
  /// - "EXCHANGE_FYBER_GBID" : DT Fairbid.
  /// - "EXCHANGE_UNITY_GBID" : Unity LevelPlay.
  /// - "EXCHANGE_CHARTBOOST_GBID" : Chartboost Mediation.
  /// - "EXCHANGE_ADMOST_GBID" : AdMost.
  /// - "EXCHANGE_TOPON_GBID" : TopOn.
  /// - "EXCHANGE_NETFLIX" : Netflix.
  /// - "EXCHANGE_CORE" : Core.
  /// - "EXCHANGE_COMMERCE_GRID" : Commerce Grid.
  /// - "EXCHANGE_SPOTIFY" : Spotify.
  /// - "EXCHANGE_TUBI" : Tubi.
  core.String? exchange;

  /// Agency ID of Google Ad Manager.
  ///
  /// The field is only relevant when Google Ad Manager is the enabled exchange.
  ///
  /// Output only.
  core.String? googleAdManagerAgencyId;

  /// Network ID of Google Ad Manager.
  ///
  /// The field is only relevant when Google Ad Manager is the enabled exchange.
  ///
  /// Output only.
  core.String? googleAdManagerBuyerNetworkId;

  /// Seat ID of the enabled exchange.
  ///
  /// Output only.
  core.String? seatId;

  $ExchangeConfigEnabledExchange({
    this.exchange,
    this.googleAdManagerAgencyId,
    this.googleAdManagerBuyerNetworkId,
    this.seatId,
  });

  $ExchangeConfigEnabledExchange.fromJson(core.Map json_)
    : this(
        exchange: json_['exchange'] as core.String?,
        googleAdManagerAgencyId:
            json_['googleAdManagerAgencyId'] as core.String?,
        googleAdManagerBuyerNetworkId:
            json_['googleAdManagerBuyerNetworkId'] as core.String?,
        seatId: json_['seatId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exchange != null) 'exchange': exchange!,
    if (googleAdManagerAgencyId != null)
      'googleAdManagerAgencyId': googleAdManagerAgencyId!,
    if (googleAdManagerBuyerNetworkId != null)
      'googleAdManagerBuyerNetworkId': googleAdManagerBuyerNetworkId!,
    if (seatId != null) 'seatId': seatId!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeCustomTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeCustomTokenRequest
class $ExchangeCustomTokenRequest {
  /// A custom token signed using your project's Admin SDK service account
  /// credentials.
  ///
  /// Required.
  core.String? customToken;

  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  $ExchangeCustomTokenRequest({this.customToken, this.limitedUse});

  $ExchangeCustomTokenRequest.fromJson(core.Map json_)
    : this(
        customToken: json_['customToken'] as core.String?,
        limitedUse: json_['limitedUse'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customToken != null) 'customToken': customToken!,
    if (limitedUse != null) 'limitedUse': limitedUse!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeDebugTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeDebugTokenRequest
class $ExchangeDebugTokenRequest {
  /// A debug token secret.
  ///
  /// This string must match a debug token secret previously created using
  /// CreateDebugToken.
  ///
  /// Required.
  core.String? debugToken;

  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  $ExchangeDebugTokenRequest({this.debugToken, this.limitedUse});

  $ExchangeDebugTokenRequest.fromJson(core.Map json_)
    : this(
        debugToken: json_['debugToken'] as core.String?,
        limitedUse: json_['limitedUse'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (debugToken != null) 'debugToken': debugToken!,
    if (limitedUse != null) 'limitedUse': limitedUse!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeDeviceCheckTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeDeviceCheckTokenRequest
class $ExchangeDeviceCheckTokenRequest {
  /// The `device_token` as returned by Apple's client-side
  /// [DeviceCheck API](https://developer.apple.com/documentation/devicecheck/dcdevice).
  ///
  /// This is the base64 encoded `Data` (Swift) or `NSData` (ObjC) object.
  ///
  /// Required.
  core.String? deviceToken;

  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  $ExchangeDeviceCheckTokenRequest({this.deviceToken, this.limitedUse});

  $ExchangeDeviceCheckTokenRequest.fromJson(core.Map json_)
    : this(
        deviceToken: json_['deviceToken'] as core.String?,
        limitedUse: json_['limitedUse'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceToken != null) 'deviceToken': deviceToken!,
    if (limitedUse != null) 'limitedUse': limitedUse!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangePlayIntegrityTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangePlayIntegrityTokenRequest
class $ExchangePlayIntegrityTokenRequest {
  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  /// The
  /// [integrity verdict response token from Play Integrity](https://developer.android.com/google/play/integrity/verdict#decrypt-verify)
  /// issued to your app.
  ///
  /// Required.
  core.String? playIntegrityToken;

  $ExchangePlayIntegrityTokenRequest({
    this.limitedUse,
    this.playIntegrityToken,
  });

  $ExchangePlayIntegrityTokenRequest.fromJson(core.Map json_)
    : this(
        limitedUse: json_['limitedUse'] as core.bool?,
        playIntegrityToken: json_['playIntegrityToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (limitedUse != null) 'limitedUse': limitedUse!,
    if (playIntegrityToken != null) 'playIntegrityToken': playIntegrityToken!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeRecaptchaEnterpriseTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeRecaptchaEnterpriseTokenRequest
class $ExchangeRecaptchaEnterpriseTokenRequest {
  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  /// The reCAPTCHA token as returned by the
  /// [reCAPTCHA Enterprise JavaScript API](https://cloud.google.com/recaptcha-enterprise/docs/instrument-web-pages).
  ///
  /// Required.
  core.String? recaptchaEnterpriseToken;

  $ExchangeRecaptchaEnterpriseTokenRequest({
    this.limitedUse,
    this.recaptchaEnterpriseToken,
  });

  $ExchangeRecaptchaEnterpriseTokenRequest.fromJson(core.Map json_)
    : this(
        limitedUse: json_['limitedUse'] as core.bool?,
        recaptchaEnterpriseToken:
            json_['recaptchaEnterpriseToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (limitedUse != null) 'limitedUse': limitedUse!,
    if (recaptchaEnterpriseToken != null)
      'recaptchaEnterpriseToken': recaptchaEnterpriseToken!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeRecaptchaV3TokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeRecaptchaV3TokenRequest
class $ExchangeRecaptchaV3TokenRequest {
  /// Specifies whether this attestation is for use in a *limited use* (`true`)
  /// or *session based* (`false`) context.
  ///
  /// To enable this attestation to be used with the *replay protection*
  /// feature, set this to `true`. The default value is `false`.
  core.bool? limitedUse;

  /// The reCAPTCHA token as returned by the
  /// [reCAPTCHA v3 JavaScript API](https://developers.google.com/recaptcha/docs/v3).
  ///
  /// Required.
  core.String? recaptchaV3Token;

  $ExchangeRecaptchaV3TokenRequest({this.limitedUse, this.recaptchaV3Token});

  $ExchangeRecaptchaV3TokenRequest.fromJson(core.Map json_)
    : this(
        limitedUse: json_['limitedUse'] as core.bool?,
        recaptchaV3Token: json_['recaptchaV3Token'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (limitedUse != null) 'limitedUse': limitedUse!,
    if (recaptchaV3Token != null) 'recaptchaV3Token': recaptchaV3Token!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ExchangeReviewStatus
/// - displayvideo:v3 : ExchangeReviewStatus
/// - displayvideo:v4 : ExchangeReviewStatus
class $ExchangeReviewStatus {
  /// The exchange reviewing the creative.
  /// Possible string values are:
  /// - "EXCHANGE_UNSPECIFIED" : Exchange is not specified or is unknown in this
  /// version.
  /// - "EXCHANGE_GOOGLE_AD_MANAGER" : Google Ad Manager.
  /// - "EXCHANGE_APPNEXUS" : AppNexus.
  /// - "EXCHANGE_BRIGHTROLL" : BrightRoll Exchange for Video from Yahoo!.
  /// - "EXCHANGE_ADFORM" : Adform.
  /// - "EXCHANGE_ADMETA" : Admeta.
  /// - "EXCHANGE_ADMIXER" : Admixer.
  /// - "EXCHANGE_ADSMOGO" : AdsMogo.
  /// - "EXCHANGE_ADSWIZZ" : AdsWizz.
  /// - "EXCHANGE_BIDSWITCH" : BidSwitch.
  /// - "EXCHANGE_BRIGHTROLL_DISPLAY" : BrightRoll Exchange for Display from
  /// Yahoo!.
  /// - "EXCHANGE_CADREON" : Cadreon.
  /// - "EXCHANGE_DAILYMOTION" : Dailymotion.
  /// - "EXCHANGE_FIVE" : Five.
  /// - "EXCHANGE_FLUCT" : Fluct.
  /// - "EXCHANGE_FREEWHEEL" : FreeWheel SSP.
  /// - "EXCHANGE_GENIEE" : Geniee.
  /// - "EXCHANGE_GUMGUM" : GumGum.
  /// - "EXCHANGE_IMOBILE" : i-mobile.
  /// - "EXCHANGE_IBILLBOARD" : iBILLBOARD.
  /// - "EXCHANGE_IMPROVE_DIGITAL" : Improve Digital.
  /// - "EXCHANGE_INDEX" : Index Exchange.
  /// - "EXCHANGE_KARGO" : Kargo.
  /// - "EXCHANGE_MICROAD" : MicroAd.
  /// - "EXCHANGE_MOPUB" : MoPub.
  /// - "EXCHANGE_NEND" : Nend.
  /// - "EXCHANGE_ONE_BY_AOL_DISPLAY" : ONE by AOL: Display Market Place.
  /// - "EXCHANGE_ONE_BY_AOL_MOBILE" : ONE by AOL: Mobile.
  /// - "EXCHANGE_ONE_BY_AOL_VIDEO" : ONE by AOL: Video.
  /// - "EXCHANGE_OOYALA" : Ooyala.
  /// - "EXCHANGE_OPENX" : OpenX.
  /// - "EXCHANGE_PERMODO" : Permodo.
  /// - "EXCHANGE_PLATFORMONE" : Platform One.
  /// - "EXCHANGE_PLATFORMID" : PlatformId.
  /// - "EXCHANGE_PUBMATIC" : PubMatic.
  /// - "EXCHANGE_PULSEPOINT" : PulsePoint.
  /// - "EXCHANGE_REVENUEMAX" : RevenueMax.
  /// - "EXCHANGE_RUBICON" : Rubicon.
  /// - "EXCHANGE_SMARTCLIP" : SmartClip.
  /// - "EXCHANGE_SMARTRTB" : SmartRTB+.
  /// - "EXCHANGE_SMARTSTREAMTV" : SmartstreamTv.
  /// - "EXCHANGE_SOVRN" : Sovrn.
  /// - "EXCHANGE_SPOTXCHANGE" : SpotXchange.
  /// - "EXCHANGE_STROER" : Strer SSP.
  /// - "EXCHANGE_TEADSTV" : TeadsTv.
  /// - "EXCHANGE_TELARIA" : Telaria.
  /// - "EXCHANGE_TVN" : TVN.
  /// - "EXCHANGE_UNITED" : United.
  /// - "EXCHANGE_YIELDLAB" : Yieldlab.
  /// - "EXCHANGE_YIELDMO" : Yieldmo.
  /// - "EXCHANGE_UNRULYX" : UnrulyX.
  /// - "EXCHANGE_OPEN8" : Open8.
  /// - "EXCHANGE_TRITON" : Triton.
  /// - "EXCHANGE_TRIPLELIFT" : TripleLift.
  /// - "EXCHANGE_TABOOLA" : Taboola.
  /// - "EXCHANGE_INMOBI" : InMobi.
  /// - "EXCHANGE_SMAATO" : Smaato.
  /// - "EXCHANGE_AJA" : Aja.
  /// - "EXCHANGE_SUPERSHIP" : Supership.
  /// - "EXCHANGE_NEXSTAR_DIGITAL" : Nexstar Digital.
  /// - "EXCHANGE_WAZE" : Waze.
  /// - "EXCHANGE_SOUNDCAST" : SoundCast.
  /// - "EXCHANGE_SHARETHROUGH" : Sharethrough.
  /// - "EXCHANGE_FYBER" : Fyber.
  /// - "EXCHANGE_RED_FOR_PUBLISHERS" : Red For Publishers.
  /// - "EXCHANGE_MEDIANET" : Media.net.
  /// - "EXCHANGE_TAPJOY" : Tapjoy.
  /// - "EXCHANGE_VISTAR" : Vistar.
  /// - "EXCHANGE_DAX" : DAX.
  /// - "EXCHANGE_JCD" : JCD.
  /// - "EXCHANGE_PLACE_EXCHANGE" : Place Exchange.
  /// - "EXCHANGE_APPLOVIN" : AppLovin.
  /// - "EXCHANGE_CONNATIX" : Connatix.
  /// - "EXCHANGE_RESET_DIGITAL" : Reset Digital.
  /// - "EXCHANGE_HIVESTACK" : Hivestack.
  /// - "EXCHANGE_DRAX" : Drax.
  /// - "EXCHANGE_APPLOVIN_GBID" : AppLovin MAX.
  /// - "EXCHANGE_FYBER_GBID" : DT Fairbid.
  /// - "EXCHANGE_UNITY_GBID" : Unity LevelPlay.
  /// - "EXCHANGE_CHARTBOOST_GBID" : Chartboost Mediation.
  /// - "EXCHANGE_ADMOST_GBID" : AdMost.
  /// - "EXCHANGE_TOPON_GBID" : TopOn.
  /// - "EXCHANGE_NETFLIX" : Netflix.
  /// - "EXCHANGE_CORE" : Core.
  /// - "EXCHANGE_COMMERCE_GRID" : Commerce Grid.
  /// - "EXCHANGE_SPOTIFY" : Spotify.
  /// - "EXCHANGE_TUBI" : Tubi.
  core.String? exchange;

  /// Status of the exchange review.
  /// Possible string values are:
  /// - "REVIEW_STATUS_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "REVIEW_STATUS_APPROVED" : The creative is approved.
  /// - "REVIEW_STATUS_REJECTED" : The creative is rejected.
  /// - "REVIEW_STATUS_PENDING" : The creative is pending review.
  core.String? status;

  $ExchangeReviewStatus({this.exchange, this.status});

  $ExchangeReviewStatus.fromJson(core.Map json_)
    : this(
        exchange: json_['exchange'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exchange != null) 'exchange': exchange!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1ExchangeSafetyNetTokenRequest
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaExchangeSafetyNetTokenRequest
class $ExchangeSafetyNetTokenRequest {
  /// The
  /// [SafetyNet attestation response](https://developer.android.com/training/safetynet/attestation#request-attestation-step)
  /// issued to your app.
  ///
  /// Required.
  core.String? safetyNetToken;

  $ExchangeSafetyNetTokenRequest({this.safetyNetToken});

  $ExchangeSafetyNetTokenRequest.fromJson(core.Map json_)
    : this(safetyNetToken: json_['safetyNetToken'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (safetyNetToken != null) 'safetyNetToken': safetyNetToken!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ExchangeTargetingOptionDetails
/// - displayvideo:v3 : ExchangeTargetingOptionDetails
/// - displayvideo:v4 : ExchangeTargetingOptionDetails
class $ExchangeTargetingOptionDetails {
  /// The type of exchange.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EXCHANGE_UNSPECIFIED" : Exchange is not specified or is unknown in this
  /// version.
  /// - "EXCHANGE_GOOGLE_AD_MANAGER" : Google Ad Manager.
  /// - "EXCHANGE_APPNEXUS" : AppNexus.
  /// - "EXCHANGE_BRIGHTROLL" : BrightRoll Exchange for Video from Yahoo!.
  /// - "EXCHANGE_ADFORM" : Adform.
  /// - "EXCHANGE_ADMETA" : Admeta.
  /// - "EXCHANGE_ADMIXER" : Admixer.
  /// - "EXCHANGE_ADSMOGO" : AdsMogo.
  /// - "EXCHANGE_ADSWIZZ" : AdsWizz.
  /// - "EXCHANGE_BIDSWITCH" : BidSwitch.
  /// - "EXCHANGE_BRIGHTROLL_DISPLAY" : BrightRoll Exchange for Display from
  /// Yahoo!.
  /// - "EXCHANGE_CADREON" : Cadreon.
  /// - "EXCHANGE_DAILYMOTION" : Dailymotion.
  /// - "EXCHANGE_FIVE" : Five.
  /// - "EXCHANGE_FLUCT" : Fluct.
  /// - "EXCHANGE_FREEWHEEL" : FreeWheel SSP.
  /// - "EXCHANGE_GENIEE" : Geniee.
  /// - "EXCHANGE_GUMGUM" : GumGum.
  /// - "EXCHANGE_IMOBILE" : i-mobile.
  /// - "EXCHANGE_IBILLBOARD" : iBILLBOARD.
  /// - "EXCHANGE_IMPROVE_DIGITAL" : Improve Digital.
  /// - "EXCHANGE_INDEX" : Index Exchange.
  /// - "EXCHANGE_KARGO" : Kargo.
  /// - "EXCHANGE_MICROAD" : MicroAd.
  /// - "EXCHANGE_MOPUB" : MoPub.
  /// - "EXCHANGE_NEND" : Nend.
  /// - "EXCHANGE_ONE_BY_AOL_DISPLAY" : ONE by AOL: Display Market Place.
  /// - "EXCHANGE_ONE_BY_AOL_MOBILE" : ONE by AOL: Mobile.
  /// - "EXCHANGE_ONE_BY_AOL_VIDEO" : ONE by AOL: Video.
  /// - "EXCHANGE_OOYALA" : Ooyala.
  /// - "EXCHANGE_OPENX" : OpenX.
  /// - "EXCHANGE_PERMODO" : Permodo.
  /// - "EXCHANGE_PLATFORMONE" : Platform One.
  /// - "EXCHANGE_PLATFORMID" : PlatformId.
  /// - "EXCHANGE_PUBMATIC" : PubMatic.
  /// - "EXCHANGE_PULSEPOINT" : PulsePoint.
  /// - "EXCHANGE_REVENUEMAX" : RevenueMax.
  /// - "EXCHANGE_RUBICON" : Rubicon.
  /// - "EXCHANGE_SMARTCLIP" : SmartClip.
  /// - "EXCHANGE_SMARTRTB" : SmartRTB+.
  /// - "EXCHANGE_SMARTSTREAMTV" : SmartstreamTv.
  /// - "EXCHANGE_SOVRN" : Sovrn.
  /// - "EXCHANGE_SPOTXCHANGE" : SpotXchange.
  /// - "EXCHANGE_STROER" : Strer SSP.
  /// - "EXCHANGE_TEADSTV" : TeadsTv.
  /// - "EXCHANGE_TELARIA" : Telaria.
  /// - "EXCHANGE_TVN" : TVN.
  /// - "EXCHANGE_UNITED" : United.
  /// - "EXCHANGE_YIELDLAB" : Yieldlab.
  /// - "EXCHANGE_YIELDMO" : Yieldmo.
  /// - "EXCHANGE_UNRULYX" : UnrulyX.
  /// - "EXCHANGE_OPEN8" : Open8.
  /// - "EXCHANGE_TRITON" : Triton.
  /// - "EXCHANGE_TRIPLELIFT" : TripleLift.
  /// - "EXCHANGE_TABOOLA" : Taboola.
  /// - "EXCHANGE_INMOBI" : InMobi.
  /// - "EXCHANGE_SMAATO" : Smaato.
  /// - "EXCHANGE_AJA" : Aja.
  /// - "EXCHANGE_SUPERSHIP" : Supership.
  /// - "EXCHANGE_NEXSTAR_DIGITAL" : Nexstar Digital.
  /// - "EXCHANGE_WAZE" : Waze.
  /// - "EXCHANGE_SOUNDCAST" : SoundCast.
  /// - "EXCHANGE_SHARETHROUGH" : Sharethrough.
  /// - "EXCHANGE_FYBER" : Fyber.
  /// - "EXCHANGE_RED_FOR_PUBLISHERS" : Red For Publishers.
  /// - "EXCHANGE_MEDIANET" : Media.net.
  /// - "EXCHANGE_TAPJOY" : Tapjoy.
  /// - "EXCHANGE_VISTAR" : Vistar.
  /// - "EXCHANGE_DAX" : DAX.
  /// - "EXCHANGE_JCD" : JCD.
  /// - "EXCHANGE_PLACE_EXCHANGE" : Place Exchange.
  /// - "EXCHANGE_APPLOVIN" : AppLovin.
  /// - "EXCHANGE_CONNATIX" : Connatix.
  /// - "EXCHANGE_RESET_DIGITAL" : Reset Digital.
  /// - "EXCHANGE_HIVESTACK" : Hivestack.
  /// - "EXCHANGE_DRAX" : Drax.
  /// - "EXCHANGE_APPLOVIN_GBID" : AppLovin MAX.
  /// - "EXCHANGE_FYBER_GBID" : DT Fairbid.
  /// - "EXCHANGE_UNITY_GBID" : Unity LevelPlay.
  /// - "EXCHANGE_CHARTBOOST_GBID" : Chartboost Mediation.
  /// - "EXCHANGE_ADMOST_GBID" : AdMost.
  /// - "EXCHANGE_TOPON_GBID" : TopOn.
  /// - "EXCHANGE_NETFLIX" : Netflix.
  /// - "EXCHANGE_CORE" : Core.
  /// - "EXCHANGE_COMMERCE_GRID" : Commerce Grid.
  /// - "EXCHANGE_SPOTIFY" : Spotify.
  /// - "EXCHANGE_TUBI" : Tubi.
  core.String? exchange;

  $ExchangeTargetingOptionDetails({this.exchange});

  $ExchangeTargetingOptionDetails.fromJson(core.Map json_)
    : this(exchange: json_['exchange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (exchange != null) 'exchange': exchange!,
  };
}

/// Used by:
///
/// - compute:alpha : ExchangedPeeringRoute
/// - compute:beta : ExchangedPeeringRoute
/// - compute:v1 : ExchangedPeeringRoute
class $ExchangedPeeringRoute {
  /// The destination range of the route.
  core.String? destRange;

  /// True if the peering route has been imported from a peer.
  ///
  /// The actual import happens if the field networkPeering.importCustomRoutes
  /// is true for this network, and networkPeering.exportCustomRoutes is true
  /// for the peer network, and the import does not result in a route conflict.
  core.bool? imported;

  /// The region of peering route next hop, only applies to dynamic routes.
  core.String? nextHopRegion;

  /// The priority of the peering route.
  core.int? priority;

  /// The type of the peering route.
  /// Possible string values are:
  /// - "DYNAMIC_PEERING_ROUTE" : For routes exported from local network.
  /// - "STATIC_PEERING_ROUTE" : The peering route.
  /// - "SUBNET_PEERING_ROUTE" : The peering route corresponding to subnetwork
  /// range.
  core.String? type;

  $ExchangedPeeringRoute({
    this.destRange,
    this.imported,
    this.nextHopRegion,
    this.priority,
    this.type,
  });

  $ExchangedPeeringRoute.fromJson(core.Map json_)
    : this(
        destRange: json_['destRange'] as core.String?,
        imported: json_['imported'] as core.bool?,
        nextHopRegion: json_['nextHopRegion'] as core.String?,
        priority: json_['priority'] as core.int?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destRange != null) 'destRange': destRange!,
    if (imported != null) 'imported': imported!,
    if (nextHopRegion != null) 'nextHopRegion': nextHopRegion!,
    if (priority != null) 'priority': priority!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ProbeExecAction
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ProbeExecAction
/// - run:v1 : ExecAction
class $ExecAction {
  /// Command is the command line to execute inside the container, the working
  /// directory for the command is root ('/') in the container's filesystem.
  ///
  /// The command is simply exec'd, it is not run inside a shell, so traditional
  /// shell instructions ('|', etc) won't work. To use a shell, you need to
  /// explicitly call out to that shell. Exit status of 0 is treated as
  /// live/healthy and non-zero is unhealthy.
  core.List<core.String>? command;

  $ExecAction({this.command});

  $ExecAction.fromJson(core.Map json_)
    : this(
        command:
            (json_['command'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (command != null) 'command': command!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExecutableCode
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExecutableCode
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ExecutableCode
class $ExecutableCode {
  /// The code to be executed.
  ///
  /// Required.
  core.String? code;

  /// Programming language of the `code`.
  ///
  /// Required.
  /// Possible string values are:
  /// - "LANGUAGE_UNSPECIFIED" : Unspecified language. This value should not be
  /// used.
  /// - "PYTHON" : Python \>= 3.10, with numpy and simpy available.
  core.String? language;

  $ExecutableCode({this.code, this.language});

  $ExecutableCode.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        language: json_['language'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (language != null) 'language': language!,
  };
}

/// Used by:
///
/// - composer:v1 : ExecuteAirflowCommandRequest
/// - composer:v1beta1 : ExecuteAirflowCommandRequest
class $ExecuteAirflowCommandRequest {
  /// Airflow command.
  core.String? command;

  /// Parameters for the Airflow command/subcommand as an array of arguments.
  ///
  /// It may contain positional arguments like `["my-dag-id"]`, key-value
  /// parameters like `["--foo=bar"]` or `["--foo","bar"]`, or other flags like
  /// `["-f"]`.
  core.List<core.String>? parameters;

  /// Airflow subcommand.
  core.String? subcommand;

  $ExecuteAirflowCommandRequest({
    this.command,
    this.parameters,
    this.subcommand,
  });

  $ExecuteAirflowCommandRequest.fromJson(core.Map json_)
    : this(
        command: json_['command'] as core.String?,
        parameters:
            (json_['parameters'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subcommand: json_['subcommand'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (command != null) 'command': command!,
    if (parameters != null) 'parameters': parameters!,
    if (subcommand != null) 'subcommand': subcommand!,
  };
}

/// Used by:
///
/// - composer:v1 : ExecuteAirflowCommandResponse
/// - composer:v1beta1 : ExecuteAirflowCommandResponse
class $ExecuteAirflowCommandResponse {
  /// Error message.
  ///
  /// Empty if there was no error.
  core.String? error;

  /// The unique ID of the command execution for polling.
  core.String? executionId;

  /// The name of the pod where the command is executed.
  core.String? pod;

  /// The namespace of the pod where the command is executed.
  core.String? podNamespace;

  $ExecuteAirflowCommandResponse({
    this.error,
    this.executionId,
    this.pod,
    this.podNamespace,
  });

  $ExecuteAirflowCommandResponse.fromJson(core.Map json_)
    : this(
        error: json_['error'] as core.String?,
        executionId: json_['executionId'] as core.String?,
        pod: json_['pod'] as core.String?,
        podNamespace: json_['podNamespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (executionId != null) 'executionId': executionId!,
    if (pod != null) 'pod': pod!,
    if (podNamespace != null) 'podNamespace': podNamespace!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Execution
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Execution
class $Execution {
  /// Timestamp when this Execution was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Execution
  core.String? description;

  /// User provided display name of the Execution.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Executions.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Execution (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Execution.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Execution.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in `schema_title` to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Execution.
  ///
  /// This is a property of the Execution, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines) and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Execution state
  /// - "NEW" : The Execution is new
  /// - "RUNNING" : The Execution is running
  /// - "COMPLETE" : The Execution has finished running
  /// - "FAILED" : The Execution has failed
  /// - "CACHED" : The Execution completed through Cache hit.
  /// - "CANCELLED" : The Execution was cancelled.
  core.String? state;

  /// Timestamp when this Execution was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Execution({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
  });

  $Execution.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        schemaTitle: json_['schemaTitle'] as core.String?,
        schemaVersion: json_['schemaVersion'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (schemaTitle != null) 'schemaTitle': schemaTitle!,
    if (schemaVersion != null) 'schemaVersion': schemaVersion!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - datastore:v1 : ExecutionStats
/// - datastore:v1beta3 : ExecutionStats
/// - firestore:v1 : ExecutionStats
/// - firestore:v1beta1 : ExecutionStats
class $ExecutionStats {
  /// Debugging statistics from the execution of the query.
  ///
  /// Note that the debugging stats are subject to change as Firestore evolves.
  /// It could include: { "indexes_entries_scanned": "1000",
  /// "documents_scanned": "20", "billing_details" : { "documents_billable":
  /// "20", "index_entries_billable": "1000", "min_query_cost": "0" } }
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? debugStats;

  /// Total time to execute the query in the backend.
  core.String? executionDuration;

  /// Total billable read operations.
  core.String? readOperations;

  /// Total number of results returned, including documents, projections,
  /// aggregation results, keys.
  core.String? resultsReturned;

  $ExecutionStats({
    this.debugStats,
    this.executionDuration,
    this.readOperations,
    this.resultsReturned,
  });

  $ExecutionStats.fromJson(core.Map json_)
    : this(
        debugStats:
            json_.containsKey('debugStats')
                ? json_['debugStats'] as core.Map<core.String, core.dynamic>
                : null,
        executionDuration: json_['executionDuration'] as core.String?,
        readOperations: json_['readOperations'] as core.String?,
        resultsReturned: json_['resultsReturned'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (debugStats != null) 'debugStats': debugStats!,
    if (executionDuration != null) 'executionDuration': executionDuration!,
    if (readOperations != null) 'readOperations': readOperations!,
    if (resultsReturned != null) 'resultsReturned': resultsReturned!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiDistributionExemplar
/// - discoveryengine:v1beta : GoogleApiDistributionExemplar
/// - servicecontrol:v1 : Exemplar
class $Exemplar {
  /// Contextual information about the example value.
  ///
  /// Examples are: Trace: type.googleapis.com/google.monitoring.v3.SpanContext
  /// Literal string: type.googleapis.com/google.protobuf.StringValue Labels
  /// dropped during aggregation:
  /// type.googleapis.com/google.monitoring.v3.DroppedLabels There may be only a
  /// single attachment of any given message type in a single exemplar, and this
  /// is enforced by the system.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? attachments;

  /// The observation (sampling) time of the above value.
  core.String? timestamp;

  /// Value of the exemplar point.
  ///
  /// This value determines to which bucket the exemplar belongs.
  core.double? value;

  $Exemplar({this.attachments, this.timestamp, this.value});

  $Exemplar.fromJson(core.Map json_)
    : this(
        attachments:
            (json_['attachments'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        timestamp: json_['timestamp'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachments != null) 'attachments': attachments!,
    if (timestamp != null) 'timestamp': timestamp!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ExitEvent
/// - displayvideo:v3 : ExitEvent
/// - displayvideo:v4 : ExitEvent
class $ExitEvent {
  /// The name of the click tag of the exit event.
  ///
  /// The name must be unique within one creative. Leave it empty or unset for
  /// creatives containing image assets only.
  ///
  /// Optional.
  core.String? name;

  /// The name used to identify this event in reports.
  ///
  /// Leave it empty or unset for creatives containing image assets only.
  ///
  /// Optional.
  core.String? reportingName;

  /// The type of the exit event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "EXIT_EVENT_TYPE_UNSPECIFIED" : Exit event type is not specified or is
  /// unknown in this version.
  /// - "EXIT_EVENT_TYPE_DEFAULT" : The exit event is the default one.
  /// - "EXIT_EVENT_TYPE_BACKUP" : The exit event is a backup exit event. There
  /// could be multiple backup exit events in a creative.
  core.String? type;

  /// The click through URL of the exit event.
  ///
  /// This is required when type is: * `EXIT_EVENT_TYPE_DEFAULT` *
  /// `EXIT_EVENT_TYPE_BACKUP`
  ///
  /// Required.
  core.String? url;

  $ExitEvent({this.name, this.reportingName, this.type, this.url});

  $ExitEvent.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        reportingName: json_['reportingName'] as core.String?,
        type: json_['type'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (reportingName != null) 'reportingName': reportingName!,
    if (type != null) 'type': type!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - composer:v1 : ExitInfo
/// - composer:v1beta1 : ExitInfo
class $ExitInfo {
  /// Error message.
  ///
  /// Empty if there was no error.
  core.String? error;

  /// The exit code from the command execution.
  core.int? exitCode;

  $ExitInfo({this.error, this.exitCode});

  $ExitInfo.fromJson(core.Map json_)
    : this(
        error: json_['error'] as core.String?,
        exitCode: json_['exitCode'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (exitCode != null) 'exitCode': exitCode!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ExperimentInfoServingConfigExperiment
/// - retail:v2alpha : GoogleCloudRetailV2alphaExperimentInfoServingConfigExperiment
/// - retail:v2beta : GoogleCloudRetailV2betaExperimentInfoServingConfigExperiment
class $ExperimentInfoServingConfigExperiment {
  /// The fully qualified resource name of the serving config
  /// `Experiment.VariantArm.serving_config_id` responsible for generating the
  /// search response.
  ///
  /// For example: `projects / * /locations / * /catalogs / * /servingConfigs /
  /// * `.
  core.String? experimentServingConfig;

  /// The fully qualified resource name of the original SearchRequest.placement
  /// in the search request prior to reassignment by experiment API.
  ///
  /// For example: `projects / * /locations / * /catalogs / * /servingConfigs /
  /// * `.
  core.String? originalServingConfig;

  $ExperimentInfoServingConfigExperiment({
    this.experimentServingConfig,
    this.originalServingConfig,
  });

  $ExperimentInfoServingConfigExperiment.fromJson(core.Map json_)
    : this(
        experimentServingConfig:
            json_['experimentServingConfig'] as core.String?,
        originalServingConfig: json_['originalServingConfig'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (experimentServingConfig != null)
      'experimentServingConfig': experimentServingConfig!,
    if (originalServingConfig != null)
      'originalServingConfig': originalServingConfig!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExperimentResultConfidenceInterval
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExperimentResultConfidenceInterval
class $ExperimentResultConfidenceInterval {
  /// The confidence level used to construct the interval, i.e. there is X%
  /// chance that the true value is within this interval.
  core.double? confidenceLevel;

  /// Lower bound of the interval.
  core.double? lowerBound;

  /// The percent change between an experiment metric's value and the value for
  /// its control.
  core.double? ratio;

  /// Upper bound of the interval.
  core.double? upperBound;

  $ExperimentResultConfidenceInterval({
    this.confidenceLevel,
    this.lowerBound,
    this.ratio,
    this.upperBound,
  });

  $ExperimentResultConfidenceInterval.fromJson(core.Map json_)
    : this(
        confidenceLevel: (json_['confidenceLevel'] as core.num?)?.toDouble(),
        lowerBound: (json_['lowerBound'] as core.num?)?.toDouble(),
        ratio: (json_['ratio'] as core.num?)?.toDouble(),
        upperBound: (json_['upperBound'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidenceLevel != null) 'confidenceLevel': confidenceLevel!,
    if (lowerBound != null) 'lowerBound': lowerBound!,
    if (ratio != null) 'ratio': ratio!,
    if (upperBound != null) 'upperBound': upperBound!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : Expiration
/// - vmmigration:v1alpha1 : Expiration
class $Expiration {
  /// Timestamp of when this resource is considered expired.
  ///
  /// Output only.
  core.String? expireTime;

  /// Describes whether the expiration can be extended.
  ///
  /// Output only.
  core.bool? extendable;

  /// The number of times expiration was extended.
  ///
  /// Output only.
  core.int? extensionCount;

  $Expiration({this.expireTime, this.extendable, this.extensionCount});

  $Expiration.fromJson(core.Map json_)
    : this(
        expireTime: json_['expireTime'] as core.String?,
        extendable: json_['extendable'] as core.bool?,
        extensionCount: json_['extensionCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expireTime != null) 'expireTime': expireTime!,
    if (extendable != null) 'extendable': extendable!,
    if (extensionCount != null) 'extensionCount': extensionCount!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : ExpirationPolicy
/// - pubsub:v1 : ExpirationPolicy
class $ExpirationPolicy {
  /// Specifies the "time-to-live" duration for an associated resource.
  ///
  /// The resource expires if it is not active for a period of `ttl`. The
  /// definition of "activity" depends on the type of the associated resource.
  /// The minimum and maximum allowed values for `ttl` depend on the type of the
  /// associated resource, as well. If `ttl` is not set, the associated resource
  /// never expires.
  ///
  /// Optional.
  core.String? ttl;

  $ExpirationPolicy({this.ttl});

  $ExpirationPolicy.fromJson(core.Map json_)
    : this(ttl: json_['ttl'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : ExpiryDetail
/// - cloudidentity:v1beta1 : ExpiryDetail
class $ExpiryDetail {
  /// The time at which the `MembershipRole` will expire.
  core.String? expireTime;

  $ExpiryDetail({this.expireTime});

  $ExpiryDetail.fromJson(core.Map json_)
    : this(expireTime: json_['expireTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (expireTime != null) 'expireTime': expireTime!,
  };
}

/// Used by:
///
/// - datastore:v1 : ExplainOptions
/// - datastore:v1beta3 : ExplainOptions
/// - firestore:v1 : ExplainOptions
/// - firestore:v1beta1 : ExplainOptions
class $ExplainOptions {
  /// Whether to execute this query.
  ///
  /// When false (the default), the query will be planned, returning only
  /// metrics from the planning stages. When true, the query will be planned and
  /// executed, returning the full query results along with both planning and
  /// execution stage metrics.
  ///
  /// Optional.
  core.bool? analyze;

  $ExplainOptions({this.analyze});

  $ExplainOptions.fromJson(core.Map json_)
    : this(analyze: json_['analyze'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (analyze != null) 'analyze': analyze!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataFeatureValueDomain
class $ExplanationMetadataInputMetadataFeatureValueDomain {
  /// The maximum permissible value for this feature.
  core.double? maxValue;

  /// The minimum permissible value for this feature.
  core.double? minValue;

  /// If this input feature has been normalized to a mean value of 0, the
  /// original_mean specifies the mean value of the domain prior to
  /// normalization.
  core.double? originalMean;

  /// If this input feature has been normalized to a standard deviation of 1.0,
  /// the original_stddev specifies the standard deviation of the domain prior
  /// to normalization.
  core.double? originalStddev;

  $ExplanationMetadataInputMetadataFeatureValueDomain({
    this.maxValue,
    this.minValue,
    this.originalMean,
    this.originalStddev,
  });

  $ExplanationMetadataInputMetadataFeatureValueDomain.fromJson(core.Map json_)
    : this(
        maxValue: (json_['maxValue'] as core.num?)?.toDouble(),
        minValue: (json_['minValue'] as core.num?)?.toDouble(),
        originalMean: (json_['originalMean'] as core.num?)?.toDouble(),
        originalStddev: (json_['originalStddev'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
    if (originalMean != null) 'originalMean': originalMean!,
    if (originalStddev != null) 'originalStddev': originalStddev!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataVisualization
class $ExplanationMetadataInputMetadataVisualization {
  /// Excludes attributions below the specified percentile, from the highlighted
  /// areas.
  ///
  /// Defaults to 62.
  core.double? clipPercentLowerbound;

  /// Excludes attributions above the specified percentile from the highlighted
  /// areas.
  ///
  /// Using the clip_percent_upperbound and clip_percent_lowerbound together can
  /// be useful for filtering out noise and making it easier to see areas of
  /// strong attribution. Defaults to 99.9.
  core.double? clipPercentUpperbound;

  /// The color scheme used for the highlighted areas.
  ///
  /// Defaults to PINK_GREEN for Integrated Gradients attribution, which shows
  /// positive attributions in green and negative in pink. Defaults to VIRIDIS
  /// for XRAI attribution, which highlights the most influential regions in
  /// yellow and the least influential in blue.
  /// Possible string values are:
  /// - "COLOR_MAP_UNSPECIFIED" : Should not be used.
  /// - "PINK_GREEN" : Positive: green. Negative: pink.
  /// - "VIRIDIS" : Viridis color map: A perceptually uniform color mapping
  /// which is easier to see by those with colorblindness and progresses from
  /// yellow to green to blue. Positive: yellow. Negative: blue.
  /// - "RED" : Positive: red. Negative: red.
  /// - "GREEN" : Positive: green. Negative: green.
  /// - "RED_GREEN" : Positive: green. Negative: red.
  /// - "PINK_WHITE_GREEN" : PiYG palette.
  core.String? colorMap;

  /// How the original image is displayed in the visualization.
  ///
  /// Adjusting the overlay can help increase visual clarity if the original
  /// image makes it difficult to view the visualization. Defaults to NONE.
  /// Possible string values are:
  /// - "OVERLAY_TYPE_UNSPECIFIED" : Default value. This is the same as NONE.
  /// - "NONE" : No overlay.
  /// - "ORIGINAL" : The attributions are shown on top of the original image.
  /// - "GRAYSCALE" : The attributions are shown on top of grayscaled version of
  /// the original image.
  /// - "MASK_BLACK" : The attributions are used as a mask to reveal predictive
  /// parts of the image and hide the un-predictive parts.
  core.String? overlayType;

  /// Whether to only highlight pixels with positive contributions, negative or
  /// both.
  ///
  /// Defaults to POSITIVE.
  /// Possible string values are:
  /// - "POLARITY_UNSPECIFIED" : Default value. This is the same as POSITIVE.
  /// - "POSITIVE" : Highlights the pixels/outlines that were most influential
  /// to the model's prediction.
  /// - "NEGATIVE" : Setting polarity to negative highlights areas that does not
  /// lead to the models's current prediction.
  /// - "BOTH" : Shows both positive and negative attributions.
  core.String? polarity;

  /// Type of the image visualization.
  ///
  /// Only applicable to Integrated Gradients attribution. OUTLINES shows
  /// regions of attribution, while PIXELS shows per-pixel attribution. Defaults
  /// to OUTLINES.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Should not be used.
  /// - "PIXELS" : Shows which pixel contributed to the image prediction.
  /// - "OUTLINES" : Shows which region contributed to the image prediction by
  /// outlining the region.
  core.String? type;

  $ExplanationMetadataInputMetadataVisualization({
    this.clipPercentLowerbound,
    this.clipPercentUpperbound,
    this.colorMap,
    this.overlayType,
    this.polarity,
    this.type,
  });

  $ExplanationMetadataInputMetadataVisualization.fromJson(core.Map json_)
    : this(
        clipPercentLowerbound:
            (json_['clipPercentLowerbound'] as core.num?)?.toDouble(),
        clipPercentUpperbound:
            (json_['clipPercentUpperbound'] as core.num?)?.toDouble(),
        colorMap: json_['colorMap'] as core.String?,
        overlayType: json_['overlayType'] as core.String?,
        polarity: json_['polarity'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clipPercentLowerbound != null)
      'clipPercentLowerbound': clipPercentLowerbound!,
    if (clipPercentUpperbound != null)
      'clipPercentUpperbound': clipPercentUpperbound!,
    if (colorMap != null) 'colorMap': colorMap!,
    if (overlayType != null) 'overlayType': overlayType!,
    if (polarity != null) 'polarity': polarity!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExplanationMetadataOutputMetadata
class $ExplanationMetadataOutputMetadata {
  /// Specify a field name in the prediction to look for the display name.
  ///
  /// Use this if the prediction contains the display names for the outputs. The
  /// display names in the prediction must have the same shape of the outputs,
  /// so that it can be located by Attribution.output_index for a specific
  /// output.
  core.String? displayNameMappingKey;

  /// Static mapping between the index and display name.
  ///
  /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
  /// list of scores of all the classes in a pre-defined order for a
  /// multi-classification Model. It's not feasible if the outputs are
  /// non-deterministic, e.g. the Model produces top-k classes or sort the
  /// outputs by their values. The shape of the value must be an n-dimensional
  /// array of strings. The number of dimensions must match that of the outputs
  /// to be explained. The Attribution.output_display_name is populated by
  /// locating in the mapping with Attribution.output_index.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? indexDisplayNameMapping;

  /// Name of the output tensor.
  ///
  /// Required and is only applicable to Vertex AI provided images for
  /// Tensorflow.
  core.String? outputTensorName;

  $ExplanationMetadataOutputMetadata({
    this.displayNameMappingKey,
    this.indexDisplayNameMapping,
    this.outputTensorName,
  });

  $ExplanationMetadataOutputMetadata.fromJson(core.Map json_)
    : this(
        displayNameMappingKey: json_['displayNameMappingKey'] as core.String?,
        indexDisplayNameMapping: json_['indexDisplayNameMapping'],
        outputTensorName: json_['outputTensorName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayNameMappingKey != null)
      'displayNameMappingKey': displayNameMappingKey!,
    if (indexDisplayNameMapping != null)
      'indexDisplayNameMapping': indexDisplayNameMapping!,
    if (outputTensorName != null) 'outputTensorName': outputTensorName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExplanationMetadataOverrideInputMetadataOverride
class $ExplanationMetadataOverrideInputMetadataOverride {
  /// Baseline inputs for this feature.
  ///
  /// This overrides the `input_baseline` field of the
  /// ExplanationMetadata.InputMetadata object of the corresponding feature's
  /// input metadata. If it's not specified, the original baselines are not
  /// overridden.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  $ExplanationMetadataOverrideInputMetadataOverride({this.inputBaselines});

  $ExplanationMetadataOverrideInputMetadataOverride.fromJson(core.Map json_)
    : this(
        inputBaselines:
            json_.containsKey('inputBaselines')
                ? json_['inputBaselines'] as core.List
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputBaselines != null) 'inputBaselines': inputBaselines!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiDistributionBucketOptionsExplicit
/// - discoveryengine:v1beta : GoogleApiDistributionBucketOptionsExplicit
/// - logging:v2 : Explicit
/// - monitoring:v3 : Explicit
class $Explicit {
  /// The values must be monotonically increasing.
  core.List<core.double>? bounds;

  $Explicit({this.bounds});

  $Explicit.fromJson(core.Map json_)
    : this(
        bounds:
            (json_['bounds'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bounds != null) 'bounds': bounds!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_ExplicitContentDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_ExplicitContentDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_ExplicitContentDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_ExplicitContentDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_ExplicitContentDetectionConfig
class $ExplicitContentDetectionConfig {
  /// Model to use for explicit content detection.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest".
  core.String? model;

  $ExplicitContentDetectionConfig({this.model});

  $ExplicitContentDetectionConfig.fromJson(core.Map json_)
    : this(model: json_['model'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiDistributionBucketOptionsExponential
/// - discoveryengine:v1beta : GoogleApiDistributionBucketOptionsExponential
/// - logging:v2 : Exponential
/// - monitoring:v3 : Exponential
class $Exponential {
  /// Must be greater than 1.
  core.double? growthFactor;

  /// Must be greater than 0.
  core.int? numFiniteBuckets;

  /// Must be greater than 0.
  core.double? scale;

  $Exponential({this.growthFactor, this.numFiniteBuckets, this.scale});

  $Exponential.fromJson(core.Map json_)
    : this(
        growthFactor: (json_['growthFactor'] as core.num?)?.toDouble(),
        numFiniteBuckets: json_['numFiniteBuckets'] as core.int?,
        scale: (json_['scale'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (growthFactor != null) 'growthFactor': growthFactor!,
    if (numFiniteBuckets != null) 'numFiniteBuckets': numFiniteBuckets!,
    if (scale != null) 'scale': scale!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportAgentRequestGitDestination
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportAgentRequestGitDestination
class $ExportAgentRequestGitDestination {
  /// Commit message for the git push.
  core.String? commitMessage;

  /// Tracking branch for the git push.
  core.String? trackingBranch;

  $ExportAgentRequestGitDestination({this.commitMessage, this.trackingBranch});

  $ExportAgentRequestGitDestination.fromJson(core.Map json_)
    : this(
        commitMessage: json_['commitMessage'] as core.String?,
        trackingBranch: json_['trackingBranch'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (commitMessage != null) 'commitMessage': commitMessage!,
    if (trackingBranch != null) 'trackingBranch': trackingBranch!,
  };
}

/// Used by:
///
/// - redis:v1 : ExportBackupRequest
/// - redis:v1beta1 : ExportBackupRequest
class $ExportBackupRequest {
  /// Google Cloud Storage bucket, like "my-bucket".
  core.String? gcsBucket;

  $ExportBackupRequest({this.gcsBucket});

  $ExportBackupRequest.fromJson(core.Map json_)
    : this(gcsBucket: json_['gcsBucket'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsBucket != null) 'gcsBucket': gcsBucket!,
  };
}

/// Used by:
///
/// - firestore:v1beta1 : GoogleFirestoreAdminV1beta1ExportDocumentsRequest
/// - firestore:v1beta2 : GoogleFirestoreAdminV1beta2ExportDocumentsRequest
class $ExportDocumentsRequest {
  /// Which collection ids to export.
  ///
  /// Unspecified means all collections.
  core.List<core.String>? collectionIds;

  /// The output URI.
  ///
  /// Currently only supports Google Cloud Storage URIs of the form:
  /// `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name of
  /// the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional Google
  /// Cloud Storage namespace path. When choosing a name, be sure to consider
  /// Google Cloud Storage naming guidelines:
  /// https://cloud.google.com/storage/docs/naming. If the URI is a bucket
  /// (without a namespace path), a prefix will be generated based on the start
  /// time.
  core.String? outputUriPrefix;

  $ExportDocumentsRequest({this.collectionIds, this.outputUriPrefix});

  $ExportDocumentsRequest.fromJson(core.Map json_)
    : this(
        collectionIds:
            (json_['collectionIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        outputUriPrefix: json_['outputUriPrefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collectionIds != null) 'collectionIds': collectionIds!,
    if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportEntityTypesRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportEntityTypesRequest
class $ExportEntityTypesRequest {
  /// The data format of the exported entity types.
  ///
  /// If not specified, `BLOB` is assumed.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format. Treated as `BLOB`.
  /// - "BLOB" : EntityTypes will be exported as raw bytes.
  /// - "JSON_PACKAGE" : EntityTypes will be exported in JSON Package format.
  core.String? dataFormat;

  /// The name of the entity types to export.
  ///
  /// Format: `projects//locations//agents//entityTypes/`.
  ///
  /// Required.
  core.List<core.String>? entityTypes;

  /// The option to return the serialized entity types inline.
  ///
  /// Optional.
  core.bool? entityTypesContentInline;

  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// export the entity types to.
  ///
  /// The format of this URI must be `gs:///`. Dialogflow performs a write
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have write permissions for the object. For
  /// more information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  ///
  /// Optional.
  core.String? entityTypesUri;

  /// The language to retrieve the entity type for.
  ///
  /// The following fields are language dependent: * `EntityType.entities.value`
  /// * `EntityType.entities.synonyms` * `EntityType.excluded_phrases.value` If
  /// not specified, all language dependent fields will be retrieved.
  /// [Many languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported. Note: languages must be enabled in the agent before they
  /// can be used.
  ///
  /// Optional.
  core.String? languageCode;

  $ExportEntityTypesRequest({
    this.dataFormat,
    this.entityTypes,
    this.entityTypesContentInline,
    this.entityTypesUri,
    this.languageCode,
  });

  $ExportEntityTypesRequest.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        entityTypes:
            (json_['entityTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        entityTypesContentInline:
            json_['entityTypesContentInline'] as core.bool?,
        entityTypesUri: json_['entityTypesUri'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (entityTypes != null) 'entityTypes': entityTypes!,
    if (entityTypesContentInline != null)
      'entityTypesContentInline': entityTypesContentInline!,
    if (entityTypesUri != null) 'entityTypesUri': entityTypesUri!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestFullExport
class $ExportFeatureValuesRequestFullExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? endTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  $ExportFeatureValuesRequestFullExport({this.endTime, this.startTime});

  $ExportFeatureValuesRequestFullExport.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestSnapshotExport
class $ExportFeatureValuesRequestSnapshotExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? snapshotTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  $ExportFeatureValuesRequestSnapshotExport({
    this.snapshotTime,
    this.startTime,
  });

  $ExportFeatureValuesRequestSnapshotExport.fromJson(core.Map json_)
    : this(
        snapshotTime: json_['snapshotTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (snapshotTime != null) 'snapshotTime': snapshotTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportFlowRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportFlowRequest
class $ExportFlowRequest {
  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// export the flow to.
  ///
  /// The format of this URI must be `gs:///`. If left unspecified, the
  /// serialized flow is returned inline. Dialogflow performs a write operation
  /// for the Cloud Storage object on the caller's behalf, so your request
  /// authentication must have write permissions for the object. For more
  /// information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  ///
  /// Optional.
  core.String? flowUri;

  /// Whether to export flows referenced by the specified flow.
  ///
  /// Optional.
  core.bool? includeReferencedFlows;

  $ExportFlowRequest({this.flowUri, this.includeReferencedFlows});

  $ExportFlowRequest.fromJson(core.Map json_)
    : this(
        flowUri: json_['flowUri'] as core.String?,
        includeReferencedFlows: json_['includeReferencedFlows'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (flowUri != null) 'flowUri': flowUri!,
    if (includeReferencedFlows != null)
      'includeReferencedFlows': includeReferencedFlows!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportIntentsRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportIntentsRequest
class $ExportIntentsRequest {
  /// The data format of the exported intents.
  ///
  /// If not specified, `BLOB` is assumed.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format. Treated as `BLOB`.
  /// - "BLOB" : Intents will be exported as raw bytes.
  /// - "JSON" : Intents will be exported in JSON format.
  /// - "CSV" : Intents will be exported in CSV format.
  core.String? dataFormat;

  /// The name of the intents to export.
  ///
  /// Format: `projects//locations//agents//intents/`.
  ///
  /// Required.
  core.List<core.String>? intents;

  /// The option to return the serialized intents inline.
  ///
  /// Optional.
  core.bool? intentsContentInline;

  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// export the intents to.
  ///
  /// The format of this URI must be `gs:///`. Dialogflow performs a write
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have write permissions for the object. For
  /// more information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  ///
  /// Optional.
  core.String? intentsUri;

  $ExportIntentsRequest({
    this.dataFormat,
    this.intents,
    this.intentsContentInline,
    this.intentsUri,
  });

  $ExportIntentsRequest.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        intents:
            (json_['intents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        intentsContentInline: json_['intentsContentInline'] as core.bool?,
        intentsUri: json_['intentsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (intents != null) 'intents': intents!,
    if (intentsContentInline != null)
      'intentsContentInline': intentsContentInline!,
    if (intentsUri != null) 'intentsUri': intentsUri!,
  };
}

/// Used by:
///
/// - metastore:v1 : ExportMetadataRequest
/// - metastore:v1alpha : ExportMetadataRequest
/// - metastore:v1beta : ExportMetadataRequest
class $ExportMetadataRequest {
  /// The type of the database dump.
  ///
  /// If unspecified, defaults to MYSQL.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type of the database dump is unknown.
  /// - "MYSQL" : Database dump is a MySQL dump file.
  /// - "AVRO" : Database dump contains Avro files.
  core.String? databaseDumpType;

  /// A Cloud Storage URI of a folder, in the format gs:///.
  ///
  /// A sub-folder containing exported files will be created below it.
  core.String? destinationGcsFolder;

  /// A request ID.
  ///
  /// Specify a unique request ID to allow the server to ignore the request if
  /// it has completed. The server will ignore subsequent requests that provide
  /// a duplicate request ID for at least 60 minutes after the first request.For
  /// example, if an initial request times out, followed by another request with
  /// the same request ID, the server ignores the second request to prevent the
  /// creation of duplicate commitments.The request ID must be a valid UUID
  /// (https://en.wikipedia.org/wiki/Universally_unique_identifier#Format). A
  /// zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  ///
  /// Optional.
  core.String? requestId;

  $ExportMetadataRequest({
    this.databaseDumpType,
    this.destinationGcsFolder,
    this.requestId,
  });

  $ExportMetadataRequest.fromJson(core.Map json_)
    : this(
        databaseDumpType: json_['databaseDumpType'] as core.String?,
        destinationGcsFolder: json_['destinationGcsFolder'] as core.String?,
        requestId: json_['requestId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseDumpType != null) 'databaseDumpType': databaseDumpType!,
    if (destinationGcsFolder != null)
      'destinationGcsFolder': destinationGcsFolder!,
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - vault:v1 : GeminiExportOptions
/// - vault:v1 : GroupsExportOptions
/// - vault:v1 : HangoutsChatExportOptions
class $ExportOptions00 {
  /// The file format for exported messages.
  /// Possible string values are:
  /// - "EXPORT_FORMAT_UNSPECIFIED" : No export format specified.
  /// - "MBOX" : Export as MBOX. Only available for Gmail, Groups, Hangouts and
  /// Voice.
  /// - "PST" : Export as PST. Only available for Gmail, Groups, Hangouts, Voice
  /// and Calendar.
  /// - "ICS" : Export as ICS. Only available for Calendar.
  /// - "XML" : Export as XML. Only available for Gemini.
  core.String? exportFormat;

  $ExportOptions00({this.exportFormat});

  $ExportOptions00.fromJson(core.Map json_)
    : this(exportFormat: json_['exportFormat'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportFormat != null) 'exportFormat': exportFormat!,
  };
}

/// Used by:
///
/// - vault:v1 : CalendarExportOptions
/// - vault:v1 : VoiceExportOptions
class $ExportOptions01 {
  /// The file format for exported text messages.
  /// Possible string values are:
  /// - "EXPORT_FORMAT_UNSPECIFIED" : No export format specified.
  /// - "MBOX" : Export as MBOX. Only available for Gmail, Groups, Hangouts and
  /// Voice.
  /// - "PST" : Export as PST. Only available for Gmail, Groups, Hangouts, Voice
  /// and Calendar.
  /// - "ICS" : Export as ICS. Only available for Calendar.
  /// - "XML" : Export as XML. Only available for Gemini.
  core.String? exportFormat;

  $ExportOptions01({this.exportFormat});

  $ExportOptions01.fromJson(core.Map json_)
    : this(exportFormat: json_['exportFormat'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportFormat != null) 'exportFormat': exportFormat!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportPlaybookRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportPlaybookRequest
class $ExportPlaybookRequest {
  /// The data format of the exported agent.
  ///
  /// If not specified, `BLOB` is assumed.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format.
  /// - "BLOB" : Flow content will be exported as raw bytes.
  /// - "JSON" : Flow content will be exported in JSON format.
  core.String? dataFormat;

  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// export the playbook to.
  ///
  /// The format of this URI must be `gs:///`. If left unspecified, the
  /// serialized playbook is returned inline. Dialogflow performs a write
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have write permissions for the object. For
  /// more information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  ///
  /// Optional.
  core.String? playbookUri;

  $ExportPlaybookRequest({this.dataFormat, this.playbookUri});

  $ExportPlaybookRequest.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        playbookUri: json_['playbookUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (playbookUri != null) 'playbookUri': playbookUri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataRequest
class $ExportTensorboardTimeSeriesDataRequest {
  /// Exports the TensorboardTimeSeries' data that match the filter expression.
  core.String? filter;

  /// Field to use to sort the TensorboardTimeSeries' data.
  ///
  /// By default, TensorboardTimeSeries' data is returned in a pseudo random
  /// order.
  core.String? orderBy;

  /// The maximum number of data points to return per page.
  ///
  /// The default page_size is 1000. Values must be between 1 and 10000. Values
  /// above 10000 are coerced to 10000.
  core.int? pageSize;

  /// A page token, received from a previous ExportTensorboardTimeSeriesData
  /// call.
  ///
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to ExportTensorboardTimeSeriesData must match the call
  /// that provided the page token.
  core.String? pageToken;

  $ExportTensorboardTimeSeriesDataRequest({
    this.filter,
    this.orderBy,
    this.pageSize,
    this.pageToken,
  });

  $ExportTensorboardTimeSeriesDataRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        orderBy: json_['orderBy'] as core.String?,
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (orderBy != null) 'orderBy': orderBy!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ExportTestCasesRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ExportTestCasesRequest
class $ExportTestCasesRequest {
  /// The data format of the exported test cases.
  ///
  /// If not specified, `BLOB` is assumed.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format.
  /// - "BLOB" : Raw bytes.
  /// - "JSON" : JSON format.
  core.String? dataFormat;

  /// The filter expression used to filter exported test cases, see
  /// [API Filtering](https://aip.dev/160).
  ///
  /// The expression is case insensitive and supports the following syntax: name
  /// = \[OR name = \] ... For example: * "name = t1 OR name = t2" matches the
  /// test case with the exact resource name "t1" or "t2".
  core.String? filter;

  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// export the test cases to.
  ///
  /// The format of this URI must be `gs:///`. If unspecified, the serialized
  /// test cases is returned inline. Dialogflow performs a write operation for
  /// the Cloud Storage object on the caller's behalf, so your request
  /// authentication must have write permissions for the object. For more
  /// information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  core.String? gcsUri;

  $ExportTestCasesRequest({this.dataFormat, this.filter, this.gcsUri});

  $ExportTestCasesRequest.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        filter: json_['filter'] as core.String?,
        gcsUri: json_['gcsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (filter != null) 'filter': filter!,
    if (gcsUri != null) 'gcsUri': gcsUri!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : Expr
/// - aiplatform:v1 : GoogleTypeExpr
/// - aiplatform:v1beta1 : GoogleTypeExpr
/// - analyticshub:v1 : Expr
/// - analyticshub:v1beta1 : Expr
/// - apigateway:v1 : ApigatewayExpr
/// - apigateway:v1beta : ApigatewayExpr
/// - apigee:v1 : GoogleTypeExpr
/// - apigeeregistry:v1 : Expr
/// - apphub:v1 : Expr
/// - apphub:v1alpha : Expr
/// - artifactregistry:v1 : Expr
/// - artifactregistry:v1beta1 : Expr
/// - artifactregistry:v1beta2 : Expr
/// - backupdr:v1 : Expr
/// - beyondcorp:v1 : GoogleTypeExpr
/// - beyondcorp:v1alpha : GoogleTypeExpr
/// - bigquery:v2 : Expr
/// - bigqueryconnection:v1 : Expr
/// - bigqueryconnection:v1beta1 : Expr
/// - bigquerydatapolicy:v1 : Expr
/// - bigqueryreservation:v1 : Expr
/// - bigtableadmin:v2 : Expr
/// - binaryauthorization:v1 : Expr
/// - binaryauthorization:v1beta1 : Expr
/// - cloudasset:v1 : Expr
/// - cloudasset:v1beta1 : Expr
/// - cloudasset:v1p1beta1 : Expr
/// - cloudasset:v1p5beta1 : Expr
/// - cloudbilling:v1 : Expr
/// - cloudbuild:v2 : Expr
/// - clouddeploy:v1 : Expr
/// - cloudfunctions:v1 : Expr
/// - cloudfunctions:v2 : Expr
/// - cloudfunctions:v2alpha : Expr
/// - cloudfunctions:v2beta : Expr
/// - cloudkms:v1 : Expr
/// - cloudresourcemanager:v1 : Expr
/// - cloudresourcemanager:v1beta1 : Expr
/// - cloudresourcemanager:v2 : Expr
/// - cloudresourcemanager:v2beta1 : Expr
/// - cloudresourcemanager:v3 : Expr
/// - cloudtasks:v2 : Expr
/// - cloudtasks:v2beta2 : Expr
/// - cloudtasks:v2beta3 : Expr
/// - compute:alpha : Expr
/// - compute:beta : Expr
/// - compute:v1 : Expr
/// - config:v1 : Expr
/// - connectors:v1 : Expr
/// - containeranalysis:v1 : Expr
/// - containeranalysis:v1alpha1 : Expr
/// - containeranalysis:v1beta1 : Expr
/// - contentwarehouse:v1 : GoogleTypeExpr
/// - datacatalog:v1 : Expr
/// - datacatalog:v1beta1 : Expr
/// - dataform:v1beta1 : Expr
/// - datafusion:v1 : Expr
/// - datafusion:v1beta1 : Expr
/// - datamigration:v1 : Expr
/// - datamigration:v1beta1 : Expr
/// - dataplex:v1 : GoogleTypeExpr
/// - dataproc:v1 : Expr
/// - deploymentmanager:alpha : Expr
/// - deploymentmanager:v2 : Expr
/// - deploymentmanager:v2beta : Expr
/// - discoveryengine:v1alpha : GoogleTypeExpr
/// - dns:v1 : Expr
/// - dns:v1beta2 : Expr
/// - domains:v1 : Expr
/// - domains:v1alpha2 : Expr
/// - domains:v1beta1 : Expr
/// - eventarc:v1 : Expr
/// - gkebackup:v1 : Expr
/// - gkehub:v1 : Expr
/// - gkehub:v1alpha : Expr
/// - gkehub:v1beta : Expr
/// - gkehub:v1beta1 : Expr
/// - gkeonprem:v1 : Expr
/// - healthcare:v1 : Expr
/// - healthcare:v1beta1 : Expr
/// - iam:v1 : Expr
/// - iam:v2 : GoogleTypeExpr
/// - iam:v2beta : GoogleTypeExpr
/// - iap:v1 : Expr
/// - iap:v1beta1 : Expr
/// - identitytoolkit:v2 : GoogleTypeExpr
/// - logging:v2 : Expr
/// - managedidentities:v1 : Expr
/// - managedidentities:v1alpha1 : Expr
/// - managedidentities:v1beta1 : Expr
/// - metastore:v1 : Expr
/// - metastore:v1alpha : Expr
/// - metastore:v1beta : Expr
/// - ml:v1 : GoogleType__Expr
/// - networkconnectivity:v1 : Expr
/// - networkconnectivity:v1alpha1 : Expr
/// - networkmanagement:v1 : Expr
/// - networkmanagement:v1beta1 : Expr
/// - networksecurity:v1 : Expr
/// - networksecurity:v1beta1 : Expr
/// - networkservices:v1 : Expr
/// - notebooks:v1 : Expr
/// - notebooks:v2 : Expr
/// - orgpolicy:v2 : GoogleTypeExpr
/// - policysimulator:v1 : GoogleTypeExpr
/// - policysimulator:v1beta : GoogleTypeExpr
/// - policytroubleshooter:v1 : GoogleTypeExpr
/// - policytroubleshooter:v1beta : GoogleTypeExpr
/// - privateca:v1 : Expr
/// - privateca:v1beta1 : Expr
/// - pubsub:v1 : Expr
/// - pubsub:v1beta2 : Expr
/// - run:v1 : Expr
/// - run:v2 : GoogleTypeExpr
/// - runtimeconfig:v1beta1 : Expr
/// - secretmanager:v1 : Expr
/// - secretmanager:v1beta1 : Expr
/// - secretmanager:v1beta2 : Expr
/// - securesourcemanager:v1 : Expr
/// - securitycenter:v1 : Expr
/// - securitycenter:v1beta1 : Expr
/// - securityposture:v1 : Expr
/// - servicedirectory:v1 : Expr
/// - servicedirectory:v1beta1 : Expr
/// - servicemanagement:v1 : Expr
/// - spanner:v1 : Expr
/// - vmwareengine:v1 : Expr
/// - workstations:v1 : Expr
/// - workstations:v1beta : Expr
class $Expr {
  /// Description of the expression.
  ///
  /// This is a longer text which describes the expression, e.g. when hovered
  /// over it in a UI.
  ///
  /// Optional.
  core.String? description;

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  core.String? expression;

  /// String indicating the location of the expression for error reporting, e.g.
  /// a file name and a position in the file.
  ///
  /// Optional.
  core.String? location;

  /// Title for the expression, i.e. a short string describing its purpose.
  ///
  /// This can be used e.g. in UIs which allow to enter the expression.
  ///
  /// Optional.
  core.String? title;

  $Expr({this.description, this.expression, this.location, this.title});

  $Expr.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        expression: json_['expression'] as core.String?,
        location: json_['location'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (expression != null) 'expression': expression!,
    if (location != null) 'location': location!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : ExtendSchemaRequest
/// - managedidentities:v1alpha1 : ExtendSchemaRequest
/// - managedidentities:v1beta1 : ExtendSchemaRequest
class $ExtendSchemaRequest {
  /// Description for Schema Change.
  ///
  /// Required.
  core.String? description;

  /// File uploaded as a byte stream input.
  core.String? fileContents;
  core.List<core.int> get fileContentsAsBytes =>
      convert.base64.decode(fileContents!);

  set fileContentsAsBytes(core.List<core.int> bytes_) {
    fileContents = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// File stored in Cloud Storage bucket and represented in the form
  /// projects/{project_id}/buckets/{bucket_name}/objects/{object_name} File
  /// should be in the same project as the domain.
  core.String? gcsPath;

  $ExtendSchemaRequest({this.description, this.fileContents, this.gcsPath});

  $ExtendSchemaRequest.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        fileContents: json_['fileContents'] as core.String?,
        gcsPath: json_['gcsPath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (fileContents != null) 'fileContents': fileContents!,
    if (gcsPath != null) 'gcsPath': gcsPath!,
  };
}

/// Used by:
///
/// - networkservices:v1 : ExtensionChainMatchCondition
/// - networkservices:v1beta1 : ExtensionChainMatchCondition
class $ExtensionChainMatchCondition {
  /// A Common Expression Language (CEL) expression that is used to match
  /// requests for which the extension chain is executed.
  ///
  /// For more information, see
  /// [CEL matcher language reference](https://cloud.google.com/service-extensions/docs/cel-matcher-language-reference).
  ///
  /// Required.
  core.String? celExpression;

  $ExtensionChainMatchCondition({this.celExpression});

  $ExtensionChainMatchCondition.fromJson(core.Map json_)
    : this(celExpression: json_['celExpression'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (celExpression != null) 'celExpression': celExpression!,
  };
}

/// Used by:
///
/// - publicca:v1 : ExternalAccountKey
/// - publicca:v1alpha1 : ExternalAccountKey
/// - publicca:v1beta1 : ExternalAccountKey
class $ExternalAccountKey {
  /// Base64-URL-encoded HS256 key.
  ///
  /// It is generated by the PublicCertificateAuthorityService when the
  /// ExternalAccountKey is created
  ///
  /// Output only.
  core.String? b64MacKey;
  core.List<core.int> get b64MacKeyAsBytes => convert.base64.decode(b64MacKey!);

  set b64MacKeyAsBytes(core.List<core.int> bytes_) {
    b64MacKey = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Key ID.
  ///
  /// It is generated by the PublicCertificateAuthorityService when the
  /// ExternalAccountKey is created
  ///
  /// Output only.
  core.String? keyId;

  /// Resource name.
  ///
  /// projects/{project}/locations/{location}/externalAccountKeys/{key_id}
  ///
  /// Output only.
  core.String? name;

  $ExternalAccountKey({this.b64MacKey, this.keyId, this.name});

  $ExternalAccountKey.fromJson(core.Map json_)
    : this(
        b64MacKey: json_['b64MacKey'] as core.String?,
        keyId: json_['keyId'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (b64MacKey != null) 'b64MacKey': b64MacKey!,
    if (keyId != null) 'keyId': keyId!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExternalApiElasticSearchParams
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExternalApiElasticSearchParams
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ExternalApiElasticSearchParams
class $ExternalApiElasticSearchParams {
  /// The ElasticSearch index to use.
  core.String? index;

  /// Number of hits (chunks) to request.
  ///
  /// When specified, it is passed to Elasticsearch as the `num_hits` param.
  ///
  /// Optional.
  core.int? numHits;

  /// The ElasticSearch search template to use.
  core.String? searchTemplate;

  $ExternalApiElasticSearchParams({
    this.index,
    this.numHits,
    this.searchTemplate,
  });

  $ExternalApiElasticSearchParams.fromJson(core.Map json_)
    : this(
        index: json_['index'] as core.String?,
        numHits: json_['numHits'] as core.int?,
        searchTemplate: json_['searchTemplate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (index != null) 'index': index!,
    if (numHits != null) 'numHits': numHits!,
    if (searchTemplate != null) 'searchTemplate': searchTemplate!,
  };
}

/// Used by:
///
/// - cloudkms:v1 : ExternalProtectionLevelOptions
/// - kmsinventory:v1 : GoogleCloudKmsV1ExternalProtectionLevelOptions
class $ExternalProtectionLevelOptions {
  /// The path to the external key material on the EKM when using EkmConnection
  /// e.g., "v0/my/key".
  ///
  /// Set this field instead of external_key_uri when using an EkmConnection.
  core.String? ekmConnectionKeyPath;

  /// The URI for an external resource that this CryptoKeyVersion represents.
  core.String? externalKeyUri;

  $ExternalProtectionLevelOptions({
    this.ekmConnectionKeyPath,
    this.externalKeyUri,
  });

  $ExternalProtectionLevelOptions.fromJson(core.Map json_)
    : this(
        ekmConnectionKeyPath: json_['ekmConnectionKeyPath'] as core.String?,
        externalKeyUri: json_['externalKeyUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ekmConnectionKeyPath != null)
      'ekmConnectionKeyPath': ekmConnectionKeyPath!,
    if (externalKeyUri != null) 'externalKeyUri': externalKeyUri!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : ExternalRef
/// - containeranalysis:v1beta1 : ExternalRef
class $ExternalRef {
  /// An External Reference allows a Package to reference an external source of
  /// additional information, metadata, enumerations, asset identifiers, or
  /// downloadable content believed to be relevant to the Package
  /// Possible string values are:
  /// - "CATEGORY_UNSPECIFIED" : Unspecified
  /// - "SECURITY" : Security (e.g. cpe22Type, cpe23Type)
  /// - "PACKAGE_MANAGER" : Package Manager (e.g. maven-central, npm, nuget,
  /// bower, purl)
  /// - "PERSISTENT_ID" : Persistent-Id (e.g. swh)
  /// - "OTHER" : Other
  core.String? category;

  /// Human-readable information about the purpose and target of the reference
  core.String? comment;

  /// The unique string with no spaces necessary to access the package-specific
  /// information, metadata, or content within the target location
  core.String? locator;

  /// Type of category (e.g. 'npm' for the PACKAGE_MANAGER category)
  core.String? type;

  $ExternalRef({this.category, this.comment, this.locator, this.type});

  $ExternalRef.fromJson(core.Map json_)
    : this(
        category: json_['category'] as core.String?,
        comment: json_['comment'] as core.String?,
        locator: json_['locator'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (comment != null) 'comment': comment!,
    if (locator != null) 'locator': locator!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : ExternalSyncSelectedObject
/// - sqladmin:v1beta4 : ExternalSyncSelectedObject
class $ExternalSyncSelectedObject {
  /// The name of the database that Cloud SQL migrates.
  core.String? database;

  $ExternalSyncSelectedObject({this.database});

  $ExternalSyncSelectedObject.fromJson(core.Map json_)
    : this(database: json_['database'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (database != null) 'database': database!,
  };
}

/// Used by:
///
/// - compute:alpha : ExternalVpnGatewayInterface
/// - compute:beta : ExternalVpnGatewayInterface
/// - compute:v1 : ExternalVpnGatewayInterface
class $ExternalVpnGatewayInterface {
  /// The numeric ID of this interface.
  ///
  /// The allowed input values for this id for different redundancy types of
  /// external VPN gateway: - SINGLE_IP_INTERNALLY_REDUNDANT - 0 -
  /// TWO_IPS_REDUNDANCY - 0, 1 - FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
  core.int? id;

  /// IP address of the interface in the external VPN gateway.
  ///
  /// Only IPv4 is supported. This IP address can be either from your on-premise
  /// gateway or another Cloud provider's VPN gateway, it cannot be an IP
  /// address from Google Compute Engine.
  core.String? ipAddress;

  /// IPv6 address of the interface in the external VPN gateway.
  ///
  /// This IPv6 address can be either from your on-premise gateway or another
  /// Cloud provider's VPN gateway, it cannot be an IP address from Google
  /// Compute Engine. Must specify an IPv6 address (not IPV4-mapped) using any
  /// format described in RFC 4291 (e.g. 2001:db8:0:0:2d9:51:0:0). The output
  /// format is RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
  core.String? ipv6Address;

  $ExternalVpnGatewayInterface({this.id, this.ipAddress, this.ipv6Address});

  $ExternalVpnGatewayInterface.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.int?,
        ipAddress: json_['ipAddress'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : VmwareAdminF5BigIpConfig
/// - gkeonprem:v1 : VmwareF5BigIpConfig
class $F5BigIpConfig {
  /// The load balancer's IP address.
  core.String? address;

  /// The preexisting partition to be used by the load balancer.
  ///
  /// This partition is usually created for the admin cluster for example:
  /// 'my-f5-admin-partition'.
  core.String? partition;

  /// The pool name.
  ///
  /// Only necessary, if using SNAT.
  core.String? snatPool;

  $F5BigIpConfig({this.address, this.partition, this.snatPool});

  $F5BigIpConfig.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        partition: json_['partition'] as core.String?,
        snatPool: json_['snatPool'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (partition != null) 'partition': partition!,
    if (snatPool != null) 'snatPool': snatPool!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_FaceDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_FaceDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_FaceDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_FaceDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_FaceDetectionConfig
class $FaceDetectionConfig {
  /// Whether to enable face attributes detection, such as glasses,
  /// dark_glasses, mouth_open etc.
  ///
  /// Ignored if 'include_bounding_boxes' is set to false.
  core.bool? includeAttributes;

  /// Whether bounding boxes are included in the face annotation output.
  core.bool? includeBoundingBoxes;

  /// Model to use for face detection.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest".
  core.String? model;

  $FaceDetectionConfig({
    this.includeAttributes,
    this.includeBoundingBoxes,
    this.model,
  });

  $FaceDetectionConfig.fromJson(core.Map json_)
    : this(
        includeAttributes: json_['includeAttributes'] as core.bool?,
        includeBoundingBoxes: json_['includeBoundingBoxes'] as core.bool?,
        model: json_['model'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeAttributes != null) 'includeAttributes': includeAttributes!,
    if (includeBoundingBoxes != null)
      'includeBoundingBoxes': includeBoundingBoxes!,
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1FactChunk
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaFactChunk
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaFactChunk
class $FactChunk {
  /// Text content of the fact chunk.
  ///
  /// Can be at most 10K characters long.
  core.String? chunkText;

  /// The domain of the source.
  core.String? domain;

  /// The index of this chunk.
  ///
  /// Currently, only used for the streaming mode.
  core.int? index;

  /// Source from which this fact chunk was retrieved.
  ///
  /// If it was retrieved from the GroundingFacts provided in the request then
  /// this field will contain the index of the specific fact from which this
  /// chunk was retrieved.
  core.String? source;

  /// More fine-grained information for the source reference.
  core.Map<core.String, core.String>? sourceMetadata;

  /// The title of the source.
  core.String? title;

  /// The URI of the source.
  core.String? uri;

  $FactChunk({
    this.chunkText,
    this.domain,
    this.index,
    this.source,
    this.sourceMetadata,
    this.title,
    this.uri,
  });

  $FactChunk.fromJson(core.Map json_)
    : this(
        chunkText: json_['chunkText'] as core.String?,
        domain: json_['domain'] as core.String?,
        index: json_['index'] as core.int?,
        source: json_['source'] as core.String?,
        sourceMetadata: (json_['sourceMetadata']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkText != null) 'chunkText': chunkText!,
    if (domain != null) 'domain': domain!,
    if (index != null) 'index': index!,
    if (source != null) 'source': source!,
    if (sourceMetadata != null) 'sourceMetadata': sourceMetadata!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : FailoverContext
/// - sqladmin:v1beta4 : FailoverContext
class $FailoverContext {
  /// This is always `sql#failoverContext`.
  core.String? kind;

  /// The current settings version of this instance.
  ///
  /// Request will be rejected if this version doesn't match the current
  /// settings version.
  core.String? settingsVersion;

  $FailoverContext({this.kind, this.settingsVersion});

  $FailoverContext.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        settingsVersion: json_['settingsVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (settingsVersion != null) 'settingsVersion': settingsVersion!,
  };
}

/// Used by:
///
/// - redis:v1 : FailoverInstanceRequest
/// - redis:v1beta1 : FailoverInstanceRequest
class $FailoverInstanceRequest {
  /// Available data protection modes that the user can choose.
  ///
  /// If it's unspecified, data protection mode will be LIMITED_DATA_LOSS by
  /// default.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DATA_PROTECTION_MODE_UNSPECIFIED" : Defaults to LIMITED_DATA_LOSS if a
  /// data protection mode is not specified.
  /// - "LIMITED_DATA_LOSS" : Instance failover will be protected with data loss
  /// control. More specifically, the failover will only be performed if the
  /// current replication offset diff between primary and replica is under a
  /// certain threshold.
  /// - "FORCE_DATA_LOSS" : Instance failover will be performed without data
  /// loss control.
  core.String? dataProtectionMode;

  $FailoverInstanceRequest({this.dataProtectionMode});

  $FailoverInstanceRequest.fromJson(core.Map json_)
    : this(dataProtectionMode: json_['dataProtectionMode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataProtectionMode != null) 'dataProtectionMode': dataProtectionMode!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2FaqAnswer
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1FaqAnswer
class $FaqAnswer {
  /// The piece of text from the `source` knowledge base document.
  core.String? answer;

  /// The name of answer record, in the format of
  /// "projects//locations//answerRecords/"
  core.String? answerRecord;

  /// The system's confidence score that this Knowledge answer is a good match
  /// for this conversational query, range from 0.0 (completely uncertain) to
  /// 1.0 (completely certain).
  core.double? confidence;

  /// A map that contains metadata about the answer and the document from which
  /// it originates.
  core.Map<core.String, core.String>? metadata;

  /// The corresponding FAQ question.
  core.String? question;

  /// Indicates which Knowledge Document this answer was extracted from.
  ///
  /// Format: `projects//locations//agent/knowledgeBases//documents/`.
  core.String? source;

  $FaqAnswer({
    this.answer,
    this.answerRecord,
    this.confidence,
    this.metadata,
    this.question,
    this.source,
  });

  $FaqAnswer.fromJson(core.Map json_)
    : this(
        answer: json_['answer'] as core.String?,
        answerRecord: json_['answerRecord'] as core.String?,
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        metadata: (json_['metadata'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        question: json_['question'] as core.String?,
        source: json_['source'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answer != null) 'answer': answer!,
    if (answerRecord != null) 'answerRecord': answerRecord!,
    if (confidence != null) 'confidence': confidence!,
    if (metadata != null) 'metadata': metadata!,
    if (question != null) 'question': question!,
    if (source != null) 'source': source!,
  };
}

/// Used by:
///
/// - container:v1 : FastSocket
/// - container:v1beta1 : FastSocket
class $FastSocket {
  /// Whether Fast Socket features are enabled in the node pool.
  core.bool? enabled;

  $FastSocket({this.enabled});

  $FastSocket.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FasterDeploymentConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FasterDeploymentConfig
class $FasterDeploymentConfig {
  /// If true, enable fast tryout feature for this deployed model.
  core.bool? fastTryoutEnabled;

  $FasterDeploymentConfig({this.fastTryoutEnabled});

  $FasterDeploymentConfig.fromJson(core.Map json_)
    : this(fastTryoutEnabled: json_['fastTryoutEnabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fastTryoutEnabled != null) 'fastTryoutEnabled': fastTryoutEnabled!,
  };
}

/// Used by:
///
/// - fcm:v1 : AndroidFcmOptions
/// - fcm:v1 : FcmOptions
class $FcmOptions {
  /// Label associated with the message's analytics data.
  core.String? analyticsLabel;

  $FcmOptions({this.analyticsLabel});

  $FcmOptions.fromJson(core.Map json_)
    : this(analyticsLabel: json_['analyticsLabel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (analyticsLabel != null) 'analyticsLabel': analyticsLabel!,
  };
}

/// Used by:
///
/// - vision:v1 : Feature
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1Feature
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1Feature
class $Feature00 {
  /// Maximum number of results of this type.
  ///
  /// Does not apply to `TEXT_DETECTION`, `DOCUMENT_TEXT_DETECTION`, or
  /// `CROP_HINTS`.
  core.int? maxResults;

  /// Model to use for the feature.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest". `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` also
  /// support "builtin/weekly" for the bleeding edge release updated weekly.
  core.String? model;

  /// The feature type.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified feature type.
  /// - "FACE_DETECTION" : Run face detection.
  /// - "LANDMARK_DETECTION" : Run landmark detection.
  /// - "LOGO_DETECTION" : Run logo detection.
  /// - "LABEL_DETECTION" : Run label detection.
  /// - "TEXT_DETECTION" : Run text detection / optical character recognition
  /// (OCR). Text detection is optimized for areas of text within a larger
  /// image; if the image is a document, use `DOCUMENT_TEXT_DETECTION` instead.
  /// - "DOCUMENT_TEXT_DETECTION" : Run dense text document OCR. Takes
  /// precedence when both `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` are
  /// present.
  /// - "SAFE_SEARCH_DETECTION" : Run Safe Search to detect potentially unsafe
  /// or undesirable content.
  /// - "IMAGE_PROPERTIES" : Compute a set of image properties, such as the
  /// image's dominant colors.
  /// - "CROP_HINTS" : Run crop hints.
  /// - "WEB_DETECTION" : Run web detection.
  /// - "PRODUCT_SEARCH" : Run Product Search.
  /// - "OBJECT_LOCALIZATION" : Run localizer for object detection.
  core.String? type;

  $Feature00({this.maxResults, this.model, this.type});

  $Feature00.fromJson(core.Map json_)
    : this(
        maxResults: json_['maxResults'] as core.int?,
        model: json_['model'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxResults != null) 'maxResults': maxResults!,
    if (model != null) 'model': model!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Feature
/// - healthcare:v1beta1 : Feature
class $Feature01 {
  /// The model's confidence in this feature annotation.
  ///
  /// A number between 0 and 1.
  core.double? confidence;

  /// The value of this feature annotation.
  ///
  /// Its range depends on the type of the feature.
  core.String? value;

  $Feature01({this.confidence, this.value});

  $Feature01.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureGroupBigQueryTimeSeries
class $FeatureGroupBigQueryTimeSeries {
  /// Column hosting timestamp values for a time-series source.
  ///
  /// Will be used to determine the latest `feature_values` for each entity.
  /// Optional. If not provided, column named `feature_timestamp` of type
  /// `TIMESTAMP` will be used.
  ///
  /// Optional.
  core.String? timestampColumn;

  $FeatureGroupBigQueryTimeSeries({this.timestampColumn});

  $FeatureGroupBigQueryTimeSeries.fromJson(core.Map json_)
    : this(timestampColumn: json_['timestampColumn'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (timestampColumn != null) 'timestampColumn': timestampColumn!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureNoiseSigmaNoiseSigmaForFeature
class $FeatureNoiseSigmaNoiseSigmaForFeature {
  /// The name of the input feature for which noise sigma is provided.
  ///
  /// The features are defined in explanation metadata inputs.
  core.String? name;

  /// This represents the standard deviation of the Gaussian kernel that will be
  /// used to add noise to the feature prior to computing gradients.
  ///
  /// Similar to noise_sigma but represents the noise added to the current
  /// feature. Defaults to 0.1.
  core.double? sigma;

  $FeatureNoiseSigmaNoiseSigmaForFeature({this.name, this.sigma});

  $FeatureNoiseSigmaNoiseSigmaForFeature.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        sigma: (json_['sigma'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (sigma != null) 'sigma': sigma!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtableAutoScaling
class $FeatureOnlineStoreBigtableAutoScaling {
  /// A percentage of the cluster's CPU capacity.
  ///
  /// Can be from 10% to 80%. When a cluster's CPU utilization exceeds the
  /// target that you have set, Bigtable immediately adds nodes to the cluster.
  /// When CPU utilization is substantially lower than the target, Bigtable
  /// removes nodes. If not set will default to 50%.
  ///
  /// Optional.
  core.int? cpuUtilizationTarget;

  /// The maximum number of nodes to scale up to.
  ///
  /// Must be greater than or equal to min_node_count, and less than or equal to
  /// 10 times of 'min_node_count'.
  ///
  /// Required.
  core.int? maxNodeCount;

  /// The minimum number of nodes to scale down to.
  ///
  /// Must be greater than or equal to 1.
  ///
  /// Required.
  core.int? minNodeCount;

  $FeatureOnlineStoreBigtableAutoScaling({
    this.cpuUtilizationTarget,
    this.maxNodeCount,
    this.minNodeCount,
  });

  $FeatureOnlineStoreBigtableAutoScaling.fromJson(core.Map json_)
    : this(
        cpuUtilizationTarget: json_['cpuUtilizationTarget'] as core.int?,
        maxNodeCount: json_['maxNodeCount'] as core.int?,
        minNodeCount: json_['minNodeCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpuUtilizationTarget != null)
      'cpuUtilizationTarget': cpuUtilizationTarget!,
    if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
    if (minNodeCount != null) 'minNodeCount': minNodeCount!,
  };
}

/// Used by:
///
/// - gkehub:v1 : FeatureResourceState
/// - gkehub:v1alpha : FeatureResourceState
/// - gkehub:v1beta : FeatureResourceState
class $FeatureResourceState {
  /// The current state of the Feature resource in the Hub API.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State is unknown or not set.
  /// - "ENABLING" : The Feature is being enabled, and the Feature resource is
  /// being created. Once complete, the corresponding Feature will be enabled in
  /// this Fleet.
  /// - "ACTIVE" : The Feature is enabled in this Fleet, and the Feature
  /// resource is fully available.
  /// - "DISABLING" : The Feature is being disabled in this Fleet, and the
  /// Feature resource is being deleted.
  /// - "UPDATING" : The Feature resource is being updated.
  /// - "SERVICE_UPDATING" : The Feature resource is being updated by the Hub
  /// Service.
  core.String? state;

  $FeatureResourceState({this.state});

  $FeatureResourceState.fromJson(core.Map json_)
    : this(state: json_['state'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - appengine:v1 : FeatureSettings
/// - appengine:v1beta : FeatureSettings
class $FeatureSettings {
  /// Boolean value indicating if split health checks should be used instead of
  /// the legacy health checks.
  ///
  /// At an app.yaml level, this means defaulting to 'readiness_check' and
  /// 'liveness_check' values instead of 'health_check' ones. Once the legacy
  /// 'health_check' behavior is deprecated, and this value is always true, this
  /// setting can be removed.
  core.bool? splitHealthChecks;

  /// If true, use Container-Optimized OS
  /// (https://cloud.google.com/container-optimized-os/) base image for VMs,
  /// rather than a base Debian image.
  core.bool? useContainerOptimizedOs;

  $FeatureSettings({this.splitHealthChecks, this.useContainerOptimizedOs});

  $FeatureSettings.fromJson(core.Map json_)
    : this(
        splitHealthChecks: json_['splitHealthChecks'] as core.bool?,
        useContainerOptimizedOs: json_['useContainerOptimizedOs'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (splitHealthChecks != null) 'splitHealthChecks': splitHealthChecks!,
    if (useContainerOptimizedOs != null)
      'useContainerOptimizedOs': useContainerOptimizedOs!,
  };
}

/// Used by:
///
/// - gkehub:v1 : FeatureState
/// - gkehub:v1alpha : FeatureState
/// - gkehub:v1beta : FeatureState
class $FeatureState {
  /// The high-level, machine-readable status of this Feature.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Unknown or not set.
  /// - "OK" : The Feature is operating normally.
  /// - "WARNING" : The Feature has encountered an issue, and is operating in a
  /// degraded state. The Feature may need intervention to return to normal
  /// operation. See the description and any associated Feature-specific details
  /// for more information.
  /// - "ERROR" : The Feature is not operating or is in a severely degraded
  /// state. The Feature may need intervention to return to normal operation.
  /// See the description and any associated Feature-specific details for more
  /// information.
  core.String? code;

  /// A human-readable description of the current status.
  core.String? description;

  /// The time this status and any related Feature-specific details were
  /// updated.
  core.String? updateTime;

  $FeatureState({this.code, this.description, this.updateTime});

  $FeatureState.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        description: json_['description'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (description != null) 'description': description!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureStatsAnomaly
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureStatsAnomaly
class $FeatureStatsAnomaly {
  /// This is the threshold used when detecting anomalies.
  ///
  /// The threshold can be changed by user, so this one might be different from
  /// ThresholdConfig.value.
  core.double? anomalyDetectionThreshold;

  /// Path of the anomaly file for current feature values in Cloud Storage
  /// bucket.
  ///
  /// Format: gs:////anomalies. Example:
  /// gs://monitoring_bucket/feature_name/anomalies. Stats are stored as binary
  /// format with Protobuf message Anoamlies are stored as binary format with
  /// Protobuf message
  /// [tensorflow.metadata.v0.AnomalyInfo](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
  core.String? anomalyUri;

  /// Deviation from the current stats to baseline stats.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence.
  core.double? distributionDeviation;

  /// The end timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
  /// generate stats (e.g. timestamp we take snapshots for feature values).
  core.String? endTime;

  /// Feature importance score, only populated when cross-feature monitoring is
  /// enabled.
  ///
  /// For now only used to represent feature attribution score within range \[0,
  /// 1\] for ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW
  /// and ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT.
  core.double? score;

  /// The start timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), start_time is only used to indicate the monitoring
  /// intervals, so it always equals to (end_time - monitoring_interval).
  core.String? startTime;

  /// Path of the stats file for current feature values in Cloud Storage bucket.
  ///
  /// Format: gs:////stats. Example: gs://monitoring_bucket/feature_name/stats.
  /// Stats are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
  core.String? statsUri;

  $FeatureStatsAnomaly({
    this.anomalyDetectionThreshold,
    this.anomalyUri,
    this.distributionDeviation,
    this.endTime,
    this.score,
    this.startTime,
    this.statsUri,
  });

  $FeatureStatsAnomaly.fromJson(core.Map json_)
    : this(
        anomalyDetectionThreshold:
            (json_['anomalyDetectionThreshold'] as core.num?)?.toDouble(),
        anomalyUri: json_['anomalyUri'] as core.String?,
        distributionDeviation:
            (json_['distributionDeviation'] as core.num?)?.toDouble(),
        endTime: json_['endTime'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        startTime: json_['startTime'] as core.String?,
        statsUri: json_['statsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (anomalyDetectionThreshold != null)
      'anomalyDetectionThreshold': anomalyDetectionThreshold!,
    if (anomalyUri != null) 'anomalyUri': anomalyUri!,
    if (distributionDeviation != null)
      'distributionDeviation': distributionDeviation!,
    if (endTime != null) 'endTime': endTime!,
    if (score != null) 'score': score!,
    if (startTime != null) 'startTime': startTime!,
    if (statsUri != null) 'statsUri': statsUri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureValueMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureValueMetadata
class $FeatureValueMetadata {
  /// Feature generation timestamp.
  ///
  /// Typically, it is provided by user at feature ingestion time. If not,
  /// feature store will use the system timestamp when the data is ingested into
  /// feature store. Legacy Feature Store: For streaming ingestion, the time,
  /// aligned by days, must be no older than five years (1825 days) and no later
  /// than one year (366 days) in the future.
  core.String? generateTime;

  $FeatureValueMetadata({this.generateTime});

  $FeatureValueMetadata.fromJson(core.Map json_)
    : this(generateTime: json_['generateTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (generateTime != null) 'generateTime': generateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewBigQuerySource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewBigQuerySource
class $FeatureViewBigQuerySource {
  /// Columns to construct entity_id / row keys.
  ///
  /// Required.
  core.List<core.String>? entityIdColumns;

  /// The BigQuery view URI that will be materialized on each sync trigger based
  /// on FeatureView.SyncConfig.
  ///
  /// Required.
  core.String? uri;

  $FeatureViewBigQuerySource({this.entityIdColumns, this.uri});

  $FeatureViewBigQuerySource.fromJson(core.Map json_)
    : this(
        entityIdColumns:
            (json_['entityIdColumns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityIdColumns != null) 'entityIdColumns': entityIdColumns!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewDataKeyCompositeKey
class $FeatureViewDataKeyCompositeKey {
  /// Parts to construct Entity ID.
  ///
  /// Should match with the same ID columns as defined in FeatureView in the
  /// same order.
  core.List<core.String>? parts;

  $FeatureViewDataKeyCompositeKey({this.parts});

  $FeatureViewDataKeyCompositeKey.fromJson(core.Map json_)
    : this(
        parts:
            (json_['parts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parts != null) 'parts': parts!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySourceFeatureGroup
class $FeatureViewFeatureRegistrySourceFeatureGroup {
  /// Identifier of the feature group.
  ///
  /// Required.
  core.String? featureGroupId;

  /// Identifiers of features under the feature group.
  ///
  /// Required.
  core.List<core.String>? featureIds;

  $FeatureViewFeatureRegistrySourceFeatureGroup({
    this.featureGroupId,
    this.featureIds,
  });

  $FeatureViewFeatureRegistrySourceFeatureGroup.fromJson(core.Map json_)
    : this(
        featureGroupId: json_['featureGroupId'] as core.String?,
        featureIds:
            (json_['featureIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureGroupId != null) 'featureGroupId': featureGroupId!,
    if (featureIds != null) 'featureIds': featureIds!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewSyncConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewSyncConfig
class $FeatureViewSyncConfig {
  /// If true, syncs the FeatureView in a continuous manner to Online Store.
  ///
  /// Optional.
  core.bool? continuous;

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  $FeatureViewSyncConfig({this.continuous, this.cron});

  $FeatureViewSyncConfig.fromJson(core.Map json_)
    : this(
        continuous: json_['continuous'] as core.bool?,
        cron: json_['cron'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (continuous != null) 'continuous': continuous!,
    if (cron != null) 'cron': cron!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewSyncSyncSummary
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewSyncSyncSummary
class $FeatureViewSyncSyncSummary {
  /// Total number of rows synced.
  ///
  /// Output only.
  core.String? rowSynced;

  /// Lower bound of the system time watermark for the sync job.
  ///
  /// This is only set for continuously syncing feature views.
  core.String? systemWatermarkTime;

  /// BigQuery slot milliseconds consumed for the sync job.
  ///
  /// Output only.
  core.String? totalSlot;

  $FeatureViewSyncSyncSummary({
    this.rowSynced,
    this.systemWatermarkTime,
    this.totalSlot,
  });

  $FeatureViewSyncSyncSummary.fromJson(core.Map json_)
    : this(
        rowSynced: json_['rowSynced'] as core.String?,
        systemWatermarkTime: json_['systemWatermarkTime'] as core.String?,
        totalSlot: json_['totalSlot'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rowSynced != null) 'rowSynced': rowSynced!,
    if (systemWatermarkTime != null)
      'systemWatermarkTime': systemWatermarkTime!,
    if (totalSlot != null) 'totalSlot': totalSlot!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeatureViewVertexRagSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeatureViewVertexRagSource
class $FeatureViewVertexRagSource {
  /// The RAG corpus id corresponding to this FeatureView.
  ///
  /// Optional.
  core.String? ragCorpusId;

  /// The BigQuery view/table URI that will be materialized on each manual sync
  /// trigger.
  ///
  /// The table/view is expected to have the following columns and types at
  /// least: - `corpus_id` (STRING, NULLABLE/REQUIRED) - `file_id` (STRING,
  /// NULLABLE/REQUIRED) - `chunk_id` (STRING, NULLABLE/REQUIRED) -
  /// `chunk_data_type` (STRING, NULLABLE/REQUIRED) - `chunk_data` (STRING,
  /// NULLABLE/REQUIRED) - `embeddings` (FLOAT, REPEATED) - `file_original_uri`
  /// (STRING, NULLABLE/REQUIRED)
  ///
  /// Required.
  core.String? uri;

  $FeatureViewVertexRagSource({this.ragCorpusId, this.uri});

  $FeatureViewVertexRagSource.fromJson(core.Map json_)
    : this(
        ragCorpusId: json_['ragCorpusId'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragCorpusId != null) 'ragCorpusId': ragCorpusId!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigImportFeaturesAnalysis
class $FeaturestoreMonitoringConfigImportFeaturesAnalysis {
  /// The baseline used to do anomaly detection for the statistics generated by
  /// import features analysis.
  /// Possible string values are:
  /// - "BASELINE_UNSPECIFIED" : Should not be used.
  /// - "LATEST_STATS" : Choose the later one statistics generated by either
  /// most recent snapshot analysis or previous import features analysis. If non
  /// of them exists, skip anomaly detection and only generate a statistics.
  /// - "MOST_RECENT_SNAPSHOT_STATS" : Use the statistics generated by the most
  /// recent snapshot analysis if exists.
  /// - "PREVIOUS_IMPORT_FEATURES_STATS" : Use the statistics generated by the
  /// previous import features analysis if exists.
  core.String? anomalyDetectionBaseline;

  /// Whether to enable / disable / inherite default hebavior for import
  /// features analysis.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Should not be used.
  /// - "DEFAULT" : The default behavior of whether to enable the monitoring.
  /// EntityType-level config: disabled. Feature-level config: inherited from
  /// the configuration of EntityType this Feature belongs to.
  /// - "ENABLED" : Explicitly enables import features analysis.
  /// EntityType-level config: by default enables import features analysis for
  /// all Features under it. Feature-level config: enables import features
  /// analysis regardless of the EntityType-level config.
  /// - "DISABLED" : Explicitly disables import features analysis.
  /// EntityType-level config: by default disables import features analysis for
  /// all Features under it. Feature-level config: disables import features
  /// analysis regardless of the EntityType-level config.
  core.String? state;

  $FeaturestoreMonitoringConfigImportFeaturesAnalysis({
    this.anomalyDetectionBaseline,
    this.state,
  });

  $FeaturestoreMonitoringConfigImportFeaturesAnalysis.fromJson(core.Map json_)
    : this(
        anomalyDetectionBaseline:
            json_['anomalyDetectionBaseline'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (anomalyDetectionBaseline != null)
      'anomalyDetectionBaseline': anomalyDetectionBaseline!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig
class $FeaturestoreMonitoringConfigThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  $FeaturestoreMonitoringConfigThresholdConfig({this.value});

  $FeaturestoreMonitoringConfigThresholdConfig.fromJson(core.Map json_)
    : this(value: (json_['value'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfigScaling
class $FeaturestoreOnlineServingConfigScaling {
  /// The cpu utilization that the Autoscaler should be trying to achieve.
  ///
  /// This number is on a scale from 0 (no utilization) to 100 (total
  /// utilization), and is limited between 10 and 80. When a cluster's CPU
  /// utilization exceeds the target that you have set, Bigtable immediately
  /// adds nodes to the cluster. When CPU utilization is substantially lower
  /// than the target, Bigtable removes nodes. If not set or set to 0, default
  /// to 50.
  ///
  /// Optional.
  core.int? cpuUtilizationTarget;

  /// The maximum number of nodes to scale up to.
  ///
  /// Must be greater than min_node_count, and less than or equal to 10 times of
  /// 'min_node_count'.
  core.int? maxNodeCount;

  /// The minimum number of nodes to scale down to.
  ///
  /// Must be greater than or equal to 1.
  ///
  /// Required.
  core.int? minNodeCount;

  $FeaturestoreOnlineServingConfigScaling({
    this.cpuUtilizationTarget,
    this.maxNodeCount,
    this.minNodeCount,
  });

  $FeaturestoreOnlineServingConfigScaling.fromJson(core.Map json_)
    : this(
        cpuUtilizationTarget: json_['cpuUtilizationTarget'] as core.int?,
        maxNodeCount: json_['maxNodeCount'] as core.int?,
        minNodeCount: json_['minNodeCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpuUtilizationTarget != null)
      'cpuUtilizationTarget': cpuUtilizationTarget!,
    if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
    if (minNodeCount != null) 'minNodeCount': minNodeCount!,
  };
}

/// Used by:
///
/// - gmailpostmastertools:v1 : FeedbackLoop
/// - gmailpostmastertools:v1beta1 : FeedbackLoop
class $FeedbackLoop {
  /// Feedback loop identifier that uniquely identifies individual campaigns.
  core.String? id;

  /// The ratio of user marked spam messages with the identifier vs the total
  /// number of inboxed messages with that identifier.
  core.double? spamRatio;

  $FeedbackLoop({this.id, this.spamRatio});

  $FeedbackLoop.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        spamRatio: (json_['spamRatio'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (spamRatio != null) 'spamRatio': spamRatio!,
  };
}

/// Used by:
///
/// - composer:v1 : FetchDatabasePropertiesResponse
/// - composer:v1beta1 : FetchDatabasePropertiesResponse
class $FetchDatabasePropertiesResponse {
  /// The availability status of the failover replica.
  ///
  /// A false status indicates that the failover replica is out of sync. The
  /// primary instance can only fail over to the failover replica when the
  /// status is true.
  core.bool? isFailoverReplicaAvailable;

  /// The Compute Engine zone that the instance is currently serving from.
  core.String? primaryGceZone;

  /// The Compute Engine zone that the failover instance is currently serving
  /// from for a regional Cloud SQL instance.
  core.String? secondaryGceZone;

  $FetchDatabasePropertiesResponse({
    this.isFailoverReplicaAvailable,
    this.primaryGceZone,
    this.secondaryGceZone,
  });

  $FetchDatabasePropertiesResponse.fromJson(core.Map json_)
    : this(
        isFailoverReplicaAvailable:
            json_['isFailoverReplicaAvailable'] as core.bool?,
        primaryGceZone: json_['primaryGceZone'] as core.String?,
        secondaryGceZone: json_['secondaryGceZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isFailoverReplicaAvailable != null)
      'isFailoverReplicaAvailable': isFailoverReplicaAvailable!,
    if (primaryGceZone != null) 'primaryGceZone': primaryGceZone!,
    if (secondaryGceZone != null) 'secondaryGceZone': secondaryGceZone!,
  };
}

/// Used by:
///
/// - cloudbuild:v2 : FetchGitRefsResponse
/// - developerconnect:v1 : FetchGitRefsResponse
class $FetchGitRefsResponse {
  /// A token identifying a page of results the server should return.
  core.String? nextPageToken;

  /// Name of the refs fetched.
  core.List<core.String>? refNames;

  $FetchGitRefsResponse({this.nextPageToken, this.refNames});

  $FetchGitRefsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        refNames:
            (json_['refNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (refNames != null) 'refNames': refNames!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FetchPredictOperationRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FetchPredictOperationRequest
class $FetchPredictOperationRequest {
  /// The server-assigned name for the operation.
  ///
  /// Required.
  core.String? operationName;

  $FetchPredictOperationRequest({this.operationName});

  $FetchPredictOperationRequest.fromJson(core.Map json_)
    : this(operationName: json_['operationName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (operationName != null) 'operationName': operationName!,
  };
}

/// Used by:
///
/// - datastream:v1 : FetchStaticIpsResponse
/// - datastream:v1alpha1 : FetchStaticIpsResponse
class $FetchStaticIpsResponse {
  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// list of static ips by account
  core.List<core.String>? staticIps;

  $FetchStaticIpsResponse({this.nextPageToken, this.staticIps});

  $FetchStaticIpsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        staticIps:
            (json_['staticIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (staticIps != null) 'staticIps': staticIps!,
  };
}

/// Used by:
///
/// - healthcare:v1 : FhirStoreMetric
/// - healthcare:v1beta1 : FhirStoreMetric
class $FhirStoreMetric {
  /// The total count of FHIR resources in the store of this resource type.
  core.String? count;

  /// The FHIR resource type this metric applies to.
  core.String? resourceType;

  /// The total amount of structured storage used by FHIR resources of this
  /// resource type in the store.
  core.String? structuredStorageSizeBytes;

  $FhirStoreMetric({
    this.count,
    this.resourceType,
    this.structuredStorageSizeBytes,
  });

  $FhirStoreMetric.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
        structuredStorageSizeBytes:
            json_['structuredStorageSizeBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (resourceType != null) 'resourceType': resourceType!,
    if (structuredStorageSizeBytes != null)
      'structuredStorageSizeBytes': structuredStorageSizeBytes!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1FhirStoreSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaFhirStoreSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaFhirStoreSource
class $FhirStoreSource {
  /// The full resource name of the FHIR store to import data from, in the
  /// format of
  /// `projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}`.
  ///
  /// Required.
  core.String? fhirStore;

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters.
  ///
  /// Can be specified if one wants to have the FhirStore export to a specific
  /// Cloud Storage directory.
  core.String? gcsStagingDir;

  /// The FHIR resource types to import.
  ///
  /// The resource types should be a subset of all
  /// [supported FHIR resource types](https://cloud.google.com/generative-ai-app-builder/docs/fhir-schema-reference#resource-level-specification).
  /// Default to all supported FHIR resource types if empty.
  core.List<core.String>? resourceTypes;

  /// Whether to update the DataStore schema to the latest predefined schema.
  ///
  /// If true, the DataStore schema will be updated to include any FHIR fields
  /// or resource types that have been added since the last import and
  /// corresponding FHIR resources will be imported from the FHIR store. Note
  /// this field cannot be used in conjunction with `resource_types`. It should
  /// be used after initial import.
  ///
  /// Optional.
  core.bool? updateFromLatestPredefinedSchema;

  $FhirStoreSource({
    this.fhirStore,
    this.gcsStagingDir,
    this.resourceTypes,
    this.updateFromLatestPredefinedSchema,
  });

  $FhirStoreSource.fromJson(core.Map json_)
    : this(
        fhirStore: json_['fhirStore'] as core.String?,
        gcsStagingDir: json_['gcsStagingDir'] as core.String?,
        resourceTypes:
            (json_['resourceTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        updateFromLatestPredefinedSchema:
            json_['updateFromLatestPredefinedSchema'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fhirStore != null) 'fhirStore': fhirStore!,
    if (gcsStagingDir != null) 'gcsStagingDir': gcsStagingDir!,
    if (resourceTypes != null) 'resourceTypes': resourceTypes!,
    if (updateFromLatestPredefinedSchema != null)
      'updateFromLatestPredefinedSchema': updateFromLatestPredefinedSchema!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Field
/// - healthcare:v1beta1 : Field
class $Field {
  /// The maximum number of times this field can be repeated.
  ///
  /// 0 or -1 means unbounded.
  core.int? maxOccurs;

  /// The minimum number of times this field must be present/repeated.
  core.int? minOccurs;

  /// The name of the field.
  ///
  /// For example, "PID-1" or just "1".
  core.String? name;

  /// The HL7v2 table this field refers to.
  ///
  /// For example, PID-15 (Patient's Primary Language) usually refers to table
  /// "0296".
  core.String? table;

  /// The type of this field.
  ///
  /// A Type with this name must be defined in an Hl7TypesConfig.
  core.String? type;

  $Field({this.maxOccurs, this.minOccurs, this.name, this.table, this.type});

  $Field.fromJson(core.Map json_)
    : this(
        maxOccurs: json_['maxOccurs'] as core.int?,
        minOccurs: json_['minOccurs'] as core.int?,
        name: json_['name'] as core.String?,
        table: json_['table'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxOccurs != null) 'maxOccurs': maxOccurs!,
    if (minOccurs != null) 'minOccurs': minOccurs!,
    if (name != null) 'name': name!,
    if (table != null) 'table': table!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldAppliedCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldAppliedCapabilities
class $FieldAppliedCapabilities {
  /// Whether the user can read related applied metadata on items.
  core.bool? canRead;

  /// Whether the user can search for Drive items referencing this field.
  core.bool? canSearch;

  /// Whether the user can set this field on Drive items.
  core.bool? canWrite;

  $FieldAppliedCapabilities({this.canRead, this.canSearch, this.canWrite});

  $FieldAppliedCapabilities.fromJson(core.Map json_)
    : this(
        canRead: json_['canRead'] as core.bool?,
        canSearch: json_['canSearch'] as core.bool?,
        canWrite: json_['canWrite'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canRead != null) 'canRead': canRead!,
    if (canSearch != null) 'canSearch': canSearch!,
    if (canWrite != null) 'canWrite': canWrite!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldDisplayHints
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldDisplayHints
class $FieldDisplayHints {
  /// Whether the field should be shown in the UI as disabled.
  core.bool? disabled;

  /// This field should be hidden in the search menu when searching for Drive
  /// items.
  core.bool? hiddenInSearch;

  /// Whether the field should be shown as required in the UI.
  core.bool? required;

  /// This field should be shown in the apply menu when applying values to a
  /// Drive item.
  core.bool? shownInApply;

  $FieldDisplayHints({
    this.disabled,
    this.hiddenInSearch,
    this.required,
    this.shownInApply,
  });

  $FieldDisplayHints.fromJson(core.Map json_)
    : this(
        disabled: json_['disabled'] as core.bool?,
        hiddenInSearch: json_['hiddenInSearch'] as core.bool?,
        required: json_['required'] as core.bool?,
        shownInApply: json_['shownInApply'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
    if (hiddenInSearch != null) 'hiddenInSearch': hiddenInSearch!,
    if (required != null) 'required': required!,
    if (shownInApply != null) 'shownInApply': shownInApply!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldIntegerOptions
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldIntegerOptions
class $FieldIntegerOptions {
  /// The maximum valid value for the integer field.
  ///
  /// Output only.
  core.String? maxValue;

  /// The minimum valid value for the integer field.
  ///
  /// Output only.
  core.String? minValue;

  $FieldIntegerOptions({this.maxValue, this.minValue});

  $FieldIntegerOptions.fromJson(core.Map json_)
    : this(
        maxValue: json_['maxValue'] as core.String?,
        minValue: json_['minValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldListOptions
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldListOptions
class $FieldListOptions {
  /// Maximum number of entries permitted.
  core.int? maxEntries;

  $FieldListOptions({this.maxEntries});

  $FieldListOptions.fromJson(core.Map json_)
    : this(maxEntries: json_['maxEntries'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxEntries != null) 'maxEntries': maxEntries!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldProperties
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldProperties
class $FieldProperties {
  /// The display text to show in the UI identifying this field.
  ///
  /// Required.
  core.String? displayName;

  /// Input only.
  ///
  /// Insert or move this field before the indicated field. If empty, the field
  /// is placed at the end of the list.
  core.String? insertBeforeField;

  /// Whether the field should be marked as required.
  core.bool? required;

  $FieldProperties({this.displayName, this.insertBeforeField, this.required});

  $FieldProperties.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        insertBeforeField: json_['insertBeforeField'] as core.String?,
        required: json_['required'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (insertBeforeField != null) 'insertBeforeField': insertBeforeField!,
    if (required != null) 'required': required!,
  };
}

/// Used by:
///
/// - firestore:v1 : FieldReference
/// - firestore:v1beta1 : FieldReference
class $FieldReference {
  /// A reference to a field in a document.
  ///
  /// Requires: * MUST be a dot-delimited (`.`) string of segments, where each
  /// segment conforms to document field name limitations.
  core.String? fieldPath;

  $FieldReference({this.fieldPath});

  $FieldReference.fromJson(core.Map json_)
    : this(fieldPath: json_['fieldPath'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldPath != null) 'fieldPath': fieldPath!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldSchemaCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldSchemaCapabilities
class $FieldSchemaCapabilities {
  /// Whether the user can delete this field.
  ///
  /// The user must have permission and the field must be deprecated.
  core.bool? canDelete;

  /// Whether the user can disable this field.
  ///
  /// The user must have permission and this field must not already be disabled.
  core.bool? canDisable;

  /// Whether the user can enable this field.
  ///
  /// The user must have permission and this field must be disabled.
  core.bool? canEnable;

  /// Whether the user can change this field.
  core.bool? canUpdate;

  $FieldSchemaCapabilities({
    this.canDelete,
    this.canDisable,
    this.canEnable,
    this.canUpdate,
  });

  $FieldSchemaCapabilities.fromJson(core.Map json_)
    : this(
        canDelete: json_['canDelete'] as core.bool?,
        canDisable: json_['canDisable'] as core.bool?,
        canEnable: json_['canEnable'] as core.bool?,
        canUpdate: json_['canUpdate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canDelete != null) 'canDelete': canDelete!,
    if (canDisable != null) 'canDisable': canDisable!,
    if (canEnable != null) 'canEnable': canEnable!,
    if (canUpdate != null) 'canUpdate': canUpdate!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldSelectionOptionsChoiceAppliedCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldSelectionOptionsChoiceAppliedCapabilities
class $FieldSelectionOptionsChoiceAppliedCapabilities {
  /// Whether the user can read related applied metadata on items.
  core.bool? canRead;

  /// Whether the user can use this choice in search queries.
  core.bool? canSearch;

  /// Whether the user can select this choice on an item.
  core.bool? canSelect;

  $FieldSelectionOptionsChoiceAppliedCapabilities({
    this.canRead,
    this.canSearch,
    this.canSelect,
  });

  $FieldSelectionOptionsChoiceAppliedCapabilities.fromJson(core.Map json_)
    : this(
        canRead: json_['canRead'] as core.bool?,
        canSearch: json_['canSearch'] as core.bool?,
        canSelect: json_['canSelect'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canRead != null) 'canRead': canRead!,
    if (canSearch != null) 'canSearch': canSearch!,
    if (canSelect != null) 'canSelect': canSelect!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldSelectionOptionsChoiceSchemaCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldSelectionOptionsChoiceSchemaCapabilities
class $FieldSelectionOptionsChoiceSchemaCapabilities {
  /// Whether the user can delete this choice.
  core.bool? canDelete;

  /// Whether the user can disable this choice.
  core.bool? canDisable;

  /// Whether the user can enable this choice.
  core.bool? canEnable;

  /// Whether the user can update this choice.
  core.bool? canUpdate;

  $FieldSelectionOptionsChoiceSchemaCapabilities({
    this.canDelete,
    this.canDisable,
    this.canEnable,
    this.canUpdate,
  });

  $FieldSelectionOptionsChoiceSchemaCapabilities.fromJson(core.Map json_)
    : this(
        canDelete: json_['canDelete'] as core.bool?,
        canDisable: json_['canDisable'] as core.bool?,
        canEnable: json_['canEnable'] as core.bool?,
        canUpdate: json_['canUpdate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canDelete != null) 'canDelete': canDelete!,
    if (canDisable != null) 'canDisable': canDisable!,
    if (canEnable != null) 'canEnable': canEnable!,
    if (canUpdate != null) 'canUpdate': canUpdate!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2FieldTextOptions
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaFieldTextOptions
class $FieldTextOptions {
  /// The maximum valid length of values for the text field.
  ///
  /// Output only.
  core.int? maxLength;

  /// The minimum valid length of values for the text field.
  ///
  /// Output only.
  core.int? minLength;

  $FieldTextOptions({this.maxLength, this.minLength});

  $FieldTextOptions.fromJson(core.Map json_)
    : this(
        maxLength: json_['maxLength'] as core.int?,
        minLength: json_['minLength'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxLength != null) 'maxLength': maxLength!,
    if (minLength != null) 'minLength': minLength!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : File
/// - containeranalysis:v1beta1 : File
/// - ondemandscanning:v1 : File
/// - ondemandscanning:v1beta1 : File
class $File00 {
  core.Map<core.String, core.String>? digest;
  core.String? name;

  $File00({this.digest, this.name});

  $File00.fromJson(core.Map json_)
    : this(
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : File
/// - firebasedataconnect:v1beta : File
class $File01 {
  /// The file's textual content.
  ///
  /// Required.
  core.String? content;

  /// The file name including folder path, if applicable.
  ///
  /// The path should be relative to a local workspace (e.g.
  /// dataconnect/(schema|connector) / * .gql) and not an absolute path (e.g.
  /// /absolute/path/(schema|connector) / * .gql).
  ///
  /// Required.
  core.String? path;

  $File01({this.content, this.path});

  $File01.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        path: json_['path'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - compute:alpha : FileContentBuffer
/// - compute:beta : FileContentBuffer
/// - compute:v1 : FileContentBuffer
class $FileContentBuffer {
  /// The raw content in the secure keys file.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The file type of source file.
  /// Possible string values are:
  /// - "BIN"
  /// - "UNDEFINED"
  /// - "X509"
  core.String? fileType;

  $FileContentBuffer({this.content, this.fileType});

  $FileContentBuffer.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        fileType: json_['fileType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (fileType != null) 'fileType': fileType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FileData
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FileData
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1FileData
class $FileData {
  /// Display name of the file data.
  ///
  /// Used to provide a label or filename to distinguish file datas. This field
  /// is only returned in PromptMessage for prompt management. It is currently
  /// used in the Gemini GenerateContent calls only when server side tools
  /// (code_execution, google_search, and url_context) are enabled.
  ///
  /// Optional.
  core.String? displayName;

  /// URI.
  ///
  /// Required.
  core.String? fileUri;

  /// The IANA standard MIME type of the source data.
  ///
  /// Required.
  core.String? mimeType;

  $FileData({this.displayName, this.fileUri, this.mimeType});

  $FileData.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        fileUri: json_['fileUri'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (fileUri != null) 'fileUri': fileUri!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - appengine:v1 : FileInfo
/// - appengine:v1beta : FileInfo
class $FileInfo {
  /// The MIME type of the file.Defaults to the value from Google Cloud Storage.
  core.String? mimeType;

  /// The SHA1 hash of the file, in hex.
  core.String? sha1Sum;

  /// URL source to use to fetch this file.
  ///
  /// Must be a URL to a resource in Google Cloud Storage in the form
  /// 'http(s)://storage.googleapis.com//'.
  core.String? sourceUrl;

  $FileInfo({this.mimeType, this.sha1Sum, this.sourceUrl});

  $FileInfo.fromJson(core.Map json_)
    : this(
        mimeType: json_['mimeType'] as core.String?,
        sha1Sum: json_['sha1Sum'] as core.String?,
        sourceUrl: json_['sourceUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mimeType != null) 'mimeType': mimeType!,
    if (sha1Sum != null) 'sha1Sum': sha1Sum!,
    if (sourceUrl != null) 'sourceUrl': sourceUrl!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : FileNote
/// - containeranalysis:v1beta1 : FileNote
class $FileNote {
  /// Provide a unique identifier to match analysis information on each specific
  /// file in a package
  core.List<core.String>? checksum;

  /// This field provides information about the type of file identified
  /// Possible string values are:
  /// - "FILE_TYPE_UNSPECIFIED" : Unspecified
  /// - "SOURCE" : The file is human readable source code (.c, .html, etc.)
  /// - "BINARY" : The file is a compiled object, target image or binary
  /// executable (.o, .a, etc.)
  /// - "ARCHIVE" : The file represents an archive (.tar, .jar, etc.)
  /// - "APPLICATION" : The file is associated with a specific application type
  /// (MIME type of application / * )
  /// - "AUDIO" : The file is associated with an audio file (MIME type of audio
  /// / * , e.g. .mp3)
  /// - "IMAGE" : The file is associated with an picture image file (MIME type
  /// of image / * , e.g., .jpg, .gif)
  /// - "TEXT" : The file is human readable text file (MIME type of text / * )
  /// - "VIDEO" : The file is associated with a video file type (MIME type of
  /// video / * )
  /// - "DOCUMENTATION" : The file serves as documentation
  /// - "SPDX" : The file is an SPDX document
  /// - "OTHER" : The file doesn't fit into the above categories (generated
  /// artifacts, data files, etc.)
  core.String? fileType;

  /// Identify the full path and filename that corresponds to the file
  /// information in this section
  core.String? title;

  $FileNote({this.checksum, this.fileType, this.title});

  $FileNote.fromJson(core.Map json_)
    : this(
        checksum:
            (json_['checksum'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        fileType: json_['fileType'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checksum != null) 'checksum': checksum!,
    if (fileType != null) 'fileType': fileType!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FileStatus
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FileStatus
class $FileStatus {
  /// Only when the `state` field is ERROR.
  ///
  /// Output only.
  core.String? errorStatus;

  /// RagFile state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : RagFile state is unspecified.
  /// - "ACTIVE" : RagFile resource has been created and indexed successfully.
  /// - "ERROR" : RagFile resource is in a problematic state. See
  /// `error_message` field for details.
  core.String? state;

  $FileStatus({this.errorStatus, this.state});

  $FileStatus.fromJson(core.Map json_)
    : this(
        errorStatus: json_['errorStatus'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorStatus != null) 'errorStatus': errorStatus!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - container:v1 : Filter
/// - container:v1beta1 : Filter
class $Filter {
  /// Event types to allowlist.
  core.List<core.String>? eventType;

  $Filter({this.eventType});

  $Filter.fromJson(core.Map json_)
    : this(
        eventType:
            (json_['eventType'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (eventType != null) 'eventType': eventType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExportFilterSplit
/// - aiplatform:v1 : GoogleCloudAiplatformV1FilterSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FilterSplit
class $FilterSplit {
  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to test the Model. A filter with
  /// same syntax as the one used in DatasetService.ListDataItems may be used.
  /// If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? testFilter;

  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to train the Model. A filter
  /// with same syntax as the one used in DatasetService.ListDataItems may be
  /// used. If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? trainingFilter;

  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to validate the Model. A filter
  /// with same syntax as the one used in DatasetService.ListDataItems may be
  /// used. If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? validationFilter;

  $FilterSplit({this.testFilter, this.trainingFilter, this.validationFilter});

  $FilterSplit.fromJson(core.Map json_)
    : this(
        testFilter: json_['testFilter'] as core.String?,
        trainingFilter: json_['trainingFilter'] as core.String?,
        validationFilter: json_['validationFilter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (testFilter != null) 'testFilter': testFilter!,
    if (trainingFilter != null) 'trainingFilter': trainingFilter!,
    if (validationFilter != null) 'validationFilter': validationFilter!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FindNeighborsRequestQueryRRF
class $FindNeighborsRequestQueryRRF {
  /// Users can provide an alpha value to give more weight to dense vs sparse
  /// results.
  ///
  /// For example, if the alpha is 0, we only return sparse and if the alpha is
  /// 1, we only return dense.
  ///
  /// Required.
  core.double? alpha;

  $FindNeighborsRequestQueryRRF({this.alpha});

  $FindNeighborsRequestQueryRRF.fromJson(core.Map json_)
    : this(alpha: (json_['alpha'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (alpha != null) 'alpha': alpha!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Fingerprint
/// - containeranalysis:v1beta1 : Fingerprint
/// - ondemandscanning:v1 : Fingerprint
/// - ondemandscanning:v1beta1 : Fingerprint
class $Fingerprint {
  /// The layer ID of the final layer in the Docker image's v1 representation.
  ///
  /// Required.
  core.String? v1Name;

  /// The ordered list of v2 blobs that represent a given image.
  ///
  /// Required.
  core.List<core.String>? v2Blob;

  /// The name of the image's v2 blobs computed via: \[bottom\] := v2_blobbottom
  /// := sha256(v2_blob\[N\] + " " + v2_name\[N+1\]) Only the name of the final
  /// blob is kept.
  ///
  /// Output only.
  core.String? v2Name;

  $Fingerprint({this.v1Name, this.v2Blob, this.v2Name});

  $Fingerprint.fromJson(core.Map json_)
    : this(
        v1Name: json_['v1Name'] as core.String?,
        v2Blob:
            (json_['v2Blob'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        v2Name: json_['v2Name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (v1Name != null) 'v1Name': v1Name!,
    if (v2Blob != null) 'v2Blob': v2Blob!,
    if (v2Name != null) 'v2Name': v2Name!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaFirebaseLink
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaFirebaseLink
class $FirebaseLink {
  /// Time when this FirebaseLink was originally created.
  ///
  /// Output only.
  core.String? createTime;

  /// Example format: properties/1234/firebaseLinks/5678
  ///
  /// Output only.
  core.String? name;

  /// Firebase project resource name.
  ///
  /// When creating a FirebaseLink, you may provide this resource name using
  /// either a project number or project ID. Once this resource has been
  /// created, returned FirebaseLinks will always have a project_name that
  /// contains a project number. Format: 'projects/{project number}' Example:
  /// 'projects/1234'
  ///
  /// Immutable.
  core.String? project;

  $FirebaseLink({this.createTime, this.name, this.project});

  $FirebaseLink.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        project: json_['project'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (project != null) 'project': project!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1FirestoreSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaFirestoreSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaFirestoreSource
class $FirestoreSource {
  /// The Firestore collection (or entity) to copy the data from with a length
  /// limit of 1,500 characters.
  ///
  /// Required.
  core.String? collectionId;

  /// The Firestore database to copy the data from with a length limit of 256
  /// characters.
  ///
  /// Required.
  core.String? databaseId;

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters.
  ///
  /// Can be specified if one wants to have the Firestore export to a specific
  /// Cloud Storage directory. Ensure that the Firestore service account has the
  /// necessary Cloud Storage Admin permissions to access the specified Cloud
  /// Storage directory.
  core.String? gcsStagingDir;

  /// The project ID that the Cloud SQL source is in with a length limit of 128
  /// characters.
  ///
  /// If not specified, inherits the project ID from the parent request.
  core.String? projectId;

  $FirestoreSource({
    this.collectionId,
    this.databaseId,
    this.gcsStagingDir,
    this.projectId,
  });

  $FirestoreSource.fromJson(core.Map json_)
    : this(
        collectionId: json_['collectionId'] as core.String?,
        databaseId: json_['databaseId'] as core.String?,
        gcsStagingDir: json_['gcsStagingDir'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collectionId != null) 'collectionId': collectionId!,
    if (databaseId != null) 'databaseId': databaseId!,
    if (gcsStagingDir != null) 'gcsStagingDir': gcsStagingDir!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : FirewallEndpointAssociation
/// - networksecurity:v1beta1 : FirewallEndpointAssociation
class $FirewallEndpointAssociation {
  /// Create time stamp
  ///
  /// Output only.
  core.String? createTime;

  /// Whether the association is disabled.
  ///
  /// True indicates that traffic won't be intercepted
  ///
  /// Optional.
  core.bool? disabled;

  /// The URL of the FirewallEndpoint that is being associated.
  ///
  /// Required.
  core.String? firewallEndpoint;

  /// Labels as key value pairs
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// name of resource
  ///
  /// Immutable.
  core.String? name;

  /// The URL of the network that is being associated.
  ///
  /// Required.
  core.String? network;

  /// Whether reconciling is in progress, recommended per
  /// https://google.aip.dev/128.
  ///
  /// Output only.
  core.bool? reconciling;

  /// Current state of the association.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "CREATING" : Being created.
  /// - "ACTIVE" : Active and ready for traffic.
  /// - "DELETING" : Being deleted.
  /// - "INACTIVE" : Down or in an error state.
  /// - "ORPHAN" : The project that housed the association has been deleted.
  core.String? state;

  /// The URL of the TlsInspectionPolicy that is being associated.
  ///
  /// Optional.
  core.String? tlsInspectionPolicy;

  /// Update time stamp
  ///
  /// Output only.
  core.String? updateTime;

  $FirewallEndpointAssociation({
    this.createTime,
    this.disabled,
    this.firewallEndpoint,
    this.labels,
    this.name,
    this.network,
    this.reconciling,
    this.state,
    this.tlsInspectionPolicy,
    this.updateTime,
  });

  $FirewallEndpointAssociation.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        disabled: json_['disabled'] as core.bool?,
        firewallEndpoint: json_['firewallEndpoint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        reconciling: json_['reconciling'] as core.bool?,
        state: json_['state'] as core.String?,
        tlsInspectionPolicy: json_['tlsInspectionPolicy'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (disabled != null) 'disabled': disabled!,
    if (firewallEndpoint != null) 'firewallEndpoint': firewallEndpoint!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (reconciling != null) 'reconciling': reconciling!,
    if (state != null) 'state': state!,
    if (tlsInspectionPolicy != null)
      'tlsInspectionPolicy': tlsInspectionPolicy!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : FirewallEndpointAssociationReference
/// - networksecurity:v1beta1 : FirewallEndpointAssociationReference
class $FirewallEndpointAssociationReference {
  /// The resource name of the FirewallEndpointAssociation.
  ///
  /// Format:
  /// projects/{project}/locations/{location}/firewallEndpointAssociations/{id}
  ///
  /// Output only.
  core.String? name;

  /// The VPC network associated.
  ///
  /// Format: projects/{project}/global/networks/{name}.
  ///
  /// Output only.
  core.String? network;

  $FirewallEndpointAssociationReference({this.name, this.network});

  $FirewallEndpointAssociationReference.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : FirewallInfo
/// - networkmanagement:v1beta1 : FirewallInfo
class $FirewallInfo {
  /// Possible values: ALLOW, DENY, APPLY_SECURITY_PROFILE_GROUP
  core.String? action;

  /// Possible values: INGRESS, EGRESS
  core.String? direction;

  /// The display name of the firewall rule.
  ///
  /// This field might be empty for firewall policy rules.
  core.String? displayName;

  /// The firewall rule's type.
  /// Possible string values are:
  /// - "FIREWALL_RULE_TYPE_UNSPECIFIED" : Unspecified type.
  /// - "HIERARCHICAL_FIREWALL_POLICY_RULE" : Hierarchical firewall policy rule.
  /// For details, see
  /// [Hierarchical firewall policies overview](https://cloud.google.com/vpc/docs/firewall-policies).
  /// - "VPC_FIREWALL_RULE" : VPC firewall rule. For details, see
  /// [VPC firewall rules overview](https://cloud.google.com/vpc/docs/firewalls).
  /// - "IMPLIED_VPC_FIREWALL_RULE" : Implied VPC firewall rule. For details,
  /// see
  /// [Implied rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
  /// - "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE" : Implicit firewall rules
  /// that are managed by serverless VPC access to allow ingress access. They
  /// are not visible in the Google Cloud console. For details, see
  /// [VPC connector's implicit rules](https://cloud.google.com/functions/docs/networking/connecting-vpc#restrict-access).
  /// - "NETWORK_FIREWALL_POLICY_RULE" : Global network firewall policy rule.
  /// For details, see
  /// [Network firewall policies](https://cloud.google.com/vpc/docs/network-firewall-policies).
  /// - "NETWORK_REGIONAL_FIREWALL_POLICY_RULE" : Regional network firewall
  /// policy rule. For details, see
  /// [Regional network firewall policies](https://cloud.google.com/firewall/docs/regional-firewall-policies).
  /// - "UNSUPPORTED_FIREWALL_POLICY_RULE" : Firewall policy rule containing
  /// attributes not yet supported in Connectivity tests. Firewall analysis is
  /// skipped if such a rule can potentially be matched. Please see the
  /// [list of unsupported configurations](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs).
  /// - "TRACKING_STATE" : Tracking state for response traffic created when
  /// request traffic goes through allow firewall rule. For details, see
  /// [firewall rules specifications](https://cloud.google.com/firewall/docs/firewalls#specifications)
  /// - "ANALYSIS_SKIPPED" : Firewall analysis was skipped due to executing
  /// Connectivity Test in the BypassFirewallChecks mode
  core.String? firewallRuleType;

  /// The URI of the VPC network that the firewall rule is associated with.
  ///
  /// This field is not applicable to hierarchical firewall policy rules.
  core.String? networkUri;

  /// The name of the firewall policy that this rule is associated with.
  ///
  /// This field is not applicable to VPC firewall rules and implied VPC
  /// firewall rules.
  core.String? policy;

  /// The priority of the firewall policy that this rule is associated with.
  ///
  /// This field is not applicable to VPC firewall rules and implied VPC
  /// firewall rules.
  core.int? policyPriority;

  /// The URI of the firewall policy that this rule is associated with.
  ///
  /// This field is not applicable to VPC firewall rules and implied VPC
  /// firewall rules.
  core.String? policyUri;

  /// The priority of the firewall rule.
  core.int? priority;

  /// The target service accounts specified by the firewall rule.
  core.List<core.String>? targetServiceAccounts;

  /// The target tags defined by the VPC firewall rule.
  ///
  /// This field is not applicable to firewall policy rules.
  core.List<core.String>? targetTags;

  /// The URI of the firewall rule.
  ///
  /// This field is not applicable to implied VPC firewall rules.
  core.String? uri;

  $FirewallInfo({
    this.action,
    this.direction,
    this.displayName,
    this.firewallRuleType,
    this.networkUri,
    this.policy,
    this.policyPriority,
    this.policyUri,
    this.priority,
    this.targetServiceAccounts,
    this.targetTags,
    this.uri,
  });

  $FirewallInfo.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        direction: json_['direction'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        firewallRuleType: json_['firewallRuleType'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        policy: json_['policy'] as core.String?,
        policyPriority: json_['policyPriority'] as core.int?,
        policyUri: json_['policyUri'] as core.String?,
        priority: json_['priority'] as core.int?,
        targetServiceAccounts:
            (json_['targetServiceAccounts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetTags:
            (json_['targetTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (direction != null) 'direction': direction!,
    if (displayName != null) 'displayName': displayName!,
    if (firewallRuleType != null) 'firewallRuleType': firewallRuleType!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (policy != null) 'policy': policy!,
    if (policyPriority != null) 'policyPriority': policyPriority!,
    if (policyUri != null) 'policyUri': policyUri!,
    if (priority != null) 'priority': priority!,
    if (targetServiceAccounts != null)
      'targetServiceAccounts': targetServiceAccounts!,
    if (targetTags != null) 'targetTags': targetTags!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - compute:alpha : FirewallLogConfig
/// - compute:beta : FirewallLogConfig
/// - compute:v1 : FirewallLogConfig
class $FirewallLogConfig {
  /// This field denotes whether to enable logging for a particular firewall
  /// rule.
  core.bool? enable;

  /// This field can only be specified for a particular firewall rule if logging
  /// is enabled for that rule.
  ///
  /// This field denotes whether to include or exclude metadata for firewall
  /// logs.
  /// Possible string values are:
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  $FirewallLogConfig({this.enable, this.metadata});

  $FirewallLogConfig.fromJson(core.Map json_)
    : this(
        enable: json_['enable'] as core.bool?,
        metadata: json_['metadata'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Used by:
///
/// - compute:alpha : FirewallPolicyAssociation
/// - compute:beta : FirewallPolicyAssociation
class $FirewallPolicyAssociation {
  /// The target that the firewall policy is attached to.
  core.String? attachmentTarget;

  /// Deprecated, please use short name instead.
  ///
  /// The display name of the firewall policy of the association.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? displayName;

  /// The firewall policy ID of the association.
  ///
  /// Output only.
  core.String? firewallPolicyId;

  /// The name for an association.
  core.String? name;

  /// An integer indicating the priority of an association.
  ///
  /// The priority must be a positive value between 1 and 2147483647. Firewall
  /// Policies are evaluated from highest to lowest priority where 1 is the
  /// highest priority and 2147483647 is the lowest priority. The default value
  /// is `1000`. If two associations have the same priority then lexicographical
  /// order on association names is applied.
  core.int? priority;

  /// The short name of the firewall policy of the association.
  ///
  /// Output only.
  core.String? shortName;

  $FirewallPolicyAssociation({
    this.attachmentTarget,
    this.displayName,
    this.firewallPolicyId,
    this.name,
    this.priority,
    this.shortName,
  });

  $FirewallPolicyAssociation.fromJson(core.Map json_)
    : this(
        attachmentTarget: json_['attachmentTarget'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        firewallPolicyId: json_['firewallPolicyId'] as core.String?,
        name: json_['name'] as core.String?,
        priority: json_['priority'] as core.int?,
        shortName: json_['shortName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachmentTarget != null) 'attachmentTarget': attachmentTarget!,
    if (displayName != null) 'displayName': displayName!,
    if (firewallPolicyId != null) 'firewallPolicyId': firewallPolicyId!,
    if (name != null) 'name': name!,
    if (priority != null) 'priority': priority!,
    if (shortName != null) 'shortName': shortName!,
  };
}

/// Used by:
///
/// - compute:alpha : FirewallPolicyRuleMatcherLayer4Config
/// - compute:beta : FirewallPolicyRuleMatcherLayer4Config
/// - compute:v1 : FirewallPolicyRuleMatcherLayer4Config
class $FirewallPolicyRuleMatcherLayer4Config {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp), or the IP protocol number.
  core.String? ipProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for UDP or TCP protocol. Each entry must be
  /// either an integer or a range. If not specified, this rule applies to
  /// connections through any port. Example inputs include: \["22"\],
  /// \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  $FirewallPolicyRuleMatcherLayer4Config({this.ipProtocol, this.ports});

  $FirewallPolicyRuleMatcherLayer4Config.fromJson(core.Map json_)
    : this(
        ipProtocol: json_['ipProtocol'] as core.String?,
        ports:
            (json_['ports'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipProtocol != null) 'ipProtocol': ipProtocol!,
    if (ports != null) 'ports': ports!,
  };
}

/// Used by:
///
/// - compute:alpha : FirewallPolicyRuleSecureTag
/// - compute:beta : FirewallPolicyRuleSecureTag
/// - compute:v1 : FirewallPolicyRuleSecureTag
class $FirewallPolicyRuleSecureTag {
  /// Name of the secure tag, created with TagManager's TagValue API.
  core.String? name;

  /// State of the secure tag, either `EFFECTIVE` or `INEFFECTIVE`.
  ///
  /// A secure tag is `INEFFECTIVE` when it is deleted or its network is
  /// deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EFFECTIVE"
  /// - "INEFFECTIVE"
  core.String? state;

  $FirewallPolicyRuleSecureTag({this.name, this.state});

  $FirewallPolicyRuleSecureTag.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - appengine:v1 : FirewallRule
/// - appengine:v1beta : FirewallRule
class $FirewallRule {
  /// The action to take on matched requests.
  /// Possible string values are:
  /// - "UNSPECIFIED_ACTION"
  /// - "ALLOW" : Matching requests are allowed.
  /// - "DENY" : Matching requests are denied.
  core.String? action;

  /// An optional string description of this rule.
  ///
  /// This field has a maximum length of 400 characters.
  core.String? description;

  /// A positive integer between 1, Int32.MaxValue-1 that defines the order of
  /// rule evaluation.
  ///
  /// Rules with the lowest priority are evaluated first.A default rule at
  /// priority Int32.MaxValue matches all IPv4 and IPv6 traffic when no previous
  /// rule matches. Only the action of this rule can be modified by the user.
  core.int? priority;

  /// IP address or range, defined using CIDR notation, of requests that this
  /// rule applies to.
  ///
  /// You can use the wildcard character "*" to match all IPs equivalent to
  /// "0/0" and "::/0" together. Examples: 192.168.1.1 or 192.168.0.0/16 or
  /// 2001:db8::/32 or 2001:0db8:0000:0042:0000:8a2e:0370:7334. Truncation will
  /// be silently performed on addresses which are not properly truncated. For
  /// example, 1.2.3.4/24 is accepted as the same address as 1.2.3.0/24.
  /// Similarly, for IPv6, 2001:db8::1/32 is accepted as the same address as
  /// 2001:db8::/32.
  core.String? sourceRange;

  $FirewallRule({
    this.action,
    this.description,
    this.priority,
    this.sourceRange,
  });

  $FirewallRule.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        description: json_['description'] as core.String?,
        priority: json_['priority'] as core.int?,
        sourceRange: json_['sourceRange'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (description != null) 'description': description!,
    if (priority != null) 'priority': priority!,
    if (sourceRange != null) 'sourceRange': sourceRange!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : FirstPartyMobileApplicationTargeting
/// - authorizedbuyersmarketplace:v1 : FirstPartyMobileApplicationTargeting
/// - authorizedbuyersmarketplace:v1alpha : FirstPartyMobileApplicationTargeting
class $FirstPartyMobileApplicationTargeting {
  /// A list of application IDs to be excluded.
  core.List<core.String>? excludedAppIds;

  /// A list of application IDs to be included.
  core.List<core.String>? targetedAppIds;

  $FirstPartyMobileApplicationTargeting({
    this.excludedAppIds,
    this.targetedAppIds,
  });

  $FirstPartyMobileApplicationTargeting.fromJson(core.Map json_)
    : this(
        excludedAppIds:
            (json_['excludedAppIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetedAppIds:
            (json_['targetedAppIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedAppIds != null) 'excludedAppIds': excludedAppIds!,
    if (targetedAppIds != null) 'targetedAppIds': targetedAppIds!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : FitDescriptor
/// - migrationcenter:v1alpha1 : FitDescriptor
class $FitDescriptor {
  /// Fit level.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "FIT_LEVEL_UNSPECIFIED" : Not enough information.
  /// - "FIT" : Fit.
  /// - "NO_FIT" : No Fit.
  /// - "REQUIRES_EFFORT" : Fit with effort.
  core.String? fitLevel;

  $FitDescriptor({this.fitLevel});

  $FitDescriptor.fromJson(core.Map json_)
    : this(fitLevel: json_['fitLevel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fitLevel != null) 'fitLevel': fitLevel!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : FixedBidStrategy
/// - displayvideo:v3 : FixedBidStrategy
/// - displayvideo:v4 : FixedBidStrategy
class $FixedBidStrategy {
  /// The fixed bid amount, in micros of the advertiser's currency.
  ///
  /// For insertion order entity, bid_amount_micros should be set as 0. For line
  /// item entity, bid_amount_micros must be greater than or equal to billable
  /// unit of the given currency and smaller than or equal to the upper limit
  /// 1000000000. For example, 1500000 represents 1.5 standard units of the
  /// currency.
  core.String? bidAmountMicros;

  $FixedBidStrategy({this.bidAmountMicros});

  $FixedBidStrategy.fromJson(core.Map json_)
    : this(bidAmountMicros: json_['bidAmountMicros'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (bidAmountMicros != null) 'bidAmountMicros': bidAmountMicros!,
  };
}

/// Used by:
///
/// - file:v1 : FixedIOPS
/// - file:v1beta1 : FixedIOPS
class $FixedIOPS {
  /// Maximum IOPS.
  ///
  /// Required.
  core.String? maxIops;

  $FixedIOPS({this.maxIops});

  $FixedIOPS.fromJson(core.Map json_)
    : this(maxIops: json_['maxIops'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxIops != null) 'maxIops': maxIops!,
  };
}

/// Used by:
///
/// - osconfig:v1 : FixedOrPercent
/// - osconfig:v1alpha : FixedOrPercent
/// - osconfig:v1beta : FixedOrPercent
/// - osconfig:v2 : FixedOrPercent
/// - osconfig:v2beta : FixedOrPercent
class $FixedOrPercent00 {
  /// Specifies a fixed value.
  core.int? fixed;

  /// Specifies the relative value defined as a percentage, which will be
  /// multiplied by a reference value.
  core.int? percent;

  $FixedOrPercent00({this.fixed, this.percent});

  $FixedOrPercent00.fromJson(core.Map json_)
    : this(
        fixed: json_['fixed'] as core.int?,
        percent: json_['percent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fixed != null) 'fixed': fixed!,
    if (percent != null) 'percent': percent!,
  };
}

/// Used by:
///
/// - compute:alpha : FixedOrPercent
/// - compute:beta : FixedOrPercent
/// - compute:v1 : FixedOrPercent
class $FixedOrPercent01 {
  /// Absolute value of VM instances calculated based on the specific mode.
  ///
  /// - If the value is fixed, then the calculated value is equal to the fixed
  /// value. - If the value is a percent, then the calculated value is
  /// percent/100 * targetSize. For example, the calculated value of a 80% of a
  /// managed instance group with 150 instances would be (80/100 * 150) = 120 VM
  /// instances. If there is a remainder, the number is rounded.
  ///
  /// Output only.
  core.int? calculated;

  /// Specifies a fixed number of VM instances.
  ///
  /// This must be a positive integer.
  core.int? fixed;

  /// Specifies a percentage of instances between 0 to 100%, inclusive.
  ///
  /// For example, specify 80 for 80%.
  core.int? percent;

  $FixedOrPercent01({this.calculated, this.fixed, this.percent});

  $FixedOrPercent01.fromJson(core.Map json_)
    : this(
        calculated: json_['calculated'] as core.int?,
        fixed: json_['fixed'] as core.int?,
        percent: json_['percent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (calculated != null) 'calculated': calculated!,
    if (fixed != null) 'fixed': fixed!,
    if (percent != null) 'percent': percent!,
  };
}

/// Used by:
///
/// - container:v1 : Fleet
/// - container:v1beta1 : Fleet
class $Fleet {
  /// The full resource name of the registered fleet membership of the cluster,
  /// in the format `//gkehub.googleapis.com/projects / * /locations / *
  /// /memberships / * `.
  ///
  /// Output only.
  core.String? membership;

  /// The type of the cluster's fleet membership.
  /// Possible string values are:
  /// - "MEMBERSHIP_TYPE_UNSPECIFIED" : The MembershipType is not set.
  /// - "LIGHTWEIGHT" : The membership supports only lightweight compatible
  /// features.
  core.String? membershipType;

  /// Whether the cluster has been registered through the fleet API.
  ///
  /// Output only.
  core.bool? preRegistered;

  /// The Fleet host project(project ID or project number) where this cluster
  /// will be registered to.
  ///
  /// This field cannot be changed after the cluster has been registered.
  core.String? project;

  $Fleet({
    this.membership,
    this.membershipType,
    this.preRegistered,
    this.project,
  });

  $Fleet.fromJson(core.Map json_)
    : this(
        membership: json_['membership'] as core.String?,
        membershipType: json_['membershipType'] as core.String?,
        preRegistered: json_['preRegistered'] as core.bool?,
        project: json_['project'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (membership != null) 'membership': membership!,
    if (membershipType != null) 'membershipType': membershipType!,
    if (preRegistered != null) 'preRegistered': preRegistered!,
    if (project != null) 'project': project!,
  };
}

/// Used by:
///
/// - gkehub:v1 : FleetLifecycleState
/// - gkehub:v1alpha : FleetLifecycleState
/// - gkehub:v1beta : FleetLifecycleState
class $FleetLifecycleState {
  /// The current state of the Fleet resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The fleet is being created.
  /// - "READY" : The fleet active.
  /// - "DELETING" : The fleet is being deleted.
  /// - "UPDATING" : The fleet is being updated.
  core.String? code;

  $FleetLifecycleState({this.code});

  $FleetLifecycleState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - gkehub:v1 : FleetObservabilityFeatureError
/// - gkehub:v1alpha : FleetObservabilityFeatureError
/// - gkehub:v1beta : FleetObservabilityFeatureError
class $FleetObservabilityFeatureError {
  /// The code of the error.
  core.String? code;

  /// A human-readable description of the current status.
  core.String? description;

  $FleetObservabilityFeatureError({this.code, this.description});

  $FleetObservabilityFeatureError.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        description: json_['description'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (description != null) 'description': description!,
  };
}

/// Used by:
///
/// - gkehub:v1 : FleetObservabilityRoutingConfig
/// - gkehub:v1alpha : FleetObservabilityRoutingConfig
/// - gkehub:v1beta : FleetObservabilityRoutingConfig
class $FleetObservabilityRoutingConfig {
  /// mode configures the logs routing mode.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : If UNSPECIFIED, fleet logging feature is disabled.
  /// - "COPY" : logs will be copied to the destination project.
  /// - "MOVE" : logs will be moved to the destination project.
  core.String? mode;

  $FleetObservabilityRoutingConfig({this.mode});

  $FleetObservabilityRoutingConfig.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - appengine:v1 : FlexibleRuntimeSettings
/// - appengine:v1beta : FlexibleRuntimeSettings
class $FlexibleRuntimeSettings {
  /// The operating system of the application runtime.
  core.String? operatingSystem;

  /// The runtime version of an App Engine flexible application.
  core.String? runtimeVersion;

  $FlexibleRuntimeSettings({this.operatingSystem, this.runtimeVersion});

  $FlexibleRuntimeSettings.fromJson(core.Map json_)
    : this(
        operatingSystem: json_['operatingSystem'] as core.String?,
        runtimeVersion: json_['runtimeVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (operatingSystem != null) 'operatingSystem': operatingSystem!,
    if (runtimeVersion != null) 'runtimeVersion': runtimeVersion!,
  };
}

/// Used by:
///
/// - compute:alpha : FlexibleTimeRange
/// - compute:beta : FlexibleTimeRange
class $FlexibleTimeRange {
  core.String? endTimeNotEarlierThan;
  core.String? endTimeNotLaterThan;
  core.String? maxDuration;
  core.String? minDuration;
  core.String? startTimeNotEarlierThan;
  core.String? startTimeNotLaterThan;

  $FlexibleTimeRange({
    this.endTimeNotEarlierThan,
    this.endTimeNotLaterThan,
    this.maxDuration,
    this.minDuration,
    this.startTimeNotEarlierThan,
    this.startTimeNotLaterThan,
  });

  $FlexibleTimeRange.fromJson(core.Map json_)
    : this(
        endTimeNotEarlierThan: json_['endTimeNotEarlierThan'] as core.String?,
        endTimeNotLaterThan: json_['endTimeNotLaterThan'] as core.String?,
        maxDuration: json_['maxDuration'] as core.String?,
        minDuration: json_['minDuration'] as core.String?,
        startTimeNotEarlierThan:
            json_['startTimeNotEarlierThan'] as core.String?,
        startTimeNotLaterThan: json_['startTimeNotLaterThan'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTimeNotEarlierThan != null)
      'endTimeNotEarlierThan': endTimeNotEarlierThan!,
    if (endTimeNotLaterThan != null)
      'endTimeNotLaterThan': endTimeNotLaterThan!,
    if (maxDuration != null) 'maxDuration': maxDuration!,
    if (minDuration != null) 'minDuration': minDuration!,
    if (startTimeNotEarlierThan != null)
      'startTimeNotEarlierThan': startTimeNotEarlierThan!,
    if (startTimeNotLaterThan != null)
      'startTimeNotLaterThan': startTimeNotLaterThan!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3FlowMultiLanguageSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1FlowMultiLanguageSettings
class $FlowMultiLanguageSettings {
  /// Enable multi-language detection for this flow.
  ///
  /// This can be set only if agent level multi language setting is enabled.
  ///
  /// Optional.
  core.bool? enableMultiLanguageDetection;

  /// Agent will respond in the detected language if the detected language code
  /// is in the supported resolved languages for this flow.
  ///
  /// This will be used only if multi-language training is enabled in the agent
  /// and multi-language detection is enabled in the flow. The supported
  /// languages must be a subset of the languages supported by the agent.
  ///
  /// Optional.
  core.List<core.String>? supportedResponseLanguageCodes;

  $FlowMultiLanguageSettings({
    this.enableMultiLanguageDetection,
    this.supportedResponseLanguageCodes,
  });

  $FlowMultiLanguageSettings.fromJson(core.Map json_)
    : this(
        enableMultiLanguageDetection:
            json_['enableMultiLanguageDetection'] as core.bool?,
        supportedResponseLanguageCodes:
            (json_['supportedResponseLanguageCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableMultiLanguageDetection != null)
      'enableMultiLanguageDetection': enableMultiLanguageDetection!,
    if (supportedResponseLanguageCodes != null)
      'supportedResponseLanguageCodes': supportedResponseLanguageCodes!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FluencyResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FluencyResult
class $FluencyResult {
  /// Confidence for fluency score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for fluency score.
  ///
  /// Output only.
  core.String? explanation;

  /// Fluency score.
  ///
  /// Output only.
  core.double? score;

  $FluencyResult({this.confidence, this.explanation, this.score});

  $FluencyResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v2 : Folder
/// - cloudresourcemanager:v2beta1 : Folder
class $Folder {
  /// Optional capabilities configured for this folder (via UpdateCapability
  /// API).
  ///
  /// Example: `folders/123/capabilities/app-management`.
  ///
  /// Output only.
  core.List<core.String>? configuredCapabilities;

  /// Timestamp when the Folder was created.
  ///
  /// Assigned by the server.
  ///
  /// Output only.
  core.String? createTime;

  /// The folder's display name.
  ///
  /// A folder's display name must be unique amongst its siblings, e.g. no two
  /// folders with the same parent can share the same display name. The display
  /// name must start and end with a letter or digit, may contain letters,
  /// digits, spaces, hyphens and underscores and can be no longer than 30
  /// characters. This is captured by the regular expression:
  /// `[\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?`.
  core.String? displayName;

  /// The lifecycle state of the folder.
  ///
  /// Updates to the lifecycle_state must be performed via DeleteFolder and
  /// UndeleteFolder.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "LIFECYCLE_STATE_UNSPECIFIED" : Unspecified state.
  /// - "ACTIVE" : The normal and active state.
  /// - "DELETE_REQUESTED" : The folder has been marked for deletion by the
  /// user.
  core.String? lifecycleState;

  /// Management Project associated with this folder (if app-management
  /// capability is enabled).
  ///
  /// Example: `projects/google-mp-123` OUTPUT ONLY.
  ///
  /// Output only.
  core.String? managementProject;

  /// The resource name of the Folder.
  ///
  /// Its format is `folders/{folder_id}`, for example: "folders/1234".
  ///
  /// Output only.
  core.String? name;

  /// The Folder's parent's resource name.
  ///
  /// Updates to the folder's parent must be performed via MoveFolder.
  ///
  /// Required.
  core.String? parent;

  /// Input only.
  ///
  /// Immutable. Tag keys/values directly bound to this folder. Each item in the
  /// map must be expressed as " : ". For example: "123/environment" :
  /// "production", "123/costCenter" : "marketing" Note: Currently this field is
  /// in Preview.
  ///
  /// Optional.
  core.Map<core.String, core.String>? tags;

  $Folder({
    this.configuredCapabilities,
    this.createTime,
    this.displayName,
    this.lifecycleState,
    this.managementProject,
    this.name,
    this.parent,
    this.tags,
  });

  $Folder.fromJson(core.Map json_)
    : this(
        configuredCapabilities:
            (json_['configuredCapabilities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        lifecycleState: json_['lifecycleState'] as core.String?,
        managementProject: json_['managementProject'] as core.String?,
        name: json_['name'] as core.String?,
        parent: json_['parent'] as core.String?,
        tags: (json_['tags'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configuredCapabilities != null)
      'configuredCapabilities': configuredCapabilities!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (lifecycleState != null) 'lifecycleState': lifecycleState!,
    if (managementProject != null) 'managementProject': managementProject!,
    if (name != null) 'name': name!,
    if (parent != null) 'parent': parent!,
    if (tags != null) 'tags': tags!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : Form
/// - websecurityscanner:v1beta : Form
class $Form {
  /// ! The URI where to send the form when it's submitted.
  core.String? actionUri;

  /// ! The names of form fields related to the vulnerability.
  core.List<core.String>? fields;

  $Form({this.actionUri, this.fields});

  $Form.fromJson(core.Map json_)
    : this(
        actionUri: json_['actionUri'] as core.String?,
        fields:
            (json_['fields'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actionUri != null) 'actionUri': actionUri!,
    if (fields != null) 'fields': fields!,
  };
}

/// Used by:
///
/// - eventarc:v1 : GoogleCloudEventarcV1PipelineMessagePayloadFormatAvroFormat
/// - eventarc:v1 : GoogleCloudEventarcV1PipelineMessagePayloadFormatProtobufFormat
class $Format {
  /// The entire schema definition is stored in this field.
  ///
  /// Optional.
  core.String? schemaDefinition;

  $Format({this.schemaDefinition});

  $Format.fromJson(core.Map json_)
    : this(schemaDefinition: json_['schemaDefinition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (schemaDefinition != null) 'schemaDefinition': schemaDefinition!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : ForwardInfo
/// - networkmanagement:v1beta1 : ForwardInfo
class $ForwardInfo {
  /// IP address of the target (if applicable).
  core.String? ipAddress;

  /// URI of the resource that the packet is forwarded to.
  core.String? resourceUri;

  /// Target type where this packet is forwarded to.
  /// Possible string values are:
  /// - "TARGET_UNSPECIFIED" : Target not specified.
  /// - "PEERING_VPC" : Forwarded to a VPC peering network.
  /// - "VPN_GATEWAY" : Forwarded to a Cloud VPN gateway.
  /// - "INTERCONNECT" : Forwarded to a Cloud Interconnect connection.
  /// - "GKE_MASTER" : Forwarded to a Google Kubernetes Engine Container cluster
  /// master.
  /// - "IMPORTED_CUSTOM_ROUTE_NEXT_HOP" : Forwarded to the next hop of a custom
  /// route imported from a peering VPC.
  /// - "CLOUD_SQL_INSTANCE" : Forwarded to a Cloud SQL instance.
  /// - "ANOTHER_PROJECT" : Forwarded to a VPC network in another project.
  /// - "NCC_HUB" : Forwarded to an NCC Hub.
  /// - "ROUTER_APPLIANCE" : Forwarded to a router appliance.
  /// - "SECURE_WEB_PROXY_GATEWAY" : Forwarded to a Secure Web Proxy Gateway.
  core.String? target;

  $ForwardInfo({this.ipAddress, this.resourceUri, this.target});

  $ForwardInfo.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        resourceUri: json_['resourceUri'] as core.String?,
        target: json_['target'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (resourceUri != null) 'resourceUri': resourceUri!,
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - datamigration:v1 : ForwardSshTunnelConnectivity
/// - datastream:v1 : ForwardSshTunnelConnectivity
/// - datastream:v1alpha1 : ForwardSshTunnelConnectivity
class $ForwardSshTunnelConnectivity {
  /// Hostname for the SSH tunnel.
  ///
  /// Required.
  core.String? hostname;

  /// Input only.
  ///
  /// SSH password.
  core.String? password;

  /// Port for the SSH tunnel, default value is 22.
  core.int? port;

  /// Input only.
  ///
  /// SSH private key.
  core.String? privateKey;

  /// Username for the SSH tunnel.
  ///
  /// Required.
  core.String? username;

  $ForwardSshTunnelConnectivity({
    this.hostname,
    this.password,
    this.port,
    this.privateKey,
    this.username,
  });

  $ForwardSshTunnelConnectivity.fromJson(core.Map json_)
    : this(
        hostname: json_['hostname'] as core.String?,
        password: json_['password'] as core.String?,
        port: json_['port'] as core.int?,
        privateKey: json_['privateKey'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostname != null) 'hostname': hostname!,
    if (password != null) 'password': password!,
    if (port != null) 'port': port!,
    if (privateKey != null) 'privateKey': privateKey!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : ForwardingRuleInfo
/// - networkmanagement:v1beta1 : ForwardingRuleInfo
class $ForwardingRuleInfo {
  /// Name of the forwarding rule.
  core.String? displayName;

  /// Name of the load balancer the forwarding rule belongs to.
  ///
  /// Empty for forwarding rules not related to load balancers (like PSC
  /// forwarding rules).
  core.String? loadBalancerName;

  /// Port range defined in the forwarding rule that matches the packet.
  core.String? matchedPortRange;

  /// Protocol defined in the forwarding rule that matches the packet.
  core.String? matchedProtocol;

  /// Network URI.
  core.String? networkUri;

  /// PSC Google API target this forwarding rule targets (if applicable).
  core.String? pscGoogleApiTarget;

  /// URI of the PSC service attachment this forwarding rule targets (if
  /// applicable).
  core.String? pscServiceAttachmentUri;

  /// Region of the forwarding rule.
  ///
  /// Set only for regional forwarding rules.
  core.String? region;

  /// Target type of the forwarding rule.
  core.String? target;

  /// URI of the forwarding rule.
  core.String? uri;

  /// VIP of the forwarding rule.
  core.String? vip;

  $ForwardingRuleInfo({
    this.displayName,
    this.loadBalancerName,
    this.matchedPortRange,
    this.matchedProtocol,
    this.networkUri,
    this.pscGoogleApiTarget,
    this.pscServiceAttachmentUri,
    this.region,
    this.target,
    this.uri,
    this.vip,
  });

  $ForwardingRuleInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        loadBalancerName: json_['loadBalancerName'] as core.String?,
        matchedPortRange: json_['matchedPortRange'] as core.String?,
        matchedProtocol: json_['matchedProtocol'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        pscGoogleApiTarget: json_['pscGoogleApiTarget'] as core.String?,
        pscServiceAttachmentUri:
            json_['pscServiceAttachmentUri'] as core.String?,
        region: json_['region'] as core.String?,
        target: json_['target'] as core.String?,
        uri: json_['uri'] as core.String?,
        vip: json_['vip'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (loadBalancerName != null) 'loadBalancerName': loadBalancerName!,
    if (matchedPortRange != null) 'matchedPortRange': matchedPortRange!,
    if (matchedProtocol != null) 'matchedProtocol': matchedProtocol!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (pscGoogleApiTarget != null) 'pscGoogleApiTarget': pscGoogleApiTarget!,
    if (pscServiceAttachmentUri != null)
      'pscServiceAttachmentUri': pscServiceAttachmentUri!,
    if (region != null) 'region': region!,
    if (target != null) 'target': target!,
    if (uri != null) 'uri': uri!,
    if (vip != null) 'vip': vip!,
  };
}

/// Used by:
///
/// - compute:alpha : ForwardingRuleReference
/// - compute:beta : ForwardingRuleReference
/// - compute:v1 : ForwardingRuleReference
class $ForwardingRuleReference {
  core.String? forwardingRule;

  $ForwardingRuleReference({this.forwardingRule});

  $ForwardingRuleReference.fromJson(core.Map json_)
    : this(forwardingRule: json_['forwardingRule'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
  };
}

/// Used by:
///
/// - compute:alpha : ForwardingRuleServiceDirectoryRegistration
/// - compute:beta : ForwardingRuleServiceDirectoryRegistration
/// - compute:v1 : ForwardingRuleServiceDirectoryRegistration
class $ForwardingRuleServiceDirectoryRegistration {
  /// Service Directory namespace to register the forwarding rule under.
  core.String? namespace;

  /// Service Directory service to register the forwarding rule under.
  core.String? service;

  /// Service Directory region to register this global forwarding rule under.
  ///
  /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
  /// Google APIs forwarding rules on the same network should use the same
  /// Service Directory region.
  ///
  /// Optional.
  core.String? serviceDirectoryRegion;

  $ForwardingRuleServiceDirectoryRegistration({
    this.namespace,
    this.service,
    this.serviceDirectoryRegion,
  });

  $ForwardingRuleServiceDirectoryRegistration.fromJson(core.Map json_)
    : this(
        namespace: json_['namespace'] as core.String?,
        service: json_['service'] as core.String?,
        serviceDirectoryRegion: json_['serviceDirectoryRegion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (namespace != null) 'namespace': namespace!,
    if (service != null) 'service': service!,
    if (serviceDirectoryRegion != null)
      'serviceDirectoryRegion': serviceDirectoryRegion!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExportFractionSplit
/// - aiplatform:v1 : GoogleCloudAiplatformV1FractionSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExportFractionSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FractionSplit
class $FractionSplit {
  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  $FractionSplit({
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  $FractionSplit.fromJson(core.Map json_)
    : this(
        testFraction: (json_['testFraction'] as core.num?)?.toDouble(),
        trainingFraction: (json_['trainingFraction'] as core.num?)?.toDouble(),
        validationFraction:
            (json_['validationFraction'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (testFraction != null) 'testFraction': testFraction!,
    if (trainingFraction != null) 'trainingFraction': trainingFraction!,
    if (validationFraction != null) 'validationFraction': validationFraction!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : FrameViolationEntry
/// - migrationcenter:v1alpha1 : FrameViolationEntry
class $FrameViolationEntry {
  /// The field of the original frame where the violation occurred.
  core.String? field;

  /// A message describing the violation.
  core.String? violation;

  $FrameViolationEntry({this.field, this.violation});

  $FrameViolationEntry.fromJson(core.Map json_)
    : this(
        field: json_['field'] as core.String?,
        violation: json_['violation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (field != null) 'field': field!,
    if (violation != null) 'violation': violation!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2FreeFormContext
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1FreeFormContext
class $FreeFormContext {
  /// Free form text input to LLM.
  ///
  /// Optional.
  core.String? text;

  $FreeFormContext({this.text});

  $FreeFormContext.fromJson(core.Map json_)
    : this(text: json_['text'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2FreeFormSuggestion
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1FreeFormSuggestion
class $FreeFormSuggestion {
  /// Free form suggestion.
  ///
  /// Required.
  core.String? response;

  $FreeFormSuggestion({this.response});

  $FreeFormSuggestion.fromJson(core.Map json_)
    : this(response: json_['response'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : FrequencyCap
/// - displayvideo:v3 : FrequencyCap
/// - displayvideo:v4 : FrequencyCap
class $FrequencyCap00 {
  /// The maximum number of times a user may be shown the same ad during this
  /// period.
  ///
  /// Must be greater than 0. Required when unlimited is `false` and max_views
  /// is not set.
  core.int? maxImpressions;

  /// The maximum number of times a user may click-through or fully view an ad
  /// during this period until it is no longer served to them.
  ///
  /// Must be greater than 0. Only applicable to YouTube and Partners resources.
  /// Required when unlimited is `false` and max_impressions is not set.
  ///
  /// Optional.
  core.int? maxViews;

  /// The time unit in which the frequency cap will be applied.
  ///
  /// Required when unlimited is `false`.
  /// Possible string values are:
  /// - "TIME_UNIT_UNSPECIFIED" : Time unit value is not specified or is unknown
  /// in this version.
  /// - "TIME_UNIT_LIFETIME" : The frequency cap will be applied to the whole
  /// life time of the line item.
  /// - "TIME_UNIT_MONTHS" : The frequency cap will be applied to a number of
  /// months.
  /// - "TIME_UNIT_WEEKS" : The frequency cap will be applied to a number of
  /// weeks.
  /// - "TIME_UNIT_DAYS" : The frequency cap will be applied to a number of
  /// days.
  /// - "TIME_UNIT_HOURS" : The frequency cap will be applied to a number of
  /// hours.
  /// - "TIME_UNIT_MINUTES" : The frequency cap will be applied to a number of
  /// minutes.
  core.String? timeUnit;

  /// The number of time_unit the frequency cap will last.
  ///
  /// Required when unlimited is `false`. The following restrictions apply based
  /// on the value of time_unit: * `TIME_UNIT_MONTHS` - must be 1 *
  /// `TIME_UNIT_WEEKS` - must be between 1 and 4 * `TIME_UNIT_DAYS` - must be
  /// between 1 and 6 * `TIME_UNIT_HOURS` - must be between 1 and 23 *
  /// `TIME_UNIT_MINUTES` - must be between 1 and 59
  core.int? timeUnitCount;

  /// Whether unlimited frequency capping is applied.
  ///
  /// When this field is set to `true`, the remaining frequency cap fields are
  /// not applicable.
  core.bool? unlimited;

  $FrequencyCap00({
    this.maxImpressions,
    this.maxViews,
    this.timeUnit,
    this.timeUnitCount,
    this.unlimited,
  });

  $FrequencyCap00.fromJson(core.Map json_)
    : this(
        maxImpressions: json_['maxImpressions'] as core.int?,
        maxViews: json_['maxViews'] as core.int?,
        timeUnit: json_['timeUnit'] as core.String?,
        timeUnitCount: json_['timeUnitCount'] as core.int?,
        unlimited: json_['unlimited'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxImpressions != null) 'maxImpressions': maxImpressions!,
    if (maxViews != null) 'maxViews': maxViews!,
    if (timeUnit != null) 'timeUnit': timeUnit!,
    if (timeUnitCount != null) 'timeUnitCount': timeUnitCount!,
    if (unlimited != null) 'unlimited': unlimited!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : FrequencyCap
/// - authorizedbuyersmarketplace:v1alpha : FrequencyCap
class $FrequencyCap01 {
  /// The maximum number of impressions that can be served to a user within the
  /// specified time period.
  core.int? maxImpressions;

  /// The time unit.
  ///
  /// Along with num_time_units defines the amount of time over which
  /// impressions per user are counted and capped.
  /// Possible string values are:
  /// - "TIME_UNIT_TYPE_UNSPECIFIED" : A placeholder for an undefined time unit
  /// type. This just indicates the variable with this value hasn't been
  /// initialized.
  /// - "MINUTE" : Minute unit.
  /// - "HOUR" : Hour unit.
  /// - "DAY" : Day unit.
  /// - "WEEK" : Week unit.
  /// - "MONTH" : Month unit.
  /// - "LIFETIME" : Lifecycle/Lifetime unit.
  /// - "POD" : Pod unit.
  /// - "STREAM" : Stream unit.
  core.String? timeUnitType;

  /// The amount of time, in the units specified by time_unit_type.
  ///
  /// Defines the amount of time over which impressions per user are counted and
  /// capped.
  core.int? timeUnitsCount;

  $FrequencyCap01({
    this.maxImpressions,
    this.timeUnitType,
    this.timeUnitsCount,
  });

  $FrequencyCap01.fromJson(core.Map json_)
    : this(
        maxImpressions: json_['maxImpressions'] as core.int?,
        timeUnitType: json_['timeUnitType'] as core.String?,
        timeUnitsCount: json_['timeUnitsCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxImpressions != null) 'maxImpressions': maxImpressions!,
    if (timeUnitType != null) 'timeUnitType': timeUnitType!,
    if (timeUnitsCount != null) 'timeUnitsCount': timeUnitsCount!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : FstabEntry
/// - migrationcenter:v1alpha1 : FstabEntry
class $FstabEntry {
  /// The mount point for the filesystem.
  core.String? file;

  /// Used by dump to determine which filesystems need to be dumped.
  core.int? freq;

  /// Mount options associated with the filesystem.
  core.String? mntops;

  /// Used by the fsck(8) program to determine the order in which filesystem
  /// checks are done at reboot time.
  core.int? passno;

  /// The block special device or remote filesystem to be mounted.
  core.String? spec;

  /// The type of the filesystem.
  core.String? vfstype;

  $FstabEntry({
    this.file,
    this.freq,
    this.mntops,
    this.passno,
    this.spec,
    this.vfstype,
  });

  $FstabEntry.fromJson(core.Map json_)
    : this(
        file: json_['file'] as core.String?,
        freq: json_['freq'] as core.int?,
        mntops: json_['mntops'] as core.String?,
        passno: json_['passno'] as core.int?,
        spec: json_['spec'] as core.String?,
        vfstype: json_['vfstype'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (file != null) 'file': file!,
    if (freq != null) 'freq': freq!,
    if (mntops != null) 'mntops': mntops!,
    if (passno != null) 'passno': passno!,
    if (spec != null) 'spec': spec!,
    if (vfstype != null) 'vfstype': vfstype!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2FulfillmentFeature
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1FulfillmentFeature
class $FulfillmentFeature {
  /// The type of the feature that enabled for fulfillment.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Feature type not specified.
  /// - "SMALLTALK" : Fulfillment is enabled for SmallTalk.
  core.String? type;

  $FulfillmentFeature({this.type});

  $FulfillmentFeature.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3FulfillmentGeneratorSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1FulfillmentGeneratorSettings
class $FulfillmentGeneratorSettings {
  /// The generator to call.
  ///
  /// Format: `projects//locations//agents//generators/`.
  ///
  /// Required.
  core.String? generator;

  /// Map from placeholder parameter in the Generator to corresponding session
  /// parameters.
  ///
  /// By default, Dialogflow uses the session parameter with the same name to
  /// fill in the generator template. e.g. If there is a placeholder parameter
  /// `city` in the Generator, Dialogflow default to fill in the `$city` with
  /// `$session.params.city`. However, you may choose to fill `$city` with
  /// `$session.params.desination-city`. - Map key: parameter ID - Map value:
  /// session parameter name
  core.Map<core.String, core.String>? inputParameters;

  /// Output parameter which should contain the generator response.
  ///
  /// Required.
  core.String? outputParameter;

  $FulfillmentGeneratorSettings({
    this.generator,
    this.inputParameters,
    this.outputParameter,
  });

  $FulfillmentGeneratorSettings.fromJson(core.Map json_)
    : this(
        generator: json_['generator'] as core.String?,
        inputParameters: (json_['inputParameters']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        outputParameter: json_['outputParameter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (generator != null) 'generator': generator!,
    if (inputParameters != null) 'inputParameters': inputParameters!,
    if (outputParameter != null) 'outputParameter': outputParameter!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2FulfillmentInfo
/// - retail:v2alpha : GoogleCloudRetailV2alphaFulfillmentInfo
/// - retail:v2beta : GoogleCloudRetailV2betaFulfillmentInfo
class $FulfillmentInfo {
  /// The IDs for this type, such as the store IDs for
  /// FulfillmentInfo.type.pickup-in-store or the region IDs for
  /// FulfillmentInfo.type.same-day-delivery.
  ///
  /// A maximum of 3000 values are allowed. Each value must be a string with a
  /// length limit of 30 characters, matching the pattern `[a-zA-Z0-9_-]+`, such
  /// as "store1" or "REGION-2". Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  core.List<core.String>? placeIds;

  /// The fulfillment type, including commonly used types (such as pickup in
  /// store and same day delivery), and custom types.
  ///
  /// Customers have to map custom types to their display names before rendering
  /// UI. Supported values: * "pickup-in-store" * "ship-to-store" *
  /// "same-day-delivery" * "next-day-delivery" * "custom-type-1" *
  /// "custom-type-2" * "custom-type-3" * "custom-type-4" * "custom-type-5" If
  /// this field is set to an invalid value other than these, an
  /// INVALID_ARGUMENT error is returned.
  core.String? type;

  $FulfillmentInfo({this.placeIds, this.type});

  $FulfillmentInfo.fromJson(core.Map json_)
    : this(
        placeIds:
            (json_['placeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (placeIds != null) 'placeIds': placeIds!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FulfillmentInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FulfillmentInstance
class $FulfillmentInstance {
  /// Inference instruction prompt to compare prediction with.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  $FulfillmentInstance({this.instruction, this.prediction});

  $FulfillmentInstance.fromJson(core.Map json_)
    : this(
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FulfillmentResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FulfillmentResult
class $FulfillmentResult {
  /// Confidence for fulfillment score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for fulfillment score.
  ///
  /// Output only.
  core.String? explanation;

  /// Fulfillment score.
  ///
  /// Output only.
  core.double? score;

  $FulfillmentResult({this.confidence, this.explanation, this.score});

  $FulfillmentResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3FulfillmentSetParameterAction
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1FulfillmentSetParameterAction
class $FulfillmentSetParameterAction {
  /// Display name of the parameter.
  core.String? parameter;

  /// The new value of the parameter.
  ///
  /// A null value clears the parameter.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? value;

  $FulfillmentSetParameterAction({this.parameter, this.value});

  $FulfillmentSetParameterAction.fromJson(core.Map json_)
    : this(
        parameter: json_['parameter'] as core.String?,
        value: json_['value'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parameter != null) 'parameter': parameter!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1FunctionCallingConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FunctionCallingConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1FunctionCallingConfig
class $FunctionCallingConfig {
  /// Function names to call.
  ///
  /// Only set when the Mode is ANY. Function names should match
  /// \[FunctionDeclaration.name\]. With mode set to ANY, model will predict a
  /// function call from the set of function names provided.
  ///
  /// Optional.
  core.List<core.String>? allowedFunctionNames;

  /// Function calling mode.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Unspecified function calling mode. This value
  /// should not be used.
  /// - "AUTO" : Default model behavior, model decides to predict either
  /// function calls or natural language response.
  /// - "ANY" : Model is constrained to always predicting function calls only.
  /// If "allowed_function_names" are set, the predicted function calls will be
  /// limited to any one of "allowed_function_names", else the predicted
  /// function calls will be any one of the provided "function_declarations".
  /// - "NONE" : Model will not predict any function calls. Model behavior is
  /// same as when not passing any function declarations.
  core.String? mode;

  $FunctionCallingConfig({this.allowedFunctionNames, this.mode});

  $FunctionCallingConfig.fromJson(core.Map json_)
    : this(
        allowedFunctionNames:
            (json_['allowedFunctionNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedFunctionNames != null)
      'allowedFunctionNames': allowedFunctionNames!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - compute:alpha : FutureReservationStatusExistingMatchingUsageInfo
/// - compute:beta : FutureReservationStatusExistingMatchingUsageInfo
class $FutureReservationStatusExistingMatchingUsageInfo {
  /// Count to represent min(FR total_count,
  /// matching_reserved_capacity+matching_unreserved_instances)
  core.String? count;

  /// Timestamp when the matching usage was calculated
  core.String? timestamp;

  $FutureReservationStatusExistingMatchingUsageInfo({
    this.count,
    this.timestamp,
  });

  $FutureReservationStatusExistingMatchingUsageInfo.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        timestamp: json_['timestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (timestamp != null) 'timestamp': timestamp!,
  };
}

/// Used by:
///
/// - compute:alpha : FutureReservationStatusSpecificSKUProperties
/// - compute:beta : FutureReservationStatusSpecificSKUProperties
class $FutureReservationStatusSpecificSKUProperties {
  /// ID of the instance template used to populate the Future Reservation
  /// properties.
  core.String? sourceInstanceTemplateId;

  $FutureReservationStatusSpecificSKUProperties({
    this.sourceInstanceTemplateId,
  });

  $FutureReservationStatusSpecificSKUProperties.fromJson(core.Map json_)
    : this(
        sourceInstanceTemplateId:
            json_['sourceInstanceTemplateId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceInstanceTemplateId != null)
      'sourceInstanceTemplateId': sourceInstanceTemplateId!,
  };
}

/// Used by:
///
/// - compute:alpha : FutureResourcesRecommendationOtherLocation
/// - compute:beta : FutureResourcesRecommendationOtherLocation
class $FutureResourcesRecommendationOtherLocation {
  /// Details (human readable) describing the situation.
  ///
  /// For example, if status is CONDITION_NOT_MET, then details contain
  /// information about the parameters of the time window that did not meet the
  /// required conditions.
  core.String? details;

  /// Status of recommendation in this location.
  /// Possible string values are:
  /// - "CONDITIONS_NOT_MET" : The requested resources are offered in this
  /// location but the requested time window is does not meet the required
  /// conditions.
  /// - "NOT_SUPPORTED" : The requested resources are not offered in this
  /// location. Retrying the request will not change this status.
  /// - "NO_CAPACITY" : The requested resources are offered in this location and
  /// the requested time window is accepted but there is no capacity within the
  /// requested time window.
  /// - "OTHER_LOCATION_STATUS_UNDEFINED" : Default value, unused.
  /// - "RECOMMENDED" : The requested resources are offered in this location and
  /// it is possible to request them. However, another location was better and
  /// was recommended.
  core.String? status;

  $FutureResourcesRecommendationOtherLocation({this.details, this.status});

  $FutureResourcesRecommendationOtherLocation.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:alpha : FutureResourcesSpecAggregateResources
/// - compute:beta : FutureResourcesSpecAggregateResources
class $FutureResourcesSpecAggregateResources {
  /// Size of the request, in accelerator (chip) count.
  core.String? acceleratorCount;

  /// The VM family that all instances scheduled against this reservation must
  /// belong to.
  ///
  /// Use for TPU reservations.
  /// Possible string values are:
  /// - "VM_FAMILY_CLOUD_TPU_DEVICE_CT3"
  /// - "VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L"
  /// - "VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP"
  /// - "VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT6E"
  /// - "VM_FAMILY_CLOUD_TPU_POD_SLICE_CT3P"
  /// - "VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P"
  /// - "VM_FAMILY_CLOUD_TPU_POD_SLICE_CT5P"
  core.String? vmFamily;

  /// Workload type.
  ///
  /// Use for TPU reservations.
  /// Possible string values are:
  /// - "BATCH" : Reserved resources will be optimized for BATCH workloads, such
  /// as ML training.
  /// - "SERVING" : Reserved resources will be optimized for SERVING workloads,
  /// such as ML inference.
  /// - "UNSPECIFIED"
  core.String? workloadType;

  $FutureResourcesSpecAggregateResources({
    this.acceleratorCount,
    this.vmFamily,
    this.workloadType,
  });

  $FutureResourcesSpecAggregateResources.fromJson(core.Map json_)
    : this(
        acceleratorCount: json_['acceleratorCount'] as core.String?,
        vmFamily: json_['vmFamily'] as core.String?,
        workloadType: json_['workloadType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
    if (vmFamily != null) 'vmFamily': vmFamily!,
    if (workloadType != null) 'workloadType': workloadType!,
  };
}

/// Used by:
///
/// - compute:alpha : FutureResourcesSpecLocationPolicyLocation
/// - compute:beta : FutureResourcesSpecLocationPolicyLocation
class $FutureResourcesSpecLocationPolicyLocation {
  /// Preference for this location.
  /// Possible string values are:
  /// - "ALLOW" : Location is allowed for use.
  /// - "DENY" : Location is prohibited.
  /// - "PREFERENCE_UNSPECIFIED" : Default value, unused.
  core.String? preference;

  $FutureResourcesSpecLocationPolicyLocation({this.preference});

  $FutureResourcesSpecLocationPolicyLocation.fromJson(core.Map json_)
    : this(preference: json_['preference'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (preference != null) 'preference': preference!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : GCAInstanceConfig
/// - alloydb:v1beta : GCAInstanceConfig
class $GCAInstanceConfig {
  /// Represents the GCA entitlement state of the instance.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GCA_ENTITLEMENT_TYPE_UNSPECIFIED" : No GCA entitlement is assigned.
  /// - "GCA_STANDARD" : The resource is entitled to the GCA Standard Tier.
  core.String? gcaEntitlement;

  $GCAInstanceConfig({this.gcaEntitlement});

  $GCAInstanceConfig.fromJson(core.Map json_)
    : this(gcaEntitlement: json_['gcaEntitlement'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcaEntitlement != null) 'gcaEntitlement': gcaEntitlement!,
  };
}

/// Used by:
///
/// - container:v1 : GCPSecretManagerCertificateConfig
/// - container:v1beta1 : GCPSecretManagerCertificateConfig
class $GCPSecretManagerCertificateConfig {
  /// Secret URI, in the form
  /// "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION".
  ///
  /// Version can be fixed (e.g. "2") or "latest"
  core.String? secretUri;

  $GCPSecretManagerCertificateConfig({this.secretUri});

  $GCPSecretManagerCertificateConfig.fromJson(core.Map json_)
    : this(secretUri: json_['secretUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (secretUri != null) 'secretUri': secretUri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : GKEMasterInfo
/// - networkmanagement:v1beta1 : GKEMasterInfo
class $GKEMasterInfo {
  /// URI of a GKE cluster network.
  core.String? clusterNetworkUri;

  /// URI of a GKE cluster.
  core.String? clusterUri;

  /// DNS endpoint of a GKE cluster control plane.
  core.String? dnsEndpoint;

  /// External IP address of a GKE cluster control plane.
  core.String? externalIp;

  /// Internal IP address of a GKE cluster control plane.
  core.String? internalIp;

  $GKEMasterInfo({
    this.clusterNetworkUri,
    this.clusterUri,
    this.dnsEndpoint,
    this.externalIp,
    this.internalIp,
  });

  $GKEMasterInfo.fromJson(core.Map json_)
    : this(
        clusterNetworkUri: json_['clusterNetworkUri'] as core.String?,
        clusterUri: json_['clusterUri'] as core.String?,
        dnsEndpoint: json_['dnsEndpoint'] as core.String?,
        externalIp: json_['externalIp'] as core.String?,
        internalIp: json_['internalIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterNetworkUri != null) 'clusterNetworkUri': clusterNetworkUri!,
    if (clusterUri != null) 'clusterUri': clusterUri!,
    if (dnsEndpoint != null) 'dnsEndpoint': dnsEndpoint!,
    if (externalIp != null) 'externalIp': externalIp!,
    if (internalIp != null) 'internalIp': internalIp!,
  };
}

/// Used by:
///
/// - container:v1 : GPUDriverInstallationConfig
/// - container:v1beta1 : GPUDriverInstallationConfig
class $GPUDriverInstallationConfig {
  /// Mode for how the GPU driver is installed.
  /// Possible string values are:
  /// - "GPU_DRIVER_VERSION_UNSPECIFIED" : Default value is to not install any
  /// GPU driver.
  /// - "INSTALLATION_DISABLED" : Disable GPU driver auto installation and needs
  /// manual installation
  /// - "DEFAULT" : "Default" GPU driver in COS and Ubuntu.
  /// - "LATEST" : "Latest" GPU driver in COS.
  core.String? gpuDriverVersion;

  $GPUDriverInstallationConfig({this.gpuDriverVersion});

  $GPUDriverInstallationConfig.fromJson(core.Map json_)
    : this(gpuDriverVersion: json_['gpuDriverVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gpuDriverVersion != null) 'gpuDriverVersion': gpuDriverVersion!,
  };
}

/// Used by:
///
/// - container:v1 : GPUSharingConfig
/// - container:v1beta1 : GPUSharingConfig
class $GPUSharingConfig {
  /// The type of GPU sharing strategy to enable on the GPU node.
  /// Possible string values are:
  /// - "GPU_SHARING_STRATEGY_UNSPECIFIED" : Default value.
  /// - "TIME_SHARING" : GPUs are time-shared between containers.
  /// - "MPS" : GPUs are shared between containers with NVIDIA MPS.
  core.String? gpuSharingStrategy;

  /// The max number of containers that can share a physical GPU.
  core.String? maxSharedClientsPerGpu;

  $GPUSharingConfig({this.gpuSharingStrategy, this.maxSharedClientsPerGpu});

  $GPUSharingConfig.fromJson(core.Map json_)
    : this(
        gpuSharingStrategy: json_['gpuSharingStrategy'] as core.String?,
        maxSharedClientsPerGpu: json_['maxSharedClientsPerGpu'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gpuSharingStrategy != null) 'gpuSharingStrategy': gpuSharingStrategy!,
    if (maxSharedClientsPerGpu != null)
      'maxSharedClientsPerGpu': maxSharedClientsPerGpu!,
  };
}

/// Used by:
///
/// - compute:alpha : GRPCHealthCheck
/// - compute:beta : GRPCHealthCheck
/// - compute:v1 : GRPCHealthCheck
class $GRPCHealthCheck {
  /// The gRPC service name for the health check.
  ///
  /// This field is optional. The value of grpc_service_name has the following
  /// meanings by convention: - Empty service_name means the overall status of
  /// all services at the backend. - Non-empty service_name means the health of
  /// that gRPC service, as defined by the owner of the service. The
  /// grpc_service_name can only be ASCII.
  core.String? grpcServiceName;

  /// The TCP port number to which the health check prober sends packets.
  ///
  /// Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  $GRPCHealthCheck({
    this.grpcServiceName,
    this.port,
    this.portName,
    this.portSpecification,
  });

  $GRPCHealthCheck.fromJson(core.Map json_)
    : this(
        grpcServiceName: json_['grpcServiceName'] as core.String?,
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (grpcServiceName != null) 'grpcServiceName': grpcServiceName!,
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
  };
}

/// Used by:
///
/// - compute:alpha : GRPCTLSHealthCheck
/// - compute:beta : GRPCTLSHealthCheck
class $GRPCTLSHealthCheck {
  /// The gRPC service name for the health check.
  ///
  /// This field is optional. The value of grpc_service_name has the following
  /// meanings by convention: - Empty service_name means the overall status of
  /// all services at the backend. - Non-empty service_name means the health of
  /// that gRPC service, as defined by the owner of the service. The
  /// grpc_service_name can only be ASCII.
  core.String? grpcServiceName;

  /// The TCP port number to which the health check prober sends packets.
  ///
  /// Valid values are 1 through 65535.
  core.int? port;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  $GRPCTLSHealthCheck({
    this.grpcServiceName,
    this.port,
    this.portSpecification,
  });

  $GRPCTLSHealthCheck.fromJson(core.Map json_)
    : this(
        grpcServiceName: json_['grpcServiceName'] as core.String?,
        port: json_['port'] as core.int?,
        portSpecification: json_['portSpecification'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (grpcServiceName != null) 'grpcServiceName': grpcServiceName!,
    if (port != null) 'port': port!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
  };
}

/// Used by:
///
/// - networkservices:v1 : Gateway
/// - networkservices:v1beta1 : Gateway
class $Gateway {
  /// Zero or one IPv4 or IPv6 address on which the Gateway will receive the
  /// traffic.
  ///
  /// When no address is provided, an IP from the subnetwork is allocated This
  /// field only applies to gateways of type 'SECURE_WEB_GATEWAY'. Gateways of
  /// type 'OPEN_MESH' listen on 0.0.0.0 for IPv4 and :: for IPv6.
  ///
  /// Optional.
  core.List<core.String>? addresses;

  /// A fully-qualified Certificates URL reference.
  ///
  /// The proxy presents a Certificate (selected based on SNI) when establishing
  /// a TLS connection. This feature only applies to gateways of type
  /// 'SECURE_WEB_GATEWAY'.
  ///
  /// Optional.
  core.List<core.String>? certificateUrls;

  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A free-text description of the resource.
  ///
  /// Max length 1024 characters.
  ///
  /// Optional.
  core.String? description;

  /// Determines if envoy will insert internal debug headers into upstream
  /// requests.
  ///
  /// Other Envoy headers may still be injected. By default, envoy will not
  /// insert any debug headers.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ENVOY_HEADERS_UNSPECIFIED" : Defaults to NONE.
  /// - "NONE" : Suppress envoy debug headers.
  /// - "DEBUG_HEADERS" : Envoy will insert default internal debug headers into
  /// upstream requests: x-envoy-attempt-count x-envoy-is-timeout-retry
  /// x-envoy-expected-rq-timeout-ms x-envoy-original-path
  /// x-envoy-upstream-stream-duration-ms
  core.String? envoyHeaders;

  /// A fully-qualified GatewaySecurityPolicy URL reference.
  ///
  /// Defines how a server should apply security policy to inbound (VM to Proxy)
  /// initiated connections. For example: `projects / * /locations / *
  /// /gatewaySecurityPolicies/swg-policy`. This policy is specific to gateways
  /// of type 'SECURE_WEB_GATEWAY'.
  ///
  /// Optional.
  core.String? gatewaySecurityPolicy;

  /// The IP Version that will be used by this gateway.
  ///
  /// Valid options are IPV4 or IPV6. Default is IPV4.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IP_VERSION_UNSPECIFIED" : The type when IP version is not specified.
  /// Defaults to IPV4.
  /// - "IPV4" : The type for IP version 4.
  /// - "IPV6" : The type for IP version 6.
  core.String? ipVersion;

  /// Set of label tags associated with the Gateway resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the Gateway resource. It matches pattern `projects / * /locations
  /// / * /gateways/`.
  core.String? name;

  /// The relative resource name identifying the VPC network that is using this
  /// configuration.
  ///
  /// For example: `projects / * /global/networks/network-1`. Currently, this
  /// field is specific to gateways of type 'SECURE_WEB_GATEWAY'.
  ///
  /// Optional.
  core.String? network;

  /// One or more port numbers (1-65535), on which the Gateway will receive
  /// traffic.
  ///
  /// The proxy binds to the specified ports. Gateways of type
  /// 'SECURE_WEB_GATEWAY' are limited to 5 ports. Gateways of type 'OPEN_MESH'
  /// listen on 0.0.0.0 for IPv4 and :: for IPv6 and support multiple ports.
  ///
  /// Required.
  core.List<core.int>? ports;

  /// The routing mode of the Gateway.
  ///
  /// This field is configurable only for gateways of type SECURE_WEB_GATEWAY.
  /// This field is required for gateways of type SECURE_WEB_GATEWAY.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "EXPLICIT_ROUTING_MODE" : The routing mode is explicit; clients are
  /// configured to send traffic through the gateway. This is the default
  /// routing mode.
  /// - "NEXT_HOP_ROUTING_MODE" : The routing mode is next-hop. Clients are
  /// unaware of the gateway, and a route (advanced route or other route type)
  /// can be configured to direct traffic from client to gateway. The gateway
  /// then acts as a next-hop to the destination.
  core.String? routingMode;

  /// Scope determines how configuration across multiple Gateway instances are
  /// merged.
  ///
  /// The configuration for multiple Gateway instances with the same scope will
  /// be merged as presented as a single configuration to the proxy/load
  /// balancer. Max length 64 characters. Scope should start with a letter and
  /// can only have letters, numbers, hyphens.
  ///
  /// Optional.
  core.String? scope;

  /// Server-defined URL of this resource
  ///
  /// Output only.
  core.String? selfLink;

  /// A fully-qualified ServerTLSPolicy URL reference.
  ///
  /// Specifies how TLS traffic is terminated. If empty, TLS termination is
  /// disabled.
  ///
  /// Optional.
  core.String? serverTlsPolicy;

  /// The relative resource name identifying the subnetwork in which this SWG is
  /// allocated.
  ///
  /// For example: `projects / * /regions/us-central1/subnetworks/network-1`
  /// Currently, this field is specific to gateways of type
  /// 'SECURE_WEB_GATEWAY".
  ///
  /// Optional.
  core.String? subnetwork;

  /// The type of the customer managed gateway.
  ///
  /// This field is required. If unspecified, an error is returned.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type of the customer managed gateway is
  /// unspecified.
  /// - "OPEN_MESH" : The type of the customer managed gateway is
  /// TrafficDirector Open Mesh.
  /// - "SECURE_WEB_GATEWAY" : The type of the customer managed gateway is
  /// SecureWebGateway (SWG).
  core.String? type;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Gateway({
    this.addresses,
    this.certificateUrls,
    this.createTime,
    this.description,
    this.envoyHeaders,
    this.gatewaySecurityPolicy,
    this.ipVersion,
    this.labels,
    this.name,
    this.network,
    this.ports,
    this.routingMode,
    this.scope,
    this.selfLink,
    this.serverTlsPolicy,
    this.subnetwork,
    this.type,
    this.updateTime,
  });

  $Gateway.fromJson(core.Map json_)
    : this(
        addresses:
            (json_['addresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        certificateUrls:
            (json_['certificateUrls'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        envoyHeaders: json_['envoyHeaders'] as core.String?,
        gatewaySecurityPolicy: json_['gatewaySecurityPolicy'] as core.String?,
        ipVersion: json_['ipVersion'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        ports:
            (json_['ports'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        routingMode: json_['routingMode'] as core.String?,
        scope: json_['scope'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        serverTlsPolicy: json_['serverTlsPolicy'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
        type: json_['type'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addresses != null) 'addresses': addresses!,
    if (certificateUrls != null) 'certificateUrls': certificateUrls!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (envoyHeaders != null) 'envoyHeaders': envoyHeaders!,
    if (gatewaySecurityPolicy != null)
      'gatewaySecurityPolicy': gatewaySecurityPolicy!,
    if (ipVersion != null) 'ipVersion': ipVersion!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (ports != null) 'ports': ports!,
    if (routingMode != null) 'routingMode': routingMode!,
    if (scope != null) 'scope': scope!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (serverTlsPolicy != null) 'serverTlsPolicy': serverTlsPolicy!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
    if (type != null) 'type': type!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - container:v1 : GatewayAPIConfig
/// - container:v1beta1 : GatewayAPIConfig
class $GatewayAPIConfig {
  /// The Gateway API release channel to use for Gateway API.
  /// Possible string values are:
  /// - "CHANNEL_UNSPECIFIED" : Default value.
  /// - "CHANNEL_DISABLED" : Gateway API support is disabled
  /// - "CHANNEL_EXPERIMENTAL" : Deprecated: use CHANNEL_STANDARD instead.
  /// Gateway API support is enabled, experimental CRDs are installed
  /// - "CHANNEL_STANDARD" : Gateway API support is enabled, standard CRDs are
  /// installed
  core.String? channel;

  $GatewayAPIConfig({this.channel});

  $GatewayAPIConfig.fromJson(core.Map json_)
    : this(channel: json_['channel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (channel != null) 'channel': channel!,
  };
}

/// Used by:
///
/// - workstations:v1 : GatewayConfig
/// - workstations:v1beta : GatewayConfig
class $GatewayConfig {
  /// Whether HTTP/2 is enabled for this workstation cluster.
  ///
  /// Defaults to false.
  ///
  /// Optional.
  core.bool? http2Enabled;

  $GatewayConfig({this.http2Enabled});

  $GatewayConfig.fromJson(core.Map json_)
    : this(http2Enabled: json_['http2Enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (http2Enabled != null) 'http2Enabled': http2Enabled!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GatewayRouteView
/// - networkservices:v1beta1 : GatewayRouteView
class $GatewayRouteView {
  /// Identifier.
  ///
  /// Full path name of the GatewayRouteView resource. Format:
  /// projects/{project_number}/locations/{location}/gateways/{gateway}/routeViews/{route_view}
  ///
  /// Output only.
  core.String? name;

  /// The resource id for the route.
  ///
  /// Output only.
  core.String? routeId;

  /// Location where the route exists.
  ///
  /// Output only.
  core.String? routeLocation;

  /// Project number where the route exists.
  ///
  /// Output only.
  core.String? routeProjectNumber;

  /// Type of the route: HttpRoute,GrpcRoute,TcpRoute, or TlsRoute
  ///
  /// Output only.
  core.String? routeType;

  $GatewayRouteView({
    this.name,
    this.routeId,
    this.routeLocation,
    this.routeProjectNumber,
    this.routeType,
  });

  $GatewayRouteView.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        routeId: json_['routeId'] as core.String?,
        routeLocation: json_['routeLocation'] as core.String?,
        routeProjectNumber: json_['routeProjectNumber'] as core.String?,
        routeType: json_['routeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (routeId != null) 'routeId': routeId!,
    if (routeLocation != null) 'routeLocation': routeLocation!,
    if (routeProjectNumber != null) 'routeProjectNumber': routeProjectNumber!,
    if (routeType != null) 'routeType': routeType!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : GatewaySecurityPolicy
/// - networksecurity:v1beta1 : GatewaySecurityPolicy
class $GatewaySecurityPolicy {
  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// Name of the resource.
  ///
  /// Name is of the form
  /// projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}
  /// gateway_security_policy should match the
  /// pattern:(^\[a-z\](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
  ///
  /// Required.
  core.String? name;

  /// Name of a TLS Inspection Policy resource that defines how TLS inspection
  /// will be performed for any rule(s) which enables it.
  ///
  /// Optional.
  core.String? tlsInspectionPolicy;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $GatewaySecurityPolicy({
    this.createTime,
    this.description,
    this.name,
    this.tlsInspectionPolicy,
    this.updateTime,
  });

  $GatewaySecurityPolicy.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        tlsInspectionPolicy: json_['tlsInspectionPolicy'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (tlsInspectionPolicy != null)
      'tlsInspectionPolicy': tlsInspectionPolicy!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : GatewaySecurityPolicyRule
/// - networksecurity:v1beta1 : GatewaySecurityPolicyRule
class $GatewaySecurityPolicyRule {
  /// CEL expression for matching on L7/application level criteria.
  ///
  /// Optional.
  core.String? applicationMatcher;

  /// Profile which tells what the primitive action should be.
  ///
  /// Required.
  /// Possible string values are:
  /// - "BASIC_PROFILE_UNSPECIFIED" : If there is not a mentioned action for the
  /// target.
  /// - "ALLOW" : Allow the matched traffic.
  /// - "DENY" : Deny the matched traffic.
  core.String? basicProfile;

  /// Time when the rule was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// Whether the rule is enforced.
  ///
  /// Required.
  core.bool? enabled;

  /// Name of the resource.
  ///
  /// ame is the full resource name so
  /// projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}/rules/{rule}
  /// rule should match the pattern: (^\[a-z\](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
  ///
  /// Required. Immutable.
  core.String? name;

  /// Priority of the rule.
  ///
  /// Lower number corresponds to higher precedence.
  ///
  /// Required.
  core.int? priority;

  /// CEL expression for matching on session criteria.
  ///
  /// Required.
  core.String? sessionMatcher;

  /// Flag to enable TLS inspection of traffic matching on , can only be true if
  /// the parent GatewaySecurityPolicy references a TLSInspectionConfig.
  ///
  /// Optional.
  core.bool? tlsInspectionEnabled;

  /// Time when the rule was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $GatewaySecurityPolicyRule({
    this.applicationMatcher,
    this.basicProfile,
    this.createTime,
    this.description,
    this.enabled,
    this.name,
    this.priority,
    this.sessionMatcher,
    this.tlsInspectionEnabled,
    this.updateTime,
  });

  $GatewaySecurityPolicyRule.fromJson(core.Map json_)
    : this(
        applicationMatcher: json_['applicationMatcher'] as core.String?,
        basicProfile: json_['basicProfile'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        enabled: json_['enabled'] as core.bool?,
        name: json_['name'] as core.String?,
        priority: json_['priority'] as core.int?,
        sessionMatcher: json_['sessionMatcher'] as core.String?,
        tlsInspectionEnabled: json_['tlsInspectionEnabled'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (applicationMatcher != null) 'applicationMatcher': applicationMatcher!,
    if (basicProfile != null) 'basicProfile': basicProfile!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (enabled != null) 'enabled': enabled!,
    if (name != null) 'name': name!,
    if (priority != null) 'priority': priority!,
    if (sessionMatcher != null) 'sessionMatcher': sessionMatcher!,
    if (tlsInspectionEnabled != null)
      'tlsInspectionEnabled': tlsInspectionEnabled!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - workstations:v1 : GceConfidentialInstanceConfig
/// - workstations:v1beta : GceConfidentialInstanceConfig
class $GceConfidentialInstanceConfig {
  /// Whether the instance has confidential compute enabled.
  ///
  /// Optional.
  core.bool? enableConfidentialCompute;

  $GceConfidentialInstanceConfig({this.enableConfidentialCompute});

  $GceConfidentialInstanceConfig.fromJson(core.Map json_)
    : this(
        enableConfidentialCompute:
            json_['enableConfidentialCompute'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableConfidentialCompute != null)
      'enableConfidentialCompute': enableConfidentialCompute!,
  };
}

/// Used by:
///
/// - workstations:v1 : GceInstanceHost
/// - workstations:v1beta : GceInstanceHost
class $GceInstanceHost {
  /// The ID of the Compute Engine instance.
  ///
  /// Optional. Output only.
  core.String? id;

  /// The name of the Compute Engine instance.
  ///
  /// Optional. Output only.
  core.String? name;

  /// The zone of the Compute Engine instance.
  ///
  /// Optional. Output only.
  core.String? zone;

  $GceInstanceHost({this.id, this.name, this.zone});

  $GceInstanceHost.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - workstations:v1 : GcePersistentDisk
/// - workstations:v1beta : GcePersistentDisk
class $GcePersistentDisk {
  /// Type of the disk to use.
  ///
  /// Defaults to `"pd-standard"`.
  ///
  /// Optional.
  core.String? diskType;

  /// Whether the disk is read only.
  ///
  /// If true, the disk may be shared by multiple VMs and source_snapshot must
  /// be set.
  ///
  /// Optional.
  core.bool? readOnly;

  /// Name of the disk image to use as the source for the disk.
  ///
  /// Must be empty if source_snapshot is set. Updating source_image will update
  /// content in the ephemeral directory after the workstation is restarted.
  /// Only file systems supported by Container-Optimized OS (COS) are explicitly
  /// supported. For a list of supported file systems, please refer to the
  /// [COS documentation](https://cloud.google.com/container-optimized-os/docs/concepts/supported-filesystems).
  /// This field is mutable.
  ///
  /// Optional.
  core.String? sourceImage;

  /// Name of the snapshot to use as the source for the disk.
  ///
  /// Must be empty if source_image is set. Must be empty if read_only is false.
  /// Updating source_snapshot will update content in the ephemeral directory
  /// after the workstation is restarted. Only file systems supported by
  /// Container-Optimized OS (COS) are explicitly supported. For a list of
  /// supported file systems, see \[the filesystems available in
  /// Container-Optimized
  /// OS\](https://cloud.google.com/container-optimized-os/docs/concepts/supported-filesystems).
  /// This field is mutable.
  ///
  /// Optional.
  core.String? sourceSnapshot;

  $GcePersistentDisk({
    this.diskType,
    this.readOnly,
    this.sourceImage,
    this.sourceSnapshot,
  });

  $GcePersistentDisk.fromJson(core.Map json_)
    : this(
        diskType: json_['diskType'] as core.String?,
        readOnly: json_['readOnly'] as core.bool?,
        sourceImage: json_['sourceImage'] as core.String?,
        sourceSnapshot: json_['sourceSnapshot'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskType != null) 'diskType': diskType!,
    if (readOnly != null) 'readOnly': readOnly!,
    if (sourceImage != null) 'sourceImage': sourceImage!,
    if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
  };
}

/// Used by:
///
/// - container:v1 : GcePersistentDiskCsiDriverConfig
/// - container:v1beta1 : GcePersistentDiskCsiDriverConfig
class $GcePersistentDiskCsiDriverConfig {
  /// Whether the Compute Engine PD CSI driver is enabled for this cluster.
  core.bool? enabled;

  $GcePersistentDiskCsiDriverConfig({this.enabled});

  $GcePersistentDiskCsiDriverConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - workstations:v1 : GceRegionalPersistentDisk
/// - workstations:v1beta : GceRegionalPersistentDisk
class $GceRegionalPersistentDisk {
  /// The
  /// [type of the persistent disk](https://cloud.google.com/compute/docs/disks#disk-types)
  /// for the home directory.
  ///
  /// Defaults to `"pd-standard"`.
  ///
  /// Optional.
  core.String? diskType;

  /// Type of file system that the disk should be formatted with.
  ///
  /// The workstation image must support this file system type. Must be empty if
  /// source_snapshot is set. Defaults to `"ext4"`.
  ///
  /// Optional.
  core.String? fsType;

  /// Whether the persistent disk should be deleted when the workstation is
  /// deleted.
  ///
  /// Valid values are `DELETE` and `RETAIN`. Defaults to `DELETE`.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "RECLAIM_POLICY_UNSPECIFIED" : Do not use.
  /// - "DELETE" : Delete the persistent disk when deleting the workstation.
  /// - "RETAIN" : Keep the persistent disk when deleting the workstation. An
  /// administrator must manually delete the disk.
  core.String? reclaimPolicy;

  /// The GB capacity of a persistent home directory for each workstation
  /// created with this configuration.
  ///
  /// Must be empty if source_snapshot is set. Valid values are `10`, `50`,
  /// `100`, `200`, `500`, or `1000`. Defaults to `200`. If less than `200` GB,
  /// the disk_type must be `"pd-balanced"` or `"pd-ssd"`.
  ///
  /// Optional.
  core.int? sizeGb;

  /// Name of the snapshot to use as the source for the disk.
  ///
  /// If set, size_gb and fs_type must be empty. Must be formatted as ext4 file
  /// system with no partitions.
  ///
  /// Optional.
  core.String? sourceSnapshot;

  $GceRegionalPersistentDisk({
    this.diskType,
    this.fsType,
    this.reclaimPolicy,
    this.sizeGb,
    this.sourceSnapshot,
  });

  $GceRegionalPersistentDisk.fromJson(core.Map json_)
    : this(
        diskType: json_['diskType'] as core.String?,
        fsType: json_['fsType'] as core.String?,
        reclaimPolicy: json_['reclaimPolicy'] as core.String?,
        sizeGb: json_['sizeGb'] as core.int?,
        sourceSnapshot: json_['sourceSnapshot'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskType != null) 'diskType': diskType!,
    if (fsType != null) 'fsType': fsType!,
    if (reclaimPolicy != null) 'reclaimPolicy': reclaimPolicy!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
    if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
  };
}

/// Used by:
///
/// - workstations:v1 : GceShieldedInstanceConfig
/// - workstations:v1beta : GceShieldedInstanceConfig
class $GceShieldedInstanceConfig {
  /// Whether the instance has integrity monitoring enabled.
  ///
  /// Optional.
  core.bool? enableIntegrityMonitoring;

  /// Whether the instance has Secure Boot enabled.
  ///
  /// Optional.
  core.bool? enableSecureBoot;

  /// Whether the instance has the vTPM enabled.
  ///
  /// Optional.
  core.bool? enableVtpm;

  $GceShieldedInstanceConfig({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
    this.enableVtpm,
  });

  $GceShieldedInstanceConfig.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
        enableVtpm: json_['enableVtpm'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
    if (enableVtpm != null) 'enableVtpm': enableVtpm!,
  };
}

/// Used by:
///
/// - container:v1 : GcfsConfig
/// - container:v1beta1 : GcfsConfig
class $GcfsConfig {
  /// Whether to use GCFS.
  core.bool? enabled;

  $GcfsConfig({this.enabled});

  $GcfsConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1ViolationRemediationInstructionsGcloud
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1ViolationRemediationInstructionsGcloud
/// - cloudcontrolspartner:v1 : Gcloud
/// - cloudcontrolspartner:v1beta : Gcloud
class $Gcloud {
  /// Additional urls for more information about steps
  core.List<core.String>? additionalLinks;

  /// Gcloud command to resolve violation
  core.List<core.String>? gcloudCommands;

  /// Steps to resolve violation via gcloud cli
  core.List<core.String>? steps;

  $Gcloud({this.additionalLinks, this.gcloudCommands, this.steps});

  $Gcloud.fromJson(core.Map json_)
    : this(
        additionalLinks:
            (json_['additionalLinks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        gcloudCommands:
            (json_['gcloudCommands'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        steps:
            (json_['steps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (additionalLinks != null) 'additionalLinks': additionalLinks!,
    if (gcloudCommands != null) 'gcloudCommands': gcloudCommands!,
    if (steps != null) 'steps': steps!,
  };
}

/// Used by:
///
/// - container:v1 : GcpFilestoreCsiDriverConfig
/// - container:v1beta1 : GcpFilestoreCsiDriverConfig
class $GcpFilestoreCsiDriverConfig {
  /// Whether the GCP Filestore CSI driver is enabled for this cluster.
  core.bool? enabled;

  $GcpFilestoreCsiDriverConfig({this.enabled});

  $GcpFilestoreCsiDriverConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - redis:v1 : GcsBackupSource
/// - redis:v1beta1 : GcsBackupSource
class $GcsBackupSource {
  /// URIs of the Cloud Storage objects to import.
  ///
  /// Example: gs://bucket1/object1, gs://bucket2/folder2/object2
  ///
  /// Optional.
  core.List<core.String>? uris;

  $GcsBackupSource({this.uris});

  $GcsBackupSource.fromJson(core.Map json_)
    : this(
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (uris != null) 'uris': uris!,
  };
}

/// Used by:
///
/// - parallelstore:v1 : DestinationGcsBucket
/// - parallelstore:v1 : SourceGcsBucket
/// - parallelstore:v1beta : DestinationGcsBucket
/// - parallelstore:v1beta : SourceGcsBucket
class $GcsBucket {
  /// URI to a Cloud Storage bucket in the format: `gs:///`.
  ///
  /// The path inside the bucket is optional.
  ///
  /// Required.
  core.String? uri;

  $GcsBucket({this.uri});

  $GcsBucket.fromJson(core.Map json_) : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - alloydb:v1 : GcsDestination
/// - alloydb:v1alpha : GcsDestination
/// - alloydb:v1beta : GcsDestination
class $GcsDestination00 {
  /// The path to the file in Google Cloud Storage where the export will be
  /// stored.
  ///
  /// The URI is in the form `gs://bucketName/fileName`.
  ///
  /// Required.
  core.String? uri;

  $GcsDestination00({this.uri});

  $GcsDestination00.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - vision:v1 : GcsDestination
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1GcsDestination
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1GcsDestination
class $GcsDestination01 {
  /// Google Cloud Storage URI prefix where the results will be stored.
  ///
  /// Results will be in JSON format and preceded by its corresponding input URI
  /// prefix. This field can either represent a gcs file prefix or gcs
  /// directory. In either case, the uri should be unique because in order to
  /// get all of the output files, you will need to do a wildcard gcs search on
  /// the uri prefix you provide. Examples: * File Prefix:
  /// gs://bucket-name/here/filenameprefix The output files will be created in
  /// gs://bucket-name/here/ and the names of the output files will begin with
  /// "filenameprefix". * Directory Prefix: gs://bucket-name/some/location/ The
  /// output files will be created in gs://bucket-name/some/location/ and the
  /// names of the output files could be anything because there was no filename
  /// prefix specified. If multiple outputs, each response is still
  /// AnnotateFileResponse, each of which contains some subset of the full list
  /// of AnnotateImageResponse. Multiple outputs can happen if, for example, the
  /// output JSON is too large and overflows into multiple sharded files.
  core.String? uri;

  $GcsDestination01({this.uri});

  $GcsDestination01.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GcsDestination
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GcsDestination
class $GcsDestination02 {
  /// Google Cloud Storage URI to output directory.
  ///
  /// If the uri doesn't end with '/', a '/' will be automatically appended. The
  /// directory is created if it doesn't exist.
  ///
  /// Required.
  core.String? outputUriPrefix;

  $GcsDestination02({this.outputUriPrefix});

  $GcsDestination02.fromJson(core.Map json_)
    : this(outputUriPrefix: json_['outputUriPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3GcsDestination
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1GcsDestination
class $GcsDestination03 {
  /// The Google Cloud Storage URI for the exported objects.
  ///
  /// A URI is of the form: `gs://bucket/object-name-or-prefix` Whether a full
  /// object name, or just a prefix, its usage depends on the Dialogflow
  /// operation.
  ///
  /// Required.
  core.String? uri;

  $GcsDestination03({this.uri});

  $GcsDestination03.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - redis:v1 : GcsDestination
/// - redis:v1beta1 : GcsDestination
class $GcsDestination04 {
  /// Data destination URI (e.g. 'gs://my_bucket/my_object').
  ///
  /// Existing files will be overwritten.
  ///
  /// Required.
  core.String? uri;

  $GcsDestination04({this.uri});

  $GcsDestination04.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1GcsDocument
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3GcsDocument
class $GcsDocument {
  /// The Cloud Storage object uri.
  core.String? gcsUri;

  /// An IANA MIME type (RFC6838) of the content.
  core.String? mimeType;

  $GcsDocument({this.gcsUri, this.mimeType});

  $GcsDocument.fromJson(core.Map json_)
    : this(
        gcsUri: json_['gcsUri'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsUri != null) 'gcsUri': gcsUri!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - container:v1 : GcsFuseCsiDriverConfig
/// - container:v1beta1 : GcsFuseCsiDriverConfig
class $GcsFuseCsiDriverConfig {
  /// Whether the Cloud Storage Fuse CSI driver is enabled for this cluster.
  core.bool? enabled;

  $GcsFuseCsiDriverConfig({this.enabled});

  $GcsFuseCsiDriverConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1GcsPrefix
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3GcsPrefix
class $GcsPrefix {
  /// The URI prefix.
  core.String? gcsUriPrefix;

  $GcsPrefix({this.gcsUriPrefix});

  $GcsPrefix.fromJson(core.Map json_)
    : this(gcsUriPrefix: json_['gcsUriPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsUriPrefix != null) 'gcsUriPrefix': gcsUriPrefix!,
  };
}

/// Used by:
///
/// - healthcare:v1 : GcsSource
/// - healthcare:v1 : GoogleCloudHealthcareV1FhirGcsSource
/// - healthcare:v1beta1 : GcsSource
/// - healthcare:v1beta1 : GoogleCloudHealthcareV1beta1FhirGcsSource
class $GcsSource00 {
  /// Points to a Cloud Storage URI containing file(s) to import.
  ///
  /// The URI must be in the following format: `gs://{bucket_id}/{object_id}`.
  /// The URI can include wildcards in `object_id` and thus identify multiple
  /// files. Supported wildcards: * `*` to match 0 or more non-separator
  /// characters * `**` to match 0 or more characters (including separators).
  /// Must be used at the end of a path and with no other wildcards in the path.
  /// Can also be used with a file extension (such as .ndjson), which imports
  /// all files with the extension in the specified directory and its
  /// sub-directories. For example, `gs://my-bucket/my-directory / * *.ndjson`
  /// imports all files with `.ndjson` extensions in `my-directory/` and its
  /// sub-directories. * `?` to match 1 character Files matching the wildcard
  /// are expected to contain content only, no metadata.
  core.String? uri;

  $GcsSource00({this.uri});

  $GcsSource00.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1GcsSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaGcsSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaGcsSource
class $GcsSource01 {
  /// The schema to use when parsing the data from the source.
  ///
  /// Supported values for document imports: * `document` (default): One JSON
  /// Document per line. Each document must have a valid Document.id. *
  /// `content`: Unstructured data (e.g. PDF, HTML). Each file matched by
  /// `input_uris` becomes a document, with the ID set to the first 128 bits of
  /// SHA256(URI) encoded as a hex string. * `custom`: One custom data JSON per
  /// row in arbitrary format that conforms to the defined Schema of the data
  /// store. This can only be used by the GENERIC Data Store vertical. * `csv`:
  /// A CSV file with header conforming to the defined Schema of the data store.
  /// Each entry after the header is imported as a Document. This can only be
  /// used by the GENERIC Data Store vertical. Supported values for user event
  /// imports: * `user_event` (default): One JSON UserEvent per line.
  core.String? dataSchema;

  /// Cloud Storage URIs to input files.
  ///
  /// Each URI can be up to 2000 characters long. URIs can match the full object
  /// path (for example, `gs://bucket/directory/object.json`) or a pattern
  /// matching one or more files, such as `gs://bucket/directory / * .json`. A
  /// request can contain at most 100 files (or 100,000 files if `data_schema`
  /// is `content`). Each file can be up to 2 GB (or 100 MB if `data_schema` is
  /// `content`).
  ///
  /// Required.
  core.List<core.String>? inputUris;

  $GcsSource01({this.dataSchema, this.inputUris});

  $GcsSource01.fromJson(core.Map json_)
    : this(
        dataSchema: json_['dataSchema'] as core.String?,
        inputUris:
            (json_['inputUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataSchema != null) 'dataSchema': dataSchema!,
    if (inputUris != null) 'inputUris': inputUris!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2GcsSource
/// - retail:v2alpha : GoogleCloudRetailV2alphaGcsSource
/// - retail:v2beta : GoogleCloudRetailV2betaGcsSource
class $GcsSource02 {
  /// The schema to use when parsing the data from the source.
  ///
  /// Supported values for product imports: * `product` (default): One JSON
  /// Product per line. Each product must have a valid Product.id. *
  /// `product_merchant_center`: See
  /// [Importing catalog data from Merchant Center](https://cloud.google.com/retail/recommendations-ai/docs/upload-catalog#mc).
  /// Supported values for user events imports: * `user_event` (default): One
  /// JSON UserEvent per line. * `user_event_ga360`: Using
  /// https://support.google.com/analytics/answer/3437719. Supported values for
  /// control imports: * `control` (default): One JSON Control per line.
  /// Supported values for catalog attribute imports: * `catalog_attribute`
  /// (default): One CSV CatalogAttribute per line.
  core.String? dataSchema;

  /// Google Cloud Storage URIs to input files.
  ///
  /// URI can be up to 2000 characters long. URIs can match the full object path
  /// (for example, `gs://bucket/directory/object.json`) or a pattern matching
  /// one or more files, such as `gs://bucket/directory / * .json`. A request
  /// can contain at most 100 files, and each file can be up to 2 GB. See
  /// [Importing product information](https://cloud.google.com/retail/recommendations-ai/docs/upload-catalog)
  /// for the expected file format and setup instructions.
  ///
  /// Required.
  core.List<core.String>? inputUris;

  $GcsSource02({this.dataSchema, this.inputUris});

  $GcsSource02.fromJson(core.Map json_)
    : this(
        dataSchema: json_['dataSchema'] as core.String?,
        inputUris:
            (json_['inputUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataSchema != null) 'dataSchema': dataSchema!,
    if (inputUris != null) 'inputUris': inputUris!,
  };
}

/// Used by:
///
/// - vision:v1 : GcsSource
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1GcsSource
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1GcsSource
class $GcsSource03 {
  /// Google Cloud Storage URI for the input file.
  ///
  /// This must only be a Google Cloud Storage object. Wildcards are not
  /// currently supported.
  core.String? uri;

  $GcsSource03({this.uri});

  $GcsSource03.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GcsSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GcsSource
class $GcsSource04 {
  /// Google Cloud Storage URI(-s) to the input file(s).
  ///
  /// May contain wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  ///
  /// Required.
  core.List<core.String>? uris;

  $GcsSource04({this.uris});

  $GcsSource04.fromJson(core.Map json_)
    : this(
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (uris != null) 'uris': uris!,
  };
}

/// Used by:
///
/// - redis:v1 : GcsSource
/// - redis:v1beta1 : GcsSource
class $GcsSource05 {
  /// Source data URI.
  ///
  /// (e.g. 'gs://my_bucket/my_object').
  ///
  /// Required.
  core.String? uri;

  $GcsSource05({this.uri});

  $GcsSource05.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2GcsSources
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1GcsSources
class $GcsSources {
  /// Google Cloud Storage URIs for the inputs.
  ///
  /// A URI is of the form: `gs://bucket/object-prefix-or-name` Whether a prefix
  /// or name is used depends on the use case.
  ///
  /// Required.
  core.List<core.String>? uris;

  $GcsSources({this.uris});

  $GcsSources.fromJson(core.Map json_)
    : this(
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (uris != null) 'uris': uris!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GdcConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GdcConfig
class $GdcConfig {
  /// GDC zone.
  ///
  /// A cluster will be designated for the Vertex AI workload in this zone.
  core.String? zone;

  $GdcConfig({this.zone});

  $GdcConfig.fromJson(core.Map json_)
    : this(zone: json_['zone'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : GeminiInstanceConfig
/// - sqladmin:v1beta4 : GeminiInstanceConfig
class $GeminiInstanceConfig {
  /// Whether the active query is enabled.
  ///
  /// Output only.
  core.bool? activeQueryEnabled;

  /// Whether Gemini is enabled.
  ///
  /// Output only.
  core.bool? entitled;

  /// Whether the flag recommender is enabled.
  ///
  /// Output only.
  core.bool? flagRecommenderEnabled;

  /// Whether the vacuum management is enabled.
  ///
  /// Output only.
  core.bool? googleVacuumMgmtEnabled;

  /// Whether the index advisor is enabled.
  ///
  /// Output only.
  core.bool? indexAdvisorEnabled;

  /// Whether canceling the out-of-memory (OOM) session is enabled.
  ///
  /// Output only.
  core.bool? oomSessionCancelEnabled;

  $GeminiInstanceConfig({
    this.activeQueryEnabled,
    this.entitled,
    this.flagRecommenderEnabled,
    this.googleVacuumMgmtEnabled,
    this.indexAdvisorEnabled,
    this.oomSessionCancelEnabled,
  });

  $GeminiInstanceConfig.fromJson(core.Map json_)
    : this(
        activeQueryEnabled: json_['activeQueryEnabled'] as core.bool?,
        entitled: json_['entitled'] as core.bool?,
        flagRecommenderEnabled: json_['flagRecommenderEnabled'] as core.bool?,
        googleVacuumMgmtEnabled: json_['googleVacuumMgmtEnabled'] as core.bool?,
        indexAdvisorEnabled: json_['indexAdvisorEnabled'] as core.bool?,
        oomSessionCancelEnabled: json_['oomSessionCancelEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeQueryEnabled != null) 'activeQueryEnabled': activeQueryEnabled!,
    if (entitled != null) 'entitled': entitled!,
    if (flagRecommenderEnabled != null)
      'flagRecommenderEnabled': flagRecommenderEnabled!,
    if (googleVacuumMgmtEnabled != null)
      'googleVacuumMgmtEnabled': googleVacuumMgmtEnabled!,
    if (indexAdvisorEnabled != null)
      'indexAdvisorEnabled': indexAdvisorEnabled!,
    if (oomSessionCancelEnabled != null)
      'oomSessionCancelEnabled': oomSessionCancelEnabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfigRagConfig
class $GenAiAdvancedFeaturesConfigRagConfig {
  /// If true, enable Retrieval Augmented Generation in ChatCompletion request.
  ///
  /// Once enabled, the endpoint will be identified as GenAI endpoint and
  /// Arthedain router will be used.
  core.bool? enableRag;

  $GenAiAdvancedFeaturesConfigRagConfig({this.enableRag});

  $GenAiAdvancedFeaturesConfigRagConfig.fromJson(core.Map json_)
    : this(enableRag: json_['enableRag'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableRag != null) 'enableRag': enableRag!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GenderAssignedTargetingOptionDetails
/// - displayvideo:v3 : GenderAssignedTargetingOptionDetails
/// - displayvideo:v4 : GenderAssignedTargetingOptionDetails
class $GenderAssignedTargetingOptionDetails {
  /// The gender of the audience.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GENDER_UNSPECIFIED" : Default value when gender is not specified in
  /// this version. This enum is a place holder for default value and does not
  /// represent a real gender option.
  /// - "GENDER_MALE" : The audience gender is male.
  /// - "GENDER_FEMALE" : The audience gender is female.
  /// - "GENDER_UNKNOWN" : The audience gender is unknown.
  core.String? gender;

  $GenderAssignedTargetingOptionDetails({this.gender});

  $GenderAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(gender: json_['gender'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gender != null) 'gender': gender!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GenderTargetingOptionDetails
/// - displayvideo:v3 : GenderTargetingOptionDetails
/// - displayvideo:v4 : GenderTargetingOptionDetails
class $GenderTargetingOptionDetails {
  /// The gender of an audience.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GENDER_UNSPECIFIED" : Default value when gender is not specified in
  /// this version. This enum is a place holder for default value and does not
  /// represent a real gender option.
  /// - "GENDER_MALE" : The audience gender is male.
  /// - "GENDER_FEMALE" : The audience gender is female.
  /// - "GENDER_UNKNOWN" : The audience gender is unknown.
  core.String? gender;

  $GenderTargetingOptionDetails({this.gender});

  $GenderTargetingOptionDetails.fromJson(core.Map json_)
    : this(gender: json_['gender'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gender != null) 'gender': gender!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenerateAccessTokenRequest
/// - notebooks:v2 : GenerateAccessTokenRequest
class $GenerateAccessTokenRequest00 {
  /// The VM identity token (a JWT) for authenticating the VM.
  ///
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity
  ///
  /// Required.
  core.String? vmToken;

  $GenerateAccessTokenRequest00({this.vmToken});

  $GenerateAccessTokenRequest00.fromJson(core.Map json_)
    : this(vmToken: json_['vmToken'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vmToken != null) 'vmToken': vmToken!,
  };
}

/// Used by:
///
/// - workstations:v1 : GenerateAccessTokenRequest
/// - workstations:v1beta : GenerateAccessTokenRequest
class $GenerateAccessTokenRequest01 {
  /// Desired expiration time of the access token.
  ///
  /// This value must be at most 24 hours in the future. If a value is not
  /// specified, the token's expiration time will be set to a default value of 1
  /// hour in the future.
  core.String? expireTime;

  /// Port for which the access token should be generated.
  ///
  /// If specified, the generated access token grants access only to the
  /// specified port of the workstation. If specified, values must be within the
  /// range \[1 - 65535\]. If not specified, the generated access token grants
  /// access to all ports of the workstation.
  ///
  /// Optional.
  core.int? port;

  /// Desired lifetime duration of the access token.
  ///
  /// This value must be at most 24 hours. If a value is not specified, the
  /// token's lifetime will be set to a default value of 1 hour.
  core.String? ttl;

  $GenerateAccessTokenRequest01({this.expireTime, this.port, this.ttl});

  $GenerateAccessTokenRequest01.fromJson(core.Map json_)
    : this(
        expireTime: json_['expireTime'] as core.String?,
        port: json_['port'] as core.int?,
        ttl: json_['ttl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expireTime != null) 'expireTime': expireTime!,
    if (port != null) 'port': port!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - workstations:v1 : GenerateAccessTokenResponse
/// - workstations:v1beta : GenerateAccessTokenResponse
class $GenerateAccessTokenResponse {
  /// The generated bearer access token.
  ///
  /// To use this token, include it in an Authorization header of an HTTP
  /// request sent to the associated workstation's hostnamefor example,
  /// `Authorization: Bearer `.
  core.String? accessToken;

  /// Time at which the generated token will expire.
  core.String? expireTime;

  $GenerateAccessTokenResponse({this.accessToken, this.expireTime});

  $GenerateAccessTokenResponse.fromJson(core.Map json_)
    : this(
        accessToken: json_['accessToken'] as core.String?,
        expireTime: json_['expireTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'accessToken': accessToken!,
    if (expireTime != null) 'expireTime': expireTime!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1GenerateAppAttestChallengeResponse
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaGenerateAppAttestChallengeResponse
class $GenerateAppAttestChallengeResponse {
  /// A one-time use challenge for the client to pass to the App Attest API.
  core.String? challenge;
  core.List<core.int> get challengeAsBytes => convert.base64.decode(challenge!);

  set challengeAsBytes(core.List<core.int> bytes_) {
    challenge = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The duration from the time this challenge is minted until its expiration.
  ///
  /// This field is intended to ease client-side token management, since the
  /// client may have clock skew, but is still able to accurately measure a
  /// duration.
  core.String? ttl;

  $GenerateAppAttestChallengeResponse({this.challenge, this.ttl});

  $GenerateAppAttestChallengeResponse.fromJson(core.Map json_)
    : this(
        challenge: json_['challenge'] as core.String?,
        ttl: json_['ttl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (challenge != null) 'challenge': challenge!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - cloudfunctions:v1 : GenerateDownloadUrlResponse
/// - cloudfunctions:v2 : GenerateDownloadUrlResponse
/// - cloudfunctions:v2alpha : GenerateDownloadUrlResponse
/// - cloudfunctions:v2beta : GenerateDownloadUrlResponse
class $GenerateDownloadUrlResponse {
  /// The generated Google Cloud Storage signed URL that should be used for
  /// function source code download.
  core.String? downloadUrl;

  $GenerateDownloadUrlResponse({this.downloadUrl});

  $GenerateDownloadUrlResponse.fromJson(core.Map json_)
    : this(downloadUrl: json_['downloadUrl'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (downloadUrl != null) 'downloadUrl': downloadUrl!,
  };
}

/// Used by:
///
/// - androidenterprise:v1 : GenerateEnterpriseUpgradeUrlResponse
/// - androidmanagement:v1 : GenerateEnterpriseUpgradeUrlResponse
class $GenerateEnterpriseUpgradeUrlResponse {
  /// A URL for an enterprise admin to upgrade their enterprise.
  ///
  /// The page can't be rendered in an iframe.
  core.String? url;

  $GenerateEnterpriseUpgradeUrlResponse({this.url});

  $GenerateEnterpriseUpgradeUrlResponse.fromJson(core.Map json_)
    : this(url: json_['url'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : GenerateEphemeralCertRequest
/// - sqladmin:v1beta4 : GenerateEphemeralCertRequest
class $GenerateEphemeralCertRequest {
  /// Access token to include in the signed certificate.
  ///
  /// Optional.
  core.String? accessToken;

  /// PEM encoded public key to include in the signed certificate.
  core.String? publicKey;

  /// Optional snapshot read timestamp to trade freshness for performance.
  ///
  /// Optional.
  core.String? readTime;

  /// If set, it will contain the cert valid duration.
  ///
  /// Optional.
  core.String? validDuration;

  $GenerateEphemeralCertRequest({
    this.accessToken,
    this.publicKey,
    this.readTime,
    this.validDuration,
  });

  $GenerateEphemeralCertRequest.fromJson(core.Map json_)
    : this(
        accessToken: json_['access_token'] as core.String?,
        publicKey: json_['public_key'] as core.String?,
        readTime: json_['readTime'] as core.String?,
        validDuration: json_['validDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'access_token': accessToken!,
    if (publicKey != null) 'public_key': publicKey!,
    if (readTime != null) 'readTime': readTime!,
    if (validDuration != null) 'validDuration': validDuration!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : GenerateExclusivityManifestResponse
/// - gkehub:v1beta1 : GenerateExclusivityManifestResponse
class $GenerateExclusivityManifestResponse {
  /// The YAML manifest of the membership CR to apply if a new version of the CR
  /// is available.
  ///
  /// Empty if no update needs to be applied.
  core.String? crManifest;

  /// The YAML manifest of the membership CRD to apply if a newer version of the
  /// CRD is available.
  ///
  /// Empty if no update needs to be applied.
  core.String? crdManifest;

  $GenerateExclusivityManifestResponse({this.crManifest, this.crdManifest});

  $GenerateExclusivityManifestResponse.fromJson(core.Map json_)
    : this(
        crManifest: json_['crManifest'] as core.String?,
        crdManifest: json_['crdManifest'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (crManifest != null) 'crManifest': crManifest!,
    if (crdManifest != null) 'crdManifest': crdManifest!,
  };
}

/// Used by:
///
/// - gkehub:v1 : GenerateMembershipRBACRoleBindingYAMLResponse
/// - gkehub:v1alpha : GenerateMembershipRBACRoleBindingYAMLResponse
/// - gkehub:v1beta : GenerateMembershipRBACRoleBindingYAMLResponse
class $GenerateMembershipRBACRoleBindingYAMLResponse {
  /// a yaml text blob including the RBAC policies.
  core.String? roleBindingsYaml;

  $GenerateMembershipRBACRoleBindingYAMLResponse({this.roleBindingsYaml});

  $GenerateMembershipRBACRoleBindingYAMLResponse.fromJson(core.Map json_)
    : this(roleBindingsYaml: json_['roleBindingsYaml'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (roleBindingsYaml != null) 'roleBindingsYaml': roleBindingsYaml!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1GeneratePlayIntegrityChallengeResponse
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaGeneratePlayIntegrityChallengeResponse
class $GeneratePlayIntegrityChallengeResponse {
  /// A one-time use
  /// [challenge](https://developer.android.com/google/play/integrity/verdict#protect-against-replay-attacks)
  /// for the client to pass to the Play Integrity API.
  core.String? challenge;

  /// The duration from the time this challenge is minted until its expiration.
  ///
  /// This field is intended to ease client-side token management, since the
  /// client may have clock skew, but is still able to accurately measure a
  /// duration.
  core.String? ttl;

  $GeneratePlayIntegrityChallengeResponse({this.challenge, this.ttl});

  $GeneratePlayIntegrityChallengeResponse.fromJson(core.Map json_)
    : this(
        challenge: json_['challenge'] as core.String?,
        ttl: json_['ttl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (challenge != null) 'challenge': challenge!,
    if (ttl != null) 'ttl': ttl!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2GenerateStatelessSummaryResponseSummary
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1GenerateStatelessSummaryResponseSummary
class $GenerateStatelessSummaryResponseSummary {
  /// The baseline model version used to generate this summary.
  ///
  /// It is empty if a baseline model was not used to generate this summary.
  core.String? baselineModelVersion;

  /// The summary content that is concatenated into one string.
  core.String? text;

  /// The summary content that is divided into sections.
  ///
  /// The key is the section's name and the value is the section's content.
  /// There is no specific format for the key or value.
  core.Map<core.String, core.String>? textSections;

  $GenerateStatelessSummaryResponseSummary({
    this.baselineModelVersion,
    this.text,
    this.textSections,
  });

  $GenerateStatelessSummaryResponseSummary.fromJson(core.Map json_)
    : this(
        baselineModelVersion: json_['baselineModelVersion'] as core.String?,
        text: json_['text'] as core.String?,
        textSections: (json_['textSections']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselineModelVersion != null)
      'baselineModelVersion': baselineModelVersion!,
    if (text != null) 'text': text!,
    if (textSections != null) 'textSections': textSections!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2GenerateSuggestionsRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1GenerateSuggestionsRequest
class $GenerateSuggestionsRequest {
  /// The name of the latest conversation message for which the request is
  /// triggered.
  ///
  /// Format: `projects//locations//conversations//messages/`.
  ///
  /// Optional.
  core.String? latestMessage;

  /// A list of trigger events.
  ///
  /// Only generators configured in the conversation_profile whose trigger_event
  /// is listed here will be triggered.
  ///
  /// Optional.
  core.List<core.String>? triggerEvents;

  $GenerateSuggestionsRequest({this.latestMessage, this.triggerEvents});

  $GenerateSuggestionsRequest.fromJson(core.Map json_)
    : this(
        latestMessage: json_['latestMessage'] as core.String?,
        triggerEvents:
            (json_['triggerEvents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (latestMessage != null) 'latestMessage': latestMessage!,
    if (triggerEvents != null) 'triggerEvents': triggerEvents!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : GenerateUploadUrlRequest
/// - cloudfunctions:v2alpha : GenerateUploadUrlRequest
/// - cloudfunctions:v2beta : GenerateUploadUrlRequest
class $GenerateUploadUrlRequest {
  /// The function environment the generated upload url will be used for.
  ///
  /// The upload url for 2nd Gen functions can also be used for 1st gen
  /// functions, but not vice versa. If not specified, 2nd generation-style
  /// upload URLs are generated.
  /// Possible string values are:
  /// - "ENVIRONMENT_UNSPECIFIED" : Unspecified
  /// - "GEN_1" : Gen 1
  /// - "GEN_2" : Gen 2
  core.String? environment;

  /// Resource name of a KMS crypto key (managed by the user) used to
  /// encrypt/decrypt function source code objects in intermediate Cloud Storage
  /// buckets.
  ///
  /// When you generate an upload url and upload your source code, it gets
  /// copied to an intermediate Cloud Storage bucket. The source code is then
  /// copied to a versioned directory in the sources bucket in the consumer
  /// project during the function deployment. It must match the pattern
  /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
  /// The Google Cloud Functions service account
  /// (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) must be
  /// granted the role 'Cloud KMS CryptoKey Encrypter/Decrypter
  /// (roles/cloudkms.cryptoKeyEncrypterDecrypter)' on the
  /// Key/KeyRing/Project/Organization (least access preferred).
  core.String? kmsKeyName;

  $GenerateUploadUrlRequest({this.environment, this.kmsKeyName});

  $GenerateUploadUrlRequest.fromJson(core.Map json_)
    : this(
        environment: json_['environment'] as core.String?,
        kmsKeyName: json_['kmsKeyName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigAutoRoutingMode
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigAutoRoutingMode
class $GenerationConfigRoutingConfigAutoRoutingMode {
  /// The model routing preference.
  /// Possible string values are:
  /// - "UNKNOWN" : Unspecified model routing preference.
  /// - "PRIORITIZE_QUALITY" : Prefer higher quality over low cost.
  /// - "BALANCED" : Balanced model routing preference.
  /// - "PRIORITIZE_COST" : Prefer lower cost over higher quality.
  core.String? modelRoutingPreference;

  $GenerationConfigRoutingConfigAutoRoutingMode({this.modelRoutingPreference});

  $GenerationConfigRoutingConfigAutoRoutingMode.fromJson(core.Map json_)
    : this(
        modelRoutingPreference: json_['modelRoutingPreference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelRoutingPreference != null)
      'modelRoutingPreference': modelRoutingPreference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigManualRoutingMode
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigManualRoutingMode
class $GenerationConfigRoutingConfigManualRoutingMode {
  /// The model name to use.
  ///
  /// Only the public LLM models are accepted. See
  /// [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models).
  core.String? modelName;

  $GenerationConfigRoutingConfigManualRoutingMode({this.modelName});

  $GenerationConfigRoutingConfigManualRoutingMode.fromJson(core.Map json_)
    : this(modelName: json_['modelName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GenerationConfigThinkingConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenerationConfigThinkingConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GenerationConfigThinkingConfig
class $GenerationConfigThinkingConfig {
  /// Indicates whether to include thoughts in the response.
  ///
  /// If true, thoughts are returned only when available.
  ///
  /// Optional.
  core.bool? includeThoughts;

  /// Indicates the thinking budget in tokens.
  ///
  /// Optional.
  core.int? thinkingBudget;

  $GenerationConfigThinkingConfig({this.includeThoughts, this.thinkingBudget});

  $GenerationConfigThinkingConfig.fromJson(core.Map json_)
    : this(
        includeThoughts: json_['includeThoughts'] as core.bool?,
        thinkingBudget: json_['thinkingBudget'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeThoughts != null) 'includeThoughts': includeThoughts!,
    if (thinkingBudget != null) 'thinkingBudget': thinkingBudget!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2GenerativeQuestionConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaGenerativeQuestionConfig
/// - retail:v2beta : GoogleCloudRetailV2betaGenerativeQuestionConfig
class $GenerativeQuestionConfig {
  /// Whether the question is asked at serving time.
  ///
  /// Optional.
  core.bool? allowedInConversation;

  /// Resource name of the catalog.
  ///
  /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
  ///
  /// Required.
  core.String? catalog;

  /// Values that can be used to answer the question.
  ///
  /// Output only.
  core.List<core.String>? exampleValues;

  /// The facet to which the question is associated.
  ///
  /// Required.
  core.String? facet;

  /// The question that will be used at serving time.
  ///
  /// Question can have a max length of 300 bytes. When not populated,
  /// generated_question should be used.
  ///
  /// Optional.
  core.String? finalQuestion;

  /// The ratio of how often a question was asked.
  ///
  /// Output only.
  core.double? frequency;

  /// The LLM generated question.
  ///
  /// Output only.
  core.String? generatedQuestion;

  $GenerativeQuestionConfig({
    this.allowedInConversation,
    this.catalog,
    this.exampleValues,
    this.facet,
    this.finalQuestion,
    this.frequency,
    this.generatedQuestion,
  });

  $GenerativeQuestionConfig.fromJson(core.Map json_)
    : this(
        allowedInConversation: json_['allowedInConversation'] as core.bool?,
        catalog: json_['catalog'] as core.String?,
        exampleValues:
            (json_['exampleValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        facet: json_['facet'] as core.String?,
        finalQuestion: json_['finalQuestion'] as core.String?,
        frequency: (json_['frequency'] as core.num?)?.toDouble(),
        generatedQuestion: json_['generatedQuestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedInConversation != null)
      'allowedInConversation': allowedInConversation!,
    if (catalog != null) 'catalog': catalog!,
    if (exampleValues != null) 'exampleValues': exampleValues!,
    if (facet != null) 'facet': facet!,
    if (finalQuestion != null) 'finalQuestion': finalQuestion!,
    if (frequency != null) 'frequency': frequency!,
    if (generatedQuestion != null) 'generatedQuestion': generatedQuestion!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2GenerativeQuestionsFeatureConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaGenerativeQuestionsFeatureConfig
/// - retail:v2beta : GoogleCloudRetailV2betaGenerativeQuestionsFeatureConfig
class $GenerativeQuestionsFeatureConfig {
  /// Resource name of the affected catalog.
  ///
  /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
  ///
  /// Required.
  core.String? catalog;

  /// Determines whether questions will be used at serving time.
  ///
  /// Note: This feature cannot be enabled until initial data requirements are
  /// satisfied.
  ///
  /// Optional.
  core.bool? featureEnabled;

  /// Minimum number of products in the response to trigger follow-up questions.
  ///
  /// Value must be 0 or positive.
  ///
  /// Optional.
  core.int? minimumProducts;

  $GenerativeQuestionsFeatureConfig({
    this.catalog,
    this.featureEnabled,
    this.minimumProducts,
  });

  $GenerativeQuestionsFeatureConfig.fromJson(core.Map json_)
    : this(
        catalog: json_['catalog'] as core.String?,
        featureEnabled: json_['featureEnabled'] as core.bool?,
        minimumProducts: json_['minimumProducts'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (catalog != null) 'catalog': catalog!,
    if (featureEnabled != null) 'featureEnabled': featureEnabled!,
    if (minimumProducts != null) 'minimumProducts': minimumProducts!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3GenerativeSettingsFallbackSettingsPromptTemplate
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1GenerativeSettingsFallbackSettingsPromptTemplate
class $GenerativeSettingsFallbackSettingsPromptTemplate {
  /// Prompt name.
  core.String? displayName;

  /// If the flag is true, the prompt is frozen and cannot be modified by users.
  core.bool? frozen;

  /// Prompt text that is sent to a LLM on no-match default, placeholders are
  /// filled downstream.
  ///
  /// For example: "Here is a conversation $conversation, a response is: "
  core.String? promptText;

  $GenerativeSettingsFallbackSettingsPromptTemplate({
    this.displayName,
    this.frozen,
    this.promptText,
  });

  $GenerativeSettingsFallbackSettingsPromptTemplate.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        frozen: json_['frozen'] as core.bool?,
        promptText: json_['promptText'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (frozen != null) 'frozen': frozen!,
    if (promptText != null) 'promptText': promptText!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3GenerativeSettingsKnowledgeConnectorSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1GenerativeSettingsKnowledgeConnectorSettings
class $GenerativeSettingsKnowledgeConnectorSettings {
  /// Name of the virtual agent.
  ///
  /// Used for LLM prompt. Can be left empty.
  core.String? agent;

  /// Identity of the agent, e.g. "virtual agent", "AI assistant".
  core.String? agentIdentity;

  /// Agent scope, e.g. "Example company website", "internal Example company
  /// website for employees", "manual of car owner".
  core.String? agentScope;

  /// Name of the company, organization or other entity that the agent
  /// represents.
  ///
  /// Used for knowledge connector LLM prompt and for knowledge search.
  core.String? business;

  /// Company description, used for LLM prompt, e.g. "a family company selling
  /// freshly roasted coffee beans".
  core.String? businessDescription;

  /// Whether to disable fallback to Data Store search results (in case the LLM
  /// couldn't pick a proper answer).
  ///
  /// Per default the feature is enabled.
  core.bool? disableDataStoreFallback;

  $GenerativeSettingsKnowledgeConnectorSettings({
    this.agent,
    this.agentIdentity,
    this.agentScope,
    this.business,
    this.businessDescription,
    this.disableDataStoreFallback,
  });

  $GenerativeSettingsKnowledgeConnectorSettings.fromJson(core.Map json_)
    : this(
        agent: json_['agent'] as core.String?,
        agentIdentity: json_['agentIdentity'] as core.String?,
        agentScope: json_['agentScope'] as core.String?,
        business: json_['business'] as core.String?,
        businessDescription: json_['businessDescription'] as core.String?,
        disableDataStoreFallback:
            json_['disableDataStoreFallback'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agent != null) 'agent': agent!,
    if (agentIdentity != null) 'agentIdentity': agentIdentity!,
    if (agentScope != null) 'agentScope': agentScope!,
    if (business != null) 'business': business!,
    if (businessDescription != null)
      'businessDescription': businessDescription!,
    if (disableDataStoreFallback != null)
      'disableDataStoreFallback': disableDataStoreFallback!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3GeneratorModelParameter
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1GeneratorModelParameter
class $GeneratorModelParameter {
  /// The maximum number of tokens to generate.
  core.int? maxDecodeSteps;

  /// The temperature used for sampling.
  ///
  /// Temperature sampling occurs after both topP and topK have been applied.
  /// Valid range: \[0.0, 1.0\] Low temperature = less random. High temperature
  /// = more random.
  core.double? temperature;

  /// If set, the sampling process in each step is limited to the top_k tokens
  /// with highest probabilities.
  ///
  /// Valid range: \[1, 40\] or 1000+. Small topK = less random. Large topK =
  /// more random.
  core.int? topK;

  /// If set, only the tokens comprising the top top_p probability mass are
  /// considered.
  ///
  /// If both top_p and top_k are set, top_p will be used for further refining
  /// candidates selected with top_k. Valid range: (0.0, 1.0\]. Small topP =
  /// less random. Large topP = more random.
  core.double? topP;

  $GeneratorModelParameter({
    this.maxDecodeSteps,
    this.temperature,
    this.topK,
    this.topP,
  });

  $GeneratorModelParameter.fromJson(core.Map json_)
    : this(
        maxDecodeSteps: json_['maxDecodeSteps'] as core.int?,
        temperature: (json_['temperature'] as core.num?)?.toDouble(),
        topK: json_['topK'] as core.int?,
        topP: (json_['topP'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxDecodeSteps != null) 'maxDecodeSteps': maxDecodeSteps!,
    if (temperature != null) 'temperature': temperature!,
    if (topK != null) 'topK': topK!,
    if (topP != null) 'topP': topP!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3GeneratorPlaceholder
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1GeneratorPlaceholder
class $GeneratorPlaceholder {
  /// Unique ID used to map custom placeholder to parameters in fulfillment.
  core.String? id;

  /// Custom placeholder value in the prompt text.
  core.String? name;

  $GeneratorPlaceholder({this.id, this.name});

  $GeneratorPlaceholder.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : GenericPlatformDetails
/// - migrationcenter:v1alpha1 : GenericPlatformDetails
class $GenericPlatformDetails {
  /// Whether the machine is hyperthreaded.
  /// Possible string values are:
  /// - "HYPERTHREADING_STATUS_UNSPECIFIED" : Simultaneous Multithreading status
  /// unknown.
  /// - "HYPERTHREADING_STATUS_DISABLED" : Simultaneous Multithreading is
  /// disabled or unavailable.
  /// - "HYPERTHREADING_STATUS_ENABLED" : Simultaneous Multithreading is
  /// enabled.
  core.String? hyperthreading;

  /// Free text representation of the machine location.
  ///
  /// The format of this field should not be relied on. Different VMs in the
  /// same location may have different string values for this field.
  core.String? location;

  $GenericPlatformDetails({this.hyperthreading, this.location});

  $GenericPlatformDetails.fromJson(core.Map json_)
    : this(
        hyperthreading: json_['hyperthreading'] as core.String?,
        location: json_['location'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperthreading != null) 'hyperthreading': hyperthreading!,
    if (location != null) 'location': location!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GenieSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenieSource
class $GenieSource {
  /// The public base model URI.
  ///
  /// Required.
  core.String? baseModelUri;

  $GenieSource({this.baseModelUri});

  $GenieSource.fromJson(core.Map json_)
    : this(baseModelUri: json_['baseModelUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseModelUri != null) 'baseModelUri': baseModelUri!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GeoRegionAssignedTargetingOptionDetails
/// - displayvideo:v3 : GeoRegionAssignedTargetingOptionDetails
/// - displayvideo:v4 : GeoRegionAssignedTargetingOptionDetails
class $GeoRegionAssignedTargetingOptionDetails {
  /// The display name of the geographic region (e.g., "Ontario, Canada").
  ///
  /// Output only.
  core.String? displayName;

  /// The type of geographic region targeting.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GEO_REGION_TYPE_UNKNOWN" : The geographic region type is unknown.
  /// - "GEO_REGION_TYPE_OTHER" : The geographic region type is other.
  /// - "GEO_REGION_TYPE_COUNTRY" : The geographic region is a country.
  /// - "GEO_REGION_TYPE_REGION" : The geographic region type is region.
  /// - "GEO_REGION_TYPE_TERRITORY" : The geographic region is a territory.
  /// - "GEO_REGION_TYPE_PROVINCE" : The geographic region is a province.
  /// - "GEO_REGION_TYPE_STATE" : The geographic region is a state.
  /// - "GEO_REGION_TYPE_PREFECTURE" : The geographic region is a prefecture.
  /// - "GEO_REGION_TYPE_GOVERNORATE" : The geographic region is a governorate.
  /// - "GEO_REGION_TYPE_CANTON" : The geographic region is a canton.
  /// - "GEO_REGION_TYPE_UNION_TERRITORY" : The geographic region is a union
  /// territory.
  /// - "GEO_REGION_TYPE_AUTONOMOUS_COMMUNITY" : The geographic region is an
  /// autonomous community.
  /// - "GEO_REGION_TYPE_DMA_REGION" : The geographic region is a designated
  /// market area (DMA) region.
  /// - "GEO_REGION_TYPE_METRO" : The geographic region type is metro.
  /// - "GEO_REGION_TYPE_CONGRESSIONAL_DISTRICT" : The geographic region is a
  /// congressional district.
  /// - "GEO_REGION_TYPE_COUNTY" : The geographic region is a county.
  /// - "GEO_REGION_TYPE_MUNICIPALITY" : The geographic region is a
  /// municipality.
  /// - "GEO_REGION_TYPE_CITY" : The geographic region is a city.
  /// - "GEO_REGION_TYPE_POSTAL_CODE" : The geographic region targeting type is
  /// postal code.
  /// - "GEO_REGION_TYPE_DEPARTMENT" : The geographic region targeting type is
  /// department.
  /// - "GEO_REGION_TYPE_AIRPORT" : The geographic region is an airport.
  /// - "GEO_REGION_TYPE_TV_REGION" : The geographic region is a TV region.
  /// - "GEO_REGION_TYPE_OKRUG" : The geographic region is an okrug.
  /// - "GEO_REGION_TYPE_BOROUGH" : The geographic region is a borough.
  /// - "GEO_REGION_TYPE_CITY_REGION" : The geographic region is a city region.
  /// - "GEO_REGION_TYPE_ARRONDISSEMENT" : The geographic region is an
  /// arrondissement.
  /// - "GEO_REGION_TYPE_NEIGHBORHOOD" : The geographic region is a
  /// neighborhood.
  /// - "GEO_REGION_TYPE_UNIVERSITY" : The geographic region is a university.
  /// - "GEO_REGION_TYPE_DISTRICT" : The geographic region is a district.
  /// - "GEO_REGION_TYPE_NATIONAL_PARK" : The geographic region is a national
  /// park.
  /// - "GEO_REGION_TYPE_BARRIO" : The geographic region is a barrio.
  /// - "GEO_REGION_TYPE_SUB_WARD" : The geographic region is a sub ward.
  /// - "GEO_REGION_TYPE_MUNICIPALITY_DISTRICT" : The geographic region is a
  /// municipality district.
  /// - "GEO_REGION_TYPE_SUB_DISTRICT" : The geographic region is a sub
  /// district.
  /// - "GEO_REGION_TYPE_QUARTER" : The geographic region is a quarter.
  /// - "GEO_REGION_TYPE_DIVISION" : The geographic region is a division.
  /// - "GEO_REGION_TYPE_COMMUNE" : The geographic region is a commune.
  /// - "GEO_REGION_TYPE_COLLOQUIAL_AREA" : The geographic region is a
  /// colloquial area.
  core.String? geoRegionType;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_GEO_REGION`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $GeoRegionAssignedTargetingOptionDetails({
    this.displayName,
    this.geoRegionType,
    this.negative,
    this.targetingOptionId,
  });

  $GeoRegionAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        geoRegionType: json_['geoRegionType'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (geoRegionType != null) 'geoRegionType': geoRegionType!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GeoRegionSearchTerms
/// - displayvideo:v3 : GeoRegionSearchTerms
/// - displayvideo:v4 : GeoRegionSearchTerms
class $GeoRegionSearchTerms {
  /// The search query for the desired geo region.
  ///
  /// The query can be a prefix, e.g. "New Yor", "Seattle", "USA", etc.
  core.String? geoRegionQuery;

  $GeoRegionSearchTerms({this.geoRegionQuery});

  $GeoRegionSearchTerms.fromJson(core.Map json_)
    : this(geoRegionQuery: json_['geoRegionQuery'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (geoRegionQuery != null) 'geoRegionQuery': geoRegionQuery!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GeoRegionTargetingOptionDetails
/// - displayvideo:v3 : GeoRegionTargetingOptionDetails
/// - displayvideo:v4 : GeoRegionTargetingOptionDetails
class $GeoRegionTargetingOptionDetails {
  /// The display name of the geographic region (e.g., "Ontario, Canada").
  ///
  /// Output only.
  core.String? displayName;

  /// The type of geographic region targeting.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GEO_REGION_TYPE_UNKNOWN" : The geographic region type is unknown.
  /// - "GEO_REGION_TYPE_OTHER" : The geographic region type is other.
  /// - "GEO_REGION_TYPE_COUNTRY" : The geographic region is a country.
  /// - "GEO_REGION_TYPE_REGION" : The geographic region type is region.
  /// - "GEO_REGION_TYPE_TERRITORY" : The geographic region is a territory.
  /// - "GEO_REGION_TYPE_PROVINCE" : The geographic region is a province.
  /// - "GEO_REGION_TYPE_STATE" : The geographic region is a state.
  /// - "GEO_REGION_TYPE_PREFECTURE" : The geographic region is a prefecture.
  /// - "GEO_REGION_TYPE_GOVERNORATE" : The geographic region is a governorate.
  /// - "GEO_REGION_TYPE_CANTON" : The geographic region is a canton.
  /// - "GEO_REGION_TYPE_UNION_TERRITORY" : The geographic region is a union
  /// territory.
  /// - "GEO_REGION_TYPE_AUTONOMOUS_COMMUNITY" : The geographic region is an
  /// autonomous community.
  /// - "GEO_REGION_TYPE_DMA_REGION" : The geographic region is a designated
  /// market area (DMA) region.
  /// - "GEO_REGION_TYPE_METRO" : The geographic region type is metro.
  /// - "GEO_REGION_TYPE_CONGRESSIONAL_DISTRICT" : The geographic region is a
  /// congressional district.
  /// - "GEO_REGION_TYPE_COUNTY" : The geographic region is a county.
  /// - "GEO_REGION_TYPE_MUNICIPALITY" : The geographic region is a
  /// municipality.
  /// - "GEO_REGION_TYPE_CITY" : The geographic region is a city.
  /// - "GEO_REGION_TYPE_POSTAL_CODE" : The geographic region targeting type is
  /// postal code.
  /// - "GEO_REGION_TYPE_DEPARTMENT" : The geographic region targeting type is
  /// department.
  /// - "GEO_REGION_TYPE_AIRPORT" : The geographic region is an airport.
  /// - "GEO_REGION_TYPE_TV_REGION" : The geographic region is a TV region.
  /// - "GEO_REGION_TYPE_OKRUG" : The geographic region is an okrug.
  /// - "GEO_REGION_TYPE_BOROUGH" : The geographic region is a borough.
  /// - "GEO_REGION_TYPE_CITY_REGION" : The geographic region is a city region.
  /// - "GEO_REGION_TYPE_ARRONDISSEMENT" : The geographic region is an
  /// arrondissement.
  /// - "GEO_REGION_TYPE_NEIGHBORHOOD" : The geographic region is a
  /// neighborhood.
  /// - "GEO_REGION_TYPE_UNIVERSITY" : The geographic region is a university.
  /// - "GEO_REGION_TYPE_DISTRICT" : The geographic region is a district.
  /// - "GEO_REGION_TYPE_NATIONAL_PARK" : The geographic region is a national
  /// park.
  /// - "GEO_REGION_TYPE_BARRIO" : The geographic region is a barrio.
  /// - "GEO_REGION_TYPE_SUB_WARD" : The geographic region is a sub ward.
  /// - "GEO_REGION_TYPE_MUNICIPALITY_DISTRICT" : The geographic region is a
  /// municipality district.
  /// - "GEO_REGION_TYPE_SUB_DISTRICT" : The geographic region is a sub
  /// district.
  /// - "GEO_REGION_TYPE_QUARTER" : The geographic region is a quarter.
  /// - "GEO_REGION_TYPE_DIVISION" : The geographic region is a division.
  /// - "GEO_REGION_TYPE_COMMUNE" : The geographic region is a commune.
  /// - "GEO_REGION_TYPE_COLLOQUIAL_AREA" : The geographic region is a
  /// colloquial area.
  core.String? geoRegionType;

  $GeoRegionTargetingOptionDetails({this.displayName, this.geoRegionType});

  $GeoRegionTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        geoRegionType: json_['geoRegionType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (geoRegionType != null) 'geoRegionType': geoRegionType!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2GetDefaultBranchResponse
/// - retail:v2alpha : GoogleCloudRetailV2alphaGetDefaultBranchResponse
/// - retail:v2beta : GoogleCloudRetailV2betaGetDefaultBranchResponse
class $GetDefaultBranchResponse {
  /// Full resource name of the branch id currently set as default branch.
  core.String? branch;

  /// This corresponds to SetDefaultBranchRequest.note field, when this branch
  /// was set as default.
  core.String? note;

  /// The time when this branch is set to default.
  core.String? setTime;

  $GetDefaultBranchResponse({this.branch, this.note, this.setTime});

  $GetDefaultBranchResponse.fromJson(core.Map json_)
    : this(
        branch: json_['branch'] as core.String?,
        note: json_['note'] as core.String?,
        setTime: json_['setTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (branch != null) 'branch': branch!,
    if (note != null) 'note': note!,
    if (setTime != null) 'setTime': setTime!,
  };
}

/// Used by:
///
/// - tpu:v2 : GetGuestAttributesRequest
/// - tpu:v2alpha1 : GetGuestAttributesRequest
class $GetGuestAttributesRequest {
  /// The guest attributes path to be queried.
  core.String? queryPath;

  /// The 0-based worker ID.
  ///
  /// If it is empty, all workers' GuestAttributes will be returned.
  core.List<core.String>? workerIds;

  $GetGuestAttributesRequest({this.queryPath, this.workerIds});

  $GetGuestAttributesRequest.fromJson(core.Map json_)
    : this(
        queryPath: json_['queryPath'] as core.String?,
        workerIds:
            (json_['workerIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryPath != null) 'queryPath': queryPath!,
    if (workerIds != null) 'workerIds': workerIds!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : GetPolicyOptions
/// - aiplatform:v1beta1 : GoogleIamV1GetPolicyOptions
/// - analyticshub:v1 : GetPolicyOptions
/// - analyticshub:v1beta1 : GetPolicyOptions
/// - bigquery:v2 : GetPolicyOptions
/// - bigqueryconnection:v1 : GetPolicyOptions
/// - bigqueryconnection:v1beta1 : GetPolicyOptions
/// - bigquerydatapolicy:v1 : GetPolicyOptions
/// - bigtableadmin:v2 : GetPolicyOptions
/// - cloudresourcemanager:v1 : GetPolicyOptions
/// - cloudresourcemanager:v1beta1 : GetPolicyOptions
/// - cloudresourcemanager:v2 : GetPolicyOptions
/// - cloudresourcemanager:v2beta1 : GetPolicyOptions
/// - cloudresourcemanager:v3 : GetPolicyOptions
/// - cloudtasks:v2 : GetPolicyOptions
/// - cloudtasks:v2beta2 : GetPolicyOptions
/// - cloudtasks:v2beta3 : GetPolicyOptions
/// - containeranalysis:v1 : GetPolicyOptions
/// - containeranalysis:v1alpha1 : GetPolicyOptions
/// - containeranalysis:v1beta1 : GetPolicyOptions
/// - datacatalog:v1 : GetPolicyOptions
/// - datacatalog:v1beta1 : GetPolicyOptions
/// - dns:v1 : GoogleIamV1GetPolicyOptions
/// - dns:v1beta2 : GoogleIamV1GetPolicyOptions
/// - iam:v1 : GetPolicyOptions
/// - iap:v1 : GetPolicyOptions
/// - iap:v1beta1 : GetPolicyOptions
/// - identitytoolkit:v2 : GoogleIamV1GetPolicyOptions
/// - securitycenter:v1 : GetPolicyOptions
/// - securitycenter:v1beta1 : GetPolicyOptions
/// - servicedirectory:v1 : GetPolicyOptions
/// - servicedirectory:v1beta1 : GetPolicyOptions
/// - servicemanagement:v1 : GetPolicyOptions
/// - spanner:v1 : GetPolicyOptions
class $GetPolicyOptions00 {
  /// The maximum policy version that will be used to format the policy.
  ///
  /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
  /// rejected. Requests for policies with any conditional role bindings must
  /// specify version 3. Policies with no conditional role bindings may specify
  /// any valid value or leave the field unset. The policy in the response might
  /// use the policy version that you specified, or it might use a lower policy
  /// version. For example, if you specify version 3, but the policy has no
  /// conditional role bindings, the response uses version 1. To learn which
  /// resources support conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// Optional.
  core.int? requestedPolicyVersion;

  $GetPolicyOptions00({this.requestedPolicyVersion});

  $GetPolicyOptions00.fromJson(core.Map json_)
    : this(
        requestedPolicyVersion: json_['requestedPolicyVersion'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestedPolicyVersion != null)
      'requestedPolicyVersion': requestedPolicyVersion!,
  };
}

/// Used by:
///
/// - dataproc:v1 : GetPolicyOptions
/// - logging:v2 : GetPolicyOptions
class $GetPolicyOptions01 {
  /// The maximum policy version that will be used to format the policy.Valid
  /// values are 0, 1, and 3.
  ///
  /// Requests specifying an invalid value will be rejected.Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset.The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1.To learn which resources support
  /// conditions in their IAM policies, see the IAM documentation
  /// (https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// Optional.
  core.int? requestedPolicyVersion;

  $GetPolicyOptions01({this.requestedPolicyVersion});

  $GetPolicyOptions01.fromJson(core.Map json_)
    : this(
        requestedPolicyVersion: json_['requestedPolicyVersion'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestedPolicyVersion != null)
      'requestedPolicyVersion': requestedPolicyVersion!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : GitSourceContext
/// - containeranalysis:v1beta1 : GitSourceContext
/// - ondemandscanning:v1 : GitSourceContext
/// - ondemandscanning:v1beta1 : GitSourceContext
class $GitSourceContext {
  /// Git commit hash.
  core.String? revisionId;

  /// Git repository URL.
  core.String? url;

  $GitSourceContext({this.revisionId, this.url});

  $GitSourceContext.fromJson(core.Map json_)
    : this(
        revisionId: json_['revisionId'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (revisionId != null) 'revisionId': revisionId!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - container:v1 : GkeAutoUpgradeConfig
/// - container:v1beta1 : GkeAutoUpgradeConfig
class $GkeAutoUpgradeConfig {
  /// PatchMode specifies how auto upgrade patch builds should be selected.
  /// Possible string values are:
  /// - "PATCH_MODE_UNSPECIFIED" : PATCH_MODE_UNSPECIFIED defaults to using the
  /// upgrade target from the channel's patch upgrade targets as the upgrade
  /// target for the version.
  /// - "ACCELERATED" : ACCELERATED denotes that the latest patch build in the
  /// channel should be used as the upgrade target for the version.
  core.String? patchMode;

  $GkeAutoUpgradeConfig({this.patchMode});

  $GkeAutoUpgradeConfig.fromJson(core.Map json_)
    : this(patchMode: json_['patchMode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (patchMode != null) 'patchMode': patchMode!,
  };
}

/// Used by:
///
/// - container:v1 : GkeBackupAgentConfig
/// - container:v1beta1 : GkeBackupAgentConfig
class $GkeBackupAgentConfig {
  /// Whether the Backup for GKE agent is enabled for this cluster.
  core.bool? enabled;

  $GkeBackupAgentConfig({this.enabled});

  $GkeBackupAgentConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - gkehub:v1 : GkeCluster
/// - gkehub:v1alpha : GkeCluster
/// - gkehub:v1beta : GkeCluster
class $GkeCluster {
  /// If cluster_missing is set then it denotes that the GKE cluster no longer
  /// exists in the GKE Control Plane.
  ///
  /// Output only.
  core.bool? clusterMissing;

  /// Self-link of the Google Cloud resource for the GKE cluster.
  ///
  /// For example:
  /// //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
  /// Zonal clusters are also supported.
  ///
  /// Immutable.
  core.String? resourceLink;

  $GkeCluster({this.clusterMissing, this.resourceLink});

  $GkeCluster.fromJson(core.Map json_)
    : this(
        clusterMissing: json_['clusterMissing'] as core.bool?,
        resourceLink: json_['resourceLink'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterMissing != null) 'clusterMissing': clusterMissing!,
    if (resourceLink != null) 'resourceLink': resourceLink!,
  };
}

/// Used by:
///
/// - compute:alpha : GlobalAddressesMoveRequest
/// - compute:beta : GlobalAddressesMoveRequest
/// - compute:v1 : GlobalAddressesMoveRequest
class $GlobalAddressesMoveRequest {
  /// An optional destination address description if intended to be different
  /// from the source.
  core.String? description;

  /// The URL of the destination address to move to.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a address: -
  /// https://www.googleapis.com/compute/v1/projects/project
  /// /global/addresses/address - projects/project/global/addresses/address Note
  /// that destination project must be different from the source project. So
  /// /global/addresses/address is not valid partial url.
  core.String? destinationAddress;

  $GlobalAddressesMoveRequest({this.description, this.destinationAddress});

  $GlobalAddressesMoveRequest.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        destinationAddress: json_['destinationAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (destinationAddress != null) 'destinationAddress': destinationAddress!,
  };
}

/// Used by:
///
/// - compute:alpha : GlobalSetLabelsRequest
/// - compute:beta : GlobalSetLabelsRequest
/// - compute:v1 : GlobalSetLabelsRequest
class $GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash when updating or changing labels, otherwise
  /// the request will fail with error 412 conditionNotMet. Make a get() request
  /// to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// A list of labels to apply for this resource.
  ///
  /// Each label must comply with the requirements for labels. For example,
  /// "webserver-frontend": "images". A label value can also be empty (e.g.
  /// "my-label": "").
  core.Map<core.String, core.String>? labels;

  $GlobalSetLabelsRequest({this.labelFingerprint, this.labels});

  $GlobalSetLabelsRequest.fromJson(core.Map json_)
    : this(
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - translate:v3 : GlossaryConfig
/// - translate:v3 : TranslateTextGlossaryConfig
class $GlossaryConfig {
  /// If set to true, the glossary will be used for contextual translation.
  ///
  /// Optional.
  core.bool? contextualTranslationEnabled;

  /// The `glossary` to be applied for this translation.
  ///
  /// The format depends on the glossary: - User-provided custom glossary:
  /// `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
  ///
  /// Required.
  core.String? glossary;

  /// Indicates match is case insensitive.
  ///
  /// The default value is `false` if missing.
  ///
  /// Optional.
  core.bool? ignoreCase;

  $GlossaryConfig({
    this.contextualTranslationEnabled,
    this.glossary,
    this.ignoreCase,
  });

  $GlossaryConfig.fromJson(core.Map json_)
    : this(
        contextualTranslationEnabled:
            json_['contextualTranslationEnabled'] as core.bool?,
        glossary: json_['glossary'] as core.String?,
        ignoreCase: json_['ignoreCase'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contextualTranslationEnabled != null)
      'contextualTranslationEnabled': contextualTranslationEnabled!,
    if (glossary != null) 'glossary': glossary!,
    if (ignoreCase != null) 'ignoreCase': ignoreCase!,
  };
}

/// Used by:
///
/// - domains:v1 : GlueRecord
/// - domains:v1alpha2 : GlueRecord
/// - domains:v1beta1 : GlueRecord
class $GlueRecord {
  /// Domain name of the host in Punycode format.
  ///
  /// Required.
  core.String? hostName;

  /// List of IPv4 addresses corresponding to this host in the standard decimal
  /// format (e.g. `198.51.100.1`).
  ///
  /// At least one of `ipv4_address` and `ipv6_address` must be set.
  core.List<core.String>? ipv4Addresses;

  /// List of IPv6 addresses corresponding to this host in the standard
  /// hexadecimal format (e.g. `2001:db8::`).
  ///
  /// At least one of `ipv4_address` and `ipv6_address` must be set.
  core.List<core.String>? ipv6Addresses;

  $GlueRecord({this.hostName, this.ipv4Addresses, this.ipv6Addresses});

  $GlueRecord.fromJson(core.Map json_)
    : this(
        hostName: json_['hostName'] as core.String?,
        ipv4Addresses:
            (json_['ipv4Addresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ipv6Addresses:
            (json_['ipv6Addresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostName != null) 'hostName': hostName!,
    if (ipv4Addresses != null) 'ipv4Addresses': ipv4Addresses!,
    if (ipv6Addresses != null) 'ipv6Addresses': ipv6Addresses!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceRepositoryResourceGooRepository
/// - osconfig:v1alpha : OSPolicyResourceRepositoryResourceGooRepository
/// - osconfig:v1beta : GooRepository
/// - osconfig:v2 : OSPolicyResourceRepositoryResourceGooRepository
/// - osconfig:v2beta : OSPolicyResourceRepositoryResourceGooRepository
class $GooRepository {
  /// The name of the repository.
  ///
  /// Required.
  core.String? name;

  /// The url of the repository.
  ///
  /// Required.
  core.String? url;

  $GooRepository({this.name, this.url});

  $GooRepository.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : GoogleAccount
/// - websecurityscanner:v1beta : GoogleAccount
class $GoogleAccount {
  /// Input only.
  ///
  /// The password of the Google account. The credential is stored encrypted and
  /// not returned in any response nor included in audit logs.
  ///
  /// Required.
  core.String? password;

  /// The user name of the Google account.
  ///
  /// Required.
  core.String? username;

  $GoogleAccount({this.password, this.username});

  $GoogleAccount.fromJson(core.Map json_)
    : this(
        password: json_['password'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaGoogleAdsLink
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaGoogleAdsLink
class $GoogleAdsLink {
  /// Enable personalized advertising features with this integration.
  ///
  /// Automatically publish my Google Analytics audience lists and Google
  /// Analytics remarketing events/parameters to the linked Google Ads account.
  /// If this field is not set on create/update, it will be defaulted to true.
  core.bool? adsPersonalizationEnabled;

  /// If true, this link is for a Google Ads manager account.
  ///
  /// Output only.
  core.bool? canManageClients;

  /// Time when this link was originally created.
  ///
  /// Output only.
  core.String? createTime;

  /// Email address of the user that created the link.
  ///
  /// An empty string will be returned if the email address can't be retrieved.
  ///
  /// Output only.
  core.String? creatorEmailAddress;

  /// Google Ads customer ID.
  ///
  /// Immutable.
  core.String? customerId;

  /// Format: properties/{propertyId}/googleAdsLinks/{googleAdsLinkId} Note:
  /// googleAdsLinkId is not the Google Ads customer ID.
  ///
  /// Output only.
  core.String? name;

  /// Time when this link was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $GoogleAdsLink({
    this.adsPersonalizationEnabled,
    this.canManageClients,
    this.createTime,
    this.creatorEmailAddress,
    this.customerId,
    this.name,
    this.updateTime,
  });

  $GoogleAdsLink.fromJson(core.Map json_)
    : this(
        adsPersonalizationEnabled:
            json_['adsPersonalizationEnabled'] as core.bool?,
        canManageClients: json_['canManageClients'] as core.bool?,
        createTime: json_['createTime'] as core.String?,
        creatorEmailAddress: json_['creatorEmailAddress'] as core.String?,
        customerId: json_['customerId'] as core.String?,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adsPersonalizationEnabled != null)
      'adsPersonalizationEnabled': adsPersonalizationEnabled!,
    if (canManageClients != null) 'canManageClients': canManageClients!,
    if (createTime != null) 'createTime': createTime!,
    if (creatorEmailAddress != null)
      'creatorEmailAddress': creatorEmailAddress!,
    if (customerId != null) 'customerId': customerId!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiMetric
/// - discoveryengine:v1beta : GoogleApiMetric
class $GoogleApiMetric {
  /// The set of label values that uniquely identify this metric.
  ///
  /// All labels listed in the `MetricDescriptor` must be assigned values.
  core.Map<core.String, core.String>? labels;

  /// An existing metric type, see google.api.MetricDescriptor.
  ///
  /// For example, `custom.googleapis.com/invoice/paid/amount`.
  core.String? type;

  $GoogleApiMetric({this.labels, this.type});

  $GoogleApiMetric.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiMonitoredResource
/// - discoveryengine:v1beta : GoogleApiMonitoredResource
class $GoogleApiMonitoredResource {
  /// Values for all of the labels listed in the associated monitored resource
  /// descriptor.
  ///
  /// For example, Compute Engine VM instances use the labels `"project_id"`,
  /// `"instance_id"`, and `"zone"`.
  ///
  /// Required.
  core.Map<core.String, core.String>? labels;

  /// The monitored resource type.
  ///
  /// This field must match the `type` field of a MonitoredResourceDescriptor
  /// object. For example, the type of a Compute Engine VM instance is
  /// `gce_instance`. Some descriptors include the service name in the type; for
  /// example, the type of a Datastream stream is
  /// `datastream.googleapis.com/Stream`.
  ///
  /// Required.
  core.String? type;

  $GoogleApiMonitoredResource({this.labels, this.type});

  $GoogleApiMonitoredResource.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiMonitoredResourceMetadata
/// - discoveryengine:v1beta : GoogleApiMonitoredResourceMetadata
class $GoogleApiMonitoredResourceMetadata {
  /// Values for predefined system metadata labels.
  ///
  /// System labels are a kind of metadata extracted by Google, including
  /// "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System
  /// label values can be only strings, Boolean values, or a list of strings.
  /// For example: { "name": "my-test-instance", "security_group": \["a", "b",
  /// "c"\], "spot_instance": false }
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? systemLabels;

  /// A map of user-defined metadata labels.
  ///
  /// Output only.
  core.Map<core.String, core.String>? userLabels;

  $GoogleApiMonitoredResourceMetadata({this.systemLabels, this.userLabels});

  $GoogleApiMonitoredResourceMetadata.fromJson(core.Map json_)
    : this(
        systemLabels:
            json_.containsKey('systemLabels')
                ? json_['systemLabels'] as core.Map<core.String, core.dynamic>
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (systemLabels != null) 'systemLabels': systemLabels!,
    if (userLabels != null) 'userLabels': userLabels!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GoogleAudience
/// - displayvideo:v3 : GoogleAudience
/// - displayvideo:v4 : GoogleAudience
class $GoogleAudience {
  /// The display name of the Google audience.
  ///
  /// .
  ///
  /// Output only.
  core.String? displayName;

  /// The unique ID of the Google audience.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? googleAudienceId;

  /// The type of Google audience.
  ///
  /// .
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GOOGLE_AUDIENCE_TYPE_UNSPECIFIED" : Default value when type is not
  /// specified or is unknown.
  /// - "GOOGLE_AUDIENCE_TYPE_AFFINITY" : Affinity type Google audience.
  /// - "GOOGLE_AUDIENCE_TYPE_IN_MARKET" : In-Market type Google audience.
  /// - "GOOGLE_AUDIENCE_TYPE_INSTALLED_APPS" : Installed-Apps type Google
  /// audience.
  /// - "GOOGLE_AUDIENCE_TYPE_NEW_MOBILE_DEVICES" : New-Mobile-Devices type
  /// Google audience.
  /// - "GOOGLE_AUDIENCE_TYPE_LIFE_EVENT" : Life-Event type Google audience.
  /// - "GOOGLE_AUDIENCE_TYPE_EXTENDED_DEMOGRAPHIC" : Extended-Demographic type
  /// Google audience.
  core.String? googleAudienceType;

  /// The resource name of the google audience.
  ///
  /// Output only.
  core.String? name;

  $GoogleAudience({
    this.displayName,
    this.googleAudienceId,
    this.googleAudienceType,
    this.name,
  });

  $GoogleAudience.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        googleAudienceId: json_['googleAudienceId'] as core.String?,
        googleAudienceType: json_['googleAudienceType'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (googleAudienceId != null) 'googleAudienceId': googleAudienceId!,
    if (googleAudienceType != null) 'googleAudienceType': googleAudienceType!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GoogleAudienceTargetingSetting
/// - displayvideo:v3 : GoogleAudienceTargetingSetting
/// - displayvideo:v4 : GoogleAudienceTargetingSetting
class $GoogleAudienceTargetingSetting {
  /// Google audience id of the Google audience targeting setting.
  ///
  /// This id is google_audience_id.
  ///
  /// Required.
  core.String? googleAudienceId;

  $GoogleAudienceTargetingSetting({this.googleAudienceId});

  $GoogleAudienceTargetingSetting.fromJson(core.Map json_)
    : this(googleAudienceId: json_['googleAudienceId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleAudienceId != null) 'googleAudienceId': googleAudienceId!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FunctionCall
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1FunctionCall
class $GoogleCloudAiplatformV1beta1FunctionCall {
  /// The function parameters and values in JSON object format.
  ///
  /// See \[FunctionDeclaration.parameters\] for parameter details.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? args;

  /// The unique id of the function call.
  ///
  /// If populated, the client to execute the `function_call` and return the
  /// response with the matching `id`.
  ///
  /// Optional.
  core.String? id;

  /// The name of the function to call.
  ///
  /// Matches \[FunctionDeclaration.name\].
  ///
  /// Required.
  core.String? name;

  $GoogleCloudAiplatformV1beta1FunctionCall({this.args, this.id, this.name});

  $GoogleCloudAiplatformV1beta1FunctionCall.fromJson(core.Map json_)
    : this(
        args:
            json_.containsKey('args')
                ? json_['args'] as core.Map<core.String, core.dynamic>
                : null,
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FunctionResponse
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1FunctionResponse
class $GoogleCloudAiplatformV1beta1FunctionResponse {
  /// The id of the function call this response is for.
  ///
  /// Populated by the client to match the corresponding function call `id`.
  ///
  /// Optional.
  core.String? id;

  /// The name of the function to call.
  ///
  /// Matches \[FunctionDeclaration.name\] and \[FunctionCall.name\].
  ///
  /// Required.
  core.String? name;

  /// The function response in JSON object format.
  ///
  /// Use "output" key to specify function output and "error" key to specify
  /// error details (if any). If "output" and "error" keys are not specified,
  /// then whole "response" is treated as function output.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  $GoogleCloudAiplatformV1beta1FunctionResponse({
    this.id,
    this.name,
    this.response,
  });

  $GoogleCloudAiplatformV1beta1FunctionResponse.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
        response:
            json_.containsKey('response')
                ? json_['response'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GenerationConfigModelConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GenerationConfigModelConfig
class $GoogleCloudAiplatformV1beta1GenerationConfigModelConfig {
  /// Feature selection preference.
  ///
  /// Required.
  /// Possible string values are:
  /// - "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED" : Unspecified feature
  /// selection preference.
  /// - "PRIORITIZE_QUALITY" : Prefer higher quality over lower cost.
  /// - "BALANCED" : Balanced feature selection preference.
  /// - "PRIORITIZE_COST" : Prefer lower cost over higher quality.
  core.String? featureSelectionPreference;

  $GoogleCloudAiplatformV1beta1GenerationConfigModelConfig({
    this.featureSelectionPreference,
  });

  $GoogleCloudAiplatformV1beta1GenerationConfigModelConfig.fromJson(
    core.Map json_,
  ) : this(
        featureSelectionPreference:
            json_['featureSelectionPreference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureSelectionPreference != null)
      'featureSelectionPreference': featureSelectionPreference!,
  };
}

/// Used by:
///
/// - orgpolicy:v2 : GoogleCloudOrgpolicyV2CustomConstraint
/// - policysimulator:v1 : GoogleCloudOrgpolicyV2CustomConstraint
/// - policysimulator:v1beta : GoogleCloudOrgpolicyV2CustomConstraint
class $GoogleCloudOrgpolicyV2CustomConstraint {
  /// Allow or deny type.
  /// Possible string values are:
  /// - "ACTION_TYPE_UNSPECIFIED" : This is only used for distinguishing unset
  /// values and should never be used. Results in an error.
  /// - "ALLOW" : Allowed action type.
  /// - "DENY" : Deny action type.
  core.String? actionType;

  /// A Common Expression Language (CEL) condition which is used in the
  /// evaluation of the constraint.
  ///
  /// For example: `resource.instanceName.matches("[production|test]_.*_(\d)+")`
  /// or, `resource.management.auto_upgrade == true` The max length of the
  /// condition is 1000 characters.
  core.String? condition;

  /// Detailed information about this custom policy constraint.
  ///
  /// The max length of the description is 2000 characters.
  core.String? description;

  /// One line display name for the UI.
  ///
  /// The max length of the display_name is 200 characters.
  core.String? displayName;

  /// All the operations being applied for this constraint.
  core.List<core.String>? methodTypes;

  /// Name of the constraint.
  ///
  /// This is unique within the organization. Format of the name should be *
  /// `organizations/{organization_id}/customConstraints/{custom_constraint_id}`
  /// Example: `organizations/123/customConstraints/custom.createOnlyE2TypeVms`
  /// The max length is 70 characters and the minimum length is 1. Note that the
  /// prefix `organizations/{organization_id}/customConstraints/` is not
  /// counted.
  ///
  /// Immutable.
  core.String? name;

  /// The resource instance type on which this policy applies.
  ///
  /// Format will be of the form : `/` Example: *
  /// `compute.googleapis.com/Instance`.
  ///
  /// Immutable.
  core.List<core.String>? resourceTypes;

  /// The last time this custom constraint was updated.
  ///
  /// This represents the last time that the `CreateCustomConstraint` or
  /// `UpdateCustomConstraint` methods were called.
  ///
  /// Output only.
  core.String? updateTime;

  $GoogleCloudOrgpolicyV2CustomConstraint({
    this.actionType,
    this.condition,
    this.description,
    this.displayName,
    this.methodTypes,
    this.name,
    this.resourceTypes,
    this.updateTime,
  });

  $GoogleCloudOrgpolicyV2CustomConstraint.fromJson(core.Map json_)
    : this(
        actionType: json_['actionType'] as core.String?,
        condition: json_['condition'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        methodTypes:
            (json_['methodTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        resourceTypes:
            (json_['resourceTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actionType != null) 'actionType': actionType!,
    if (condition != null) 'condition': condition!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (methodTypes != null) 'methodTypes': methodTypes!,
    if (name != null) 'name': name!,
    if (resourceTypes != null) 'resourceTypes': resourceTypes!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GoogleDriveSourceResourceId
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GoogleDriveSourceResourceId
class $GoogleDriveSourceResourceId {
  /// The ID of the Google Drive resource.
  ///
  /// Required.
  core.String? resourceId;

  /// The type of the Google Drive resource.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESOURCE_TYPE_UNSPECIFIED" : Unspecified resource type.
  /// - "RESOURCE_TYPE_FILE" : File resource type.
  /// - "RESOURCE_TYPE_FOLDER" : Folder resource type.
  core.String? resourceType;

  $GoogleDriveSourceResourceId({this.resourceId, this.resourceType});

  $GoogleDriveSourceResourceId.fromJson(core.Map json_)
    : this(
        resourceId: json_['resourceId'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceId != null) 'resourceId': resourceId!,
    if (resourceType != null) 'resourceType': resourceType!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : GoogleServiceInfo
/// - networkmanagement:v1beta1 : GoogleServiceInfo
class $GoogleServiceInfo {
  /// Recognized type of a Google Service.
  /// Possible string values are:
  /// - "GOOGLE_SERVICE_TYPE_UNSPECIFIED" : Unspecified Google Service.
  /// - "IAP" : Identity aware proxy.
  /// https://cloud.google.com/iap/docs/using-tcp-forwarding
  /// - "GFE_PROXY_OR_HEALTH_CHECK_PROBER" : One of two services sharing IP
  /// ranges: * Load Balancer proxy * Centralized Health Check prober
  /// https://cloud.google.com/load-balancing/docs/firewall-rules
  /// - "CLOUD_DNS" : Connectivity from Cloud DNS to forwarding targets or
  /// alternate name servers that use private routing.
  /// https://cloud.google.com/dns/docs/zones/forwarding-zones#firewall-rules
  /// https://cloud.google.com/dns/docs/policies#firewall-rules
  /// - "GOOGLE_API" : private.googleapis.com and restricted.googleapis.com
  /// - "GOOGLE_API_PSC" : Google API via Private Service Connect.
  /// https://cloud.google.com/vpc/docs/configure-private-service-connect-apis
  /// - "GOOGLE_API_VPC_SC" : Google API via VPC Service Controls.
  /// https://cloud.google.com/vpc/docs/configure-private-service-connect-apis
  /// - "SERVERLESS_VPC_ACCESS" : Google API via Serverless VPC Access.
  /// https://cloud.google.com/vpc/docs/serverless-vpc-access
  core.String? googleServiceType;

  /// Source IP address.
  core.String? sourceIp;

  $GoogleServiceInfo({this.googleServiceType, this.sourceIp});

  $GoogleServiceInfo.fromJson(core.Map json_)
    : this(
        googleServiceType: json_['googleServiceType'] as core.String?,
        sourceIp: json_['sourceIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleServiceType != null) 'googleServiceType': googleServiceType!,
    if (sourceIp != null) 'sourceIp': sourceIp!,
  };
}

/// Used by:
///
/// - paymentsresellersubscription:v1 : GoogleTypeLocalizedText
/// - places:v1 : GoogleTypeLocalizedText
class $GoogleTypeLocalizedText {
  /// The text's BCP-47 language code, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  core.String? languageCode;

  /// Localized string in the language corresponding to language_code below.
  core.String? text;

  $GoogleTypeLocalizedText({this.languageCode, this.text});

  $GoogleTypeLocalizedText.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness
/// - ondemandscanning:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness
/// - ondemandscanning:v1beta1 : GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness
class $GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness {
  core.bool? environment;
  core.bool? materials;
  core.bool? parameters;

  $GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness({
    this.environment,
    this.materials,
    this.parameters,
  });

  $GrafeasV1SlsaProvenanceZeroTwoSlsaCompleteness.fromJson(core.Map json_)
    : this(
        environment: json_['environment'] as core.bool?,
        materials: json_['materials'] as core.bool?,
        parameters: json_['parameters'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
    if (materials != null) 'materials': materials!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource
/// - ondemandscanning:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource
/// - ondemandscanning:v1beta1 : GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource
class $GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource {
  core.Map<core.String, core.String>? digest;
  core.String? entryPoint;
  core.String? uri;

  $GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource({
    this.digest,
    this.entryPoint,
    this.uri,
  });

  $GrafeasV1SlsaProvenanceZeroTwoSlsaConfigSource.fromJson(core.Map json_)
    : this(
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        entryPoint: json_['entryPoint'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (entryPoint != null) 'entryPoint': entryPoint!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : GraphqlErrorExtensions
/// - firebasedataconnect:v1beta : GraphqlErrorExtensions
class $GraphqlErrorExtensions {
  /// Maps to canonical gRPC codes.
  ///
  /// If not specified, it represents `Code.INTERNAL`.
  /// Possible string values are:
  /// - "OK" : Not an error; returned on success. HTTP Mapping: 200 OK
  /// - "CANCELLED" : The operation was cancelled, typically by the caller. HTTP
  /// Mapping: 499 Client Closed Request
  /// - "UNKNOWN" : Unknown error. For example, this error may be returned when
  /// a `Status` value received from another address space belongs to an error
  /// space that is not known in this address space. Also errors raised by APIs
  /// that do not return enough error information may be converted to this
  /// error. HTTP Mapping: 500 Internal Server Error
  /// - "INVALID_ARGUMENT" : The client specified an invalid argument. Note that
  /// this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates
  /// arguments that are problematic regardless of the state of the system
  /// (e.g., a malformed file name). HTTP Mapping: 400 Bad Request
  /// - "DEADLINE_EXCEEDED" : The deadline expired before the operation could
  /// complete. For operations that change the state of the system, this error
  /// may be returned even if the operation has completed successfully. For
  /// example, a successful response from a server could have been delayed long
  /// enough for the deadline to expire. HTTP Mapping: 504 Gateway Timeout
  /// - "NOT_FOUND" : Some requested entity (e.g., file or directory) was not
  /// found. Note to server developers: if a request is denied for an entire
  /// class of users, such as gradual feature rollout or undocumented allowlist,
  /// `NOT_FOUND` may be used. If a request is denied for some users within a
  /// class of users, such as user-based access control, `PERMISSION_DENIED`
  /// must be used. HTTP Mapping: 404 Not Found
  /// - "ALREADY_EXISTS" : The entity that a client attempted to create (e.g.,
  /// file or directory) already exists. HTTP Mapping: 409 Conflict
  /// - "PERMISSION_DENIED" : The caller does not have permission to execute the
  /// specified operation. `PERMISSION_DENIED` must not be used for rejections
  /// caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for
  /// those errors). `PERMISSION_DENIED` must not be used if the caller can not
  /// be identified (use `UNAUTHENTICATED` instead for those errors). This error
  /// code does not imply the request is valid or the requested entity exists or
  /// satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
  /// - "UNAUTHENTICATED" : The request does not have valid authentication
  /// credentials for the operation. HTTP Mapping: 401 Unauthorized
  /// - "RESOURCE_EXHAUSTED" : Some resource has been exhausted, perhaps a
  /// per-user quota, or perhaps the entire file system is out of space. HTTP
  /// Mapping: 429 Too Many Requests
  /// - "FAILED_PRECONDITION" : The operation was rejected because the system is
  /// not in a state required for the operation's execution. For example, the
  /// directory to be deleted is non-empty, an rmdir operation is applied to a
  /// non-directory, etc. Service implementors can use the following guidelines
  /// to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a)
  /// Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use
  /// `ABORTED` if the client should retry at a higher level. For example, when
  /// a client-specified test-and-set fails, indicating the client should
  /// restart a read-modify-write sequence. (c) Use `FAILED_PRECONDITION` if the
  /// client should not retry until the system state has been explicitly fixed.
  /// For example, if an "rmdir" fails because the directory is non-empty,
  /// `FAILED_PRECONDITION` should be returned since the client should not retry
  /// unless the files are deleted from the directory. HTTP Mapping: 400 Bad
  /// Request
  /// - "ABORTED" : The operation was aborted, typically due to a concurrency
  /// issue such as a sequencer check failure or transaction abort. See the
  /// guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`,
  /// and `UNAVAILABLE`. HTTP Mapping: 409 Conflict
  /// - "OUT_OF_RANGE" : The operation was attempted past the valid range. E.g.,
  /// seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error
  /// indicates a problem that may be fixed if the system state changes. For
  /// example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to
  /// read at an offset that is not in the range \[0,2^32-1\], but it will
  /// generate `OUT_OF_RANGE` if asked to read from an offset past the current
  /// file size. There is a fair bit of overlap between `FAILED_PRECONDITION`
  /// and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific
  /// error) when it applies so that callers who are iterating through a space
  /// can easily look for an `OUT_OF_RANGE` error to detect when they are done.
  /// HTTP Mapping: 400 Bad Request
  /// - "UNIMPLEMENTED" : The operation is not implemented or is not
  /// supported/enabled in this service. HTTP Mapping: 501 Not Implemented
  /// - "INTERNAL" : Internal errors. This means that some invariants expected
  /// by the underlying system have been broken. This error code is reserved for
  /// serious errors. HTTP Mapping: 500 Internal Server Error
  /// - "UNAVAILABLE" : The service is currently unavailable. This is most
  /// likely a transient condition, which can be corrected by retrying with a
  /// backoff. Note that it is not always safe to retry non-idempotent
  /// operations. See the guidelines above for deciding between
  /// `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503
  /// Service Unavailable
  /// - "DATA_LOSS" : Unrecoverable data loss or corruption. HTTP Mapping: 500
  /// Internal Server Error
  core.String? code;

  /// More detailed error message to assist debugging.
  ///
  /// It contains application business logic that are inappropriate to leak
  /// publicly. In the emulator, Data Connect API always includes it to assist
  /// local development and debugging. In the backend, ConnectorService always
  /// hides it. GraphqlService without impersonation always include it.
  /// GraphqlService with impersonation includes it only if explicitly opted-in
  /// with `include_debug_details` in `GraphqlRequestExtensions`.
  core.String? debugDetails;

  /// The source file name where the error occurred.
  ///
  /// Included only for `UpdateSchema` and `UpdateConnector`, it corresponds to
  /// `File.path` of the provided `Source`.
  core.String? file;

  /// Distinguish which schema or connector the error originates from.
  ///
  /// It should be set on errors from control plane APIs (e.g. `UpdateSchema`,
  /// `UpdateConnector`).
  core.String? resource;

  $GraphqlErrorExtensions({
    this.code,
    this.debugDetails,
    this.file,
    this.resource,
  });

  $GraphqlErrorExtensions.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        debugDetails: json_['debugDetails'] as core.String?,
        file: json_['file'] as core.String?,
        resource: json_['resource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (debugDetails != null) 'debugDetails': debugDetails!,
    if (file != null) 'file': file!,
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GroundednessInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GroundednessInstance
class $GroundednessInstance {
  /// Background information provided in context used to compare against the
  /// prediction.
  ///
  /// Required.
  core.String? context;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  $GroundednessInstance({this.context, this.prediction});

  $GroundednessInstance.fromJson(core.Map json_)
    : this(
        context: json_['context'] as core.String?,
        prediction: json_['prediction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (prediction != null) 'prediction': prediction!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GroundednessResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GroundednessResult
class $GroundednessResult {
  /// Confidence for groundedness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for groundedness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Groundedness score.
  ///
  /// Output only.
  core.double? score;

  $GroundednessResult({this.confidence, this.explanation, this.score});

  $GroundednessResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1GroundingChunkWeb
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GroundingChunkWeb
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1GroundingChunkWeb
class $GroundingChunkWeb {
  /// Domain of the (original) URI.
  core.String? domain;

  /// Title of the chunk.
  core.String? title;

  /// URI reference of the chunk.
  core.String? uri;

  $GroundingChunkWeb({this.domain, this.title, this.uri});

  $GroundingChunkWeb.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1GroundingFact
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaGroundingFact
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaGroundingFact
class $GroundingFact {
  /// Attributes associated with the fact.
  ///
  /// Common attributes include `source` (indicating where the fact was sourced
  /// from), `author` (indicating the author of the fact), and so on.
  core.Map<core.String, core.String>? attributes;

  /// Text content of the fact.
  ///
  /// Can be at most 10K characters long.
  core.String? factText;

  $GroundingFact({this.attributes, this.factText});

  $GroundingFact.fromJson(core.Map json_)
    : this(
        attributes: (json_['attributes']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        factText: json_['factText'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributes != null) 'attributes': attributes!,
    if (factText != null) 'factText': factText!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : Group
/// - migrationcenter:v1alpha1 : Group
class $Group00 {
  /// The timestamp when the group was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the group.
  ///
  /// Optional.
  core.String? description;

  /// User-friendly display name.
  ///
  /// Optional.
  core.String? displayName;

  /// Labels as key value pairs.
  core.Map<core.String, core.String>? labels;

  /// The name of the group.
  ///
  /// Output only.
  core.String? name;

  /// The timestamp when the group was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Group00({
    this.createTime,
    this.description,
    this.displayName,
    this.labels,
    this.name,
    this.updateTime,
  });

  $Group00.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : Group
/// - vmmigration:v1alpha1 : Group
class $Group01 {
  /// The create time timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// User-provided description of the group.
  core.String? description;

  /// Display name is a user defined name for this group which can be updated.
  core.String? displayName;

  /// The target type of this group.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "MIGRATION_TARGET_TYPE_UNSPECIFIED" : Group type is not specified. This
  /// defaults to Compute Engine targets.
  /// - "MIGRATION_TARGET_TYPE_GCE" : All MigratingVMs in the group must have
  /// Compute Engine targets.
  /// - "MIGRATION_TARGET_TYPE_DISKS" : All MigratingVMs in the group must have
  /// Compute Engine Disks targets.
  core.String? migrationTargetType;

  /// The Group name.
  ///
  /// Output only.
  core.String? name;

  /// The update time timestamp.
  ///
  /// Output only.
  core.String? updateTime;

  $Group01({
    this.createTime,
    this.description,
    this.displayName,
    this.migrationTargetType,
    this.name,
    this.updateTime,
  });

  $Group01.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        migrationTargetType: json_['migrationTargetType'] as core.String?,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (migrationTargetType != null)
      'migrationTargetType': migrationTargetType!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - securitycenter:v1 : GroupResult
/// - securitycenter:v1beta1 : GroupResult
class $GroupResult {
  /// Total count of resources for the given properties.
  core.String? count;

  /// Properties matching the groupBy fields in the request.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? properties;

  $GroupResult({this.count, this.properties});

  $GroupResult.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        properties:
            json_.containsKey('properties')
                ? json_['properties'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (properties != null) 'properties': properties!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : GoogleCloudNetworksecurityV1GrpcEndpoint
/// - networksecurity:v1beta1 : GoogleCloudNetworksecurityV1beta1GrpcEndpoint
class $GrpcEndpoint {
  /// The target URI of the gRPC endpoint.
  ///
  /// Only UDS path is supported, and should start with "unix:".
  ///
  /// Required.
  core.String? targetUri;

  $GrpcEndpoint({this.targetUri});

  $GrpcEndpoint.fromJson(core.Map json_)
    : this(targetUri: json_['targetUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetUri != null) 'targetUri': targetUri!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteDestination
/// - networkservices:v1beta1 : GrpcRouteDestination
class $GrpcRouteDestination {
  /// The URL of a destination service to which to route traffic.
  ///
  /// Must refer to either a BackendService or ServiceDirectoryService.
  ///
  /// Required.
  core.String? serviceName;

  /// Specifies the proportion of requests forwarded to the backend referenced
  /// by the serviceName field.
  ///
  /// This is computed as: - weight/Sum(weights in this destination list). For
  /// non-zero values, there may be some epsilon from the exact proportion
  /// defined here depending on the precision an implementation supports. If
  /// only one serviceName is specified and it has a weight greater than 0, 100%
  /// of the traffic is forwarded to that backend. If weights are specified for
  /// any one service name, they need to be specified for all of them. If
  /// weights are unspecified for all services, then, traffic is distributed in
  /// equal proportions to all of them.
  ///
  /// Optional.
  core.int? weight;

  $GrpcRouteDestination({this.serviceName, this.weight});

  $GrpcRouteDestination.fromJson(core.Map json_)
    : this(
        serviceName: json_['serviceName'] as core.String?,
        weight: json_['weight'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceName != null) 'serviceName': serviceName!,
    if (weight != null) 'weight': weight!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteHeaderMatch
/// - networkservices:v1beta1 : GrpcRouteHeaderMatch
class $GrpcRouteHeaderMatch {
  /// The key of the header.
  ///
  /// Required.
  core.String? key;

  /// Specifies how to match against the value of the header.
  ///
  /// If not specified, a default value of EXACT is used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified.
  /// - "EXACT" : Will only match the exact value provided.
  /// - "REGULAR_EXPRESSION" : Will match paths conforming to the prefix
  /// specified by value. RE2 syntax is supported.
  core.String? type;

  /// The value of the header.
  ///
  /// Required.
  core.String? value;

  $GrpcRouteHeaderMatch({this.key, this.type, this.value});

  $GrpcRouteHeaderMatch.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteMethodMatch
/// - networkservices:v1beta1 : GrpcRouteMethodMatch
class $GrpcRouteMethodMatch {
  /// Specifies that matches are case sensitive.
  ///
  /// The default value is true. case_sensitive must not be used with a type of
  /// REGULAR_EXPRESSION.
  ///
  /// Optional.
  core.bool? caseSensitive;

  /// Name of the method to match against.
  ///
  /// If unspecified, will match all methods.
  ///
  /// Required.
  core.String? grpcMethod;

  /// Name of the service to match against.
  ///
  /// If unspecified, will match all services.
  ///
  /// Required.
  core.String? grpcService;

  /// Specifies how to match against the name.
  ///
  /// If not specified, a default value of "EXACT" is used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified.
  /// - "EXACT" : Will only match the exact name provided.
  /// - "REGULAR_EXPRESSION" : Will interpret grpc_method and grpc_service as
  /// regexes. RE2 syntax is supported.
  core.String? type;

  $GrpcRouteMethodMatch({
    this.caseSensitive,
    this.grpcMethod,
    this.grpcService,
    this.type,
  });

  $GrpcRouteMethodMatch.fromJson(core.Map json_)
    : this(
        caseSensitive: json_['caseSensitive'] as core.bool?,
        grpcMethod: json_['grpcMethod'] as core.String?,
        grpcService: json_['grpcService'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseSensitive != null) 'caseSensitive': caseSensitive!,
    if (grpcMethod != null) 'grpcMethod': grpcMethod!,
    if (grpcService != null) 'grpcService': grpcService!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteRetryPolicy
/// - networkservices:v1beta1 : GrpcRouteRetryPolicy
class $GrpcRouteRetryPolicy {
  /// Specifies the allowed number of retries.
  ///
  /// This number must be \> 0. If not specified, default to 1.
  core.int? numRetries;

  /// - connect-failure: Router will retry on failures connecting to Backend
  /// Services, for example due to connection timeouts.
  ///
  /// - refused-stream: Router will retry if the backend service resets the
  /// stream with a REFUSED_STREAM error code. This reset type indicates that it
  /// is safe to retry. - cancelled: Router will retry if the gRPC status code
  /// in the response header is set to cancelled - deadline-exceeded: Router
  /// will retry if the gRPC status code in the response header is set to
  /// deadline-exceeded - resource-exhausted: Router will retry if the gRPC
  /// status code in the response header is set to resource-exhausted -
  /// unavailable: Router will retry if the gRPC status code in the response
  /// header is set to unavailable
  core.List<core.String>? retryConditions;

  $GrpcRouteRetryPolicy({this.numRetries, this.retryConditions});

  $GrpcRouteRetryPolicy.fromJson(core.Map json_)
    : this(
        numRetries: json_['numRetries'] as core.int?,
        retryConditions:
            (json_['retryConditions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numRetries != null) 'numRetries': numRetries!,
    if (retryConditions != null) 'retryConditions': retryConditions!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : GuaranteedOrderStatus
/// - displayvideo:v3 : GuaranteedOrderStatus
/// - displayvideo:v4 : GuaranteedOrderStatus
class $GuaranteedOrderStatus {
  /// The configuration status of the guaranteed order.
  ///
  /// Acceptable values are `PENDING` and `COMPLETED`. A guaranteed order must
  /// be configured (fill in the required fields, choose creatives, and select a
  /// default campaign) before it can serve. Currently the configuration action
  /// can only be performed via UI.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "GUARANTEED_ORDER_CONFIG_STATUS_UNSPECIFIED" : The approval status is
  /// not specified or is unknown in this version.
  /// - "PENDING" : The beginning state of a guaranteed order. The guaranteed
  /// order in this state needs to be configured before it can serve.
  /// - "COMPLETED" : The state after the buyer configures a guaranteed order.
  core.String? configStatus;

  /// The user-provided reason for pausing this guaranteed order.
  ///
  /// Must be UTF-8 encoded with a maximum length of 100 bytes. Only applicable
  /// when entity_status is set to `ENTITY_STATUS_PAUSED`.
  core.String? entityPauseReason;

  /// Whether or not the guaranteed order is servable.
  ///
  /// Acceptable values are `ENTITY_STATUS_ACTIVE`, `ENTITY_STATUS_ARCHIVED`,
  /// and `ENTITY_STATUS_PAUSED`. Default value is `ENTITY_STATUS_ACTIVE`.
  /// Possible string values are:
  /// - "ENTITY_STATUS_UNSPECIFIED" : Default value when status is not specified
  /// or is unknown in this version.
  /// - "ENTITY_STATUS_ACTIVE" : The entity is enabled to bid and spend budget.
  /// - "ENTITY_STATUS_ARCHIVED" : The entity is archived. Bidding and budget
  /// spending are disabled. An entity can be deleted after archived. Deleted
  /// entities cannot be retrieved.
  /// - "ENTITY_STATUS_DRAFT" : The entity is under draft. Bidding and budget
  /// spending are disabled.
  /// - "ENTITY_STATUS_PAUSED" : Bidding and budget spending are paused for the
  /// entity.
  /// - "ENTITY_STATUS_SCHEDULED_FOR_DELETION" : The entity is scheduled for
  /// deletion.
  core.String? entityStatus;

  $GuaranteedOrderStatus({
    this.configStatus,
    this.entityPauseReason,
    this.entityStatus,
  });

  $GuaranteedOrderStatus.fromJson(core.Map json_)
    : this(
        configStatus: json_['configStatus'] as core.String?,
        entityPauseReason: json_['entityPauseReason'] as core.String?,
        entityStatus: json_['entityStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configStatus != null) 'configStatus': configStatus!,
    if (entityPauseReason != null) 'entityPauseReason': entityPauseReason!,
    if (entityStatus != null) 'entityStatus': entityStatus!,
  };
}

/// Used by:
///
/// - compute:alpha : GuestAttributesEntry
/// - compute:beta : GuestAttributesEntry
/// - compute:v1 : GuestAttributesEntry
/// - tpu:v2 : GuestAttributesEntry
/// - tpu:v2alpha1 : GuestAttributesEntry
class $GuestAttributesEntry {
  /// Key for the guest attribute entry.
  core.String? key;

  /// Namespace for the guest attribute entry.
  core.String? namespace;

  /// Value for the guest attribute entry.
  core.String? value;

  $GuestAttributesEntry({this.key, this.namespace, this.value});

  $GuestAttributesEntry.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        namespace: json_['namespace'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (namespace != null) 'namespace': namespace!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : GuestOsFeature
/// - compute:beta : GuestOsFeature
/// - compute:v1 : GuestOsFeature
class $GuestOsFeature {
  /// The ID of a supported feature.
  ///
  /// To add multiple values, use commas to separate values. Set to one or more
  /// of the following values: - VIRTIO_SCSI_MULTIQUEUE - WINDOWS -
  /// MULTI_IP_SUBNET - UEFI_COMPATIBLE - GVNIC - SEV_CAPABLE -
  /// SUSPEND_RESUME_COMPATIBLE - SEV_LIVE_MIGRATABLE_V2 - SEV_SNP_CAPABLE -
  /// TDX_CAPABLE - IDPF - SNP_SVSM_CAPABLE For more information, see Enabling
  /// guest operating system features.
  /// Possible string values are:
  /// - "BARE_METAL_LINUX_COMPATIBLE"
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "GVNIC"
  /// - "IDPF"
  /// - "MULTI_IP_SUBNET"
  /// - "SECURE_BOOT"
  /// - "SEV_CAPABLE"
  /// - "SEV_LIVE_MIGRATABLE"
  /// - "SEV_LIVE_MIGRATABLE_V2"
  /// - "SEV_SNP_CAPABLE"
  /// - "SNP_SVSM_CAPABLE"
  /// - "TDX_CAPABLE"
  /// - "UEFI_COMPATIBLE"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String? type;

  $GuestOsFeature({this.type});

  $GuestOsFeature.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - connectors:v1 : HPAConfig
/// - integrations:v1 : GoogleCloudConnectorsV1HPAConfig
class $HPAConfig {
  /// Percent CPU utilization where HPA triggers autoscaling.
  ///
  /// Output only.
  core.String? cpuUtilizationThreshold;

  /// Percent Memory utilization where HPA triggers autoscaling.
  ///
  /// Output only.
  core.String? memoryUtilizationThreshold;

  $HPAConfig({this.cpuUtilizationThreshold, this.memoryUtilizationThreshold});

  $HPAConfig.fromJson(core.Map json_)
    : this(
        cpuUtilizationThreshold:
            json_['cpuUtilizationThreshold'] as core.String?,
        memoryUtilizationThreshold:
            json_['memoryUtilizationThreshold'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpuUtilizationThreshold != null)
      'cpuUtilizationThreshold': cpuUtilizationThreshold!,
    if (memoryUtilizationThreshold != null)
      'memoryUtilizationThreshold': memoryUtilizationThreshold!,
  };
}

/// Used by:
///
/// - compute:beta : HTTP2HealthCheck
/// - compute:v1 : HTTP2HealthCheck
class $HTTP2HealthCheck {
  /// The value of the host header in the HTTP/2 health check request.
  ///
  /// If left empty (default value), the host header is set to the destination
  /// IP address to which health check packets are sent. The destination IP
  /// address depends on the type of load balancer. For details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
  core.String? host;

  /// The TCP port number to which the health check prober sends packets.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP/2 health check request.
  ///
  /// The default value is /. Must comply with RFC3986.
  core.String? requestPath;

  /// Creates a content-based HTTP/2 health check.
  ///
  /// In addition to the required HTTP 200 (OK) status code, you can configure
  /// the health check to pass only when the backend sends this specific ASCII
  /// response string within the first 1024 bytes of the HTTP response body. For
  /// details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
  core.String? response;

  $HTTP2HealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  $HTTP2HealthCheck.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        requestPath: json_['requestPath'] as core.String?,
        response: json_['response'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (requestPath != null) 'requestPath': requestPath!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - compute:beta : HTTPHealthCheck
/// - compute:v1 : HTTPHealthCheck
class $HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the host header is set to the destination
  /// IP address to which health check packets are sent. The destination IP
  /// address depends on the type of load balancer. For details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
  core.String? host;

  /// The TCP port number to which the health check prober sends packets.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Also supported in legacy HTTP health checks for
  /// target pools. The health check supports all backends supported by the
  /// backend service provided the backend can be health checked. For example,
  /// GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups,
  /// and instance group backends. USE_NAMED_PORT: Not supported.
  /// USE_SERVING_PORT: Provides an indirect method of specifying the health
  /// check port by referring to the backend service. Only supported by backend
  /// services for proxy load balancers. Not supported by target pools. Not
  /// supported by backend services for pass-through load balancers. Supports
  /// all backends that can be health checked; for example, GCE_VM_IP_PORT
  /// network endpoint groups and instance group backends. For GCE_VM_IP_PORT
  /// network endpoint group backends, the health check uses the port number
  /// specified for each endpoint in the network endpoint group. For instance
  /// group backends, the health check uses the port number determined by
  /// looking up the backend service's named port in the instance group's list
  /// of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /. Must comply with RFC3986.
  core.String? requestPath;

  /// Creates a content-based HTTP health check.
  ///
  /// In addition to the required HTTP 200 (OK) status code, you can configure
  /// the health check to pass only when the backend sends this specific ASCII
  /// response string within the first 1024 bytes of the HTTP response body. For
  /// details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
  core.String? response;

  $HTTPHealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  $HTTPHealthCheck.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        requestPath: json_['requestPath'] as core.String?,
        response: json_['response'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (requestPath != null) 'requestPath': requestPath!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - compute:beta : HTTPSHealthCheck
/// - compute:v1 : HTTPSHealthCheck
class $HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the host header is set to the destination
  /// IP address to which health check packets are sent. The destination IP
  /// address depends on the type of load balancer. For details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
  core.String? host;

  /// The TCP port number to which the health check prober sends packets.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is /. Must comply with RFC3986.
  core.String? requestPath;

  /// Creates a content-based HTTPS health check.
  ///
  /// In addition to the required HTTP 200 (OK) status code, you can configure
  /// the health check to pass only when the backend sends this specific ASCII
  /// response string within the first 1024 bytes of the HTTP response body. For
  /// details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
  core.String? response;

  $HTTPSHealthCheck({
    this.host,
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.requestPath,
    this.response,
  });

  $HTTPSHealthCheck.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        requestPath: json_['requestPath'] as core.String?,
        response: json_['response'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (requestPath != null) 'requestPath': requestPath!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - appengine:v1 : ApiEndpointHandler
/// - appengine:v1 : ScriptHandler
/// - appengine:v1beta : ApiEndpointHandler
/// - appengine:v1beta : ScriptHandler
class $Handler {
  /// Path to the script from the application root directory.
  core.String? scriptPath;

  $Handler({this.scriptPath});

  $Handler.fromJson(core.Map json_)
    : this(scriptPath: json_['scriptPath'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (scriptPath != null) 'scriptPath': scriptPath!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : Hash
/// - artifactregistry:v1beta1 : Hash
/// - artifactregistry:v1beta2 : Hash
class $Hash00 {
  /// The algorithm used to compute the hash value.
  /// Possible string values are:
  /// - "HASH_TYPE_UNSPECIFIED" : Unspecified.
  /// - "SHA256" : SHA256 hash.
  /// - "MD5" : MD5 hash.
  core.String? type;

  /// The hash value.
  core.String? value;
  core.List<core.int> get valueAsBytes => convert.base64.decode(value!);

  set valueAsBytes(core.List<core.int> bytes_) {
    value = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Hash00({this.type, this.value});

  $Hash00.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Hash
/// - ondemandscanning:v1 : Hash
/// - ondemandscanning:v1beta1 : Hash
class $Hash01 {
  /// The type of hash that was performed, e.g. "SHA-256".
  ///
  /// Required.
  core.String? type;

  /// The hash value.
  ///
  /// Required.
  core.String? value;
  core.List<core.int> get valueAsBytes => convert.base64.decode(value!);

  set valueAsBytes(core.List<core.int> bytes_) {
    value = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Hash01({this.type, this.value});

  $Hash01.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : UrlMapTestHeader
/// - compute:beta : UrlMapTestHeader
/// - compute:v1 : UrlMapTestHeader
/// - websecurityscanner:v1 : Header
/// - websecurityscanner:v1alpha : Header
/// - websecurityscanner:v1beta : Header
class $Header00 {
  /// Header name.
  core.String? name;

  /// Header value.
  core.String? value;

  $Header00({this.name, this.value});

  $Header00.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - apihub:v1 : GoogleCloudApihubV1Header
/// - apim:v1alpha : HttpOperationHeader
class $Header01 {
  /// The number of occurrences of this Header across transactions.
  core.String? count;

  /// Data type of header
  /// Possible string values are:
  /// - "DATA_TYPE_UNSPECIFIED" : Unspecified data type
  /// - "BOOL" : Boolean data type
  /// - "INTEGER" : Integer data type
  /// - "FLOAT" : Float data type
  /// - "STRING" : String data type
  /// - "UUID" : UUID data type
  core.String? dataType;

  /// Header name.
  core.String? name;

  $Header01({this.count, this.dataType, this.name});

  $Header01.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        dataType: json_['dataType'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (dataType != null) 'dataType': dataType!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : Header
/// - cloudtasks:v2beta3 : Header
class $Header02 {
  /// The Key of the header.
  core.String? key;

  /// The Value of the header.
  core.String? value;

  $Header02({this.key, this.value});

  $Header02.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - appengine:v1 : HealthCheck
/// - appengine:v1beta : HealthCheck
class $HealthCheck {
  /// Interval between health checks.
  core.String? checkInterval;

  /// Whether to explicitly disable health checks for this instance.
  core.bool? disableHealthCheck;

  /// Number of consecutive successful health checks required before receiving
  /// traffic.
  core.int? healthyThreshold;

  /// Host header to send when performing an HTTP health check.
  ///
  /// Example: "myapp.appspot.com"
  core.String? host;

  /// Number of consecutive failed health checks required before an instance is
  /// restarted.
  core.int? restartThreshold;

  /// Time before the health check is considered failed.
  core.String? timeout;

  /// Number of consecutive failed health checks required before removing
  /// traffic.
  core.int? unhealthyThreshold;

  $HealthCheck({
    this.checkInterval,
    this.disableHealthCheck,
    this.healthyThreshold,
    this.host,
    this.restartThreshold,
    this.timeout,
    this.unhealthyThreshold,
  });

  $HealthCheck.fromJson(core.Map json_)
    : this(
        checkInterval: json_['checkInterval'] as core.String?,
        disableHealthCheck: json_['disableHealthCheck'] as core.bool?,
        healthyThreshold: json_['healthyThreshold'] as core.int?,
        host: json_['host'] as core.String?,
        restartThreshold: json_['restartThreshold'] as core.int?,
        timeout: json_['timeout'] as core.String?,
        unhealthyThreshold: json_['unhealthyThreshold'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkInterval != null) 'checkInterval': checkInterval!,
    if (disableHealthCheck != null) 'disableHealthCheck': disableHealthCheck!,
    if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
    if (host != null) 'host': host!,
    if (restartThreshold != null) 'restartThreshold': restartThreshold!,
    if (timeout != null) 'timeout': timeout!,
    if (unhealthyThreshold != null) 'unhealthyThreshold': unhealthyThreshold!,
  };
}

/// Used by:
///
/// - compute:alpha : HealthCheckLogConfig
/// - compute:beta : HealthCheckLogConfig
/// - compute:v1 : HealthCheckLogConfig
class $HealthCheckLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default, which means no health check logging will be
  /// done.
  core.bool? enable;

  $HealthCheckLogConfig({this.enable});

  $HealthCheckLogConfig.fromJson(core.Map json_)
    : this(enable: json_['enable'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
  };
}

/// Used by:
///
/// - compute:alpha : HealthCheckReference
/// - compute:beta : HealthCheckReference
/// - compute:v1 : HealthCheckReference
class $HealthCheckReference {
  core.String? healthCheck;

  $HealthCheckReference({this.healthCheck});

  $HealthCheckReference.fromJson(core.Map json_)
    : this(healthCheck: json_['healthCheck'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (healthCheck != null) 'healthCheck': healthCheck!,
  };
}

/// Used by:
///
/// - compute:alpha : HealthCheckServiceReference
/// - compute:beta : HealthCheckServiceReference
/// - compute:v1 : HealthCheckServiceReference
class $HealthCheckServiceReference {
  core.String? healthCheckService;

  $HealthCheckServiceReference({this.healthCheckService});

  $HealthCheckServiceReference.fromJson(core.Map json_)
    : this(healthCheckService: json_['healthCheckService'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (healthCheckService != null) 'healthCheckService': healthCheckService!,
  };
}

/// Used by:
///
/// - compute:alpha : HealthStatus
/// - compute:beta : HealthStatus
/// - compute:v1 : HealthStatus
class $HealthStatus {
  /// Metadata defined as annotations for network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// URL of the forwarding rule associated with the health status of the
  /// instance.
  core.String? forwardingRule;

  /// A forwarding rule IP address assigned to this instance.
  core.String? forwardingRuleIp;

  /// Health state of the IPv4 address of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String? healthState;

  /// URL of the instance resource.
  core.String? instance;

  /// For target pool based Network Load Balancing, it indicates the forwarding
  /// rule's IP address assigned to this instance.
  ///
  /// For other types of load balancing, the field indicates VM internal ip.
  core.String? ipAddress;
  core.String? ipv6Address;

  /// Health state of the IPv6 address of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String? ipv6HealthState;

  /// The named port of the instance group, not necessarily the port that is
  /// health-checked.
  core.int? port;
  core.String? weight;

  ///
  /// Possible string values are:
  /// - "INVALID_WEIGHT" : The response to a Health Check probe had the HTTP
  /// response header field X-Load-Balancing-Endpoint-Weight, but its content
  /// was invalid (i.e., not a non-negative single-precision floating-point
  /// number in decimal string representation).
  /// - "MISSING_WEIGHT" : The response to a Health Check probe did not have the
  /// HTTP response header field X-Load-Balancing-Endpoint-Weight.
  /// - "UNAVAILABLE_WEIGHT" : This is the value when the accompanied health
  /// status is either TIMEOUT (i.e.,the Health Check probe was not able to get
  /// a response in time) or UNKNOWN. For the latter, it should be typically
  /// because there has not been sufficient time to parse and report the weight
  /// for a new backend (which is with 0.0.0.0 ip address). However, it can be
  /// also due to an outage case for which the health status is explicitly reset
  /// to UNKNOWN.
  /// - "WEIGHT_NONE" : This is the default value when WeightReportMode is
  /// DISABLE, and is also the initial value when WeightReportMode has just
  /// updated to ENABLE or DRY_RUN and there has not been sufficient time to
  /// parse and report the backend weight.
  core.String? weightError;

  $HealthStatus({
    this.annotations,
    this.forwardingRule,
    this.forwardingRuleIp,
    this.healthState,
    this.instance,
    this.ipAddress,
    this.ipv6Address,
    this.ipv6HealthState,
    this.port,
    this.weight,
    this.weightError,
  });

  $HealthStatus.fromJson(core.Map json_)
    : this(
        annotations: (json_['annotations']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        forwardingRule: json_['forwardingRule'] as core.String?,
        forwardingRuleIp: json_['forwardingRuleIp'] as core.String?,
        healthState: json_['healthState'] as core.String?,
        instance: json_['instance'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
        ipv6HealthState: json_['ipv6HealthState'] as core.String?,
        port: json_['port'] as core.int?,
        weight: json_['weight'] as core.String?,
        weightError: json_['weightError'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (forwardingRuleIp != null) 'forwardingRuleIp': forwardingRuleIp!,
    if (healthState != null) 'healthState': healthState!,
    if (instance != null) 'instance': instance!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
    if (ipv6HealthState != null) 'ipv6HealthState': ipv6HealthState!,
    if (port != null) 'port': port!,
    if (weight != null) 'weight': weight!,
    if (weightError != null) 'weightError': weightError!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1HealthcareFhirConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaHealthcareFhirConfig
class $HealthcareFhirConfig {
  /// Whether to enable configurable schema for `HEALTHCARE_FHIR` vertical.
  ///
  /// If set to `true`, the predefined healthcare fhir schema can be extended
  /// for more customized searching and filtering.
  core.bool? enableConfigurableSchema;

  /// Whether to enable static indexing for `HEALTHCARE_FHIR` batch ingestion.
  ///
  /// If set to `true`, the batch ingestion will be processed in a static
  /// indexing mode which is slower but more capable of handling larger volume.
  core.bool? enableStaticIndexingForBatchIngestion;

  $HealthcareFhirConfig({
    this.enableConfigurableSchema,
    this.enableStaticIndexingForBatchIngestion,
  });

  $HealthcareFhirConfig.fromJson(core.Map json_)
    : this(
        enableConfigurableSchema:
            json_['enableConfigurableSchema'] as core.bool?,
        enableStaticIndexingForBatchIngestion:
            json_['enableStaticIndexingForBatchIngestion'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableConfigurableSchema != null)
      'enableConfigurableSchema': enableConfigurableSchema!,
    if (enableStaticIndexingForBatchIngestion != null)
      'enableStaticIndexingForBatchIngestion':
          enableStaticIndexingForBatchIngestion!,
  };
}

/// Used by:
///
/// - container:v1 : HighScaleCheckpointingConfig
/// - container:v1beta1 : HighScaleCheckpointingConfig
class $HighScaleCheckpointingConfig {
  /// Whether the High Scale Checkpointing is enabled for this cluster.
  core.bool? enabled;

  $HighScaleCheckpointingConfig({this.enabled});

  $HighScaleCheckpointingConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Hint
/// - containeranalysis:v1beta1 : Hint
class $Hint {
  /// The human readable name of this attestation authority, for example "qa".
  ///
  /// Required.
  core.String? humanReadableName;

  $Hint({this.humanReadableName});

  $Hint.fromJson(core.Map json_)
    : this(humanReadableName: json_['humanReadableName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (humanReadableName != null) 'humanReadableName': humanReadableName!,
  };
}

/// Used by:
///
/// - jobs:v3p1beta1 : HistogramQueryResult
/// - jobs:v4 : HistogramQueryResult
class $HistogramQueryResult {
  /// A map from the values of the facet associated with distinct values to the
  /// number of matching entries with corresponding value.
  ///
  /// The key format is: * (for string histogram) string values stored in the
  /// field. * (for named numeric bucket) name specified in `bucket()` function,
  /// like for `bucket(0, MAX, "non-negative")`, the key will be `non-negative`.
  /// * (for anonymous numeric bucket) range formatted as `-`, for example,
  /// `0-1000`, `MIN-0`, and `0-MAX`.
  core.Map<core.String, core.String>? histogram;

  /// Requested histogram expression.
  core.String? histogramQuery;

  $HistogramQueryResult({this.histogram, this.histogramQuery});

  $HistogramQueryResult.fromJson(core.Map json_)
    : this(
        histogram: (json_['histogram'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        histogramQuery: json_['histogramQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (histogram != null) 'histogram': histogram!,
    if (histogramQuery != null) 'histogramQuery': histogramQuery!,
  };
}

/// Used by:
///
/// - jobs:v3 : HistogramResult
/// - jobs:v3p1beta1 : HistogramResult
class $HistogramResult {
  /// The Histogram search filters.
  /// Possible string values are:
  /// - "SEARCH_TYPE_UNSPECIFIED" : The default value if search type is not
  /// specified.
  /// - "COMPANY_ID" : Filter by the company id field.
  /// - "EMPLOYMENT_TYPE" : Filter by the employment type field, such as
  /// `FULL_TIME` or `PART_TIME`.
  /// - "COMPANY_SIZE" : Filter by the company size type field, such as `BIG`,
  /// `SMALL` or `BIGGER`.
  /// - "DATE_PUBLISHED" : Filter by the date published field. Possible return
  /// values are: * PAST_24_HOURS (The past 24 hours) * PAST_3_DAYS (The past 3
  /// days) * PAST_WEEK (The past 7 days) * PAST_MONTH (The past 30 days) *
  /// PAST_YEAR (The past 365 days)
  /// - "EDUCATION_LEVEL" : Filter by the required education level of the job.
  /// - "EXPERIENCE_LEVEL" : Filter by the required experience level of the job.
  /// - "ADMIN_1" : Filter by Admin1, which is a global placeholder for
  /// referring to state, province, or the particular term a country uses to
  /// define the geographic structure below the country level. Examples include
  /// states codes such as "CA", "IL", "NY", and provinces, such as "BC".
  /// - "COUNTRY" : Filter by the country code of job, such as US, JP, FR.
  /// - "CITY" : Filter by the "city name", "Admin1 code", for example,
  /// "Mountain View, CA" or "New York, NY".
  /// - "LOCALE" : Filter by the locale field of a job, such as "en-US",
  /// "fr-FR". This is the BCP-47 language code, such as "en-US" or "sr-Latn".
  /// For more information, see
  /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
  /// - "LANGUAGE" : Filter by the language code portion of the locale field,
  /// such as "en" or "fr".
  /// - "CATEGORY" : Filter by the Category.
  /// - "CITY_COORDINATE" : Filter by the city center GPS coordinate (latitude
  /// and longitude), for example, 37.4038522,-122.0987765. Since the
  /// coordinates of a city center can change, clients may need to refresh them
  /// periodically.
  /// - "ADMIN_1_COUNTRY" : A combination of state or province code with a
  /// country code. This field differs from `JOB_ADMIN1`, which can be used in
  /// multiple countries.
  /// - "COMPANY_DISPLAY_NAME" : Company display name.
  /// - "BASE_COMPENSATION_UNIT" : Base compensation unit.
  core.String? searchType;

  /// A map from the values of field to the number of jobs with that value in
  /// this search result.
  ///
  /// Key: search type (filter names, such as the companyName). Values: the
  /// count of jobs that match the filter for this search.
  core.Map<core.String, core.int>? values;

  $HistogramResult({this.searchType, this.values});

  $HistogramResult.fromJson(core.Map json_)
    : this(
        searchType: json_['searchType'] as core.String?,
        values: (json_['values'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.int),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchType != null) 'searchType': searchType!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Hl7V2StoreMetric
/// - healthcare:v1beta1 : Hl7V2StoreMetric
class $Hl7V2StoreMetric {
  /// The total count of HL7v2 messages in the store for the given message type.
  core.String? count;

  /// The Hl7v2 message type this metric applies to, such as `ADT` or `ORU`.
  core.String? messageType;

  /// The total amount of structured storage used by HL7v2 messages of this
  /// message type in the store.
  core.String? structuredStorageSizeBytes;

  $Hl7V2StoreMetric({
    this.count,
    this.messageType,
    this.structuredStorageSizeBytes,
  });

  $Hl7V2StoreMetric.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        messageType: json_['messageType'] as core.String?,
        structuredStorageSizeBytes:
            json_['structuredStorageSizeBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (messageType != null) 'messageType': messageType!,
    if (structuredStorageSizeBytes != null)
      'structuredStorageSizeBytes': structuredStorageSizeBytes!,
  };
}

/// Used by:
///
/// - container:v1 : HorizontalPodAutoscaling
/// - container:v1beta1 : HorizontalPodAutoscaling
class $HorizontalPodAutoscaling {
  /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
  ///
  /// When enabled, it ensures that metrics are collected into Stackdriver
  /// Monitoring.
  core.bool? disabled;

  $HorizontalPodAutoscaling({this.disabled});

  $HorizontalPodAutoscaling.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - compute:alpha : HostRule
/// - compute:beta : HostRule
/// - compute:v1 : HostRule
class $HostRule {
  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of host patterns to match.
  ///
  /// They must be valid hostnames with optional port numbers in the format
  /// host:port. * matches any string of (\[a-z0-9-.\]*). In that case, * must
  /// be the first character, and if followed by anything, the immediate
  /// following character must be either - or .. * based matching is not
  /// supported when the URL map is bound to a target gRPC proxy that has the
  /// validateForProxyless field set to true.
  core.List<core.String>? hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String? pathMatcher;

  $HostRule({this.description, this.hosts, this.pathMatcher});

  $HostRule.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        hosts:
            (json_['hosts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pathMatcher: json_['pathMatcher'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (hosts != null) 'hosts': hosts!,
    if (pathMatcher != null) 'pathMatcher': pathMatcher!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : HostsEntry
/// - migrationcenter:v1alpha1 : HostsEntry
class $HostsEntry {
  /// List of host names / aliases.
  core.List<core.String>? hostNames;

  /// IP (raw, IPv4/6 agnostic).
  core.String? ip;

  $HostsEntry({this.hostNames, this.ip});

  $HostsEntry.fromJson(core.Map json_)
    : this(
        hostNames:
            (json_['hostNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ip: json_['ip'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostNames != null) 'hostNames': hostNames!,
    if (ip != null) 'ip': ip!,
  };
}

/// Used by:
///
/// - netapp:v1 : HourlySchedule
/// - netapp:v1beta1 : HourlySchedule
class $HourlySchedule {
  /// Set the minute of the hour to start the snapshot (0-59), defaults to the
  /// top of the hour (0).
  core.double? minute;

  /// The maximum number of Snapshots to keep for the hourly schedule
  core.double? snapshotsToKeep;

  $HourlySchedule({this.minute, this.snapshotsToKeep});

  $HourlySchedule.fromJson(core.Map json_)
    : this(
        minute: (json_['minute'] as core.num?)?.toDouble(),
        snapshotsToKeep: (json_['snapshotsToKeep'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (minute != null) 'minute': minute!,
    if (snapshotsToKeep != null) 'snapshotsToKeep': snapshotsToKeep!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : HouseholdIncomeAssignedTargetingOptionDetails
/// - displayvideo:v3 : HouseholdIncomeAssignedTargetingOptionDetails
/// - displayvideo:v4 : HouseholdIncomeAssignedTargetingOptionDetails
class $HouseholdIncomeAssignedTargetingOptionDetails {
  /// The household income of the audience.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HOUSEHOLD_INCOME_UNSPECIFIED" : Default value when household income is
  /// not specified in this version. This enum is a placeholder for default
  /// value and does not represent a real household income option.
  /// - "HOUSEHOLD_INCOME_UNKNOWN" : The household income of the audience is
  /// unknown.
  /// - "HOUSEHOLD_INCOME_LOWER_50_PERCENT" : The audience is in the lower 50%
  /// of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_41_TO_50_PERCENT" : The audience is in the top
  /// 41-50% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_31_TO_40_PERCENT" : The audience is in the top
  /// 31-40% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_21_TO_30_PERCENT" : The audience is in the top
  /// 21-30% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_11_TO_20_PERCENT" : The audience is in the top
  /// 11-20% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_10_PERCENT" : The audience is in the top 10% of
  /// U.S. household incomes.
  core.String? householdIncome;

  $HouseholdIncomeAssignedTargetingOptionDetails({this.householdIncome});

  $HouseholdIncomeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(householdIncome: json_['householdIncome'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (householdIncome != null) 'householdIncome': householdIncome!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : HouseholdIncomeTargetingOptionDetails
/// - displayvideo:v3 : HouseholdIncomeTargetingOptionDetails
/// - displayvideo:v4 : HouseholdIncomeTargetingOptionDetails
class $HouseholdIncomeTargetingOptionDetails {
  /// The household income of an audience.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HOUSEHOLD_INCOME_UNSPECIFIED" : Default value when household income is
  /// not specified in this version. This enum is a placeholder for default
  /// value and does not represent a real household income option.
  /// - "HOUSEHOLD_INCOME_UNKNOWN" : The household income of the audience is
  /// unknown.
  /// - "HOUSEHOLD_INCOME_LOWER_50_PERCENT" : The audience is in the lower 50%
  /// of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_41_TO_50_PERCENT" : The audience is in the top
  /// 41-50% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_31_TO_40_PERCENT" : The audience is in the top
  /// 31-40% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_21_TO_30_PERCENT" : The audience is in the top
  /// 21-30% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_11_TO_20_PERCENT" : The audience is in the top
  /// 11-20% of U.S. household incomes.
  /// - "HOUSEHOLD_INCOME_TOP_10_PERCENT" : The audience is in the top 10% of
  /// U.S. household incomes.
  core.String? householdIncome;

  $HouseholdIncomeTargetingOptionDetails({this.householdIncome});

  $HouseholdIncomeTargetingOptionDetails.fromJson(core.Map json_)
    : this(householdIncome: json_['householdIncome'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (householdIncome != null) 'householdIncome': householdIncome!,
  };
}

/// Used by:
///
/// - adsense:v2 : HttpBody
/// - aiplatform:v1 : GoogleApiHttpBody
/// - aiplatform:v1beta1 : GoogleApiHttpBody
/// - airquality:v1 : HttpBody
/// - apigee:v1 : GoogleApiHttpBody
/// - apigeeregistry:v1 : HttpBody
/// - cloudbuild:v1 : HttpBody
/// - cloudbuild:v2 : HttpBody
/// - cloudtasks:v2 : HttpBody
/// - cloudtasks:v2beta2 : HttpBody
/// - cloudtasks:v2beta3 : HttpBody
/// - developerconnect:v1 : HttpBody
/// - discoveryengine:v1 : GoogleApiHttpBody
/// - discoveryengine:v1alpha : GoogleApiHttpBody
/// - discoveryengine:v1beta : GoogleApiHttpBody
/// - healthcare:v1 : HttpBody
/// - healthcare:v1beta1 : HttpBody
/// - managedkafka:v1 : HttpBody
/// - ml:v1 : GoogleApi__HttpBody
/// - monitoring:v1 : HttpBody
/// - pollen:v1 : HttpBody
/// - recommendationengine:v1beta1 : GoogleApiHttpBody
/// - retail:v2 : GoogleApiHttpBody
/// - retail:v2alpha : GoogleApiHttpBody
/// - retail:v2beta : GoogleApiHttpBody
/// - solar:v1 : HttpBody
class $HttpBody {
  /// The HTTP Content-Type header value specifying the content type of the
  /// body.
  core.String? contentType;

  /// The HTTP request/response body as raw binary.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Application specific response metadata.
  ///
  /// Must be set in the first response for streaming APIs.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? extensions;

  $HttpBody({this.contentType, this.data, this.extensions});

  $HttpBody.fromJson(core.Map json_)
    : this(
        contentType: json_['contentType'] as core.String?,
        data: json_['data'] as core.String?,
        extensions:
            (json_['extensions'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentType != null) 'contentType': contentType!,
    if (data != null) 'data': data!,
    if (extensions != null) 'extensions': extensions!,
  };
}

/// Used by:
///
/// - container:v1 : HttpCacheControlResponseHeader
/// - container:v1beta1 : HttpCacheControlResponseHeader
class $HttpCacheControlResponseHeader {
  /// 14.6 response cache age, in seconds since the response is generated
  core.String? age;

  /// 14.9 request and response directives
  core.String? directive;

  /// 14.21 response cache expires, in RFC 1123 date format
  core.String? expires;

  $HttpCacheControlResponseHeader({this.age, this.directive, this.expires});

  $HttpCacheControlResponseHeader.fromJson(core.Map json_)
    : this(
        age: json_['age'] as core.String?,
        directive: json_['directive'] as core.String?,
        expires: json_['expires'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (age != null) 'age': age!,
    if (directive != null) 'directive': directive!,
    if (expires != null) 'expires': expires!,
  };
}

/// Used by:
///
/// - compute:alpha : HttpFaultAbort
/// - compute:beta : HttpFaultAbort
/// - compute:v1 : HttpFaultAbort
class $HttpFaultAbort {
  /// The HTTP status code used to abort the request.
  ///
  /// The value must be from 200 to 599 inclusive. For gRPC protocol, the gRPC
  /// status code is mapped to HTTP status code according to this mapping table.
  /// HTTP status 200 is mapped to gRPC status UNKNOWN. Injecting an OK status
  /// is currently not supported by Traffic Director.
  core.int? httpStatus;

  /// The percentage of traffic for connections, operations, or requests that is
  /// aborted as part of fault injection.
  ///
  /// The value must be from 0.0 to 100.0 inclusive.
  core.double? percentage;

  $HttpFaultAbort({this.httpStatus, this.percentage});

  $HttpFaultAbort.fromJson(core.Map json_)
    : this(
        httpStatus: json_['httpStatus'] as core.int?,
        percentage: (json_['percentage'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (httpStatus != null) 'httpStatus': httpStatus!,
    if (percentage != null) 'percentage': percentage!,
  };
}

/// Used by:
///
/// - compute:alpha : HttpFilterConfig
/// - compute:beta : HttpFilterConfig
class $HttpFilterConfig {
  /// The configuration needed to enable the networkservices.HttpFilter
  /// resource.
  ///
  /// The configuration must be YAML formatted and only contain fields defined
  /// in the protobuf identified in configTypeUrl
  core.String? config;

  /// The fully qualified versioned proto3 type url of the protobuf that the
  /// filter expects for its contextual settings, for example:
  /// type.googleapis.com/google.protobuf.Struct
  core.String? configTypeUrl;

  /// Name of the networkservices.HttpFilter resource this configuration belongs
  /// to.
  ///
  /// This name must be known to the xDS client. Example: envoy.wasm
  core.String? filterName;

  $HttpFilterConfig({this.config, this.configTypeUrl, this.filterName});

  $HttpFilterConfig.fromJson(core.Map json_)
    : this(
        config: json_['config'] as core.String?,
        configTypeUrl: json_['configTypeUrl'] as core.String?,
        filterName: json_['filterName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (config != null) 'config': config!,
    if (configTypeUrl != null) 'configTypeUrl': configTypeUrl!,
    if (filterName != null) 'filterName': filterName!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : HttpHeaderMatch
/// - networksecurity:v1beta1 : HttpHeaderMatch
class $HttpHeaderMatch {
  /// The name of the HTTP header to match.
  ///
  /// For matching against the HTTP request's authority, use a headerMatch with
  /// the header name ":authority". For matching a request's method, use the
  /// headerName ":method".
  ///
  /// Required.
  core.String? headerName;

  /// The value of the header must match the regular expression specified in
  /// regexMatch.
  ///
  /// For regular expression grammar, please see:
  /// en.cppreference.com/w/cpp/regex/ecmascript For matching against a port
  /// specified in the HTTP request, use a headerMatch with headerName set to
  /// Host and a regular expression that satisfies the RFC2616 Host header's
  /// port specifier.
  ///
  /// Required.
  core.String? regexMatch;

  $HttpHeaderMatch({this.headerName, this.regexMatch});

  $HttpHeaderMatch.fromJson(core.Map json_)
    : this(
        headerName: json_['headerName'] as core.String?,
        regexMatch: json_['regexMatch'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (headerName != null) 'headerName': headerName!,
    if (regexMatch != null) 'regexMatch': regexMatch!,
  };
}

/// Used by:
///
/// - compute:alpha : HttpHeaderOption
/// - compute:beta : HttpHeaderOption
/// - compute:v1 : HttpHeaderOption
class $HttpHeaderOption {
  /// The name of the header.
  core.String? headerName;

  /// The value of the header to add.
  core.String? headerValue;

  /// If false, headerValue is appended to any values that already exist for the
  /// header.
  ///
  /// If true, headerValue is set for the header, discarding any values that
  /// were set for that header. The default value is true, unless a variable is
  /// present in headerValue, in which case the default value is false. .
  core.bool? replace;

  $HttpHeaderOption({this.headerName, this.headerValue, this.replace});

  $HttpHeaderOption.fromJson(core.Map json_)
    : this(
        headerName: json_['headerName'] as core.String?,
        headerValue: json_['headerValue'] as core.String?,
        replace: json_['replace'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (headerName != null) 'headerName': headerName!,
    if (headerValue != null) 'headerValue': headerValue!,
    if (replace != null) 'replace': replace!,
  };
}

/// Used by:
///
/// - compute:beta : HttpHealthCheck
/// - compute:v1 : HttpHealthCheck
class $HttpHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#httpHealthCheck for HTTP health checks.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTP health check request.
  ///
  /// The default value is 80.
  core.int? port;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /. This field does not support query parameters. Must
  /// comply with RFC3986.
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  $HttpHealthCheck({
    this.checkIntervalSec,
    this.creationTimestamp,
    this.description,
    this.healthyThreshold,
    this.host,
    this.id,
    this.kind,
    this.name,
    this.port,
    this.requestPath,
    this.selfLink,
    this.timeoutSec,
    this.unhealthyThreshold,
  });

  $HttpHealthCheck.fromJson(core.Map json_)
    : this(
        checkIntervalSec: json_['checkIntervalSec'] as core.int?,
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        healthyThreshold: json_['healthyThreshold'] as core.int?,
        host: json_['host'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        port: json_['port'] as core.int?,
        requestPath: json_['requestPath'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        timeoutSec: json_['timeoutSec'] as core.int?,
        unhealthyThreshold: json_['unhealthyThreshold'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
    if (host != null) 'host': host!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (port != null) 'port': port!,
    if (requestPath != null) 'requestPath': requestPath!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (timeoutSec != null) 'timeoutSec': timeoutSec!,
    if (unhealthyThreshold != null) 'unhealthyThreshold': unhealthyThreshold!,
  };
}

/// Used by:
///
/// - container:v1 : HttpLoadBalancing
/// - container:v1beta1 : HttpLoadBalancing
class $HttpLoadBalancing {
  /// Whether the HTTP Load Balancing controller is enabled in the cluster.
  ///
  /// When enabled, it runs a small pod in the cluster that manages the load
  /// balancers.
  core.bool? disabled;

  $HttpLoadBalancing({this.disabled});

  $HttpLoadBalancing.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - compute:alpha : HttpQueryParameterMatch
/// - compute:beta : HttpQueryParameterMatch
/// - compute:v1 : HttpQueryParameterMatch
class $HttpQueryParameterMatch {
  /// The queryParameterMatch matches if the value of the parameter exactly
  /// matches the contents of exactMatch.
  ///
  /// Only one of presentMatch, exactMatch, or regexMatch must be set.
  core.String? exactMatch;

  /// The name of the query parameter to match.
  ///
  /// The query parameter must exist in the request, in the absence of which the
  /// request match fails.
  core.String? name;

  /// Specifies that the queryParameterMatch matches if the request contains the
  /// query parameter, irrespective of whether the parameter has a value or not.
  ///
  /// Only one of presentMatch, exactMatch, or regexMatch must be set.
  core.bool? presentMatch;

  /// The queryParameterMatch matches if the value of the parameter matches the
  /// regular expression specified by regexMatch.
  ///
  /// For more information about regular expression syntax, see Syntax. Only one
  /// of presentMatch, exactMatch, or regexMatch must be set. Regular
  /// expressions can only be used when the loadBalancingScheme is set to
  /// INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  $HttpQueryParameterMatch({
    this.exactMatch,
    this.name,
    this.presentMatch,
    this.regexMatch,
  });

  $HttpQueryParameterMatch.fromJson(core.Map json_)
    : this(
        exactMatch: json_['exactMatch'] as core.String?,
        name: json_['name'] as core.String?,
        presentMatch: json_['presentMatch'] as core.bool?,
        regexMatch: json_['regexMatch'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exactMatch != null) 'exactMatch': exactMatch!,
    if (name != null) 'name': name!,
    if (presentMatch != null) 'presentMatch': presentMatch!,
    if (regexMatch != null) 'regexMatch': regexMatch!,
  };
}

/// Used by:
///
/// - compute:alpha : HttpRedirectAction
/// - compute:beta : HttpRedirectAction
/// - compute:v1 : HttpRedirectAction
class $HttpRedirectAction {
  /// The host that is used in the redirect response instead of the one that was
  /// supplied in the request.
  ///
  /// The value must be from 1 to 255 characters.
  core.String? hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to HTTPS.
  ///
  /// If set to false, the URL scheme of the redirected request remains the same
  /// as that of the request. This must only be set for URL maps used in
  /// TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted.
  /// The default is set to false.
  core.bool? httpsRedirect;

  /// The path that is used in the redirect response instead of the one that was
  /// supplied in the request.
  ///
  /// pathRedirect cannot be supplied together with prefixRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// is used for the redirect. The value must be from 1 to 1024 characters.
  core.String? pathRedirect;

  /// The prefix that replaces the prefixMatch specified in the
  /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
  /// redirecting the request.
  ///
  /// prefixRedirect cannot be supplied together with pathRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// is used for the redirect. The value must be from 1 to 1024 characters.
  core.String? prefixRedirect;

  /// The HTTP Status code to use for this RedirectAction.
  ///
  /// Supported values are: - MOVED_PERMANENTLY_DEFAULT, which is the default
  /// value and corresponds to 301. - FOUND, which corresponds to 302. -
  /// SEE_OTHER which corresponds to 303. - TEMPORARY_REDIRECT, which
  /// corresponds to 307. In this case, the request method is retained. -
  /// PERMANENT_REDIRECT, which corresponds to 308. In this case, the request
  /// method is retained.
  /// Possible string values are:
  /// - "FOUND" : Http Status Code 302 - Found.
  /// - "MOVED_PERMANENTLY_DEFAULT" : Http Status Code 301 - Moved Permanently.
  /// - "PERMANENT_REDIRECT" : Http Status Code 308 - Permanent Redirect
  /// maintaining HTTP method.
  /// - "SEE_OTHER" : Http Status Code 303 - See Other.
  /// - "TEMPORARY_REDIRECT" : Http Status Code 307 - Temporary Redirect
  /// maintaining HTTP method.
  core.String? redirectResponseCode;

  /// If set to true, any accompanying query portion of the original URL is
  /// removed before redirecting the request.
  ///
  /// If set to false, the query portion of the original URL is retained. The
  /// default is set to false.
  core.bool? stripQuery;

  $HttpRedirectAction({
    this.hostRedirect,
    this.httpsRedirect,
    this.pathRedirect,
    this.prefixRedirect,
    this.redirectResponseCode,
    this.stripQuery,
  });

  $HttpRedirectAction.fromJson(core.Map json_)
    : this(
        hostRedirect: json_['hostRedirect'] as core.String?,
        httpsRedirect: json_['httpsRedirect'] as core.bool?,
        pathRedirect: json_['pathRedirect'] as core.String?,
        prefixRedirect: json_['prefixRedirect'] as core.String?,
        redirectResponseCode: json_['redirectResponseCode'] as core.String?,
        stripQuery: json_['stripQuery'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostRedirect != null) 'hostRedirect': hostRedirect!,
    if (httpsRedirect != null) 'httpsRedirect': httpsRedirect!,
    if (pathRedirect != null) 'pathRedirect': pathRedirect!,
    if (prefixRedirect != null) 'prefixRedirect': prefixRedirect!,
    if (redirectResponseCode != null)
      'redirectResponseCode': redirectResponseCode!,
    if (stripQuery != null) 'stripQuery': stripQuery!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteCorsPolicy
/// - networkservices:v1beta1 : HttpRouteCorsPolicy
class $HttpRouteCorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials.
  ///
  /// This translates to the Access-Control-Allow-Credentials header. Default
  /// value is false.
  core.bool? allowCredentials;

  /// Specifies the content for Access-Control-Allow-Headers header.
  core.List<core.String>? allowHeaders;

  /// Specifies the content for Access-Control-Allow-Methods header.
  core.List<core.String>? allowMethods;

  /// Specifies the regular expression patterns that match allowed origins.
  ///
  /// For regular expression grammar, please see
  /// https://github.com/google/re2/wiki/Syntax.
  core.List<core.String>? allowOriginRegexes;

  /// Specifies the list of origins that will be allowed to do CORS requests.
  ///
  /// An origin is allowed if it matches either an item in allow_origins or an
  /// item in allow_origin_regexes.
  core.List<core.String>? allowOrigins;

  /// If true, the CORS policy is disabled.
  ///
  /// The default value is false, which indicates that the CORS policy is in
  /// effect.
  core.bool? disabled;

  /// Specifies the content for Access-Control-Expose-Headers header.
  core.List<core.String>? exposeHeaders;

  /// Specifies how long result of a preflight request can be cached in seconds.
  ///
  /// This translates to the Access-Control-Max-Age header.
  core.String? maxAge;

  $HttpRouteCorsPolicy({
    this.allowCredentials,
    this.allowHeaders,
    this.allowMethods,
    this.allowOriginRegexes,
    this.allowOrigins,
    this.disabled,
    this.exposeHeaders,
    this.maxAge,
  });

  $HttpRouteCorsPolicy.fromJson(core.Map json_)
    : this(
        allowCredentials: json_['allowCredentials'] as core.bool?,
        allowHeaders:
            (json_['allowHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowMethods:
            (json_['allowMethods'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowOriginRegexes:
            (json_['allowOriginRegexes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowOrigins:
            (json_['allowOrigins'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        disabled: json_['disabled'] as core.bool?,
        exposeHeaders:
            (json_['exposeHeaders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        maxAge: json_['maxAge'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowCredentials != null) 'allowCredentials': allowCredentials!,
    if (allowHeaders != null) 'allowHeaders': allowHeaders!,
    if (allowMethods != null) 'allowMethods': allowMethods!,
    if (allowOriginRegexes != null) 'allowOriginRegexes': allowOriginRegexes!,
    if (allowOrigins != null) 'allowOrigins': allowOrigins!,
    if (disabled != null) 'disabled': disabled!,
    if (exposeHeaders != null) 'exposeHeaders': exposeHeaders!,
    if (maxAge != null) 'maxAge': maxAge!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteHeaderMatchIntegerRange
/// - networkservices:v1beta1 : HttpRouteHeaderMatchIntegerRange
class $HttpRouteHeaderMatchIntegerRange {
  /// End of the range (exclusive)
  core.int? end;

  /// Start of the range (inclusive)
  core.int? start;

  $HttpRouteHeaderMatchIntegerRange({this.end, this.start});

  $HttpRouteHeaderMatchIntegerRange.fromJson(core.Map json_)
    : this(end: json_['end'] as core.int?, start: json_['start'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (end != null) 'end': end!,
    if (start != null) 'start': start!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteHeaderModifier
/// - networkservices:v1beta1 : HttpRouteHeaderModifier
class $HttpRouteHeaderModifier {
  /// Add the headers with given map where key is the name of the header, value
  /// is the value of the header.
  core.Map<core.String, core.String>? add;

  /// Remove headers (matching by header names) specified in the list.
  core.List<core.String>? remove;

  /// Completely overwrite/replace the headers with given map where key is the
  /// name of the header, value is the value of the header.
  core.Map<core.String, core.String>? set;

  $HttpRouteHeaderModifier({this.add, this.remove, this.set});

  $HttpRouteHeaderModifier.fromJson(core.Map json_)
    : this(
        add: (json_['add'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        remove:
            (json_['remove'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        set: (json_['set'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (add != null) 'add': add!,
    if (remove != null) 'remove': remove!,
    if (set != null) 'set': set!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteHttpDirectResponse
/// - networkservices:v1beta1 : HttpRouteHttpDirectResponse
class $HttpRouteHttpDirectResponse {
  /// Response body as bytes.
  ///
  /// Maximum body size is 4096B.
  ///
  /// Optional.
  core.String? bytesBody;
  core.List<core.int> get bytesBodyAsBytes => convert.base64.decode(bytesBody!);

  set bytesBodyAsBytes(core.List<core.int> bytes_) {
    bytesBody = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Status to return as part of HTTP Response.
  ///
  /// Must be a positive integer.
  ///
  /// Required.
  core.int? status;

  /// Response body as a string.
  ///
  /// Maximum body length is 1024 characters.
  ///
  /// Optional.
  core.String? stringBody;

  $HttpRouteHttpDirectResponse({this.bytesBody, this.status, this.stringBody});

  $HttpRouteHttpDirectResponse.fromJson(core.Map json_)
    : this(
        bytesBody: json_['bytesBody'] as core.String?,
        status: json_['status'] as core.int?,
        stringBody: json_['stringBody'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bytesBody != null) 'bytesBody': bytesBody!,
    if (status != null) 'status': status!,
    if (stringBody != null) 'stringBody': stringBody!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteQueryParameterMatch
/// - networkservices:v1beta1 : HttpRouteQueryParameterMatch
class $HttpRouteQueryParameterMatch {
  /// The value of the query parameter must exactly match the contents of
  /// exact_match.
  ///
  /// Only one of exact_match, regex_match, or present_match must be set.
  core.String? exactMatch;

  /// Specifies that the QueryParameterMatcher matches if request contains query
  /// parameter, irrespective of whether the parameter has a value or not.
  ///
  /// Only one of exact_match, regex_match, or present_match must be set.
  core.bool? presentMatch;

  /// The name of the query parameter to match.
  core.String? queryParameter;

  /// The value of the query parameter must match the regular expression
  /// specified by regex_match.
  ///
  /// For regular expression grammar, please see
  /// https://github.com/google/re2/wiki/Syntax Only one of exact_match,
  /// regex_match, or present_match must be set.
  core.String? regexMatch;

  $HttpRouteQueryParameterMatch({
    this.exactMatch,
    this.presentMatch,
    this.queryParameter,
    this.regexMatch,
  });

  $HttpRouteQueryParameterMatch.fromJson(core.Map json_)
    : this(
        exactMatch: json_['exactMatch'] as core.String?,
        presentMatch: json_['presentMatch'] as core.bool?,
        queryParameter: json_['queryParameter'] as core.String?,
        regexMatch: json_['regexMatch'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exactMatch != null) 'exactMatch': exactMatch!,
    if (presentMatch != null) 'presentMatch': presentMatch!,
    if (queryParameter != null) 'queryParameter': queryParameter!,
    if (regexMatch != null) 'regexMatch': regexMatch!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteRedirect
/// - networkservices:v1beta1 : HttpRouteRedirect
class $HttpRouteRedirect {
  /// The host that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  core.String? hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to https.
  ///
  /// If set to false, the URL scheme of the redirected request will remain the
  /// same as that of the request. The default is set to false.
  core.bool? httpsRedirect;

  /// The path that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  ///
  /// path_redirect can not be supplied together with prefix_redirect. Supply
  /// one alone or neither. If neither is supplied, the path of the original
  /// request will be used for the redirect.
  core.String? pathRedirect;

  /// The port that will be used in the redirected request instead of the one
  /// that was supplied in the request.
  core.int? portRedirect;

  /// Indicates that during redirection, the matched prefix (or path) should be
  /// swapped with this value.
  ///
  /// This option allows URLs be dynamically created based on the request.
  core.String? prefixRewrite;

  /// The HTTP Status code to use for the redirect.
  /// Possible string values are:
  /// - "RESPONSE_CODE_UNSPECIFIED" : Default value
  /// - "MOVED_PERMANENTLY_DEFAULT" : Corresponds to 301.
  /// - "FOUND" : Corresponds to 302.
  /// - "SEE_OTHER" : Corresponds to 303.
  /// - "TEMPORARY_REDIRECT" : Corresponds to 307. In this case, the request
  /// method will be retained.
  /// - "PERMANENT_REDIRECT" : Corresponds to 308. In this case, the request
  /// method will be retained.
  core.String? responseCode;

  /// if set to true, any accompanying query portion of the original URL is
  /// removed prior to redirecting the request.
  ///
  /// If set to false, the query portion of the original URL is retained. The
  /// default is set to false.
  core.bool? stripQuery;

  $HttpRouteRedirect({
    this.hostRedirect,
    this.httpsRedirect,
    this.pathRedirect,
    this.portRedirect,
    this.prefixRewrite,
    this.responseCode,
    this.stripQuery,
  });

  $HttpRouteRedirect.fromJson(core.Map json_)
    : this(
        hostRedirect: json_['hostRedirect'] as core.String?,
        httpsRedirect: json_['httpsRedirect'] as core.bool?,
        pathRedirect: json_['pathRedirect'] as core.String?,
        portRedirect: json_['portRedirect'] as core.int?,
        prefixRewrite: json_['prefixRewrite'] as core.String?,
        responseCode: json_['responseCode'] as core.String?,
        stripQuery: json_['stripQuery'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostRedirect != null) 'hostRedirect': hostRedirect!,
    if (httpsRedirect != null) 'httpsRedirect': httpsRedirect!,
    if (pathRedirect != null) 'pathRedirect': pathRedirect!,
    if (portRedirect != null) 'portRedirect': portRedirect!,
    if (prefixRewrite != null) 'prefixRewrite': prefixRewrite!,
    if (responseCode != null) 'responseCode': responseCode!,
    if (stripQuery != null) 'stripQuery': stripQuery!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteRetryPolicy
/// - networkservices:v1beta1 : HttpRouteRetryPolicy
class $HttpRouteRetryPolicy {
  /// Specifies the allowed number of retries.
  ///
  /// This number must be \> 0. If not specified, default to 1.
  core.int? numRetries;

  /// Specifies a non-zero timeout per retry attempt.
  core.String? perTryTimeout;

  /// Specifies one or more conditions when this retry policy applies.
  ///
  /// Valid values are: 5xx: Proxy will attempt a retry if the destination
  /// service responds with any 5xx response code, of if the destination service
  /// does not respond at all, example: disconnect, reset, read timeout,
  /// connection failure and refused streams. gateway-error: Similar to 5xx, but
  /// only applies to response codes 502, 503, 504. reset: Proxy will attempt a
  /// retry if the destination service does not respond at all
  /// (disconnect/reset/read timeout) connect-failure: Proxy will retry on
  /// failures connecting to destination for example due to connection timeouts.
  /// retriable-4xx: Proxy will retry fro retriable 4xx response codes.
  /// Currently the only retriable error supported is 409. refused-stream: Proxy
  /// will retry if the destination resets the stream with a REFUSED_STREAM
  /// error code. This reset type indicates that it is safe to retry.
  core.List<core.String>? retryConditions;

  $HttpRouteRetryPolicy({
    this.numRetries,
    this.perTryTimeout,
    this.retryConditions,
  });

  $HttpRouteRetryPolicy.fromJson(core.Map json_)
    : this(
        numRetries: json_['numRetries'] as core.int?,
        perTryTimeout: json_['perTryTimeout'] as core.String?,
        retryConditions:
            (json_['retryConditions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numRetries != null) 'numRetries': numRetries!,
    if (perTryTimeout != null) 'perTryTimeout': perTryTimeout!,
    if (retryConditions != null) 'retryConditions': retryConditions!,
  };
}

/// Used by:
///
/// - networkservices:v1 : HttpRouteURLRewrite
/// - networkservices:v1beta1 : HttpRouteURLRewrite
class $HttpRouteURLRewrite {
  /// Prior to forwarding the request to the selected destination, the requests
  /// host header is replaced by this value.
  core.String? hostRewrite;

  /// Prior to forwarding the request to the selected destination, the matching
  /// portion of the requests path is replaced by this value.
  core.String? pathPrefixRewrite;

  $HttpRouteURLRewrite({this.hostRewrite, this.pathPrefixRewrite});

  $HttpRouteURLRewrite.fromJson(core.Map json_)
    : this(
        hostRewrite: json_['hostRewrite'] as core.String?,
        pathPrefixRewrite: json_['pathPrefixRewrite'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostRewrite != null) 'hostRewrite': hostRewrite!,
    if (pathPrefixRewrite != null) 'pathPrefixRewrite': pathPrefixRewrite!,
  };
}

/// Used by:
///
/// - compute:beta : HttpsHealthCheck
/// - compute:v1 : HttpsHealthCheck
class $HttpsHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTPS health check request.
  ///
  /// The default value is 443.
  core.int? port;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is "/". Must comply with RFC3986.
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have a
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  $HttpsHealthCheck({
    this.checkIntervalSec,
    this.creationTimestamp,
    this.description,
    this.healthyThreshold,
    this.host,
    this.id,
    this.kind,
    this.name,
    this.port,
    this.requestPath,
    this.selfLink,
    this.timeoutSec,
    this.unhealthyThreshold,
  });

  $HttpsHealthCheck.fromJson(core.Map json_)
    : this(
        checkIntervalSec: json_['checkIntervalSec'] as core.int?,
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        healthyThreshold: json_['healthyThreshold'] as core.int?,
        host: json_['host'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        port: json_['port'] as core.int?,
        requestPath: json_['requestPath'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        timeoutSec: json_['timeoutSec'] as core.int?,
        unhealthyThreshold: json_['unhealthyThreshold'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
    if (host != null) 'host': host!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (port != null) 'port': port!,
    if (requestPath != null) 'requestPath': requestPath!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (timeoutSec != null) 'timeoutSec': timeoutSec!,
    if (unhealthyThreshold != null) 'unhealthyThreshold': unhealthyThreshold!,
  };
}

/// Used by:
///
/// - container:v1 : HugepagesConfig
/// - container:v1beta1 : HugepagesConfig
class $HugepagesConfig {
  /// Amount of 1G hugepages
  ///
  /// Optional.
  core.int? hugepageSize1g;

  /// Amount of 2M hugepages
  ///
  /// Optional.
  core.int? hugepageSize2m;

  $HugepagesConfig({this.hugepageSize1g, this.hugepageSize2m});

  $HugepagesConfig.fromJson(core.Map json_)
    : this(
        hugepageSize1g: json_['hugepageSize1g'] as core.int?,
        hugepageSize2m: json_['hugepageSize2m'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hugepageSize1g != null) 'hugepageSize1g': hugepageSize1g!,
    if (hugepageSize2m != null) 'hugepageSize2m': hugepageSize2m!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigConversationModelConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigConversationModelConfig
class $HumanAgentAssistantConfigConversationModelConfig {
  /// Version of current baseline model.
  ///
  /// It will be ignored if model is set. Valid versions are: - Article
  /// Suggestion baseline model: - 0.9 - 1.0 (default) - Summarization baseline
  /// model: - 1.0
  core.String? baselineModelVersion;

  /// Conversation model resource name.
  ///
  /// Format: `projects//conversationModels/`.
  core.String? model;

  $HumanAgentAssistantConfigConversationModelConfig({
    this.baselineModelVersion,
    this.model,
  });

  $HumanAgentAssistantConfigConversationModelConfig.fromJson(core.Map json_)
    : this(
        baselineModelVersion: json_['baselineModelVersion'] as core.String?,
        model: json_['model'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselineModelVersion != null)
      'baselineModelVersion': baselineModelVersion!,
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigConversationProcessConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigConversationProcessConfig
class $HumanAgentAssistantConfigConversationProcessConfig {
  /// Number of recent non-small-talk sentences to use as context for article
  /// and FAQ suggestion
  core.int? recentSentencesCount;

  $HumanAgentAssistantConfigConversationProcessConfig({
    this.recentSentencesCount,
  });

  $HumanAgentAssistantConfigConversationProcessConfig.fromJson(core.Map json_)
    : this(recentSentencesCount: json_['recentSentencesCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (recentSentencesCount != null)
      'recentSentencesCount': recentSentencesCount!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigMessageAnalysisConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigMessageAnalysisConfig
class $HumanAgentAssistantConfigMessageAnalysisConfig {
  /// Enable entity extraction in conversation messages on
  /// [agent assist stage](https://cloud.google.com/dialogflow/priv/docs/contact-center/basics#stages).
  ///
  /// If unspecified, defaults to false. Currently, this feature is not general
  /// available, please contact Google to get access.
  core.bool? enableEntityExtraction;

  /// Enable sentiment analysis in conversation messages on
  /// [agent assist stage](https://cloud.google.com/dialogflow/priv/docs/contact-center/basics#stages).
  ///
  /// If unspecified, defaults to false. Sentiment analysis inspects user input
  /// and identifies the prevailing subjective opinion, especially to determine
  /// a user's attitude as positive, negative, or neutral:
  /// https://cloud.google.com/natural-language/docs/basics#sentiment_analysis
  /// For Participants.StreamingAnalyzeContent method, result will be in
  /// StreamingAnalyzeContentResponse.message.SentimentAnalysisResult. For
  /// Participants.AnalyzeContent method, result will be in
  /// AnalyzeContentResponse.message.SentimentAnalysisResult For
  /// Conversations.ListMessages method, result will be in
  /// ListMessagesResponse.messages.SentimentAnalysisResult If Pub/Sub
  /// notification is configured, result will be in
  /// ConversationEvent.new_message_payload.SentimentAnalysisResult.
  core.bool? enableSentimentAnalysis;

  $HumanAgentAssistantConfigMessageAnalysisConfig({
    this.enableEntityExtraction,
    this.enableSentimentAnalysis,
  });

  $HumanAgentAssistantConfigMessageAnalysisConfig.fromJson(core.Map json_)
    : this(
        enableEntityExtraction: json_['enableEntityExtraction'] as core.bool?,
        enableSentimentAnalysis: json_['enableSentimentAnalysis'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableEntityExtraction != null)
      'enableEntityExtraction': enableEntityExtraction!,
    if (enableSentimentAnalysis != null)
      'enableSentimentAnalysis': enableSentimentAnalysis!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigSuggestionQueryConfigContextFilterSettings
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigSuggestionQueryConfigContextFilterSettings
class $HumanAgentAssistantConfigSuggestionQueryConfigContextFilterSettings {
  /// If set to true, the last message from virtual agent (hand off message) and
  /// the message before it (trigger message of hand off) are dropped.
  core.bool? dropHandoffMessages;

  /// If set to true, all messages from ivr stage are dropped.
  core.bool? dropIvrMessages;

  /// If set to true, all messages from virtual agent are dropped.
  core.bool? dropVirtualAgentMessages;

  $HumanAgentAssistantConfigSuggestionQueryConfigContextFilterSettings({
    this.dropHandoffMessages,
    this.dropIvrMessages,
    this.dropVirtualAgentMessages,
  });

  $HumanAgentAssistantConfigSuggestionQueryConfigContextFilterSettings.fromJson(
    core.Map json_,
  ) : this(
        dropHandoffMessages: json_['dropHandoffMessages'] as core.bool?,
        dropIvrMessages: json_['dropIvrMessages'] as core.bool?,
        dropVirtualAgentMessages:
            json_['dropVirtualAgentMessages'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dropHandoffMessages != null)
      'dropHandoffMessages': dropHandoffMessages!,
    if (dropIvrMessages != null) 'dropIvrMessages': dropIvrMessages!,
    if (dropVirtualAgentMessages != null)
      'dropVirtualAgentMessages': dropVirtualAgentMessages!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigSuggestionQueryConfigDialogflowQuerySourceHumanAgentSideConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigSuggestionQueryConfigDialogflowQuerySourceHumanAgentSideConfig
class $HumanAgentAssistantConfigSuggestionQueryConfigDialogflowQuerySourceHumanAgentSideConfig {
  /// The name of a dialogflow virtual agent used for intent detection and
  /// suggestion triggered by human agent.
  ///
  /// Format: `projects//locations//agent`.
  ///
  /// Optional.
  core.String? agent;

  $HumanAgentAssistantConfigSuggestionQueryConfigDialogflowQuerySourceHumanAgentSideConfig({
    this.agent,
  });

  $HumanAgentAssistantConfigSuggestionQueryConfigDialogflowQuerySourceHumanAgentSideConfig.fromJson(
    core.Map json_,
  ) : this(agent: json_['agent'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (agent != null) 'agent': agent!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentAssistantConfigSuggestionQueryConfigSections
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentAssistantConfigSuggestionQueryConfigSections
class $HumanAgentAssistantConfigSuggestionQueryConfigSections {
  /// The selected sections chosen to return when requesting a summary of a
  /// conversation.
  ///
  /// A duplicate selected section will be treated as a single selected section.
  /// If section types are not provided, the default will be {SITUATION, ACTION,
  /// RESULT}.
  core.List<core.String>? sectionTypes;

  $HumanAgentAssistantConfigSuggestionQueryConfigSections({this.sectionTypes});

  $HumanAgentAssistantConfigSuggestionQueryConfigSections.fromJson(
    core.Map json_,
  ) : this(
        sectionTypes:
            (json_['sectionTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sectionTypes != null) 'sectionTypes': sectionTypes!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentHandoffConfigLivePersonConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentHandoffConfigLivePersonConfig
class $HumanAgentHandoffConfigLivePersonConfig {
  /// Account number of the LivePerson account to connect.
  ///
  /// This is the account number you input at the login page.
  ///
  /// Required.
  core.String? accountNumber;

  $HumanAgentHandoffConfigLivePersonConfig({this.accountNumber});

  $HumanAgentHandoffConfigLivePersonConfig.fromJson(core.Map json_)
    : this(accountNumber: json_['accountNumber'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (accountNumber != null) 'accountNumber': accountNumber!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2HumanAgentHandoffConfigSalesforceLiveAgentConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1HumanAgentHandoffConfigSalesforceLiveAgentConfig
class $HumanAgentHandoffConfigSalesforceLiveAgentConfig {
  /// Live Agent chat button ID.
  ///
  /// Required.
  core.String? buttonId;

  /// Live Agent deployment ID.
  ///
  /// Required.
  core.String? deploymentId;

  /// Domain of the Live Agent endpoint for this agent.
  ///
  /// You can find the endpoint URL in the `Live Agent settings` page. For
  /// example if URL has the form
  /// https://d.la4-c2-phx.salesforceliveagent.com/..., you should fill in
  /// d.la4-c2-phx.salesforceliveagent.com.
  ///
  /// Required.
  core.String? endpointDomain;

  /// The organization ID of the Salesforce account.
  ///
  /// Required.
  core.String? organizationId;

  $HumanAgentHandoffConfigSalesforceLiveAgentConfig({
    this.buttonId,
    this.deploymentId,
    this.endpointDomain,
    this.organizationId,
  });

  $HumanAgentHandoffConfigSalesforceLiveAgentConfig.fromJson(core.Map json_)
    : this(
        buttonId: json_['buttonId'] as core.String?,
        deploymentId: json_['deploymentId'] as core.String?,
        endpointDomain: json_['endpointDomain'] as core.String?,
        organizationId: json_['organizationId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (buttonId != null) 'buttonId': buttonId!,
    if (deploymentId != null) 'deploymentId': deploymentId!,
    if (endpointDomain != null) 'endpointDomain': endpointDomain!,
    if (organizationId != null) 'organizationId': organizationId!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1HumanReviewStatus
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3HumanReviewStatus
class $HumanReviewStatus {
  /// The name of the operation triggered by the processed document.
  ///
  /// This field is populated only when the state is `HUMAN_REVIEW_IN_PROGRESS`.
  /// It has the same response type and metadata as the long-running operation
  /// returned by ReviewDocument.
  core.String? humanReviewOperation;

  /// The state of human review on the processing request.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Human review state is unspecified. Most likely due
  /// to an internal error.
  /// - "SKIPPED" : Human review is skipped for the document. This can happen
  /// because human review isn't enabled on the processor or the processing
  /// request has been set to skip this document.
  /// - "VALIDATION_PASSED" : Human review validation is triggered and passed,
  /// so no review is needed.
  /// - "IN_PROGRESS" : Human review validation is triggered and the document is
  /// under review.
  /// - "ERROR" : Some error happened during triggering human review, see the
  /// state_message for details.
  core.String? state;

  /// A message providing more details about the human review state.
  core.String? stateMessage;

  $HumanReviewStatus({
    this.humanReviewOperation,
    this.state,
    this.stateMessage,
  });

  $HumanReviewStatus.fromJson(core.Map json_)
    : this(
        humanReviewOperation: json_['humanReviewOperation'] as core.String?,
        state: json_['state'] as core.String?,
        stateMessage: json_['stateMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (humanReviewOperation != null)
      'humanReviewOperation': humanReviewOperation!,
    if (state != null) 'state': state!,
    if (stateMessage != null) 'stateMessage': stateMessage!,
  };
}

/// Used by:
///
/// - netapp:v1 : HybridPeeringDetails
/// - netapp:v1beta1 : HybridPeeringDetails
class $HybridPeeringDetails {
  /// Copy-paste-able commands to be used on user's ONTAP to accept peering
  /// requests.
  ///
  /// Output only.
  core.String? command;

  /// Expiration time for the peering command to be executed on user's ONTAP.
  ///
  /// Output only.
  core.String? commandExpiryTime;

  /// Temporary passphrase generated to accept cluster peering command.
  ///
  /// Output only.
  core.String? passphrase;

  /// Name of the user's local source cluster to be peered with the destination
  /// cluster.
  ///
  /// Output only.
  core.String? peerClusterName;

  /// Name of the user's local source vserver svm to be peered with the
  /// destination vserver svm.
  ///
  /// Output only.
  core.String? peerSvmName;

  /// Name of the user's local source volume to be peered with the destination
  /// volume.
  ///
  /// Output only.
  core.String? peerVolumeName;

  /// IP address of the subnet.
  ///
  /// Output only.
  core.String? subnetIp;

  $HybridPeeringDetails({
    this.command,
    this.commandExpiryTime,
    this.passphrase,
    this.peerClusterName,
    this.peerSvmName,
    this.peerVolumeName,
    this.subnetIp,
  });

  $HybridPeeringDetails.fromJson(core.Map json_)
    : this(
        command: json_['command'] as core.String?,
        commandExpiryTime: json_['commandExpiryTime'] as core.String?,
        passphrase: json_['passphrase'] as core.String?,
        peerClusterName: json_['peerClusterName'] as core.String?,
        peerSvmName: json_['peerSvmName'] as core.String?,
        peerVolumeName: json_['peerVolumeName'] as core.String?,
        subnetIp: json_['subnetIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (command != null) 'command': command!,
    if (commandExpiryTime != null) 'commandExpiryTime': commandExpiryTime!,
    if (passphrase != null) 'passphrase': passphrase!,
    if (peerClusterName != null) 'peerClusterName': peerClusterName!,
    if (peerSvmName != null) 'peerSvmName': peerSvmName!,
    if (peerVolumeName != null) 'peerVolumeName': peerVolumeName!,
    if (subnetIp != null) 'subnetIp': subnetIp!,
  };
}

/// Used by:
///
/// - file:v1 : IOPSPerTB
/// - file:v1beta1 : IOPSPerTB
class $IOPSPerTB {
  /// Maximum IOPS per TiB.
  ///
  /// Required.
  core.String? maxIopsPerTb;

  $IOPSPerTB({this.maxIopsPerTb});

  $IOPSPerTB.fromJson(core.Map json_)
    : this(maxIopsPerTb: json_['maxIopsPerTb'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxIopsPerTb != null) 'maxIopsPerTb': maxIopsPerTb!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : IdFilter
/// - displayvideo:v4 : IdFilter
class $IdFilter {
  /// YouTube Ads to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? adGroupAdIds;

  /// YouTube Ad Groups to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? adGroupIds;

  /// YouTube Ad Groups, by ID, to download in QA format.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  ///
  /// Optional.
  core.List<core.String>? adGroupQaIds;

  /// Campaigns to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? campaignIds;

  /// Insertion Orders to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? insertionOrderIds;

  /// Line Items to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? lineItemIds;

  /// Line Items, by ID, to download in QA format.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  ///
  /// Optional.
  core.List<core.String>? lineItemQaIds;

  /// Media Products to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  core.List<core.String>? mediaProductIds;

  $IdFilter({
    this.adGroupAdIds,
    this.adGroupIds,
    this.adGroupQaIds,
    this.campaignIds,
    this.insertionOrderIds,
    this.lineItemIds,
    this.lineItemQaIds,
    this.mediaProductIds,
  });

  $IdFilter.fromJson(core.Map json_)
    : this(
        adGroupAdIds:
            (json_['adGroupAdIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        adGroupIds:
            (json_['adGroupIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        adGroupQaIds:
            (json_['adGroupQaIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        campaignIds:
            (json_['campaignIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        insertionOrderIds:
            (json_['insertionOrderIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        lineItemIds:
            (json_['lineItemIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        lineItemQaIds:
            (json_['lineItemQaIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        mediaProductIds:
            (json_['mediaProductIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adGroupAdIds != null) 'adGroupAdIds': adGroupAdIds!,
    if (adGroupIds != null) 'adGroupIds': adGroupIds!,
    if (adGroupQaIds != null) 'adGroupQaIds': adGroupQaIds!,
    if (campaignIds != null) 'campaignIds': campaignIds!,
    if (insertionOrderIds != null) 'insertionOrderIds': insertionOrderIds!,
    if (lineItemIds != null) 'lineItemIds': lineItemIds!,
    if (lineItemQaIds != null) 'lineItemQaIds': lineItemQaIds!,
    if (mediaProductIds != null) 'mediaProductIds': mediaProductIds!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IdMatcher
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IdMatcher
class $IdMatcher {
  /// The following are accepted as `ids`: * A single-element list containing
  /// only `*`, which selects all Features in the target EntityType, or * A list
  /// containing only Feature IDs, which selects only Features with those IDs in
  /// the target EntityType.
  ///
  /// Required.
  core.List<core.String>? ids;

  $IdMatcher({this.ids});

  $IdMatcher.fromJson(core.Map json_)
    : this(
        ids:
            (json_['ids'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ids != null) 'ids': ids!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Identity
/// - ondemandscanning:v1 : Identity
/// - ondemandscanning:v1beta1 : Identity
class $Identity {
  /// The revision number of the update.
  core.int? revision;

  /// The revision independent identifier of the update.
  core.String? updateId;

  $Identity({this.revision, this.updateId});

  $Identity.fromJson(core.Map json_)
    : this(
        revision: json_['revision'] as core.int?,
        updateId: json_['updateId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (revision != null) 'revision': revision!,
    if (updateId != null) 'updateId': updateId!,
  };
}

/// Used by:
///
/// - appengine:v1 : IdentityAwareProxy
/// - appengine:v1beta : IdentityAwareProxy
class $IdentityAwareProxy {
  /// Whether the serving infrastructure will authenticate and authorize all
  /// incoming requests.If true, the oauth2_client_id and oauth2_client_secret
  /// fields must be non-empty.
  core.bool? enabled;

  /// OAuth2 client ID to use for the authentication flow.
  core.String? oauth2ClientId;

  /// OAuth2 client secret to use for the authentication flow.For security
  /// reasons, this value cannot be retrieved via the API.
  ///
  /// Instead, the SHA-256 hash of the value is returned in the
  /// oauth2_client_secret_sha256 field.@InputOnly
  core.String? oauth2ClientSecret;

  /// Hex-encoded SHA-256 hash of the client secret.@OutputOnly
  ///
  /// Output only.
  core.String? oauth2ClientSecretSha256;

  $IdentityAwareProxy({
    this.enabled,
    this.oauth2ClientId,
    this.oauth2ClientSecret,
    this.oauth2ClientSecretSha256,
  });

  $IdentityAwareProxy.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        oauth2ClientId: json_['oauth2ClientId'] as core.String?,
        oauth2ClientSecret: json_['oauth2ClientSecret'] as core.String?,
        oauth2ClientSecretSha256:
            json_['oauth2ClientSecretSha256'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (oauth2ClientId != null) 'oauth2ClientId': oauth2ClientId!,
    if (oauth2ClientSecret != null) 'oauth2ClientSecret': oauth2ClientSecret!,
    if (oauth2ClientSecretSha256 != null)
      'oauth2ClientSecretSha256': oauth2ClientSecretSha256!,
  };
}

/// Used by:
///
/// - compute:alpha : ShieldedInstanceIdentityEntry
/// - compute:alpha : ShieldedVmIdentityEntry
/// - compute:beta : ShieldedInstanceIdentityEntry
/// - compute:beta : ShieldedVmIdentityEntry
/// - compute:v1 : ShieldedInstanceIdentityEntry
class $IdentityEntry {
  /// A PEM-encoded X.509 certificate.
  ///
  /// This field can be empty.
  core.String? ekCert;

  /// A PEM-encoded public key.
  core.String? ekPub;

  $IdentityEntry({this.ekCert, this.ekPub});

  $IdentityEntry.fromJson(core.Map json_)
    : this(
        ekCert: json_['ekCert'] as core.String?,
        ekPub: json_['ekPub'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ekCert != null) 'ekCert': ekCert!,
    if (ekPub != null) 'ekPub': ekPub!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1IdentityMappingEntry
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaIdentityMappingEntry
class $IdentityMappingEntry {
  /// Identity outside the customer identity provider.
  ///
  /// The length limit of external identity will be of 100 characters.
  ///
  /// Required.
  core.String? externalIdentity;

  /// Group identifier.
  ///
  /// For Google Workspace user account, group_id should be the google workspace
  /// group email. For non-google identity provider, group_id is the mapped
  /// group identifier configured during the workforcepool config.
  core.String? groupId;

  /// User identifier.
  ///
  /// For Google Workspace user account, user_id should be the google workspace
  /// user email. For non-google identity provider, user_id is the mapped user
  /// identifier configured during the workforcepool config.
  core.String? userId;

  $IdentityMappingEntry({this.externalIdentity, this.groupId, this.userId});

  $IdentityMappingEntry.fromJson(core.Map json_)
    : this(
        externalIdentity: json_['externalIdentity'] as core.String?,
        groupId: json_['groupId'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalIdentity != null) 'externalIdentity': externalIdentity!,
    if (groupId != null) 'groupId': groupId!,
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceAzureADConfig
/// - gkehub:v1alpha : IdentityServiceAzureADConfig
/// - gkehub:v1beta : IdentityServiceAzureADConfig
/// - gkehub:v2 : IdentityServiceAzureADConfig
/// - gkehub:v2alpha : IdentityServiceAzureADConfig
/// - gkehub:v2beta : IdentityServiceAzureADConfig
class $IdentityServiceAzureADConfig {
  /// ID for the registered client application that makes authentication
  /// requests to the Azure AD identity provider.
  core.String? clientId;

  /// Input only.
  ///
  /// Unencrypted AzureAD client secret will be passed to the GKE Hub CLH.
  core.String? clientSecret;

  /// Encrypted AzureAD client secret.
  ///
  /// Output only.
  core.String? encryptedClientSecret;
  core.List<core.int> get encryptedClientSecretAsBytes =>
      convert.base64.decode(encryptedClientSecret!);

  set encryptedClientSecretAsBytes(core.List<core.int> bytes_) {
    encryptedClientSecret = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Format of the AzureAD groups that the client wants for auth.
  ///
  /// Optional.
  core.String? groupFormat;

  /// The redirect URL that kubectl uses for authorization.
  core.String? kubectlRedirectUri;

  /// Kind of Azure AD account to be authenticated.
  ///
  /// Supported values are or for accounts belonging to a specific tenant.
  core.String? tenant;

  /// Claim in the AzureAD ID Token that holds the user details.
  ///
  /// Optional.
  core.String? userClaim;

  $IdentityServiceAzureADConfig({
    this.clientId,
    this.clientSecret,
    this.encryptedClientSecret,
    this.groupFormat,
    this.kubectlRedirectUri,
    this.tenant,
    this.userClaim,
  });

  $IdentityServiceAzureADConfig.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        clientSecret: json_['clientSecret'] as core.String?,
        encryptedClientSecret: json_['encryptedClientSecret'] as core.String?,
        groupFormat: json_['groupFormat'] as core.String?,
        kubectlRedirectUri: json_['kubectlRedirectUri'] as core.String?,
        tenant: json_['tenant'] as core.String?,
        userClaim: json_['userClaim'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (encryptedClientSecret != null)
      'encryptedClientSecret': encryptedClientSecret!,
    if (groupFormat != null) 'groupFormat': groupFormat!,
    if (kubectlRedirectUri != null) 'kubectlRedirectUri': kubectlRedirectUri!,
    if (tenant != null) 'tenant': tenant!,
    if (userClaim != null) 'userClaim': userClaim!,
  };
}

/// Used by:
///
/// - container:v1 : IdentityServiceConfig
/// - container:v1beta1 : IdentityServiceConfig
class $IdentityServiceConfig {
  /// Whether to enable the Identity Service component
  core.bool? enabled;

  $IdentityServiceConfig({this.enabled});

  $IdentityServiceConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceDiagnosticInterface
/// - gkehub:v1alpha : IdentityServiceDiagnosticInterface
/// - gkehub:v1beta : IdentityServiceDiagnosticInterface
/// - gkehub:v2 : IdentityServiceDiagnosticInterface
/// - gkehub:v2alpha : IdentityServiceDiagnosticInterface
/// - gkehub:v2beta : IdentityServiceDiagnosticInterface
class $IdentityServiceDiagnosticInterface {
  /// Determines whether to enable the diagnostic interface.
  core.bool? enabled;

  /// Determines the expiration time of the diagnostic interface enablement.
  ///
  /// When reached, requests to the interface would be automatically rejected.
  core.String? expirationTime;

  $IdentityServiceDiagnosticInterface({this.enabled, this.expirationTime});

  $IdentityServiceDiagnosticInterface.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        expirationTime: json_['expirationTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (expirationTime != null) 'expirationTime': expirationTime!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceGoogleConfig
/// - gkehub:v1alpha : IdentityServiceGoogleConfig
/// - gkehub:v1beta : IdentityServiceGoogleConfig
/// - gkehub:v2 : IdentityServiceGoogleConfig
/// - gkehub:v2alpha : IdentityServiceGoogleConfig
/// - gkehub:v2beta : IdentityServiceGoogleConfig
class $IdentityServiceGoogleConfig {
  /// Disable automatic configuration of Google Plugin on supported platforms.
  core.bool? disable;

  $IdentityServiceGoogleConfig({this.disable});

  $IdentityServiceGoogleConfig.fromJson(core.Map json_)
    : this(disable: json_['disable'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disable != null) 'disable': disable!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceGroupConfig
/// - gkehub:v1alpha : IdentityServiceGroupConfig
/// - gkehub:v1beta : IdentityServiceGroupConfig
/// - gkehub:v2 : IdentityServiceGroupConfig
/// - gkehub:v2alpha : IdentityServiceGroupConfig
/// - gkehub:v2beta : IdentityServiceGroupConfig
class $IdentityServiceGroupConfig {
  /// The location of the subtree in the LDAP directory to search for group
  /// entries.
  ///
  /// Required.
  core.String? baseDn;

  /// Optional filter to be used when searching for groups a user belongs to.
  ///
  /// This can be used to explicitly match only certain groups in order to
  /// reduce the amount of groups returned for each user. This defaults to
  /// "(objectClass=Group)".
  ///
  /// Optional.
  core.String? filter;

  /// The identifying name of each group a user belongs to.
  ///
  /// For example, if this is set to "distinguishedName" then RBACs and other
  /// group expectations should be written as full DNs. This defaults to
  /// "distinguishedName".
  ///
  /// Optional.
  core.String? idAttribute;

  $IdentityServiceGroupConfig({this.baseDn, this.filter, this.idAttribute});

  $IdentityServiceGroupConfig.fromJson(core.Map json_)
    : this(
        baseDn: json_['baseDn'] as core.String?,
        filter: json_['filter'] as core.String?,
        idAttribute: json_['idAttribute'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseDn != null) 'baseDn': baseDn!,
    if (filter != null) 'filter': filter!,
    if (idAttribute != null) 'idAttribute': idAttribute!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceOidcConfig
/// - gkehub:v1alpha : IdentityServiceOidcConfig
/// - gkehub:v1beta : IdentityServiceOidcConfig
/// - gkehub:v2 : IdentityServiceOidcConfig
/// - gkehub:v2alpha : IdentityServiceOidcConfig
/// - gkehub:v2beta : IdentityServiceOidcConfig
class $IdentityServiceOidcConfig {
  /// PEM-encoded CA for OIDC provider.
  core.String? certificateAuthorityData;

  /// ID for OIDC client application.
  core.String? clientId;

  /// Input only.
  ///
  /// Unencrypted OIDC client secret will be passed to the GKE Hub CLH.
  core.String? clientSecret;

  /// Flag to denote if reverse proxy is used to connect to auth provider.
  ///
  /// This flag should be set to true when provider is not reachable by Google
  /// Cloud Console.
  core.bool? deployCloudConsoleProxy;

  /// Enable access token.
  core.bool? enableAccessToken;

  /// Encrypted OIDC Client secret
  ///
  /// Output only.
  core.String? encryptedClientSecret;
  core.List<core.int> get encryptedClientSecretAsBytes =>
      convert.base64.decode(encryptedClientSecret!);

  set encryptedClientSecretAsBytes(core.List<core.int> bytes_) {
    encryptedClientSecret = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Comma-separated list of key-value pairs.
  core.String? extraParams;

  /// Prefix to prepend to group name.
  core.String? groupPrefix;

  /// Claim in OIDC ID token that holds group information.
  core.String? groupsClaim;

  /// URI for the OIDC provider.
  ///
  /// This should point to the level below .well-known/openid-configuration.
  core.String? issuerUri;

  /// Registered redirect uri to redirect users going through OAuth flow using
  /// kubectl plugin.
  core.String? kubectlRedirectUri;

  /// Comma-separated list of identifiers.
  core.String? scopes;

  /// Claim in OIDC ID token that holds username.
  core.String? userClaim;

  /// Prefix to prepend to user name.
  core.String? userPrefix;

  $IdentityServiceOidcConfig({
    this.certificateAuthorityData,
    this.clientId,
    this.clientSecret,
    this.deployCloudConsoleProxy,
    this.enableAccessToken,
    this.encryptedClientSecret,
    this.extraParams,
    this.groupPrefix,
    this.groupsClaim,
    this.issuerUri,
    this.kubectlRedirectUri,
    this.scopes,
    this.userClaim,
    this.userPrefix,
  });

  $IdentityServiceOidcConfig.fromJson(core.Map json_)
    : this(
        certificateAuthorityData:
            json_['certificateAuthorityData'] as core.String?,
        clientId: json_['clientId'] as core.String?,
        clientSecret: json_['clientSecret'] as core.String?,
        deployCloudConsoleProxy: json_['deployCloudConsoleProxy'] as core.bool?,
        enableAccessToken: json_['enableAccessToken'] as core.bool?,
        encryptedClientSecret: json_['encryptedClientSecret'] as core.String?,
        extraParams: json_['extraParams'] as core.String?,
        groupPrefix: json_['groupPrefix'] as core.String?,
        groupsClaim: json_['groupsClaim'] as core.String?,
        issuerUri: json_['issuerUri'] as core.String?,
        kubectlRedirectUri: json_['kubectlRedirectUri'] as core.String?,
        scopes: json_['scopes'] as core.String?,
        userClaim: json_['userClaim'] as core.String?,
        userPrefix: json_['userPrefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateAuthorityData != null)
      'certificateAuthorityData': certificateAuthorityData!,
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (deployCloudConsoleProxy != null)
      'deployCloudConsoleProxy': deployCloudConsoleProxy!,
    if (enableAccessToken != null) 'enableAccessToken': enableAccessToken!,
    if (encryptedClientSecret != null)
      'encryptedClientSecret': encryptedClientSecret!,
    if (extraParams != null) 'extraParams': extraParams!,
    if (groupPrefix != null) 'groupPrefix': groupPrefix!,
    if (groupsClaim != null) 'groupsClaim': groupsClaim!,
    if (issuerUri != null) 'issuerUri': issuerUri!,
    if (kubectlRedirectUri != null) 'kubectlRedirectUri': kubectlRedirectUri!,
    if (scopes != null) 'scopes': scopes!,
    if (userClaim != null) 'userClaim': userClaim!,
    if (userPrefix != null) 'userPrefix': userPrefix!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceSamlConfig
/// - gkehub:v1alpha : IdentityServiceSamlConfig
/// - gkehub:v1beta : IdentityServiceSamlConfig
/// - gkehub:v2 : IdentityServiceSamlConfig
/// - gkehub:v2alpha : IdentityServiceSamlConfig
/// - gkehub:v2beta : IdentityServiceSamlConfig
class $IdentityServiceSamlConfig {
  /// The mapping of additional user attributes like nickname, birthday and
  /// address etc..
  ///
  /// `key` is the name of this additional attribute. `value` is a string
  /// presenting as CEL(common expression language, go/cel) used for getting the
  /// value from the resources. Take nickname as an example, in this case, `key`
  /// is "attribute.nickname" and `value` is "assertion.nickname".
  ///
  /// Optional.
  core.Map<core.String, core.String>? attributeMapping;

  /// Prefix to prepend to group name.
  ///
  /// Optional.
  core.String? groupPrefix;

  /// The SAML attribute to read groups from.
  ///
  /// This value is expected to be a string and will be passed along as-is (with
  /// the option of being prefixed by the `group_prefix`).
  ///
  /// Optional.
  core.String? groupsAttribute;

  /// The list of IdP certificates to validate the SAML response against.
  ///
  /// Required.
  core.List<core.String>? identityProviderCertificates;

  /// The entity ID of the SAML IdP.
  ///
  /// Required.
  core.String? identityProviderId;

  /// The URI where the SAML IdP exposes the SSO service.
  ///
  /// Required.
  core.String? identityProviderSsoUri;

  /// The SAML attribute to read username from.
  ///
  /// If unspecified, the username will be read from the NameID element of the
  /// assertion in SAML response. This value is expected to be a string and will
  /// be passed along as-is (with the option of being prefixed by the
  /// `user_prefix`).
  ///
  /// Optional.
  core.String? userAttribute;

  /// Prefix to prepend to user name.
  ///
  /// Optional.
  core.String? userPrefix;

  $IdentityServiceSamlConfig({
    this.attributeMapping,
    this.groupPrefix,
    this.groupsAttribute,
    this.identityProviderCertificates,
    this.identityProviderId,
    this.identityProviderSsoUri,
    this.userAttribute,
    this.userPrefix,
  });

  $IdentityServiceSamlConfig.fromJson(core.Map json_)
    : this(
        attributeMapping: (json_['attributeMapping']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        groupPrefix: json_['groupPrefix'] as core.String?,
        groupsAttribute: json_['groupsAttribute'] as core.String?,
        identityProviderCertificates:
            (json_['identityProviderCertificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        identityProviderId: json_['identityProviderId'] as core.String?,
        identityProviderSsoUri: json_['identityProviderSsoUri'] as core.String?,
        userAttribute: json_['userAttribute'] as core.String?,
        userPrefix: json_['userPrefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeMapping != null) 'attributeMapping': attributeMapping!,
    if (groupPrefix != null) 'groupPrefix': groupPrefix!,
    if (groupsAttribute != null) 'groupsAttribute': groupsAttribute!,
    if (identityProviderCertificates != null)
      'identityProviderCertificates': identityProviderCertificates!,
    if (identityProviderId != null) 'identityProviderId': identityProviderId!,
    if (identityProviderSsoUri != null)
      'identityProviderSsoUri': identityProviderSsoUri!,
    if (userAttribute != null) 'userAttribute': userAttribute!,
    if (userPrefix != null) 'userPrefix': userPrefix!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceServerConfig
/// - gkehub:v1alpha : IdentityServiceServerConfig
/// - gkehub:v1beta : IdentityServiceServerConfig
/// - gkehub:v2 : IdentityServiceServerConfig
/// - gkehub:v2alpha : IdentityServiceServerConfig
/// - gkehub:v2beta : IdentityServiceServerConfig
class $IdentityServiceServerConfig {
  /// Contains a Base64 encoded, PEM formatted certificate authority certificate
  /// for the LDAP server.
  ///
  /// This must be provided for the "ldaps" and "startTLS" connections.
  ///
  /// Optional.
  core.String? certificateAuthorityData;
  core.List<core.int> get certificateAuthorityDataAsBytes =>
      convert.base64.decode(certificateAuthorityData!);

  set certificateAuthorityDataAsBytes(core.List<core.int> bytes_) {
    certificateAuthorityData = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Defines the connection type to communicate with the LDAP server.
  ///
  /// If `starttls` or `ldaps` is specified, the certificate_authority_data
  /// should not be empty.
  ///
  /// Optional.
  core.String? connectionType;

  /// Defines the hostname or IP of the LDAP server.
  ///
  /// Port is optional and will default to 389, if unspecified. For example,
  /// "ldap.server.example" or "10.10.10.10:389".
  ///
  /// Required.
  core.String? host;

  $IdentityServiceServerConfig({
    this.certificateAuthorityData,
    this.connectionType,
    this.host,
  });

  $IdentityServiceServerConfig.fromJson(core.Map json_)
    : this(
        certificateAuthorityData:
            json_['certificateAuthorityData'] as core.String?,
        connectionType: json_['connectionType'] as core.String?,
        host: json_['host'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateAuthorityData != null)
      'certificateAuthorityData': certificateAuthorityData!,
    if (connectionType != null) 'connectionType': connectionType!,
    if (host != null) 'host': host!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceSimpleBindCredentials
/// - gkehub:v1alpha : IdentityServiceSimpleBindCredentials
/// - gkehub:v1beta : IdentityServiceSimpleBindCredentials
/// - gkehub:v2 : IdentityServiceSimpleBindCredentials
/// - gkehub:v2alpha : IdentityServiceSimpleBindCredentials
/// - gkehub:v2beta : IdentityServiceSimpleBindCredentials
class $IdentityServiceSimpleBindCredentials {
  /// The distinguished name(DN) of the service account object/user.
  ///
  /// Required.
  core.String? dn;

  /// The encrypted password of the service account object/user.
  ///
  /// Output only.
  core.String? encryptedPassword;
  core.List<core.int> get encryptedPasswordAsBytes =>
      convert.base64.decode(encryptedPassword!);

  set encryptedPasswordAsBytes(core.List<core.int> bytes_) {
    encryptedPassword = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Input only.
  ///
  /// The password of the service account object/user.
  ///
  /// Required.
  core.String? password;

  $IdentityServiceSimpleBindCredentials({
    this.dn,
    this.encryptedPassword,
    this.password,
  });

  $IdentityServiceSimpleBindCredentials.fromJson(core.Map json_)
    : this(
        dn: json_['dn'] as core.String?,
        encryptedPassword: json_['encryptedPassword'] as core.String?,
        password: json_['password'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dn != null) 'dn': dn!,
    if (encryptedPassword != null) 'encryptedPassword': encryptedPassword!,
    if (password != null) 'password': password!,
  };
}

/// Used by:
///
/// - gkehub:v1 : IdentityServiceUserConfig
/// - gkehub:v1alpha : IdentityServiceUserConfig
/// - gkehub:v1beta : IdentityServiceUserConfig
/// - gkehub:v2 : IdentityServiceUserConfig
/// - gkehub:v2alpha : IdentityServiceUserConfig
/// - gkehub:v2beta : IdentityServiceUserConfig
class $IdentityServiceUserConfig {
  /// The location of the subtree in the LDAP directory to search for user
  /// entries.
  ///
  /// Required.
  core.String? baseDn;

  /// Filter to apply when searching for the user.
  ///
  /// This can be used to further restrict the user accounts which are allowed
  /// to login. This defaults to "(objectClass=User)".
  ///
  /// Optional.
  core.String? filter;

  /// Determines which attribute to use as the user's identity after they are
  /// authenticated.
  ///
  /// This is distinct from the loginAttribute field to allow users to login
  /// with a username, but then have their actual identifier be an email address
  /// or full Distinguished Name (DN). For example, setting loginAttribute to
  /// "sAMAccountName" and identifierAttribute to "userPrincipalName" would
  /// allow a user to login as "bsmith", but actual RBAC policies for the user
  /// would be written as "bsmith@example.com". Using "userPrincipalName" is
  /// recommended since this will be unique for each user. This defaults to
  /// "userPrincipalName".
  ///
  /// Optional.
  core.String? idAttribute;

  /// The name of the attribute which matches against the input username.
  ///
  /// This is used to find the user in the LDAP database e.g. "(=)" and is
  /// combined with the optional filter field. This defaults to
  /// "userPrincipalName".
  ///
  /// Optional.
  core.String? loginAttribute;

  $IdentityServiceUserConfig({
    this.baseDn,
    this.filter,
    this.idAttribute,
    this.loginAttribute,
  });

  $IdentityServiceUserConfig.fromJson(core.Map json_)
    : this(
        baseDn: json_['baseDn'] as core.String?,
        filter: json_['filter'] as core.String?,
        idAttribute: json_['idAttribute'] as core.String?,
        loginAttribute: json_['loginAttribute'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseDn != null) 'baseDn': baseDn!,
    if (filter != null) 'filter': filter!,
    if (idAttribute != null) 'idAttribute': idAttribute!,
    if (loginAttribute != null) 'loginAttribute': loginAttribute!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2Image
/// - retail:v2alpha : GoogleCloudRetailV2alphaImage
/// - retail:v2beta : GoogleCloudRetailV2betaImage
class $Image00 {
  /// Height of the image in number of pixels.
  ///
  /// This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  core.int? height;

  /// URI of the image.
  ///
  /// This field must be a valid UTF-8 encoded URI with a length limit of 5,000
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned. Google
  /// Merchant Center property
  /// [image_link](https://support.google.com/merchants/answer/6324350).
  /// Schema.org property [Product.image](https://schema.org/image).
  ///
  /// Required.
  core.String? uri;

  /// Width of the image in number of pixels.
  ///
  /// This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  core.int? width;

  $Image00({this.height, this.uri, this.width});

  $Image00.fromJson(core.Map json_)
    : this(
        height: json_['height'] as core.int?,
        uri: json_['uri'] as core.String?,
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (height != null) 'height': height!,
    if (uri != null) 'uri': uri!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : Image
/// - realtimebidding:v1 : Image
class $Image01 {
  /// Image height in pixels.
  core.int? height;

  /// The URL of the image.
  core.String? url;

  /// Image width in pixels.
  core.int? width;

  $Image01({this.height, this.url, this.width});

  $Image01.fromJson(core.Map json_)
    : this(
        height: json_['height'] as core.int?,
        url: json_['url'] as core.String?,
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (height != null) 'height': height!,
    if (url != null) 'url': url!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Image
/// - healthcare:v1beta1 : Image
class $Image02 {
  /// Input only.
  ///
  /// Points to a Cloud Storage URI containing the consent artifact content. The
  /// URI must be in the following format: `gs://{bucket_id}/{object_id}`. The
  /// Cloud Healthcare API service account must have the
  /// `roles/storage.objectViewer` Cloud IAM role for this Cloud Storage
  /// location. The consent artifact content at this URI is copied to a Cloud
  /// Storage location managed by the Cloud Healthcare API. Responses to
  /// fetching requests return the consent artifact content in raw_bytes.
  core.String? gcsUri;

  /// Consent artifact content represented as a stream of bytes.
  ///
  /// This field is populated when returned in GetConsentArtifact response, but
  /// not included in CreateConsentArtifact and ListConsentArtifact response.
  core.String? rawBytes;
  core.List<core.int> get rawBytesAsBytes => convert.base64.decode(rawBytes!);

  set rawBytesAsBytes(core.List<core.int> bytes_) {
    rawBytes = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Image02({this.gcsUri, this.rawBytes});

  $Image02.fromJson(core.Map json_)
    : this(
        gcsUri: json_['gcsUri'] as core.String?,
        rawBytes: json_['rawBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsUri != null) 'gcsUri': gcsUri!,
    if (rawBytes != null) 'rawBytes': rawBytes!,
  };
}

/// Used by:
///
/// - vision:v1 : ImageAnnotationContext
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1ImageAnnotationContext
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1ImageAnnotationContext
class $ImageAnnotationContext {
  /// If the file was a PDF or TIFF, this field gives the page number within the
  /// file used to produce the image.
  core.int? pageNumber;

  /// The URI of the file used to produce the image.
  core.String? uri;

  $ImageAnnotationContext({this.pageNumber, this.uri});

  $ImageAnnotationContext.fromJson(core.Map json_)
    : this(
        pageNumber: json_['pageNumber'] as core.int?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageNumber != null) 'pageNumber': pageNumber!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpAppconnectorsV1ImageConfig
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpAppconnectorsV1alphaImageConfig
class $ImageConfig {
  /// The stable image that the remote agent will fallback to if the target
  /// image fails.
  ///
  /// Format would be a gcr image path, e.g.: gcr.io/PROJECT-ID/my-image:tag1
  core.String? stableImage;

  /// The initial image the remote agent will attempt to run for the control
  /// plane.
  ///
  /// Format would be a gcr image path, e.g.: gcr.io/PROJECT-ID/my-image:tag1
  core.String? targetImage;

  $ImageConfig({this.stableImage, this.targetImage});

  $ImageConfig.fromJson(core.Map json_)
    : this(
        stableImage: json_['stableImage'] as core.String?,
        targetImage: json_['targetImage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (stableImage != null) 'stableImage': stableImage!,
    if (targetImage != null) 'targetImage': targetImage!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ImageImportOsAdaptationParameters
/// - vmmigration:v1alpha1 : ImageImportOsAdaptationParameters
class $ImageImportOsAdaptationParameters {
  /// By default the image will keep its existing boot option.
  ///
  /// Setting this property will trigger an internal process which will convert
  /// the image from using the existing boot option to another. The size of the
  /// boot disk might be increased to allow the conversion
  ///
  /// Optional.
  /// Possible string values are:
  /// - "BOOT_CONVERSION_UNSPECIFIED" : Unspecified conversion type.
  /// - "NONE" : No conversion.
  /// - "BIOS_TO_EFI" : Convert from BIOS to EFI.
  core.String? bootConversion;

  /// Set to true in order to generalize the imported image.
  ///
  /// The generalization process enables co-existence of multiple VMs created
  /// from the same image. For Windows, generalizing the image removes
  /// computer-specific information such as installed drivers and the computer
  /// security identifier (SID).
  ///
  /// Optional.
  core.bool? generalize;

  /// Choose which type of license to apply to the imported image.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT" : The license type is the default
  /// for the OS.
  /// - "COMPUTE_ENGINE_LICENSE_TYPE_PAYG" : The license type is Pay As You Go
  /// license type.
  /// - "COMPUTE_ENGINE_LICENSE_TYPE_BYOL" : The license type is Bring Your Own
  /// License type.
  core.String? licenseType;

  $ImageImportOsAdaptationParameters({
    this.bootConversion,
    this.generalize,
    this.licenseType,
  });

  $ImageImportOsAdaptationParameters.fromJson(core.Map json_)
    : this(
        bootConversion: json_['bootConversion'] as core.String?,
        generalize: json_['generalize'] as core.bool?,
        licenseType: json_['licenseType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bootConversion != null) 'bootConversion': bootConversion!,
    if (generalize != null) 'generalize': generalize!,
    if (licenseType != null) 'licenseType': licenseType!,
  };
}

/// Used by:
///
/// - vision:v1 : ImageSource
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1ImageSource
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1ImageSource
class $ImageSource {
  /// **Use `image_uri` instead.** The Google Cloud Storage URI of the form
  /// `gs://bucket_name/object_name`.
  ///
  /// Object versioning is not supported. See
  /// [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris)
  /// for more info.
  core.String? gcsImageUri;

  /// The URI of the source image.
  ///
  /// Can be either: 1. A Google Cloud Storage URI of the form
  /// `gs://bucket_name/object_name`. Object versioning is not supported. See
  /// [Google Cloud Storage Request URIs](https://cloud.google.com/storage/docs/reference-uris)
  /// for more info. 2. A publicly-accessible image HTTP/HTTPS URL. When
  /// fetching images from HTTP/HTTPS URLs, Google cannot guarantee that the
  /// request will be completed. Your request may fail if the specified host
  /// denies the request (e.g. due to request throttling or DOS prevention), or
  /// if Google throttles requests to the site for abuse prevention. You should
  /// not depend on externally-hosted images for production applications. When
  /// both `gcs_image_uri` and `image_uri` are specified, `image_uri` takes
  /// precedence.
  core.String? imageUri;

  $ImageSource({this.gcsImageUri, this.imageUri});

  $ImageSource.fromJson(core.Map json_)
    : this(
        gcsImageUri: json_['gcsImageUri'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsImageUri != null) 'gcsImageUri': gcsImageUri!,
    if (imageUri != null) 'imageUri': imageUri!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : Impersonation
/// - firebasedataconnect:v1beta : Impersonation
class $Impersonation {
  /// Evaluate the auth policy with a customized JWT auth token.
  ///
  /// Should follow the Firebase Auth token format.
  /// https://firebase.google.com/docs/rules/rules-and-auth For example: a
  /// verified user may have auth_claims of {"sub": , "email_verified": true}
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? authClaims;

  /// If set, include debug details in GraphQL error extensions.
  ///
  /// Optional.
  core.bool? includeDebugDetails;

  /// Evaluate the auth policy as an unauthenticated request.
  ///
  /// Can only be set to true.
  core.bool? unauthenticated;

  $Impersonation({
    this.authClaims,
    this.includeDebugDetails,
    this.unauthenticated,
  });

  $Impersonation.fromJson(core.Map json_)
    : this(
        authClaims:
            json_.containsKey('authClaims')
                ? json_['authClaims'] as core.Map<core.String, core.dynamic>
                : null,
        includeDebugDetails: json_['includeDebugDetails'] as core.bool?,
        unauthenticated: json_['unauthenticated'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authClaims != null) 'authClaims': authClaims!,
    if (includeDebugDetails != null)
      'includeDebugDetails': includeDebugDetails!,
    if (unauthenticated != null) 'unauthenticated': unauthenticated!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ImportAgentRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ImportAgentRequest
class $ImportAgentRequest {
  /// Zip compressed raw byte content for agent.
  core.String? agentContent;
  core.List<core.int> get agentContentAsBytes =>
      convert.base64.decode(agentContent!);

  set agentContentAsBytes(core.List<core.int> bytes_) {
    agentContent = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The URI to a Google Cloud Storage file containing the agent to import.
  ///
  /// Note: The URI must start with "gs://". Dialogflow performs a read
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have read permissions for the object. For more
  /// information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  core.String? agentUri;

  $ImportAgentRequest({this.agentContent, this.agentUri});

  $ImportAgentRequest.fromJson(core.Map json_)
    : this(
        agentContent: json_['agentContent'] as core.String?,
        agentUri: json_['agentUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentContent != null) 'agentContent': agentContent!,
    if (agentUri != null) 'agentUri': agentUri!,
  };
}

/// Used by:
///
/// - domains:v1 : ImportDomainRequest
/// - domains:v1alpha2 : ImportDomainRequest
/// - domains:v1beta1 : ImportDomainRequest
class $ImportDomainRequest {
  /// The domain name.
  ///
  /// Unicode domain names must be expressed in Punycode format.
  ///
  /// Required.
  core.String? domainName;

  /// Set of labels associated with the `Registration`.
  core.Map<core.String, core.String>? labels;

  $ImportDomainRequest({this.domainName, this.labels});

  $ImportDomainRequest.fromJson(core.Map json_)
    : this(
        domainName: json_['domainName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domainName != null) 'domainName': domainName!,
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ImportError
/// - migrationcenter:v1alpha1 : ImportError
class $ImportError {
  /// The error information.
  core.String? errorDetails;

  /// The severity of the error.
  /// Possible string values are:
  /// - "SEVERITY_UNSPECIFIED"
  /// - "ERROR"
  /// - "WARNING"
  /// - "INFO"
  core.String? severity;

  $ImportError({this.errorDetails, this.severity});

  $ImportError.fromJson(core.Map json_)
    : this(
        errorDetails: json_['errorDetails'] as core.String?,
        severity: json_['severity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorDetails != null) 'errorDetails': errorDetails!,
    if (severity != null) 'severity': severity!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ImportErrorConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaImportErrorConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaImportErrorConfig
class $ImportErrorConfig {
  /// Cloud Storage prefix for import errors.
  ///
  /// This must be an empty, existing Cloud Storage directory. Import errors are
  /// written to sharded files in this directory, one per line, as a
  /// JSON-encoded `google.rpc.Status` message.
  core.String? gcsPrefix;

  $ImportErrorConfig({this.gcsPrefix});

  $ImportErrorConfig.fromJson(core.Map json_)
    : this(gcsPrefix: json_['gcsPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsPrefix != null) 'gcsPrefix': gcsPrefix!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ImportErrorsConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaImportErrorsConfig
/// - retail:v2beta : GoogleCloudRetailV2betaImportErrorsConfig
class $ImportErrorsConfig {
  /// Google Cloud Storage prefix for import errors.
  ///
  /// This must be an empty, existing Cloud Storage directory. Import errors are
  /// written to sharded files in this directory, one per line, as a
  /// JSON-encoded `google.rpc.Status` message.
  core.String? gcsPrefix;

  $ImportErrorsConfig({this.gcsPrefix});

  $ImportErrorsConfig.fromJson(core.Map json_)
    : this(gcsPrefix: json_['gcsPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsPrefix != null) 'gcsPrefix': gcsPrefix!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ImportFeatureValuesRequestFeatureSpec
class $ImportFeatureValuesRequestFeatureSpec {
  /// ID of the Feature to import values of.
  ///
  /// This Feature must exist in the target EntityType, or the request will
  /// fail.
  ///
  /// Required.
  core.String? id;

  /// Source column to get the Feature values from.
  ///
  /// If not set, uses the column with the same name as the Feature ID.
  core.String? sourceField;

  $ImportFeatureValuesRequestFeatureSpec({this.id, this.sourceField});

  $ImportFeatureValuesRequestFeatureSpec.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        sourceField: json_['sourceField'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (sourceField != null) 'sourceField': sourceField!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : ImportFile
/// - deploymentmanager:v2 : ImportFile
/// - deploymentmanager:v2beta : ImportFile
class $ImportFile {
  /// The contents of the file.
  core.String? content;

  /// The name of the file.
  core.String? name;

  $ImportFile({this.content, this.name});

  $ImportFile.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ImportRowErrorCsvErrorDetails
/// - migrationcenter:v1alpha1 : ImportRowErrorCsvErrorDetails
class $ImportRowErrorCsvErrorDetails {
  /// The row number where the error was detected.
  core.int? rowNumber;

  $ImportRowErrorCsvErrorDetails({this.rowNumber});

  $ImportRowErrorCsvErrorDetails.fromJson(core.Map json_)
    : this(rowNumber: json_['rowNumber'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (rowNumber != null) 'rowNumber': rowNumber!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ImportRowErrorXlsxErrorDetails
/// - migrationcenter:v1alpha1 : ImportRowErrorXlsxErrorDetails
class $ImportRowErrorXlsxErrorDetails {
  /// The row number where the error was detected.
  core.int? rowNumber;

  /// The name of the sheet where the error was detected.
  core.String? sheet;

  $ImportRowErrorXlsxErrorDetails({this.rowNumber, this.sheet});

  $ImportRowErrorXlsxErrorDetails.fromJson(core.Map json_)
    : this(
        rowNumber: json_['rowNumber'] as core.int?,
        sheet: json_['sheet'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rowNumber != null) 'rowNumber': rowNumber!,
    if (sheet != null) 'sheet': sheet!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ImportTestCasesRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ImportTestCasesRequest
class $ImportTestCasesRequest {
  /// Uncompressed raw byte content for test cases.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
  /// import test cases from.
  ///
  /// The format of this URI must be `gs:///`. Dialogflow performs a read
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have read permissions for the object. For more
  /// information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  core.String? gcsUri;

  $ImportTestCasesRequest({this.content, this.gcsUri});

  $ImportTestCasesRequest.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        gcsUri: json_['gcsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (gcsUri != null) 'gcsUri': gcsUri!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessInListFilter
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessInListFilter
/// - analyticsdata:v1beta : InListFilter
class $InListFilter {
  /// If true, the string value is case sensitive.
  core.bool? caseSensitive;

  /// The list of string values.
  ///
  /// Must be non-empty.
  core.List<core.String>? values;

  $InListFilter({this.caseSensitive, this.values});

  $InListFilter.fromJson(core.Map json_)
    : this(
        caseSensitive: json_['caseSensitive'] as core.bool?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseSensitive != null) 'caseSensitive': caseSensitive!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - dataform:v1beta1 : ActionIncrementalLoadMode
/// - dataform:v1beta1 : IncrementalLoadMode
class $IncrementalLoadMode {
  /// Column name for incremental load modes
  core.String? column;

  $IncrementalLoadMode({this.column});

  $IncrementalLoadMode.fromJson(core.Map json_)
    : this(column: json_['column'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (column != null) 'column': column!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IndexDatapointCrowdingTag
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IndexDatapointCrowdingTag
class $IndexDatapointCrowdingTag {
  /// The attribute value used for crowding.
  ///
  /// The maximum number of neighbors to return per crowding attribute value
  /// (per_crowding_attribute_num_neighbors) is configured per-query. This field
  /// is ignored if per_crowding_attribute_num_neighbors is larger than the
  /// total number of neighbors to return for a given query.
  core.String? crowdingAttribute;

  $IndexDatapointCrowdingTag({this.crowdingAttribute});

  $IndexDatapointCrowdingTag.fromJson(core.Map json_)
    : this(crowdingAttribute: json_['crowdingAttribute'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (crowdingAttribute != null) 'crowdingAttribute': crowdingAttribute!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IndexDatapointNumericRestriction
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IndexDatapointNumericRestriction
class $IndexDatapointNumericRestriction {
  /// The namespace of this restriction.
  ///
  /// e.g.: cost.
  core.String? namespace;

  /// This MUST be specified for queries and must NOT be specified for
  /// datapoints.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : Default value of the enum.
  /// - "LESS" : Datapoints are eligible iff their value is \< the query's.
  /// - "LESS_EQUAL" : Datapoints are eligible iff their value is \<= the
  /// query's.
  /// - "EQUAL" : Datapoints are eligible iff their value is == the query's.
  /// - "GREATER_EQUAL" : Datapoints are eligible iff their value is \>= the
  /// query's.
  /// - "GREATER" : Datapoints are eligible iff their value is \> the query's.
  /// - "NOT_EQUAL" : Datapoints are eligible iff their value is != the query's.
  core.String? op;

  /// Represents 64 bit float.
  core.double? valueDouble;

  /// Represents 32 bit float.
  core.double? valueFloat;

  /// Represents 64 bit integer.
  core.String? valueInt;

  $IndexDatapointNumericRestriction({
    this.namespace,
    this.op,
    this.valueDouble,
    this.valueFloat,
    this.valueInt,
  });

  $IndexDatapointNumericRestriction.fromJson(core.Map json_)
    : this(
        namespace: json_['namespace'] as core.String?,
        op: json_['op'] as core.String?,
        valueDouble: (json_['valueDouble'] as core.num?)?.toDouble(),
        valueFloat: (json_['valueFloat'] as core.num?)?.toDouble(),
        valueInt: json_['valueInt'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (namespace != null) 'namespace': namespace!,
    if (op != null) 'op': op!,
    if (valueDouble != null) 'valueDouble': valueDouble!,
    if (valueFloat != null) 'valueFloat': valueFloat!,
    if (valueInt != null) 'valueInt': valueInt!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IndexDatapointRestriction
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IndexDatapointRestriction
class $IndexDatapointRestriction {
  /// The attributes to allow in this namespace.
  ///
  /// e.g.: 'red'
  core.List<core.String>? allowList;

  /// The attributes to deny in this namespace.
  ///
  /// e.g.: 'blue'
  core.List<core.String>? denyList;

  /// The namespace of this restriction.
  ///
  /// e.g.: color.
  core.String? namespace;

  $IndexDatapointRestriction({this.allowList, this.denyList, this.namespace});

  $IndexDatapointRestriction.fromJson(core.Map json_)
    : this(
        allowList:
            (json_['allowList'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        denyList:
            (json_['denyList'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        namespace: json_['namespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowList != null) 'allowList': allowList!,
    if (denyList != null) 'denyList': denyList!,
    if (namespace != null) 'namespace': namespace!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IndexDatapointSparseEmbedding
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IndexDatapointSparseEmbedding
class $IndexDatapointSparseEmbedding {
  /// The list of indexes for the embedding values of the sparse vector.
  ///
  /// Required.
  core.List<core.String>? dimensions;

  /// The list of embedding values of the sparse vector.
  ///
  /// Required.
  core.List<core.double>? values;

  $IndexDatapointSparseEmbedding({this.dimensions, this.values});

  $IndexDatapointSparseEmbedding.fromJson(core.Map json_)
    : this(
        dimensions:
            (json_['dimensions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensions != null) 'dimensions': dimensions!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1IndexStats
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1IndexStats
class $IndexStats {
  /// The number of shards in the Index.
  ///
  /// Output only.
  core.int? shardsCount;

  /// The number of sparse vectors in the Index.
  ///
  /// Output only.
  core.String? sparseVectorsCount;

  /// The number of dense vectors in the Index.
  ///
  /// Output only.
  core.String? vectorsCount;

  $IndexStats({this.shardsCount, this.sparseVectorsCount, this.vectorsCount});

  $IndexStats.fromJson(core.Map json_)
    : this(
        shardsCount: json_['shardsCount'] as core.int?,
        sparseVectorsCount: json_['sparseVectorsCount'] as core.String?,
        vectorsCount: json_['vectorsCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (shardsCount != null) 'shardsCount': shardsCount!,
    if (sparseVectorsCount != null) 'sparseVectorsCount': sparseVectorsCount!,
    if (vectorsCount != null) 'vectorsCount': vectorsCount!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2InferenceParameter
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1InferenceParameter
class $InferenceParameter {
  /// Maximum number of the output tokens for the generator.
  ///
  /// Optional.
  core.int? maxOutputTokens;

  /// Controls the randomness of LLM predictions.
  ///
  /// Low temperature = less random. High temperature = more random. If unset
  /// (or 0), uses a default value of 0.
  ///
  /// Optional.
  core.double? temperature;

  /// Top-k changes how the model selects tokens for output.
  ///
  /// A top-k of 1 means the selected token is the most probable among all
  /// tokens in the model's vocabulary (also called greedy decoding), while a
  /// top-k of 3 means that the next token is selected from among the 3 most
  /// probable tokens (using temperature). For each token selection step, the
  /// top K tokens with the highest probabilities are sampled. Then tokens are
  /// further filtered based on topP with the final token selected using
  /// temperature sampling. Specify a lower value for less random responses and
  /// a higher value for more random responses. Acceptable value is \[1, 40\],
  /// default to 40.
  ///
  /// Optional.
  core.int? topK;

  /// Top-p changes how the model selects tokens for output.
  ///
  /// Tokens are selected from most K (see topK parameter) probable to least
  /// until the sum of their probabilities equals the top-p value. For example,
  /// if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the
  /// top-p value is 0.5, then the model will select either A or B as the next
  /// token (using temperature) and doesn't consider C. The default top-p value
  /// is 0.95. Specify a lower value for less random responses and a higher
  /// value for more random responses. Acceptable value is \[0.0, 1.0\], default
  /// to 0.95.
  ///
  /// Optional.
  core.double? topP;

  $InferenceParameter({
    this.maxOutputTokens,
    this.temperature,
    this.topK,
    this.topP,
  });

  $InferenceParameter.fromJson(core.Map json_)
    : this(
        maxOutputTokens: json_['maxOutputTokens'] as core.int?,
        temperature: (json_['temperature'] as core.num?)?.toDouble(),
        topK: json_['topK'] as core.int?,
        topP: (json_['topP'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxOutputTokens != null) 'maxOutputTokens': maxOutputTokens!,
    if (temperature != null) 'temperature': temperature!,
    if (topK != null) 'topK': topK!,
    if (topP != null) 'topP': topP!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : IngressSource
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1IngressSource
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1IngressSource
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1IngressSource
class $IngressSource {
  /// An AccessLevel resource name that allow resources within the
  /// ServicePerimeters to be accessed from the internet.
  ///
  /// AccessLevels listed must be in the same policy as this ServicePerimeter.
  /// Referencing a nonexistent AccessLevel will cause an error. If no
  /// AccessLevel names are listed, resources within the perimeter can only be
  /// accessed via Google Cloud calls with request origins within the perimeter.
  /// Example: `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*`
  /// is specified for `access_level`, then all IngressSources will be allowed.
  core.String? accessLevel;

  /// A Google Cloud resource that is allowed to ingress the perimeter.
  ///
  /// Requests from these resources will be allowed to access perimeter data.
  /// Currently only projects and VPCs are allowed. Project format:
  /// `projects/{project_number}` VPC network format:
  /// `//compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NAME}`.
  /// The project may be in any Google Cloud organization, not just the
  /// organization that the perimeter is defined in. `*` is not allowed, the
  /// case of allowing all Google Cloud resources only is not supported.
  core.String? resource;

  $IngressSource({this.accessLevel, this.resource});

  $IngressSource.fromJson(core.Map json_)
    : this(
        accessLevel: json_['accessLevel'] as core.String?,
        resource: json_['resource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessLevel != null) 'accessLevel': accessLevel!,
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - dataportability:v1 : InitiatePortabilityArchiveRequest
/// - dataportability:v1beta : InitiatePortabilityArchiveRequest
class $InitiatePortabilityArchiveRequest {
  /// The timestamp that represents the end point for the data you are
  /// exporting.
  ///
  /// If the end_time is not specified in the InitiatePortabilityArchiveRequest,
  /// this field is set to the latest available data.
  ///
  /// Optional.
  core.String? endTime;

  /// The resources from which you're exporting data.
  ///
  /// These values have a 1:1 correspondence with the OAuth scopes.
  core.List<core.String>? resources;

  /// The timestamp that represents the starting point for the data you are
  /// exporting.
  ///
  /// If the start_time is not specified in the
  /// InitiatePortabilityArchiveRequest, the field is set to the earliest
  /// available data.
  ///
  /// Optional.
  core.String? startTime;

  $InitiatePortabilityArchiveRequest({
    this.endTime,
    this.resources,
    this.startTime,
  });

  $InitiatePortabilityArchiveRequest.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        resources:
            (json_['resources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (resources != null) 'resources': resources!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - dataportability:v1 : InitiatePortabilityArchiveResponse
/// - dataportability:v1beta : InitiatePortabilityArchiveResponse
class $InitiatePortabilityArchiveResponse {
  /// The access type of the Archive job initiated by the API.
  /// Possible string values are:
  /// - "ACCESS_TYPE_UNSPECIFIED" : Default value. This value is unused.
  /// - "ACCESS_TYPE_ONE_TIME" : One-time access to the requested scopes.
  /// - "ACCESS_TYPE_TIME_BASED" : Multiple exports allowed over 30 days. Enum
  /// value subject to change before launch.
  core.String? accessType;

  /// The archive job ID that is initiated in the API.
  ///
  /// This can be used to get the state of the job.
  core.String? archiveJobId;

  $InitiatePortabilityArchiveResponse({this.accessType, this.archiveJobId});

  $InitiatePortabilityArchiveResponse.fromJson(core.Map json_)
    : this(
        accessType: json_['accessType'] as core.String?,
        archiveJobId: json_['archiveJobId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessType != null) 'accessType': accessType!,
    if (archiveJobId != null) 'archiveJobId': archiveJobId!,
  };
}

/// Used by:
///
/// - domains:v1 : InitiatePushTransferRequest
/// - domains:v1alpha2 : InitiatePushTransferRequest
/// - domains:v1beta1 : InitiatePushTransferRequest
class $InitiatePushTransferRequest {
  /// The Tag of the new registrar.
  ///
  /// Can be found at [List of registrars](https://nominet.uk/registrar-list/).
  ///
  /// Required.
  core.String? tag;

  $InitiatePushTransferRequest({this.tag});

  $InitiatePushTransferRequest.fromJson(core.Map json_)
    : this(tag: json_['tag'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (tag != null) 'tag': tag!,
  };
}

/// Used by:
///
/// - alloydb:v1 : InjectFaultRequest
/// - alloydb:v1alpha : InjectFaultRequest
/// - alloydb:v1beta : InjectFaultRequest
class $InjectFaultRequest {
  /// The type of fault to be injected in an instance.
  ///
  /// Required.
  /// Possible string values are:
  /// - "FAULT_TYPE_UNSPECIFIED" : The fault type is unknown.
  /// - "STOP_VM" : Stop the VM
  core.String? faultType;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server ignores the request if it has already been completed. The server
  /// guarantees that for at least 60 minutes since the first request. For
  /// example, consider a situation where you make an initial request and the
  /// request times out. If you make the request again with the same request ID,
  /// the server can check if the original operation with the same request ID
  /// was received, and if so, ignores the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported
  /// (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// If set, performs request validation, for example, permission checks and
  /// any other type of validation, but does not actually execute the create
  /// request.
  ///
  /// Optional.
  core.bool? validateOnly;

  $InjectFaultRequest({this.faultType, this.requestId, this.validateOnly});

  $InjectFaultRequest.fromJson(core.Map json_)
    : this(
        faultType: json_['faultType'] as core.String?,
        requestId: json_['requestId'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (faultType != null) 'faultType': faultType!,
    if (requestId != null) 'requestId': requestId!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : InlineScopedRouteConfigs
/// - trafficdirector:v3 : InlineScopedRouteConfigs
class $InlineScopedRouteConfigs {
  /// The timestamp when the scoped route config set was last updated.
  core.String? lastUpdated;

  /// The name assigned to the scoped route configurations.
  core.String? name;

  /// The scoped route configurations.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? scopedRouteConfigs;

  $InlineScopedRouteConfigs({
    this.lastUpdated,
    this.name,
    this.scopedRouteConfigs,
  });

  $InlineScopedRouteConfigs.fromJson(core.Map json_)
    : this(
        lastUpdated: json_['lastUpdated'] as core.String?,
        name: json_['name'] as core.String?,
        scopedRouteConfigs:
            (json_['scopedRouteConfigs'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastUpdated != null) 'lastUpdated': lastUpdated!,
    if (name != null) 'name': name!,
    if (scopedRouteConfigs != null) 'scopedRouteConfigs': scopedRouteConfigs!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3InlineSource
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1InlineSource
class $InlineSource {
  /// The uncompressed byte content for the objects.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $InlineSource({this.content});

  $InlineSource.fromJson(core.Map json_)
    : this(content: json_['content'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : InputMapping
/// - deploymentmanager:v2beta : InputMapping
class $InputMapping {
  /// The name of the field that is going to be injected.
  core.String? fieldName;

  /// The location where this mapping applies.
  /// Possible string values are:
  /// - "UNKNOWN"
  /// - "PATH"
  /// - "QUERY"
  /// - "BODY"
  /// - "HEADER"
  core.String? location;

  /// Regex to evaluate on method to decide if input applies.
  core.String? methodMatch;

  /// A jsonPath expression to select an element.
  core.String? value;

  $InputMapping({this.fieldName, this.location, this.methodMatch, this.value});

  $InputMapping.fromJson(core.Map json_)
    : this(
        fieldName: json_['fieldName'] as core.String?,
        location: json_['location'] as core.String?,
        methodMatch: json_['methodMatch'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldName != null) 'fieldName': fieldName!,
    if (location != null) 'location': location!,
    if (methodMatch != null) 'methodMatch': methodMatch!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dataproc:v1 : InputMetrics
/// - dataproc:v1 : StageInputMetrics
class $InputMetrics {
  core.String? bytesRead;
  core.String? recordsRead;

  $InputMetrics({this.bytesRead, this.recordsRead});

  $InputMetrics.fromJson(core.Map json_)
    : this(
        bytesRead: json_['bytesRead'] as core.String?,
        recordsRead: json_['recordsRead'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bytesRead != null) 'bytesRead': bytesRead!,
    if (recordsRead != null) 'recordsRead': recordsRead!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1InsightRecommendationReference
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1InsightRecommendationReference
class $InsightRecommendationReference {
  /// Recommendation resource name, e.g.
  /// projects/\[PROJECT_NUMBER\]/locations/\[LOCATION\]/recommenders/\[RECOMMENDER_ID\]/recommendations/\[RECOMMENDATION_ID\]
  core.String? recommendation;

  $InsightRecommendationReference({this.recommendation});

  $InsightRecommendationReference.fromJson(core.Map json_)
    : this(recommendation: json_['recommendation'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (recommendation != null) 'recommendation': recommendation!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1InsightStateInfo
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1InsightStateInfo
class $InsightStateInfo {
  /// Insight state.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state.
  /// - "ACTIVE" : Insight is active. Content for ACTIVE insights can be updated
  /// by Google. ACTIVE insights can be marked DISMISSED OR ACCEPTED.
  /// - "ACCEPTED" : Some action has been taken based on this insight. Insights
  /// become accepted when a recommendation derived from the insight has been
  /// marked CLAIMED, SUCCEEDED, or FAILED. ACTIVE insights can also be marked
  /// ACCEPTED explicitly. Content for ACCEPTED insights is immutable. ACCEPTED
  /// insights can only be marked ACCEPTED (which may update state metadata).
  /// - "DISMISSED" : Insight is dismissed. Content for DISMISSED insights can
  /// be updated by Google. DISMISSED insights can be marked as ACTIVE.
  core.String? state;

  /// A map of metadata for the state, provided by user or automations systems.
  core.Map<core.String, core.String>? stateMetadata;

  $InsightStateInfo({this.state, this.stateMetadata});

  $InsightStateInfo.fromJson(core.Map json_)
    : this(
        state: json_['state'] as core.String?,
        stateMetadata: (json_['stateMetadata']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
    if (stateMetadata != null) 'stateMetadata': stateMetadata!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1InsightTypeGenerationConfig
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1InsightTypeGenerationConfig
class $InsightTypeGenerationConfig {
  /// Parameters for this InsightTypeGenerationConfig.
  ///
  /// These configs can be used by or are applied to all subtypes.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  $InsightTypeGenerationConfig({this.params});

  $InsightTypeGenerationConfig.fromJson(core.Map json_)
    : this(
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (params != null) 'params': params!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : InsightsConfig
/// - sqladmin:v1beta4 : InsightsConfig
class $InsightsConfig {
  /// Whether Query Insights feature is enabled.
  core.bool? queryInsightsEnabled;

  /// Number of query execution plans captured by Insights per minute for all
  /// queries combined.
  ///
  /// Default is 5.
  core.int? queryPlansPerMinute;

  /// Maximum query length stored in bytes.
  ///
  /// Default value: 1024 bytes. Range: 256-4500 bytes. Query lengths greater
  /// than this field value will be truncated to this value. When unset, query
  /// length will be the default value. Changing query length will restart the
  /// database.
  core.int? queryStringLength;

  /// Whether Query Insights will record application tags from query when
  /// enabled.
  core.bool? recordApplicationTags;

  /// Whether Query Insights will record client address when enabled.
  core.bool? recordClientAddress;

  $InsightsConfig({
    this.queryInsightsEnabled,
    this.queryPlansPerMinute,
    this.queryStringLength,
    this.recordApplicationTags,
    this.recordClientAddress,
  });

  $InsightsConfig.fromJson(core.Map json_)
    : this(
        queryInsightsEnabled: json_['queryInsightsEnabled'] as core.bool?,
        queryPlansPerMinute: json_['queryPlansPerMinute'] as core.int?,
        queryStringLength: json_['queryStringLength'] as core.int?,
        recordApplicationTags: json_['recordApplicationTags'] as core.bool?,
        recordClientAddress: json_['recordClientAddress'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryInsightsEnabled != null)
      'queryInsightsEnabled': queryInsightsEnabled!,
    if (queryPlansPerMinute != null)
      'queryPlansPerMinute': queryPlansPerMinute!,
    if (queryStringLength != null) 'queryStringLength': queryStringLength!,
    if (recordApplicationTags != null)
      'recordApplicationTags': recordApplicationTags!,
    if (recordClientAddress != null)
      'recordClientAddress': recordClientAddress!,
  };
}

/// Used by:
///
/// - cloudbuild:v2 : InstallationState
/// - developerconnect:v1 : InstallationState
class $InstallationState {
  /// Link to follow for next action.
  ///
  /// Empty string if the installation is already complete.
  ///
  /// Output only.
  core.String? actionUri;

  /// Message of what the user should do next to continue the installation.
  ///
  /// Empty string if the installation is already complete.
  ///
  /// Output only.
  core.String? message;

  /// Current step of the installation process.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STAGE_UNSPECIFIED" : No stage specified.
  /// - "PENDING_CREATE_APP" : Only for GitHub Enterprise. An App creation has
  /// been requested. The user needs to confirm the creation in their GitHub
  /// enterprise host.
  /// - "PENDING_USER_OAUTH" : User needs to authorize the GitHub (or
  /// Enterprise) App via OAuth.
  /// - "PENDING_INSTALL_APP" : User needs to follow the link to install the
  /// GitHub (or Enterprise) App.
  /// - "COMPLETE" : Installation process has been completed.
  core.String? stage;

  $InstallationState({this.actionUri, this.message, this.stage});

  $InstallationState.fromJson(core.Map json_)
    : this(
        actionUri: json_['actionUri'] as core.String?,
        message: json_['message'] as core.String?,
        stage: json_['stage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actionUri != null) 'actionUri': actionUri!,
    if (message != null) 'message': message!,
    if (stage != null) 'stage': stage!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1BleuInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1ExactMatchInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1RougeInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolCallValidInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolNameMatchInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKVMatchInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKeyMatchInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1BleuInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ExactMatchInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RougeInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolCallValidInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolNameMatchInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKVMatchInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInstance
class $Instance00 {
  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Required.
  core.String? reference;

  $Instance00({this.prediction, this.reference});

  $Instance00.fromJson(core.Map json_)
    : this(
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CoherenceInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1FluencyInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1SafetyInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CoherenceInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FluencyInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SafetyInstance
class $Instance01 {
  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  $Instance01({this.prediction});

  $Instance01.fromJson(core.Map json_)
    : this(prediction: json_['prediction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (prediction != null) 'prediction': prediction!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringRelevanceInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInstance
class $Instance02 {
  /// Text provided as context to answer the question.
  ///
  /// Optional.
  core.String? context;

  /// The question asked and other instruction in the inference prompt.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $Instance02({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $Instance02.fromJson(core.Map json_)
    : this(
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CometInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetricxInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CometInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetricxInstance
class $Instance03 {
  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  /// Source text in original language.
  ///
  /// Optional.
  core.String? source;

  $Instance03({this.prediction, this.reference, this.source});

  $Instance03.fromJson(core.Map json_)
    : this(
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
        source: json_['source'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
    if (source != null) 'source': source!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationHelpfulnessInstance
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationVerbosityInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationVerbosityInstance
class $Instance04 {
  /// Text to be summarized.
  ///
  /// Required.
  core.String? context;

  /// Summarization prompt for LLM.
  ///
  /// Optional.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $Instance04({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $Instance04.fromJson(core.Map json_)
    : this(
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - appengine:v1 : Instance
/// - appengine:v1beta : Instance
class $Instance05 {
  /// App Engine release this instance is running on.
  ///
  /// Output only.
  core.String? appEngineRelease;

  /// Availability of the instance.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNSPECIFIED"
  /// - "RESIDENT"
  /// - "DYNAMIC"
  core.String? availability;

  /// Average latency (ms) over the last minute.
  ///
  /// Output only.
  core.int? averageLatency;

  /// Number of errors since this instance was started.
  ///
  /// Output only.
  core.int? errors;

  /// Relative name of the instance within the version.
  ///
  /// Example: instance-1.
  ///
  /// Output only.
  core.String? id;

  /// Total memory in use (bytes).
  ///
  /// Output only.
  core.String? memoryUsage;

  /// Full path to the Instance resource in the API.
  ///
  /// Example: apps/myapp/services/default/versions/v1/instances/instance-1.
  ///
  /// Output only.
  core.String? name;

  /// Average queries per second (QPS) over the last minute.
  ///
  /// Output only.
  core.double? qps;

  /// Number of requests since this instance was started.
  ///
  /// Output only.
  core.int? requests;

  /// Time that this instance was started.@OutputOnly
  ///
  /// Output only.
  core.String? startTime;

  /// Whether this instance is in debug mode.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.bool? vmDebugEnabled;

  /// Virtual machine ID of this instance.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.String? vmId;

  /// The IP address of this instance.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.String? vmIp;

  /// The liveness health check of this instance.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "LIVENESS_STATE_UNSPECIFIED" : There is no liveness health check for the
  /// instance. Only applicable for instances in App Engine standard
  /// environment.
  /// - "UNKNOWN" : The health checking system is aware of the instance but its
  /// health is not known at the moment.
  /// - "HEALTHY" : The instance is reachable i.e. a connection to the
  /// application health checking endpoint can be established, and conforms to
  /// the requirements defined by the health check.
  /// - "UNHEALTHY" : The instance is reachable, but does not conform to the
  /// requirements defined by the health check.
  /// - "DRAINING" : The instance is being drained. The existing connections to
  /// the instance have time to complete, but the new ones are being refused.
  /// - "TIMEOUT" : The instance is unreachable i.e. a connection to the
  /// application health checking endpoint cannot be established, or the server
  /// does not respond within the specified timeout.
  core.String? vmLiveness;

  /// Name of the virtual machine where this instance lives.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.String? vmName;

  /// Status of the virtual machine where this instance lives.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.String? vmStatus;

  /// Zone where the virtual machine is located.
  ///
  /// Only applicable for instances in App Engine flexible environment.
  ///
  /// Output only.
  core.String? vmZoneName;

  $Instance05({
    this.appEngineRelease,
    this.availability,
    this.averageLatency,
    this.errors,
    this.id,
    this.memoryUsage,
    this.name,
    this.qps,
    this.requests,
    this.startTime,
    this.vmDebugEnabled,
    this.vmId,
    this.vmIp,
    this.vmLiveness,
    this.vmName,
    this.vmStatus,
    this.vmZoneName,
  });

  $Instance05.fromJson(core.Map json_)
    : this(
        appEngineRelease: json_['appEngineRelease'] as core.String?,
        availability: json_['availability'] as core.String?,
        averageLatency: json_['averageLatency'] as core.int?,
        errors: json_['errors'] as core.int?,
        id: json_['id'] as core.String?,
        memoryUsage: json_['memoryUsage'] as core.String?,
        name: json_['name'] as core.String?,
        qps: (json_['qps'] as core.num?)?.toDouble(),
        requests: json_['requests'] as core.int?,
        startTime: json_['startTime'] as core.String?,
        vmDebugEnabled: json_['vmDebugEnabled'] as core.bool?,
        vmId: json_['vmId'] as core.String?,
        vmIp: json_['vmIp'] as core.String?,
        vmLiveness: json_['vmLiveness'] as core.String?,
        vmName: json_['vmName'] as core.String?,
        vmStatus: json_['vmStatus'] as core.String?,
        vmZoneName: json_['vmZoneName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appEngineRelease != null) 'appEngineRelease': appEngineRelease!,
    if (availability != null) 'availability': availability!,
    if (averageLatency != null) 'averageLatency': averageLatency!,
    if (errors != null) 'errors': errors!,
    if (id != null) 'id': id!,
    if (memoryUsage != null) 'memoryUsage': memoryUsage!,
    if (name != null) 'name': name!,
    if (qps != null) 'qps': qps!,
    if (requests != null) 'requests': requests!,
    if (startTime != null) 'startTime': startTime!,
    if (vmDebugEnabled != null) 'vmDebugEnabled': vmDebugEnabled!,
    if (vmId != null) 'vmId': vmId!,
    if (vmIp != null) 'vmIp': vmIp!,
    if (vmLiveness != null) 'vmLiveness': vmLiveness!,
    if (vmName != null) 'vmName': vmName!,
    if (vmStatus != null) 'vmStatus': vmStatus!,
    if (vmZoneName != null) 'vmZoneName': vmZoneName!,
  };
}

/// Used by:
///
/// - parallelstore:v1 : Instance
/// - parallelstore:v1beta : Instance
class $Instance06 {
  /// A list of IPv4 addresses used for client side configuration.
  ///
  /// Output only.
  core.List<core.String>? accessPoints;

  /// The instance's storage capacity in Gibibytes (GiB).
  ///
  /// Allowed values are between 12000 and 100000, in multiples of 4000; e.g.,
  /// 12000, 16000, 20000, ...
  ///
  /// Required. Immutable.
  core.String? capacityGib;

  /// The time when the instance was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Deprecated: The version of DAOS software running in the instance.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? daosVersion;

  /// The deployment type of the instance.
  ///
  /// Allowed values are: * `SCRATCH`: the instance is a scratch instance. *
  /// `PERSISTENT`: the instance is a persistent instance.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "DEPLOYMENT_TYPE_UNSPECIFIED" : Default Deployment Type It is equivalent
  /// to SCRATCH
  /// - "SCRATCH" : Scratch
  /// - "PERSISTENT" : Persistent
  core.String? deploymentType;

  /// The description of the instance.
  ///
  /// 2048 characters or less.
  ///
  /// Optional.
  core.String? description;

  /// Stripe level for directories.
  ///
  /// Allowed values are: * `DIRECTORY_STRIPE_LEVEL_MIN`: recommended when
  /// directories contain a small number of files. *
  /// `DIRECTORY_STRIPE_LEVEL_BALANCED`: balances performance for workloads
  /// involving a mix of small and large directories. *
  /// `DIRECTORY_STRIPE_LEVEL_MAX`: recommended for directories with a large
  /// number of files.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "DIRECTORY_STRIPE_LEVEL_UNSPECIFIED" : If not set, DirectoryStripeLevel
  /// will default to DIRECTORY_STRIPE_LEVEL_MAX
  /// - "DIRECTORY_STRIPE_LEVEL_MIN" : Minimum directory striping
  /// - "DIRECTORY_STRIPE_LEVEL_BALANCED" : Medium directory striping
  /// - "DIRECTORY_STRIPE_LEVEL_MAX" : Maximum directory striping
  core.String? directoryStripeLevel;

  /// The ID of the IP address range being used by the instance's VPC network.
  ///
  /// This field is populated by the service and contains the value currently
  /// used by the service.
  ///
  /// Output only. Immutable.
  core.String? effectiveReservedIpRange;

  /// Stripe level for files.
  ///
  /// Allowed values are: * `FILE_STRIPE_LEVEL_MIN`: offers the best performance
  /// for small size files. * `FILE_STRIPE_LEVEL_BALANCED`: balances performance
  /// for workloads involving a mix of small and large files. *
  /// `FILE_STRIPE_LEVEL_MAX`: higher throughput performance for larger files.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "FILE_STRIPE_LEVEL_UNSPECIFIED" : If not set, FileStripeLevel will
  /// default to FILE_STRIPE_LEVEL_BALANCED
  /// - "FILE_STRIPE_LEVEL_MIN" : Minimum file striping
  /// - "FILE_STRIPE_LEVEL_BALANCED" : Medium file striping
  /// - "FILE_STRIPE_LEVEL_MAX" : Maximum file striping
  core.String? fileStripeLevel;

  /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
  /// resources into groups that reflect a customer's organizational needs and
  /// deployment strategies.
  ///
  /// See https://cloud.google.com/resource-manager/docs/labels-overview for
  /// details.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The resource name of the instance, in the format
  /// `projects/{project}/locations/{location}/instances/{instance_id}`.
  core.String? name;

  /// The name of the Compute Engine
  /// [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the instance
  /// is connected.
  ///
  /// Optional. Immutable.
  core.String? network;

  /// The ID of the IP address range being used by the instance's VPC network.
  ///
  /// See
  /// [Configure a VPC network](https://cloud.google.com/parallelstore/docs/vpc#create_and_configure_the_vpc).
  /// If no ID is provided, all ranges are considered.
  ///
  /// Optional. Immutable.
  core.String? reservedIpRange;

  /// The instance state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "CREATING" : The instance is being created.
  /// - "ACTIVE" : The instance is available for use.
  /// - "DELETING" : The instance is being deleted.
  /// - "FAILED" : The instance is not usable.
  /// - "UPGRADING" : The instance is being upgraded.
  /// - "REPAIRING" : The instance is being repaired. This should only be used
  /// by instances using the `PERSISTENT` deployment type.
  core.String? state;

  /// The time when the instance was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Instance06({
    this.accessPoints,
    this.capacityGib,
    this.createTime,
    this.daosVersion,
    this.deploymentType,
    this.description,
    this.directoryStripeLevel,
    this.effectiveReservedIpRange,
    this.fileStripeLevel,
    this.labels,
    this.name,
    this.network,
    this.reservedIpRange,
    this.state,
    this.updateTime,
  });

  $Instance06.fromJson(core.Map json_)
    : this(
        accessPoints:
            (json_['accessPoints'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        capacityGib: json_['capacityGib'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        daosVersion: json_['daosVersion'] as core.String?,
        deploymentType: json_['deploymentType'] as core.String?,
        description: json_['description'] as core.String?,
        directoryStripeLevel: json_['directoryStripeLevel'] as core.String?,
        effectiveReservedIpRange:
            json_['effectiveReservedIpRange'] as core.String?,
        fileStripeLevel: json_['fileStripeLevel'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        reservedIpRange: json_['reservedIpRange'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessPoints != null) 'accessPoints': accessPoints!,
    if (capacityGib != null) 'capacityGib': capacityGib!,
    if (createTime != null) 'createTime': createTime!,
    if (daosVersion != null) 'daosVersion': daosVersion!,
    if (deploymentType != null) 'deploymentType': deploymentType!,
    if (description != null) 'description': description!,
    if (directoryStripeLevel != null)
      'directoryStripeLevel': directoryStripeLevel!,
    if (effectiveReservedIpRange != null)
      'effectiveReservedIpRange': effectiveReservedIpRange!,
    if (fileStripeLevel != null) 'fileStripeLevel': fileStripeLevel!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (reservedIpRange != null) 'reservedIpRange': reservedIpRange!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - redis:v1 : InstanceAuthString
/// - redis:v1beta1 : InstanceAuthString
class $InstanceAuthString {
  /// AUTH string set on the instance.
  core.String? authString;

  $InstanceAuthString({this.authString});

  $InstanceAuthString.fromJson(core.Map json_)
    : this(authString: json_['authString'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (authString != null) 'authString': authString!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceConsumptionInfo
/// - compute:beta : InstanceConsumptionInfo
/// - compute:v1 : InstanceConsumptionInfo
class $InstanceConsumptionInfo {
  /// The number of virtual CPUs that are available to the instance.
  core.int? guestCpus;

  /// The amount of local SSD storage available to the instance, defined in GiB.
  core.int? localSsdGb;

  /// The amount of physical memory available to the instance, defined in MiB.
  core.int? memoryMb;

  /// The minimal guaranteed number of virtual CPUs that are reserved.
  core.int? minNodeCpus;

  $InstanceConsumptionInfo({
    this.guestCpus,
    this.localSsdGb,
    this.memoryMb,
    this.minNodeCpus,
  });

  $InstanceConsumptionInfo.fromJson(core.Map json_)
    : this(
        guestCpus: json_['guestCpus'] as core.int?,
        localSsdGb: json_['localSsdGb'] as core.int?,
        memoryMb: json_['memoryMb'] as core.int?,
        minNodeCpus: json_['minNodeCpus'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (guestCpus != null) 'guestCpus': guestCpus!,
    if (localSsdGb != null) 'localSsdGb': localSsdGb!,
    if (memoryMb != null) 'memoryMb': memoryMb!,
    if (minNodeCpus != null) 'minNodeCpus': minNodeCpus!,
  };
}

/// Used by:
///
/// - compute:beta : InstanceGroupManagerActionsSummary
/// - compute:v1 : InstanceGroupManagerActionsSummary
class $InstanceGroupManagerActionsSummary {
  /// The total number of instances in the managed instance group that are
  /// scheduled to be abandoned.
  ///
  /// Abandoning an instance removes it from the managed instance group without
  /// deleting it.
  ///
  /// Output only.
  core.int? abandoning;

  /// The number of instances in the managed instance group that are scheduled
  /// to be created or are currently being created.
  ///
  /// If the group fails to create any of these instances, it tries again until
  /// it creates the instance successfully. If you have disabled creation
  /// retries, this field will not be populated; instead, the
  /// creatingWithoutRetries field will be populated.
  ///
  /// Output only.
  core.int? creating;

  /// The number of instances that the managed instance group will attempt to
  /// create.
  ///
  /// The group attempts to create each instance only once. If the group fails
  /// to create any of these instances, it decreases the group's targetSize
  /// value accordingly.
  ///
  /// Output only.
  core.int? creatingWithoutRetries;

  /// The number of instances in the managed instance group that are scheduled
  /// to be deleted or are currently being deleted.
  ///
  /// Output only.
  core.int? deleting;

  /// The number of instances in the managed instance group that are running and
  /// have no scheduled actions.
  ///
  /// Output only.
  core.int? none;

  /// The number of instances in the managed instance group that are scheduled
  /// to be recreated or are currently being being recreated.
  ///
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  ///
  /// Output only.
  core.int? recreating;

  /// The number of instances in the managed instance group that are being
  /// reconfigured with properties that do not require a restart or a recreate
  /// action.
  ///
  /// For example, setting or removing target pools for the instance.
  ///
  /// Output only.
  core.int? refreshing;

  /// The number of instances in the managed instance group that are scheduled
  /// to be restarted or are currently being restarted.
  ///
  /// Output only.
  core.int? restarting;

  /// The number of instances in the managed instance group that are scheduled
  /// to be resumed or are currently being resumed.
  ///
  /// Output only.
  core.int? resuming;

  /// The number of instances in the managed instance group that are scheduled
  /// to be started or are currently being started.
  ///
  /// Output only.
  core.int? starting;

  /// The number of instances in the managed instance group that are scheduled
  /// to be stopped or are currently being stopped.
  ///
  /// Output only.
  core.int? stopping;

  /// The number of instances in the managed instance group that are scheduled
  /// to be suspended or are currently being suspended.
  ///
  /// Output only.
  core.int? suspending;

  /// The number of instances in the managed instance group that are being
  /// verified.
  ///
  /// See the managedInstances\[\].currentAction property in the
  /// listManagedInstances method documentation.
  ///
  /// Output only.
  core.int? verifying;

  $InstanceGroupManagerActionsSummary({
    this.abandoning,
    this.creating,
    this.creatingWithoutRetries,
    this.deleting,
    this.none,
    this.recreating,
    this.refreshing,
    this.restarting,
    this.resuming,
    this.starting,
    this.stopping,
    this.suspending,
    this.verifying,
  });

  $InstanceGroupManagerActionsSummary.fromJson(core.Map json_)
    : this(
        abandoning: json_['abandoning'] as core.int?,
        creating: json_['creating'] as core.int?,
        creatingWithoutRetries: json_['creatingWithoutRetries'] as core.int?,
        deleting: json_['deleting'] as core.int?,
        none: json_['none'] as core.int?,
        recreating: json_['recreating'] as core.int?,
        refreshing: json_['refreshing'] as core.int?,
        restarting: json_['restarting'] as core.int?,
        resuming: json_['resuming'] as core.int?,
        starting: json_['starting'] as core.int?,
        stopping: json_['stopping'] as core.int?,
        suspending: json_['suspending'] as core.int?,
        verifying: json_['verifying'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (abandoning != null) 'abandoning': abandoning!,
    if (creating != null) 'creating': creating!,
    if (creatingWithoutRetries != null)
      'creatingWithoutRetries': creatingWithoutRetries!,
    if (deleting != null) 'deleting': deleting!,
    if (none != null) 'none': none!,
    if (recreating != null) 'recreating': recreating!,
    if (refreshing != null) 'refreshing': refreshing!,
    if (restarting != null) 'restarting': restarting!,
    if (resuming != null) 'resuming': resuming!,
    if (starting != null) 'starting': starting!,
    if (stopping != null) 'stopping': stopping!,
    if (suspending != null) 'suspending': suspending!,
    if (verifying != null) 'verifying': verifying!,
  };
}

/// Used by:
///
/// - compute:beta : InstanceGroupManagerAutoHealingPolicy
/// - compute:v1 : InstanceGroupManagerAutoHealingPolicy
class $InstanceGroupManagerAutoHealingPolicy {
  /// The URL for the health check that signals autohealing.
  core.String? healthCheck;

  /// The initial delay is the number of seconds that a new VM takes to
  /// initialize and run its startup script.
  ///
  /// During a VM's initial delay period, the MIG ignores unsuccessful health
  /// checks because the VM might be in the startup process. This prevents the
  /// MIG from prematurely recreating a VM. If the health check receives a
  /// healthy response during the initial delay, it indicates that the startup
  /// process is complete and the VM is ready. The value of initial delay must
  /// be between 0 and 3600 seconds. The default value is 0.
  core.int? initialDelaySec;

  $InstanceGroupManagerAutoHealingPolicy({
    this.healthCheck,
    this.initialDelaySec,
  });

  $InstanceGroupManagerAutoHealingPolicy.fromJson(core.Map json_)
    : this(
        healthCheck: json_['healthCheck'] as core.String?,
        initialDelaySec: json_['initialDelaySec'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (healthCheck != null) 'healthCheck': healthCheck!,
    if (initialDelaySec != null) 'initialDelaySec': initialDelaySec!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection
/// - compute:beta : InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection
/// - compute:v1 : InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection
class $InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection {
  /// Full machine-type names, e.g. "n1-standard-16".
  core.List<core.String>? machineTypes;

  /// Preference of this instance selection.
  ///
  /// Lower number means higher preference. MIG will first try to create a VM
  /// based on the machine-type with lowest rank and fallback to next rank based
  /// on availability. Machine types and instance selections with the same rank
  /// have the same preference.
  core.int? rank;

  $InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection({
    this.machineTypes,
    this.rank,
  });

  $InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection.fromJson(
    core.Map json_,
  ) : this(
        machineTypes:
            (json_['machineTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        rank: json_['rank'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineTypes != null) 'machineTypes': machineTypes!,
    if (rank != null) 'rank': rank!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerInstanceFlexibilityPolicyProvisioningModelMix
/// - compute:beta : InstanceGroupManagerInstanceFlexibilityPolicyProvisioningModelMix
class $InstanceGroupManagerInstanceFlexibilityPolicyProvisioningModelMix {
  /// The base capacity that will always use Standard VMs to avoid risk of more
  /// preemption than the minimum capacity user needs.
  ///
  /// MIG will create only Standard VMs until it reaches standard_capacity_base
  /// and only then will start using standard_capacity_percent_above_base to mix
  /// Spot with Standard VMs.
  core.int? standardCapacityBase;

  /// The percentage of target capacity that should use Standard VM.
  ///
  /// The remaining percentage will use Spot VMs. The percentage applies only to
  /// the capacity above standard_capacity_base.
  core.int? standardCapacityPercentAboveBase;

  $InstanceGroupManagerInstanceFlexibilityPolicyProvisioningModelMix({
    this.standardCapacityBase,
    this.standardCapacityPercentAboveBase,
  });

  $InstanceGroupManagerInstanceFlexibilityPolicyProvisioningModelMix.fromJson(
    core.Map json_,
  ) : this(
        standardCapacityBase: json_['standardCapacityBase'] as core.int?,
        standardCapacityPercentAboveBase:
            json_['standardCapacityPercentAboveBase'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (standardCapacityBase != null)
      'standardCapacityBase': standardCapacityBase!,
    if (standardCapacityPercentAboveBase != null)
      'standardCapacityPercentAboveBase': standardCapacityPercentAboveBase!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerInstanceLifecyclePolicyOnRepair
/// - compute:beta : InstanceGroupManagerInstanceLifecyclePolicyOnRepair
class $InstanceGroupManagerInstanceLifecyclePolicyOnRepair {
  /// Specifies whether the MIG can change a VM's zone during a repair.
  /// Possible string values are:
  /// - "NO" : \[Default\] MIG cannot change a VM's zone during a repair.
  /// - "YES" : MIG can select a different zone for the VM during a repair.
  core.String? allowChangingZone;

  $InstanceGroupManagerInstanceLifecyclePolicyOnRepair({
    this.allowChangingZone,
  });

  $InstanceGroupManagerInstanceLifecyclePolicyOnRepair.fromJson(core.Map json_)
    : this(allowChangingZone: json_['allowChangingZone'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowChangingZone != null) 'allowChangingZone': allowChangingZone!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerParams
/// - compute:beta : InstanceGroupManagerParams
class $InstanceGroupManagerParams {
  /// Resource manager tags to bind to the managed instance group.
  ///
  /// The tags are key-value pairs. Keys must be in the format tagKeys/123 and
  /// values in the format tagValues/456. For more information, see Manage tags
  /// for resources.
  core.Map<core.String, core.String>? resourceManagerTags;

  $InstanceGroupManagerParams({this.resourceManagerTags});

  $InstanceGroupManagerParams.fromJson(core.Map json_)
    : this(
        resourceManagerTags: (json_['resourceManagerTags']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceManagerTags != null)
      'resourceManagerTags': resourceManagerTags!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerResizeRequestStatusLastAttempt
/// - compute:beta : InstanceGroupManagerResizeRequestStatusLastAttempt
/// - compute:v1 : InstanceGroupManagerResizeRequestStatusLastAttempt
class $InstanceGroupManagerResizeRequestStatusLastAttempt {
  /// Errors that prevented the ResizeRequest to be fulfilled.
  InstanceGroupManagerResizeRequestStatusLastAttemptError? error;

  $InstanceGroupManagerResizeRequestStatusLastAttempt({this.error});

  $InstanceGroupManagerResizeRequestStatusLastAttempt.fromJson(core.Map json_)
    : this(
        error:
            json_.containsKey('error')
                ? InstanceGroupManagerResizeRequestStatusLastAttemptError.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerResourcePolicies
/// - compute:beta : InstanceGroupManagerResourcePolicies
/// - compute:v1 : InstanceGroupManagerResourcePolicies
class $InstanceGroupManagerResourcePolicies {
  /// The URL of the workload policy that is specified for this managed instance
  /// group.
  ///
  /// It can be a full or partial URL. For example, the following are all valid
  /// URLs to a workload policy: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /resourcePolicies/resourcePolicy -
  /// projects/project/regions/region/resourcePolicies/resourcePolicy -
  /// regions/region/resourcePolicies/resourcePolicy
  core.String? workloadPolicy;

  $InstanceGroupManagerResourcePolicies({this.workloadPolicy});

  $InstanceGroupManagerResourcePolicies.fromJson(core.Map json_)
    : this(workloadPolicy: json_['workloadPolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (workloadPolicy != null) 'workloadPolicy': workloadPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerStandbyPolicy
/// - compute:beta : InstanceGroupManagerStandbyPolicy
/// - compute:v1 : InstanceGroupManagerStandbyPolicy
class $InstanceGroupManagerStandbyPolicy {
  /// Specifies the number of seconds that the MIG should wait to suspend or
  /// stop a VM after that VM was created.
  ///
  /// The initial delay gives the initialization script the time to prepare your
  /// VM for a quick scale out. The value of initial delay must be between 0 and
  /// 3600 seconds. The default value is 0.
  core.int? initialDelaySec;

  /// Defines how a MIG resumes or starts VMs from a standby pool when the group
  /// scales out.
  ///
  /// The default mode is `MANUAL`.
  /// Possible string values are:
  /// - "MANUAL" : MIG does not automatically resume or start VMs in the standby
  /// pool when the group scales out.
  /// - "SCALE_OUT_POOL" : MIG automatically resumes or starts VMs in the
  /// standby pool when the group scales out, and replenishes the standby pool
  /// afterwards.
  core.String? mode;

  $InstanceGroupManagerStandbyPolicy({this.initialDelaySec, this.mode});

  $InstanceGroupManagerStandbyPolicy.fromJson(core.Map json_)
    : this(
        initialDelaySec: json_['initialDelaySec'] as core.int?,
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (initialDelaySec != null) 'initialDelaySec': initialDelaySec!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerStatusAllInstancesConfig
/// - compute:beta : InstanceGroupManagerStatusAllInstancesConfig
/// - compute:v1 : InstanceGroupManagerStatusAllInstancesConfig
class $InstanceGroupManagerStatusAllInstancesConfig {
  /// Current all-instances configuration revision.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? currentRevision;

  /// A bit indicating whether this configuration has been applied to all
  /// managed instances in the group.
  ///
  /// Output only.
  core.bool? effective;

  $InstanceGroupManagerStatusAllInstancesConfig({
    this.currentRevision,
    this.effective,
  });

  $InstanceGroupManagerStatusAllInstancesConfig.fromJson(core.Map json_)
    : this(
        currentRevision: json_['currentRevision'] as core.String?,
        effective: json_['effective'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currentRevision != null) 'currentRevision': currentRevision!,
    if (effective != null) 'effective': effective!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheck
/// - compute:beta : InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheck
class $InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheck {
  /// Errors encountered during bulk instance operation.
  ///
  /// Output only.
  InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheckError? error;

  /// Timestamp of the last progress check of bulk instance operation.
  ///
  /// Timestamp is in RFC3339 text format.
  ///
  /// Output only.
  core.String? timestamp;

  $InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheck({
    this.error,
    this.timestamp,
  });

  $InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheck.fromJson(
    core.Map json_,
  ) : this(
        error:
            json_.containsKey('error')
                ? InstanceGroupManagerStatusBulkInstanceOperationLastProgressCheckError.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        timestamp: json_['timestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (timestamp != null) 'timestamp': timestamp!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerStatusStatefulPerInstanceConfigs
/// - compute:beta : InstanceGroupManagerStatusStatefulPerInstanceConfigs
/// - compute:v1 : InstanceGroupManagerStatusStatefulPerInstanceConfigs
class $InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  /// A bit indicating if all of the group's per-instance configurations (listed
  /// in the output of a listPerInstanceConfigs API call) have status EFFECTIVE
  /// or there are no per-instance-configs.
  core.bool? allEffective;

  $InstanceGroupManagerStatusStatefulPerInstanceConfigs({this.allEffective});

  $InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(core.Map json_)
    : this(allEffective: json_['allEffective'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (allEffective != null) 'allEffective': allEffective!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerStatusVersionTarget
/// - compute:beta : InstanceGroupManagerStatusVersionTarget
/// - compute:v1 : InstanceGroupManagerStatusVersionTarget
class $InstanceGroupManagerStatusVersionTarget {
  /// A bit indicating whether version target has been reached in this managed
  /// instance group, i.e. all instances are in their target version.
  ///
  /// Instances' target version are specified by version field on Instance Group
  /// Manager.
  ///
  /// Output only.
  core.bool? isReached;

  $InstanceGroupManagerStatusVersionTarget({this.isReached});

  $InstanceGroupManagerStatusVersionTarget.fromJson(core.Map json_)
    : this(isReached: json_['isReached'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (isReached != null) 'isReached': isReached!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagerTargetSizePolicy
/// - compute:beta : InstanceGroupManagerTargetSizePolicy
class $InstanceGroupManagerTargetSizePolicy {
  /// The mode of target size policy based on which the MIG creates its VMs
  /// individually or all at once.
  /// Possible string values are:
  /// - "BULK" : The mode in which the MIG creates VMs all at once. In this
  /// mode, if the MIG is unable to create even one VM, the MIG waits until all
  /// VMs can be created at the same time.
  /// - "INDIVIDUAL" : The mode in which the MIG creates VMs individually. In
  /// this mode, if the MIG is unable to create a VM, the MIG will continue to
  /// create the other VMs in the group. This is the default mode.
  /// - "UNSPECIFIED_MODE" : If mode is unspecified, MIG will behave as in the
  /// default `INDIVIDUAL` mode.
  core.String? mode;

  $InstanceGroupManagerTargetSizePolicy({this.mode});

  $InstanceGroupManagerTargetSizePolicy.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersAbandonInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersAbandonInstancesRequest
/// - compute:beta : InstanceGroupManagersAbandonInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersAbandonInstancesRequest
/// - compute:v1 : InstanceGroupManagersAbandonInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersAbandonInstancesRequest
class $InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $InstanceGroupManagersAbandonInstancesRequest({this.instances});

  $InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - compute:beta : InstanceGroupManagersApplyUpdatesRequest
/// - compute:beta : RegionInstanceGroupManagersApplyUpdatesRequest
/// - compute:v1 : InstanceGroupManagersApplyUpdatesRequest
/// - compute:v1 : RegionInstanceGroupManagersApplyUpdatesRequest
class $InstanceGroupManagersApplyUpdatesRequest00 {
  /// Flag to update all instances instead of specified list of instances.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The minimal action that you want to perform on each instance during the
  /// update: - REPLACE: At minimum, delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance and limit disruption as much as possible. - NONE: Do not
  /// disrupt the instance at all. By default, the minimum action is NONE. If
  /// your update requires a more disruptive action than you set with this flag,
  /// the necessary action is performed to execute the update.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Do not stop the instance.
  /// - "REPLACE" : (Default.) Replace the instance according to the replacement
  /// method option.
  /// - "RESTART" : Stop the instance and start it again.
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update: - REPLACE: Delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance and limit disruption as much as possible. - NONE: Do not
  /// disrupt the instance at all. By default, the most disruptive allowed
  /// action is REPLACE. If your update requires a more disruptive action than
  /// you set with this flag, the update request will fail.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Do not stop the instance.
  /// - "REPLACE" : (Default.) Replace the instance according to the replacement
  /// method option.
  /// - "RESTART" : Stop the instance and start it again.
  core.String? mostDisruptiveAllowedAction;

  $InstanceGroupManagersApplyUpdatesRequest00({
    this.allInstances,
    this.instances,
    this.minimalAction,
    this.mostDisruptiveAllowedAction,
  });

  $InstanceGroupManagersApplyUpdatesRequest00.fromJson(core.Map json_)
    : this(
        allInstances: json_['allInstances'] as core.bool?,
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        minimalAction: json_['minimalAction'] as core.String?,
        mostDisruptiveAllowedAction:
            json_['mostDisruptiveAllowedAction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allInstances != null) 'allInstances': allInstances!,
    if (instances != null) 'instances': instances!,
    if (minimalAction != null) 'minimalAction': minimalAction!,
    if (mostDisruptiveAllowedAction != null)
      'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersApplyUpdatesRequest
/// - compute:alpha : RegionInstanceGroupManagersApplyUpdatesRequest
class $InstanceGroupManagersApplyUpdatesRequest01 {
  /// Flag to update all instances instead of specified list of instances.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The maximal action that should be performed on the instances.
  ///
  /// By default REPLACE. This field is deprecated, please use
  /// most_disruptive_allowed_action.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Do not stop the instance.
  /// - "REPLACE" : (Default.) Replace the instance according to the replacement
  /// method option.
  /// - "RESTART" : Stop the instance and start it again.
  core.String? maximalAction;

  /// The minimal action that you want to perform on each instance during the
  /// update: - REPLACE: At minimum, delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance and limit disruption as much as possible. - NONE: Do not
  /// disrupt the instance at all. By default, the minimum action is NONE. If
  /// your update requires a more disruptive action than you set with this flag,
  /// the necessary action is performed to execute the update.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Do not stop the instance.
  /// - "REPLACE" : (Default.) Replace the instance according to the replacement
  /// method option.
  /// - "RESTART" : Stop the instance and start it again.
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update: - REPLACE: Delete the instance and create it again.
  ///
  /// - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
  /// the instance and limit disruption as much as possible. - NONE: Do not
  /// disrupt the instance at all. By default, the most disruptive allowed
  /// action is REPLACE. If your update requires a more disruptive action than
  /// you set with this flag, the update request will fail.
  /// Possible string values are:
  /// - "NONE" : Do not perform any action.
  /// - "REFRESH" : Do not stop the instance.
  /// - "REPLACE" : (Default.) Replace the instance according to the replacement
  /// method option.
  /// - "RESTART" : Stop the instance and start it again.
  core.String? mostDisruptiveAllowedAction;

  $InstanceGroupManagersApplyUpdatesRequest01({
    this.allInstances,
    this.instances,
    this.maximalAction,
    this.minimalAction,
    this.mostDisruptiveAllowedAction,
  });

  $InstanceGroupManagersApplyUpdatesRequest01.fromJson(core.Map json_)
    : this(
        allInstances: json_['allInstances'] as core.bool?,
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        maximalAction: json_['maximalAction'] as core.String?,
        minimalAction: json_['minimalAction'] as core.String?,
        mostDisruptiveAllowedAction:
            json_['mostDisruptiveAllowedAction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allInstances != null) 'allInstances': allInstances!,
    if (instances != null) 'instances': instances!,
    if (maximalAction != null) 'maximalAction': maximalAction!,
    if (minimalAction != null) 'minimalAction': minimalAction!,
    if (mostDisruptiveAllowedAction != null)
      'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
  };
}

/// Used by:
///
/// - compute:beta : InstanceGroupManagersDeleteInstancesRequest
/// - compute:v1 : InstanceGroupManagersDeleteInstancesRequest
class $InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\]. Queued instances do not have
  /// URL and can be deleted only by name. One cannot specify both URLs and
  /// names in a single request.
  core.List<core.String>? instances;

  /// Specifies whether the request should proceed despite the inclusion of
  /// instances that are not members of the group or that are already in the
  /// process of being deleted or abandoned.
  ///
  /// If this field is set to `false` and such an instance is specified in the
  /// request, the operation fails. The operation always fails if the request
  /// contains a malformed instance URL or a reference to an instance that
  /// exists in a zone or region other than the group's zone or region.
  core.bool? skipInstancesOnValidationError;

  $InstanceGroupManagersDeleteInstancesRequest({
    this.instances,
    this.skipInstancesOnValidationError,
  });

  $InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        skipInstancesOnValidationError:
            json_['skipInstancesOnValidationError'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (skipInstancesOnValidationError != null)
      'skipInstancesOnValidationError': skipInstancesOnValidationError!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersResizeAdvancedRequest
/// - compute:beta : InstanceGroupManagersResizeAdvancedRequest
class $InstanceGroupManagersResizeAdvancedRequest {
  /// If this flag is true, the managed instance group attempts to create all
  /// instances initiated by this resize request only once.
  ///
  /// If there is an error during creation, the managed instance group does not
  /// retry create this instance, and we will decrease the targetSize of the
  /// request instead. If the flag is false, the group attempts to recreate each
  /// instance continuously until it succeeds. This flag matters only in the
  /// first attempt of creation of an instance. After an instance is
  /// successfully created while this flag is enabled, the instance behaves the
  /// same way as all the other instances created with a regular resize request.
  /// In particular, if a running instance dies unexpectedly at a later time and
  /// needs to be recreated, this mode does not affect the recreation behavior
  /// in that scenario. This flag is applicable only to the current resize
  /// request. It does not influence other resize requests in any way. You can
  /// see which instances is being creating in which mode by calling the get or
  /// listManagedInstances API.
  core.bool? noCreationRetries;

  /// The number of running instances that the managed instance group should
  /// maintain at any given time.
  ///
  /// The group automatically adds or removes instances to maintain the number
  /// of instances specified by this parameter.
  core.int? targetSize;

  $InstanceGroupManagersResizeAdvancedRequest({
    this.noCreationRetries,
    this.targetSize,
  });

  $InstanceGroupManagersResizeAdvancedRequest.fromJson(core.Map json_)
    : this(
        noCreationRetries: json_['noCreationRetries'] as core.bool?,
        targetSize: json_['targetSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (noCreationRetries != null) 'noCreationRetries': noCreationRetries!,
    if (targetSize != null) 'targetSize': targetSize!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersResumeInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersResumeInstancesRequest
/// - compute:beta : InstanceGroupManagersResumeInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersResumeInstancesRequest
/// - compute:v1 : InstanceGroupManagersResumeInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersResumeInstancesRequest
class $InstanceGroupManagersResumeInstancesRequest {
  /// The URLs of one or more instances to resume.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $InstanceGroupManagersResumeInstancesRequest({this.instances});

  $InstanceGroupManagersResumeInstancesRequest.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersSetInstanceTemplateRequest
/// - compute:beta : InstanceGroupManagersSetInstanceTemplateRequest
/// - compute:v1 : InstanceGroupManagersSetInstanceTemplateRequest
class $InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create all new instances in the managed
  /// instance group. The templates for existing instances in the group do not
  /// change unless you run recreateInstances, run applyUpdatesToInstances, or
  /// set the group's updatePolicy.type to PROACTIVE.
  core.String? instanceTemplate;

  $InstanceGroupManagersSetInstanceTemplateRequest({this.instanceTemplate});

  $InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map json_)
    : this(instanceTemplate: json_['instanceTemplate'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersSetTargetPoolsRequest
/// - compute:beta : InstanceGroupManagersSetTargetPoolsRequest
/// - compute:v1 : InstanceGroupManagersSetTargetPoolsRequest
class $InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the target pools settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to.
  ///
  /// The managed instance group applies these target pools to all of the
  /// instances in the group. Existing instances and new instances in the group
  /// all receive these target pool settings.
  core.List<core.String>? targetPools;

  $InstanceGroupManagersSetTargetPoolsRequest({
    this.fingerprint,
    this.targetPools,
  });

  $InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map json_)
    : this(
        fingerprint: json_['fingerprint'] as core.String?,
        targetPools:
            (json_['targetPools'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (targetPools != null) 'targetPools': targetPools!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersStartInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersStartInstancesRequest
/// - compute:beta : InstanceGroupManagersStartInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersStartInstancesRequest
/// - compute:v1 : InstanceGroupManagersStartInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersStartInstancesRequest
class $InstanceGroupManagersStartInstancesRequest {
  /// The URLs of one or more instances to start.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $InstanceGroupManagersStartInstancesRequest({this.instances});

  $InstanceGroupManagersStartInstancesRequest.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersStopInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersStopInstancesRequest
/// - compute:beta : InstanceGroupManagersStopInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersStopInstancesRequest
/// - compute:v1 : InstanceGroupManagersStopInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersStopInstancesRequest
class $InstanceGroupManagersStopInstancesRequest {
  /// If this flag is set to true, the Instance Group Manager will proceed to
  /// stop the instances, skipping initialization on them.
  core.bool? forceStop;

  /// The URLs of one or more instances to stop.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $InstanceGroupManagersStopInstancesRequest({this.forceStop, this.instances});

  $InstanceGroupManagersStopInstancesRequest.fromJson(core.Map json_)
    : this(
        forceStop: json_['forceStop'] as core.bool?,
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (forceStop != null) 'forceStop': forceStop!,
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersSuspendInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersSuspendInstancesRequest
/// - compute:beta : InstanceGroupManagersSuspendInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersSuspendInstancesRequest
/// - compute:v1 : InstanceGroupManagersSuspendInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersSuspendInstancesRequest
class $InstanceGroupManagersSuspendInstancesRequest {
  /// If this flag is set to true, the Instance Group Manager will proceed to
  /// suspend the instances, skipping initialization on them.
  core.bool? forceSuspend;

  /// The URLs of one or more instances to suspend.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $InstanceGroupManagersSuspendInstancesRequest({
    this.forceSuspend,
    this.instances,
  });

  $InstanceGroupManagersSuspendInstancesRequest.fromJson(core.Map json_)
    : this(
        forceSuspend: json_['forceSuspend'] as core.bool?,
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (forceSuspend != null) 'forceSuspend': forceSuspend!,
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupsListInstancesRequest
/// - compute:beta : InstanceGroupsListInstancesRequest
/// - compute:v1 : InstanceGroupsListInstancesRequest
class $InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group.
  ///
  /// Valid options are ALL or RUNNING. If you do not specify this parameter the
  /// list includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL" : Includes all instances in the generated list regardless of their
  /// state.
  /// - "RUNNING" : Includes instances in the generated list only if they have a
  /// RUNNING state.
  core.String? instanceState;

  $InstanceGroupsListInstancesRequest({this.instanceState});

  $InstanceGroupsListInstancesRequest.fromJson(core.Map json_)
    : this(instanceState: json_['instanceState'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceState != null) 'instanceState': instanceState!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : InstanceInfo
/// - networkmanagement:v1beta1 : InstanceInfo
class $InstanceInfo {
  /// Name of a Compute Engine instance.
  core.String? displayName;

  /// External IP address of the network interface.
  core.String? externalIp;

  /// Name of the network interface of a Compute Engine instance.
  core.String? interface;

  /// Internal IP address of the network interface.
  core.String? internalIp;

  /// Network tags configured on the instance.
  core.List<core.String>? networkTags;

  /// URI of a Compute Engine network.
  core.String? networkUri;

  /// URI of the PSC network attachment the NIC is attached to (if relevant).
  core.String? pscNetworkAttachmentUri;

  /// Indicates whether the Compute Engine instance is running.
  ///
  /// Deprecated: use the `status` field instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? running;

  /// Service account authorized for the instance.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? serviceAccount;

  /// The status of the instance.
  /// Possible string values are:
  /// - "STATUS_UNSPECIFIED" : Default unspecified value.
  /// - "RUNNING" : The instance is running.
  /// - "NOT_RUNNING" : The instance has any status other than "RUNNING".
  core.String? status;

  /// URI of a Compute Engine instance.
  core.String? uri;

  $InstanceInfo({
    this.displayName,
    this.externalIp,
    this.interface,
    this.internalIp,
    this.networkTags,
    this.networkUri,
    this.pscNetworkAttachmentUri,
    this.running,
    this.serviceAccount,
    this.status,
    this.uri,
  });

  $InstanceInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        externalIp: json_['externalIp'] as core.String?,
        interface: json_['interface'] as core.String?,
        internalIp: json_['internalIp'] as core.String?,
        networkTags:
            (json_['networkTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        networkUri: json_['networkUri'] as core.String?,
        pscNetworkAttachmentUri:
            json_['pscNetworkAttachmentUri'] as core.String?,
        running: json_['running'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        status: json_['status'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (externalIp != null) 'externalIp': externalIp!,
    if (interface != null) 'interface': interface!,
    if (internalIp != null) 'internalIp': internalIp!,
    if (networkTags != null) 'networkTags': networkTags!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (pscNetworkAttachmentUri != null)
      'pscNetworkAttachmentUri': pscNetworkAttachmentUri!,
    if (running != null) 'running': running!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (status != null) 'status': status!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceManagedByIgmErrorManagedInstanceError
/// - compute:beta : InstanceManagedByIgmErrorManagedInstanceError
/// - compute:v1 : InstanceManagedByIgmErrorManagedInstanceError
class $InstanceManagedByIgmErrorManagedInstanceError {
  /// Error code.
  ///
  /// Output only.
  core.String? code;

  /// Error message.
  ///
  /// Output only.
  core.String? message;

  $InstanceManagedByIgmErrorManagedInstanceError({this.code, this.message});

  $InstanceManagedByIgmErrorManagedInstanceError.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - memcache:v1 : InstanceMessage
/// - memcache:v1beta2 : InstanceMessage
class $InstanceMessage {
  /// A code that correspond to one type of user-facing message.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Message Code not set.
  /// - "ZONE_DISTRIBUTION_UNBALANCED" : Memcached nodes are distributed
  /// unevenly.
  core.String? code;

  /// Message on memcached instance which will be exposed to users.
  core.String? message;

  $InstanceMessage({this.code, this.message});

  $InstanceMessage.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceMoveRequest
/// - compute:beta : InstanceMoveRequest
/// - compute:v1 : InstanceMoveRequest
class $InstanceMoveRequest {
  /// The URL of the destination zone to move the instance.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone -
  /// projects/project/zones/zone - zones/zone
  core.String? destinationZone;

  /// The URL of the target instance to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to an instance: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /instances/instance - projects/project/zones/zone/instances/instance -
  /// zones/zone/instances/instance
  core.String? targetInstance;

  $InstanceMoveRequest({this.destinationZone, this.targetInstance});

  $InstanceMoveRequest.fromJson(core.Map json_)
    : this(
        destinationZone: json_['destinationZone'] as core.String?,
        targetInstance: json_['targetInstance'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationZone != null) 'destinationZone': destinationZone!,
    if (targetInstance != null) 'targetInstance': targetInstance!,
  };
}

/// Used by:
///
/// - compute:beta : InstanceParams
/// - compute:v1 : InstanceParams
class $InstanceParams {
  /// Resource manager tags to be bound to the instance.
  ///
  /// Tag keys and values have the same definition as resource manager tags.
  /// Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the
  /// format `tagValues/456`. The field is ignored (both PUT & PATCH) when
  /// empty.
  core.Map<core.String, core.String>? resourceManagerTags;

  $InstanceParams({this.resourceManagerTags});

  $InstanceParams.fromJson(core.Map json_)
    : this(
        resourceManagerTags: (json_['resourceManagerTags']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceManagerTags != null)
      'resourceManagerTags': resourceManagerTags!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancePropertiesPatch
/// - compute:beta : InstancePropertiesPatch
/// - compute:v1 : InstancePropertiesPatch
class $InstancePropertiesPatch {
  /// The label key-value pairs that you want to patch onto the instance.
  core.Map<core.String, core.String>? labels;

  /// The metadata key-value pairs that you want to patch onto the instance.
  ///
  /// For more information, see Project and instance metadata.
  core.Map<core.String, core.String>? metadata;

  $InstancePropertiesPatch({this.labels, this.metadata});

  $InstancePropertiesPatch.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata: (json_['metadata'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceReference
/// - compute:beta : InstanceReference
/// - compute:v1 : InstanceReference
class $InstanceReference00 {
  /// The URL for a specific instance.
  ///
  /// @required compute.instancegroups.addInstances/removeInstances
  core.String? instance;

  $InstanceReference00({this.instance});

  $InstanceReference00.fromJson(core.Map json_)
    : this(instance: json_['instance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : InstanceReference
/// - sqladmin:v1beta4 : InstanceReference
class $InstanceReference01 {
  /// The name of the Cloud SQL instance being referenced.
  ///
  /// This does not include the project ID.
  core.String? name;

  /// The project ID of the Cloud SQL instance being referenced.
  ///
  /// The default is the same project ID as the instance references it.
  core.String? project;

  /// The region of the Cloud SQL instance being referenced.
  core.String? region;

  $InstanceReference01({this.name, this.project, this.region});

  $InstanceReference01.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        project: json_['project'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (project != null) 'project': project!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceSettingsMetadata
/// - compute:beta : InstanceSettingsMetadata
/// - compute:v1 : InstanceSettingsMetadata
class $InstanceSettingsMetadata {
  /// A metadata key/value items map.
  ///
  /// The total size of all keys and values must be less than 512KB.
  core.Map<core.String, core.String>? items;

  /// Type of the resource.
  ///
  /// Always compute#metadata for metadata.
  ///
  /// Output only.
  core.String? kind;

  $InstanceSettingsMetadata({this.items, this.kind});

  $InstanceSettingsMetadata.fromJson(core.Map json_)
    : this(
        items: (json_['items'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (items != null) 'items': items!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesAddResourcePoliciesRequest
/// - compute:beta : InstancesAddResourcePoliciesRequest
/// - compute:v1 : InstancesAddResourcePoliciesRequest
class $InstancesAddResourcePoliciesRequest {
  /// Resource policies to be added to this instance.
  core.List<core.String>? resourcePolicies;

  $InstancesAddResourcePoliciesRequest({this.resourcePolicies});

  $InstancesAddResourcePoliciesRequest.fromJson(core.Map json_)
    : this(
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesRemoveResourcePoliciesRequest
/// - compute:beta : InstancesRemoveResourcePoliciesRequest
/// - compute:v1 : InstancesRemoveResourcePoliciesRequest
class $InstancesRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this instance.
  core.List<core.String>? resourcePolicies;

  $InstancesRemoveResourcePoliciesRequest({this.resourcePolicies});

  $InstancesRemoveResourcePoliciesRequest.fromJson(core.Map json_)
    : this(
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesReportHostAsFaultyRequestFaultReason
/// - compute:beta : InstancesReportHostAsFaultyRequestFaultReason
/// - compute:v1 : InstancesReportHostAsFaultyRequestFaultReason
class $InstancesReportHostAsFaultyRequestFaultReason {
  ///
  /// Possible string values are:
  /// - "BEHAVIOR_UNSPECIFIED" : Public reportable behaviors
  /// - "PERFORMANCE"
  /// - "SILENT_DATA_CORRUPTION"
  /// - "UNRECOVERABLE_GPU_ERROR"
  core.String? behavior;
  core.String? description;

  $InstancesReportHostAsFaultyRequestFaultReason({
    this.behavior,
    this.description,
  });

  $InstancesReportHostAsFaultyRequestFaultReason.fromJson(core.Map json_)
    : this(
        behavior: json_['behavior'] as core.String?,
        description: json_['description'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (behavior != null) 'behavior': behavior!,
    if (description != null) 'description': description!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetLabelsRequest
/// - compute:beta : InstancesSetLabelsRequest
/// - compute:v1 : InstancesSetLabelsRequest
class $InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts.
  ///
  /// Provide the latest fingerprint value when making a request to add or
  /// change labels.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  core.Map<core.String, core.String>? labels;

  $InstancesSetLabelsRequest({this.labelFingerprint, this.labels});

  $InstancesSetLabelsRequest.fromJson(core.Map json_)
    : this(
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetMachineTypeRequest
/// - compute:beta : InstancesSetMachineTypeRequest
/// - compute:v1 : InstancesSetMachineTypeRequest
class $InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource.
  ///
  /// See Machine Types for a full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String? machineType;

  $InstancesSetMachineTypeRequest({this.machineType});

  $InstancesSetMachineTypeRequest.fromJson(core.Map json_)
    : this(machineType: json_['machineType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineType != null) 'machineType': machineType!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetMinCpuPlatformRequest
/// - compute:beta : InstancesSetMinCpuPlatformRequest
/// - compute:v1 : InstancesSetMinCpuPlatformRequest
class $InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String? minCpuPlatform;

  $InstancesSetMinCpuPlatformRequest({this.minCpuPlatform});

  $InstancesSetMinCpuPlatformRequest.fromJson(core.Map json_)
    : this(minCpuPlatform: json_['minCpuPlatform'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetNameRequest
/// - compute:beta : InstancesSetNameRequest
/// - compute:v1 : InstancesSetNameRequest
class $InstancesSetNameRequest {
  /// The current name of this resource, used to prevent conflicts.
  ///
  /// Provide the latest name when making a request to change name.
  core.String? currentName;

  /// The name to be applied to the instance.
  ///
  /// Needs to be RFC 1035 compliant.
  core.String? name;

  $InstancesSetNameRequest({this.currentName, this.name});

  $InstancesSetNameRequest.fromJson(core.Map json_)
    : this(
        currentName: json_['currentName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currentName != null) 'currentName': currentName!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetSecurityPolicyRequest
/// - compute:beta : InstancesSetSecurityPolicyRequest
/// - compute:v1 : InstancesSetSecurityPolicyRequest
class $InstancesSetSecurityPolicyRequest {
  /// The network interfaces that the security policy will be applied to.
  ///
  /// Network interfaces use the nicN naming format. You can only set a security
  /// policy for network interfaces with an access config.
  core.List<core.String>? networkInterfaces;

  /// A full or partial URL to a security policy to add to this instance.
  ///
  /// If this field is set to an empty string it will remove the associated
  /// security policy.
  core.String? securityPolicy;

  $InstancesSetSecurityPolicyRequest({
    this.networkInterfaces,
    this.securityPolicy,
  });

  $InstancesSetSecurityPolicyRequest.fromJson(core.Map json_)
    : this(
        networkInterfaces:
            (json_['networkInterfaces'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        securityPolicy: json_['securityPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (networkInterfaces != null) 'networkInterfaces': networkInterfaces!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : InstantSnapshotResourceStatus
/// - compute:beta : InstantSnapshotResourceStatus
/// - compute:v1 : InstantSnapshotResourceStatus
class $InstantSnapshotResourceStatus {
  /// The storage size of this instant snapshot.
  ///
  /// Output only.
  core.String? storageSizeBytes;

  $InstantSnapshotResourceStatus({this.storageSizeBytes});

  $InstantSnapshotResourceStatus.fromJson(core.Map json_)
    : this(storageSizeBytes: json_['storageSizeBytes'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (storageSizeBytes != null) 'storageSizeBytes': storageSizeBytes!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Int64Array
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Int64Array
class $Int64Array {
  /// A list of int64 values.
  core.List<core.String>? values;

  $Int64Array({this.values});

  $Int64Array.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : Int64RangeMatch
/// - compute:beta : Int64RangeMatch
/// - compute:v1 : Int64RangeMatch
class $Int64RangeMatch {
  /// The end of the range (exclusive) in signed long integer format.
  core.String? rangeEnd;

  /// The start of the range (inclusive) in signed long integer format.
  core.String? rangeStart;

  $Int64RangeMatch({this.rangeEnd, this.rangeStart});

  $Int64RangeMatch.fromJson(core.Map json_)
    : this(
        rangeEnd: json_['rangeEnd'] as core.String?,
        rangeStart: json_['rangeStart'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rangeEnd != null) 'rangeEnd': rangeEnd!,
    if (rangeStart != null) 'rangeStart': rangeStart!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2IntegerLimits
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaIntegerLimits
class $IntegerLimits {
  /// Maximum value for an integer Field type.
  core.String? maxValue;

  /// Minimum value for an integer Field type.
  core.String? minValue;

  $IntegerLimits({this.maxValue, this.minValue});

  $IntegerLimits.fromJson(core.Map json_)
    : this(
        maxValue: json_['maxValue'] as core.String?,
        minValue: json_['minValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
  };
}

/// Used by:
///
/// - alloydb:v1 : IntegerRestrictions
/// - alloydb:v1alpha : IntegerRestrictions
/// - alloydb:v1beta : IntegerRestrictions
class $IntegerRestrictions {
  /// The maximum value that can be specified, if applicable.
  core.String? maxValue;

  /// The minimum value that can be specified, if applicable.
  core.String? minValue;

  $IntegerRestrictions({this.maxValue, this.minValue});

  $IntegerRestrictions.fromJson(core.Map json_)
    : this(
        maxValue: json_['maxValue'] as core.String?,
        minValue: json_['minValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : IntegralAdScience
/// - displayvideo:v4 : IntegralAdScience
class $IntegralAdScience {
  /// The custom segment ID provided by Integral Ad Science.
  ///
  /// The ID must be between `1000001` and `1999999` or `3000001` and `3999999`,
  /// inclusive.
  core.List<core.String>? customSegmentId;

  /// Display Viewability section (applicable to display line items only).
  /// Possible string values are:
  /// - "PERFORMANCE_VIEWABILITY_UNSPECIFIED" : This enum is only a placeholder
  /// and it doesn't specify any display viewability options.
  /// - "PERFORMANCE_VIEWABILITY_40" : Target 40% Viewability or Higher.
  /// - "PERFORMANCE_VIEWABILITY_50" : Target 50% Viewability or Higher.
  /// - "PERFORMANCE_VIEWABILITY_60" : Target 60% Viewability or Higher.
  /// - "PERFORMANCE_VIEWABILITY_70" : Target 70% Viewability or Higher.
  core.String? displayViewability;

  /// Brand Safety - **Unrateable**.
  core.bool? excludeUnrateable;

  /// Ad Fraud settings.
  /// Possible string values are:
  /// - "SUSPICIOUS_ACTIVITY_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any ad fraud prevention options.
  /// - "SUSPICIOUS_ACTIVITY_HR" : Ad Fraud - Exclude High Risk.
  /// - "SUSPICIOUS_ACTIVITY_HMR" : Ad Fraud - Exclude High and Moderate Risk.
  core.String? excludedAdFraudRisk;

  /// Brand Safety - **Adult content**.
  /// Possible string values are:
  /// - "ADULT_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any adult options.
  /// - "ADULT_HR" : Adult - Exclude High Risk.
  /// - "ADULT_HMR" : Adult - Exclude High and Moderate Risk.
  core.String? excludedAdultRisk;

  /// Brand Safety - **Alcohol**.
  /// Possible string values are:
  /// - "ALCOHOL_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any alcohol options.
  /// - "ALCOHOL_HR" : Alcohol - Exclude High Risk.
  /// - "ALCOHOL_HMR" : Alcohol - Exclude High and Moderate Risk.
  core.String? excludedAlcoholRisk;

  /// Brand Safety - **Drugs**.
  /// Possible string values are:
  /// - "DRUGS_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any drugs options.
  /// - "DRUGS_HR" : Drugs - Exclude High Risk.
  /// - "DRUGS_HMR" : Drugs - Exclude High and Moderate Risk.
  core.String? excludedDrugsRisk;

  /// Brand Safety - **Gambling**.
  /// Possible string values are:
  /// - "GAMBLING_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any gambling options.
  /// - "GAMBLING_HR" : Gambling - Exclude High Risk.
  /// - "GAMBLING_HMR" : Gambling - Exclude High and Moderate Risk.
  core.String? excludedGamblingRisk;

  /// Brand Safety - **Hate speech**.
  /// Possible string values are:
  /// - "HATE_SPEECH_UNSPECIFIED" : This enum is only a placeholder and it
  /// doesn't specify any hate speech options.
  /// - "HATE_SPEECH_HR" : Hate Speech - Exclude High Risk.
  /// - "HATE_SPEECH_HMR" : Hate Speech - Exclude High and Moderate Risk.
  core.String? excludedHateSpeechRisk;

  /// Brand Safety - **Illegal downloads**.
  /// Possible string values are:
  /// - "ILLEGAL_DOWNLOADS_UNSPECIFIED" : This enum is only a placeholder and it
  /// doesn't specify any illegal downloads options.
  /// - "ILLEGAL_DOWNLOADS_HR" : Illegal Downloads - Exclude High Risk.
  /// - "ILLEGAL_DOWNLOADS_HMR" : Illegal Downloads - Exclude High and Moderate
  /// Risk.
  core.String? excludedIllegalDownloadsRisk;

  /// Brand Safety - **Offensive language**.
  /// Possible string values are:
  /// - "OFFENSIVE_LANGUAGE_UNSPECIFIED" : This enum is only a placeholder and
  /// it doesn't specify any language options.
  /// - "OFFENSIVE_LANGUAGE_HR" : Offensive Language - Exclude High Risk.
  /// - "OFFENSIVE_LANGUAGE_HMR" : Offensive Language - Exclude High and
  /// Moderate Risk.
  core.String? excludedOffensiveLanguageRisk;

  /// Brand Safety - **Violence**.
  /// Possible string values are:
  /// - "VIOLENCE_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any violence options.
  /// - "VIOLENCE_HR" : Violence - Exclude High Risk.
  /// - "VIOLENCE_HMR" : Violence - Exclude High and Moderate Risk.
  core.String? excludedViolenceRisk;

  /// The quality sync custom segment ID provided by Integral Ad Science.
  ///
  /// The ID must be between `3000000` and `4999999`, inclusive.
  ///
  /// Optional.
  core.List<core.String>? qualitySyncCustomSegmentId;

  /// True advertising quality (applicable to Display line items only).
  /// Possible string values are:
  /// - "TRAQ_UNSPECIFIED" : This enum is only a placeholder and it doesn't
  /// specify any true advertising quality scores.
  /// - "TRAQ_250" : TRAQ score 250-1000.
  /// - "TRAQ_500" : TRAQ score 500-1000.
  /// - "TRAQ_600" : TRAQ score 600-1000.
  /// - "TRAQ_700" : TRAQ score 700-1000.
  /// - "TRAQ_750" : TRAQ score 750-1000.
  /// - "TRAQ_875" : TRAQ score 875-1000.
  /// - "TRAQ_1000" : TRAQ score 1000.
  core.String? traqScoreOption;

  /// Video Viewability Section (applicable to video line items only).
  /// Possible string values are:
  /// - "VIDEO_VIEWABILITY_UNSPECIFIED" : This enum is only a placeholder and it
  /// doesn't specify any video viewability options.
  /// - "VIDEO_VIEWABILITY_40" : 40%+ in view (IAB video viewability standard).
  /// - "VIDEO_VIEWABILITY_50" : 50%+ in view (IAB video viewability standard).
  /// - "VIDEO_VIEWABILITY_60" : 60%+ in view (IAB video viewability standard).
  /// - "VIDEO_VIEWABILITY_70" : 70%+ in view (IAB video viewability standard).
  core.String? videoViewability;

  $IntegralAdScience({
    this.customSegmentId,
    this.displayViewability,
    this.excludeUnrateable,
    this.excludedAdFraudRisk,
    this.excludedAdultRisk,
    this.excludedAlcoholRisk,
    this.excludedDrugsRisk,
    this.excludedGamblingRisk,
    this.excludedHateSpeechRisk,
    this.excludedIllegalDownloadsRisk,
    this.excludedOffensiveLanguageRisk,
    this.excludedViolenceRisk,
    this.qualitySyncCustomSegmentId,
    this.traqScoreOption,
    this.videoViewability,
  });

  $IntegralAdScience.fromJson(core.Map json_)
    : this(
        customSegmentId:
            (json_['customSegmentId'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        displayViewability: json_['displayViewability'] as core.String?,
        excludeUnrateable: json_['excludeUnrateable'] as core.bool?,
        excludedAdFraudRisk: json_['excludedAdFraudRisk'] as core.String?,
        excludedAdultRisk: json_['excludedAdultRisk'] as core.String?,
        excludedAlcoholRisk: json_['excludedAlcoholRisk'] as core.String?,
        excludedDrugsRisk: json_['excludedDrugsRisk'] as core.String?,
        excludedGamblingRisk: json_['excludedGamblingRisk'] as core.String?,
        excludedHateSpeechRisk: json_['excludedHateSpeechRisk'] as core.String?,
        excludedIllegalDownloadsRisk:
            json_['excludedIllegalDownloadsRisk'] as core.String?,
        excludedOffensiveLanguageRisk:
            json_['excludedOffensiveLanguageRisk'] as core.String?,
        excludedViolenceRisk: json_['excludedViolenceRisk'] as core.String?,
        qualitySyncCustomSegmentId:
            (json_['qualitySyncCustomSegmentId'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        traqScoreOption: json_['traqScoreOption'] as core.String?,
        videoViewability: json_['videoViewability'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customSegmentId != null) 'customSegmentId': customSegmentId!,
    if (displayViewability != null) 'displayViewability': displayViewability!,
    if (excludeUnrateable != null) 'excludeUnrateable': excludeUnrateable!,
    if (excludedAdFraudRisk != null)
      'excludedAdFraudRisk': excludedAdFraudRisk!,
    if (excludedAdultRisk != null) 'excludedAdultRisk': excludedAdultRisk!,
    if (excludedAlcoholRisk != null)
      'excludedAlcoholRisk': excludedAlcoholRisk!,
    if (excludedDrugsRisk != null) 'excludedDrugsRisk': excludedDrugsRisk!,
    if (excludedGamblingRisk != null)
      'excludedGamblingRisk': excludedGamblingRisk!,
    if (excludedHateSpeechRisk != null)
      'excludedHateSpeechRisk': excludedHateSpeechRisk!,
    if (excludedIllegalDownloadsRisk != null)
      'excludedIllegalDownloadsRisk': excludedIllegalDownloadsRisk!,
    if (excludedOffensiveLanguageRisk != null)
      'excludedOffensiveLanguageRisk': excludedOffensiveLanguageRisk!,
    if (excludedViolenceRisk != null)
      'excludedViolenceRisk': excludedViolenceRisk!,
    if (qualitySyncCustomSegmentId != null)
      'qualitySyncCustomSegmentId': qualitySyncCustomSegmentId!,
    if (traqScoreOption != null) 'traqScoreOption': traqScoreOption!,
    if (videoViewability != null) 'videoViewability': videoViewability!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : IntegrationDetails
/// - displayvideo:v3 : IntegrationDetails
/// - displayvideo:v4 : IntegrationDetails
class $IntegrationDetails {
  /// Additional details of the entry in string format.
  ///
  /// Must be UTF-8 encoded with a length of no more than 1000 characters.
  core.String? details;

  /// An external identifier to be associated with the entry.
  ///
  /// The integration code will show up together with the entry in many places
  /// in the system, for example, reporting. Must be UTF-8 encoded with a length
  /// of no more than 500 characters.
  core.String? integrationCode;

  $IntegrationDetails({this.details, this.integrationCode});

  $IntegrationDetails.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        integrationCode: json_['integrationCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (integrationCode != null) 'integrationCode': integrationCode!,
  };
}

/// Used by:
///
/// - compute:alpha : ShieldedInstanceIntegrityPolicy
/// - compute:alpha : ShieldedVmIntegrityPolicy
/// - compute:beta : ShieldedInstanceIntegrityPolicy
/// - compute:beta : ShieldedVmIntegrityPolicy
/// - compute:v1 : ShieldedInstanceIntegrityPolicy
class $IntegrityPolicy {
  /// Updates the integrity policy baseline using the measurements from the VM
  /// instance's most recent boot.
  core.bool? updateAutoLearnPolicy;

  $IntegrityPolicy({this.updateAutoLearnPolicy});

  $IntegrityPolicy.fromJson(core.Map json_)
    : this(updateAutoLearnPolicy: json_['updateAutoLearnPolicy'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (updateAutoLearnPolicy != null)
      'updateAutoLearnPolicy': updateAutoLearnPolicy!,
  };
}

/// Used by:
///
/// - playintegrity:v1 : DecodeIntegrityTokenRequest
/// - playintegrity:v1 : DecodePcIntegrityTokenRequest
class $IntegrityTokenRequest {
  /// Encoded integrity token.
  core.String? integrityToken;

  $IntegrityTokenRequest({this.integrityToken});

  $IntegrityTokenRequest.fromJson(core.Map json_)
    : this(integrityToken: json_['integrityToken'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (integrityToken != null) 'integrityToken': integrityToken!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2IntentClassificationConfigExample
/// - retail:v2alpha : GoogleCloudRetailV2alphaIntentClassificationConfigExample
/// - retail:v2beta : GoogleCloudRetailV2betaIntentClassificationConfigExample
class $IntentClassificationConfigExample {
  /// Whether the example is classified positively.
  ///
  /// Required.
  core.bool? classifiedPositive;

  /// The intent_type must match one of the predefined intent types defined at
  /// https://cloud.google.com/retail/docs/reference/rpc/google.cloud.retail.v2alpha#querytype
  ///
  /// Optional.
  core.String? intentType;

  /// Example query.
  ///
  /// Required.
  core.String? query;

  /// The reason for the intent classification.
  ///
  /// This is used to explain the intent classification decision.
  ///
  /// Optional.
  core.String? reason;

  $IntentClassificationConfigExample({
    this.classifiedPositive,
    this.intentType,
    this.query,
    this.reason,
  });

  $IntentClassificationConfigExample.fromJson(core.Map json_)
    : this(
        classifiedPositive: json_['classifiedPositive'] as core.bool?,
        intentType: json_['intentType'] as core.String?,
        query: json_['query'] as core.String?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classifiedPositive != null) 'classifiedPositive': classifiedPositive!,
    if (intentType != null) 'intentType': intentType!,
    if (query != null) 'query': query!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2IntentClassificationConfigInlineForceIntent
/// - retail:v2alpha : GoogleCloudRetailV2alphaIntentClassificationConfigInlineForceIntent
/// - retail:v2beta : GoogleCloudRetailV2betaIntentClassificationConfigInlineForceIntent
class $IntentClassificationConfigInlineForceIntent {
  /// The intent_type must match one of the predefined intent types defined at
  /// https://cloud.google.com/retail/docs/reference/rpc/google.cloud.retail.v2alpha#querytype
  ///
  /// Optional.
  core.String? intentType;

  /// The operation to perform for the query.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "OPERATION_UNSPECIFIED" : Unspecified match operation.
  /// - "EXACT_MATCH" : Exact match.
  /// - "CONTAINS" : Contains match.
  core.String? operation;

  /// A example query.
  ///
  /// Optional.
  core.String? query;

  $IntentClassificationConfigInlineForceIntent({
    this.intentType,
    this.operation,
    this.query,
  });

  $IntentClassificationConfigInlineForceIntent.fromJson(core.Map json_)
    : this(
        intentType: json_['intentType'] as core.String?,
        operation: json_['operation'] as core.String?,
        query: json_['query'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (intentType != null) 'intentType': intentType!,
    if (operation != null) 'operation': operation!,
    if (query != null) 'query': query!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3IntentCoverageIntent
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1IntentCoverageIntent
class $IntentCoverageIntent {
  /// Whether the intent is covered by at least one of the agent's test cases.
  core.bool? covered;

  /// The intent full resource name
  core.String? intent;

  $IntentCoverageIntent({this.covered, this.intent});

  $IntentCoverageIntent.fromJson(core.Map json_)
    : this(
        covered: json_['covered'] as core.bool?,
        intent: json_['intent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (covered != null) 'covered': covered!,
    if (intent != null) 'intent': intent!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentFollowupIntentInfo
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentFollowupIntentInfo
class $IntentFollowupIntentInfo {
  /// The unique identifier of the followup intent.
  ///
  /// Format: `projects//agent/intents/`.
  core.String? followupIntentName;

  /// The unique identifier of the followup intent's parent.
  ///
  /// Format: `projects//agent/intents/`.
  core.String? parentFollowupIntentName;

  $IntentFollowupIntentInfo({
    this.followupIntentName,
    this.parentFollowupIntentName,
  });

  $IntentFollowupIntentInfo.fromJson(core.Map json_)
    : this(
        followupIntentName: json_['followupIntentName'] as core.String?,
        parentFollowupIntentName:
            json_['parentFollowupIntentName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (followupIntentName != null) 'followupIntentName': followupIntentName!,
    if (parentFollowupIntentName != null)
      'parentFollowupIntentName': parentFollowupIntentName!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3IntentInput
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1IntentInput
class $IntentInput {
  /// The unique identifier of the intent.
  ///
  /// Format: `projects//locations//agents//intents/`.
  ///
  /// Required.
  core.String? intent;

  $IntentInput({this.intent});

  $IntentInput.fromJson(core.Map json_)
    : this(intent: json_['intent'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (intent != null) 'intent': intent!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageBasicCardButtonOpenUriAction
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageBasicCardButtonOpenUriAction
class $IntentMessageBasicCardButtonOpenUriAction {
  /// The HTTP or HTTPS scheme URI.
  ///
  /// Required.
  core.String? uri;

  $IntentMessageBasicCardButtonOpenUriAction({this.uri});

  $IntentMessageBasicCardButtonOpenUriAction.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageBrowseCarouselCardBrowseCarouselCardItemOpenUrlAction
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageBrowseCarouselCardBrowseCarouselCardItemOpenUrlAction
class $IntentMessageBrowseCarouselCardBrowseCarouselCardItemOpenUrlAction {
  /// URL
  ///
  /// Required.
  core.String? url;

  /// Specifies the type of viewer that is used when opening the URL.
  ///
  /// Defaults to opening via web browser.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "URL_TYPE_HINT_UNSPECIFIED" : Unspecified
  /// - "AMP_ACTION" : Url would be an amp action
  /// - "AMP_CONTENT" : URL that points directly to AMP content, or to a
  /// canonical URL which refers to AMP content via .
  core.String? urlTypeHint;

  $IntentMessageBrowseCarouselCardBrowseCarouselCardItemOpenUrlAction({
    this.url,
    this.urlTypeHint,
  });

  $IntentMessageBrowseCarouselCardBrowseCarouselCardItemOpenUrlAction.fromJson(
    core.Map json_,
  ) : this(
        url: json_['url'] as core.String?,
        urlTypeHint: json_['urlTypeHint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (url != null) 'url': url!,
    if (urlTypeHint != null) 'urlTypeHint': urlTypeHint!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageCardButton
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageCardButton
class $IntentMessageCardButton {
  /// The text to send back to the Dialogflow API or a URI to open.
  ///
  /// Optional.
  core.String? postback;

  /// The text to show on the button.
  ///
  /// Optional.
  core.String? text;

  $IntentMessageCardButton({this.postback, this.text});

  $IntentMessageCardButton.fromJson(core.Map json_)
    : this(
        postback: json_['postback'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (postback != null) 'postback': postback!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageColumnProperties
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageColumnProperties
class $IntentMessageColumnProperties {
  /// Column heading.
  ///
  /// Required.
  core.String? header;

  /// Defines text alignment for all cells in this column.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HORIZONTAL_ALIGNMENT_UNSPECIFIED" : Text is aligned to the leading edge
  /// of the column.
  /// - "LEADING" : Text is aligned to the leading edge of the column.
  /// - "CENTER" : Text is centered in the column.
  /// - "TRAILING" : Text is aligned to the trailing edge of the column.
  core.String? horizontalAlignment;

  $IntentMessageColumnProperties({this.header, this.horizontalAlignment});

  $IntentMessageColumnProperties.fromJson(core.Map json_)
    : this(
        header: json_['header'] as core.String?,
        horizontalAlignment: json_['horizontalAlignment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (header != null) 'header': header!,
    if (horizontalAlignment != null)
      'horizontalAlignment': horizontalAlignment!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageLinkOutSuggestion
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageLinkOutSuggestion
class $IntentMessageLinkOutSuggestion {
  /// The name of the app or site this chip is linking to.
  ///
  /// Required.
  core.String? destinationName;

  /// The URI of the app or site to open when the user taps the suggestion chip.
  ///
  /// Required.
  core.String? uri;

  $IntentMessageLinkOutSuggestion({this.destinationName, this.uri});

  $IntentMessageLinkOutSuggestion.fromJson(core.Map json_)
    : this(
        destinationName: json_['destinationName'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationName != null) 'destinationName': destinationName!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageQuickReplies
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageQuickReplies
class $IntentMessageQuickReplies {
  /// The collection of quick replies.
  ///
  /// Optional.
  core.List<core.String>? quickReplies;

  /// The title of the collection of quick replies.
  ///
  /// Optional.
  core.String? title;

  $IntentMessageQuickReplies({this.quickReplies, this.title});

  $IntentMessageQuickReplies.fromJson(core.Map json_)
    : this(
        quickReplies:
            (json_['quickReplies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (quickReplies != null) 'quickReplies': quickReplies!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageSelectItemInfo
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageSelectItemInfo
class $IntentMessageSelectItemInfo {
  /// A unique key that will be sent back to the agent if this response is
  /// given.
  ///
  /// Required.
  core.String? key;

  /// A list of synonyms that can also be used to trigger this item in dialog.
  ///
  /// Optional.
  core.List<core.String>? synonyms;

  $IntentMessageSelectItemInfo({this.key, this.synonyms});

  $IntentMessageSelectItemInfo.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (synonyms != null) 'synonyms': synonyms!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageSimpleResponse
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageSimpleResponse
class $IntentMessageSimpleResponse {
  /// The text to display.
  ///
  /// Optional.
  core.String? displayText;

  /// One of text_to_speech or ssml must be provided.
  ///
  /// Structured spoken response to the user in the SSML format. Mutually
  /// exclusive with text_to_speech.
  core.String? ssml;

  /// One of text_to_speech or ssml must be provided.
  ///
  /// The plain text of the speech output. Mutually exclusive with ssml.
  core.String? textToSpeech;

  $IntentMessageSimpleResponse({
    this.displayText,
    this.ssml,
    this.textToSpeech,
  });

  $IntentMessageSimpleResponse.fromJson(core.Map json_)
    : this(
        displayText: json_['displayText'] as core.String?,
        ssml: json_['ssml'] as core.String?,
        textToSpeech: json_['textToSpeech'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayText != null) 'displayText': displayText!,
    if (ssml != null) 'ssml': ssml!,
    if (textToSpeech != null) 'textToSpeech': textToSpeech!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageSuggestion
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageSuggestion
class $IntentMessageSuggestion {
  /// The text shown the in the suggestion chip.
  ///
  /// Required.
  core.String? title;

  $IntentMessageSuggestion({this.title});

  $IntentMessageSuggestion.fromJson(core.Map json_)
    : this(title: json_['title'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageTableCardCell
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageTableCardCell
class $IntentMessageTableCardCell {
  /// Text in this cell.
  ///
  /// Required.
  core.String? text;

  $IntentMessageTableCardCell({this.text});

  $IntentMessageTableCardCell.fromJson(core.Map json_)
    : this(text: json_['text'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentMessageText
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentMessageText
class $IntentMessageText {
  /// The collection of the agent's responses.
  ///
  /// Optional.
  core.List<core.String>? text;

  $IntentMessageText({this.text});

  $IntentMessageText.fromJson(core.Map json_)
    : this(
        text:
            (json_['text'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentParameter
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentParameter
class $IntentParameter00 {
  /// The default value to use when the `value` yields an empty result.
  ///
  /// Default values can be extracted from contexts by using the following
  /// syntax: `#context_name.parameter_name`.
  ///
  /// Optional.
  core.String? defaultValue;

  /// The name of the parameter.
  ///
  /// Required.
  core.String? displayName;

  /// The name of the entity type, prefixed with `@`, that describes values of
  /// the parameter.
  ///
  /// If the parameter is required, this must be provided.
  ///
  /// Optional.
  core.String? entityTypeDisplayName;

  /// Indicates whether the parameter represents a list of values.
  ///
  /// Optional.
  core.bool? isList;

  /// Indicates whether the parameter is required.
  ///
  /// That is, whether the intent cannot be completed without collecting the
  /// parameter value.
  ///
  /// Optional.
  core.bool? mandatory;

  /// The unique identifier of this parameter.
  core.String? name;

  /// The collection of prompts that the agent can present to the user in order
  /// to collect a value for the parameter.
  ///
  /// Optional.
  core.List<core.String>? prompts;

  /// The definition of the parameter value.
  ///
  /// It can be: - a constant string, - a parameter value defined as
  /// `$parameter_name`, - an original parameter value defined as
  /// `$parameter_name.original`, - a parameter value from some context defined
  /// as `#context_name.parameter_name`.
  ///
  /// Optional.
  core.String? value;

  $IntentParameter00({
    this.defaultValue,
    this.displayName,
    this.entityTypeDisplayName,
    this.isList,
    this.mandatory,
    this.name,
    this.prompts,
    this.value,
  });

  $IntentParameter00.fromJson(core.Map json_)
    : this(
        defaultValue: json_['defaultValue'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        entityTypeDisplayName: json_['entityTypeDisplayName'] as core.String?,
        isList: json_['isList'] as core.bool?,
        mandatory: json_['mandatory'] as core.bool?,
        name: json_['name'] as core.String?,
        prompts:
            (json_['prompts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultValue != null) 'defaultValue': defaultValue!,
    if (displayName != null) 'displayName': displayName!,
    if (entityTypeDisplayName != null)
      'entityTypeDisplayName': entityTypeDisplayName!,
    if (isList != null) 'isList': isList!,
    if (mandatory != null) 'mandatory': mandatory!,
    if (name != null) 'name': name!,
    if (prompts != null) 'prompts': prompts!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3IntentParameter
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1IntentParameter
class $IntentParameter01 {
  /// The entity type of the parameter.
  ///
  /// Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity
  /// types (for example,
  /// `projects/-/locations/-/agents/-/entityTypes/sys.date`), or
  /// `projects//locations//agents//entityTypes/` for developer entity types.
  ///
  /// Required.
  core.String? entityType;

  /// The unique identifier of the parameter.
  ///
  /// This field is used by training phrases to annotate their parts.
  ///
  /// Required.
  core.String? id;

  /// Indicates whether the parameter represents a list of values.
  core.bool? isList;

  /// Indicates whether the parameter content should be redacted in log.
  ///
  /// If redaction is enabled, the parameter content will be replaced by
  /// parameter name during logging. Note: the parameter content is subject to
  /// redaction if either parameter level redaction or entity type level
  /// redaction is enabled.
  core.bool? redact;

  $IntentParameter01({this.entityType, this.id, this.isList, this.redact});

  $IntentParameter01.fromJson(core.Map json_)
    : this(
        entityType: json_['entityType'] as core.String?,
        id: json_['id'] as core.String?,
        isList: json_['isList'] as core.bool?,
        redact: json_['redact'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityType != null) 'entityType': entityType!,
    if (id != null) 'id': id!,
    if (isList != null) 'isList': isList!,
    if (redact != null) 'redact': redact!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentSuggestion
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentSuggestion
class $IntentSuggestion {
  /// Human readable description for better understanding an intent like its
  /// scope, content, result etc.
  ///
  /// Maximum character limit: 140 characters.
  core.String? description;

  /// The display name of the intent.
  core.String? displayName;

  /// The unique identifier of this intent.
  ///
  /// Format: `projects//locations//agent/intents/`.
  core.String? intentV2;

  $IntentSuggestion({this.description, this.displayName, this.intentV2});

  $IntentSuggestion.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        intentV2: json_['intentV2'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (intentV2 != null) 'intentV2': intentV2!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2IntentTrainingPhrasePart
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1IntentTrainingPhrasePart
class $IntentTrainingPhrasePart00 {
  /// The parameter name for the value extracted from the annotated part of the
  /// example.
  ///
  /// This field is required for annotated parts of the training phrase.
  ///
  /// Optional.
  core.String? alias;

  /// The entity type name prefixed with `@`.
  ///
  /// This field is required for annotated parts of the training phrase.
  ///
  /// Optional.
  core.String? entityType;

  /// The text for this part.
  ///
  /// Required.
  core.String? text;

  /// Indicates whether the text was manually annotated.
  ///
  /// This field is set to true when the Dialogflow Console is used to manually
  /// annotate the part. When creating an annotated part with the API, you must
  /// set this to true.
  ///
  /// Optional.
  core.bool? userDefined;

  $IntentTrainingPhrasePart00({
    this.alias,
    this.entityType,
    this.text,
    this.userDefined,
  });

  $IntentTrainingPhrasePart00.fromJson(core.Map json_)
    : this(
        alias: json_['alias'] as core.String?,
        entityType: json_['entityType'] as core.String?,
        text: json_['text'] as core.String?,
        userDefined: json_['userDefined'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alias != null) 'alias': alias!,
    if (entityType != null) 'entityType': entityType!,
    if (text != null) 'text': text!,
    if (userDefined != null) 'userDefined': userDefined!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3IntentTrainingPhrasePart
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1IntentTrainingPhrasePart
class $IntentTrainingPhrasePart01 {
  /// The parameter used to annotate this part of the training phrase.
  ///
  /// This field is required for annotated parts of the training phrase.
  core.String? parameterId;

  /// The text for this part.
  ///
  /// Required.
  core.String? text;

  $IntentTrainingPhrasePart01({this.parameterId, this.text});

  $IntentTrainingPhrasePart01.fromJson(core.Map json_)
    : this(
        parameterId: json_['parameterId'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parameterId != null) 'parameterId': parameterId!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptDeployment
/// - networksecurity:v1beta1 : InterceptDeployment
class $InterceptDeployment {
  /// The timestamp when the resource was created.
  ///
  /// See https://google.aip.dev/148#timestamps.
  ///
  /// Output only.
  core.String? createTime;

  /// User-provided description of the deployment.
  ///
  /// Used as additional context for the deployment.
  ///
  /// Optional.
  core.String? description;

  /// The regional forwarding rule that fronts the interceptors, for example:
  /// `projects/123456789/regions/us-central1/forwardingRules/my-rule`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Required. Immutable.
  core.String? forwardingRule;

  /// The deployment group that this deployment is a part of, for example:
  /// `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Required. Immutable.
  core.String? interceptDeploymentGroup;

  /// Labels are key/value pairs that help to organize and filter resources.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The resource name of this deployment, for example:
  /// `projects/123456789/locations/us-central1-a/interceptDeployments/my-dep`.
  /// See https://google.aip.dev/122 for more details.
  ///
  /// Immutable.
  core.String? name;

  /// The current state of the resource does not match the user's intended
  /// state, and the system is working to reconcile them.
  ///
  /// This part of the normal operation (e.g. linking a new association to the
  /// parent group). See https://google.aip.dev/128.
  ///
  /// Output only.
  core.bool? reconciling;

  /// The current state of the deployment.
  ///
  /// See https://google.aip.dev/216.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set (this is not a valid state).
  /// - "ACTIVE" : The deployment is ready and in sync with the parent group.
  /// - "CREATING" : The deployment is being created.
  /// - "DELETING" : The deployment is being deleted.
  /// - "OUT_OF_SYNC" : The deployment is out of sync with the parent group. In
  /// most cases, this is a result of a transient issue within the system (e.g.
  /// a delayed data-path config) and the system is expected to recover
  /// automatically. See the parent deployment group's state for more details.
  /// - "DELETE_FAILED" : An attempt to delete the deployment has failed. This
  /// is a terminal state and the deployment is not expected to recover. The
  /// only permitted operation is to retry deleting the deployment.
  core.String? state;

  /// The timestamp when the resource was most recently updated.
  ///
  /// See https://google.aip.dev/148#timestamps.
  ///
  /// Output only.
  core.String? updateTime;

  $InterceptDeployment({
    this.createTime,
    this.description,
    this.forwardingRule,
    this.interceptDeploymentGroup,
    this.labels,
    this.name,
    this.reconciling,
    this.state,
    this.updateTime,
  });

  $InterceptDeployment.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        forwardingRule: json_['forwardingRule'] as core.String?,
        interceptDeploymentGroup:
            json_['interceptDeploymentGroup'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        reconciling: json_['reconciling'] as core.bool?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (interceptDeploymentGroup != null)
      'interceptDeploymentGroup': interceptDeploymentGroup!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (reconciling != null) 'reconciling': reconciling!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptDeploymentGroupConnectedEndpointGroup
/// - networksecurity:v1beta1 : InterceptDeploymentGroupConnectedEndpointGroup
class $InterceptDeploymentGroupConnectedEndpointGroup {
  /// The connected endpoint group's resource name, for example:
  /// `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? name;

  $InterceptDeploymentGroupConnectedEndpointGroup({this.name});

  $InterceptDeploymentGroupConnectedEndpointGroup.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptDeploymentGroupDeployment
/// - networksecurity:v1beta1 : InterceptDeploymentGroupDeployment
class $InterceptDeploymentGroupDeployment {
  /// The name of the Intercept Deployment, in the format:
  /// `projects/{project}/locations/{location}/interceptDeployments/{intercept_deployment}`.
  ///
  /// Output only.
  core.String? name;

  /// Most recent known state of the deployment.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set (this is not a valid state).
  /// - "ACTIVE" : The deployment is ready and in sync with the parent group.
  /// - "CREATING" : The deployment is being created.
  /// - "DELETING" : The deployment is being deleted.
  /// - "OUT_OF_SYNC" : The deployment is out of sync with the parent group. In
  /// most cases, this is a result of a transient issue within the system (e.g.
  /// a delayed data-path config) and the system is expected to recover
  /// automatically. See the parent deployment group's state for more details.
  /// - "DELETE_FAILED" : An attempt to delete the deployment has failed. This
  /// is a terminal state and the deployment is not expected to recover. The
  /// only permitted operation is to retry deleting the deployment.
  core.String? state;

  $InterceptDeploymentGroupDeployment({this.name, this.state});

  $InterceptDeploymentGroupDeployment.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptEndpointGroupAssociationDetails
/// - networksecurity:v1beta1 : InterceptEndpointGroupAssociationDetails
class $InterceptEndpointGroupAssociationDetails {
  /// The connected association's resource name, for example:
  /// `projects/123456789/locations/global/interceptEndpointGroupAssociations/my-ega`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? name;

  /// The associated network, for example:
  /// projects/123456789/global/networks/my-network.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? network;

  /// Most recent known state of the association.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "ACTIVE" : The association is ready and in sync with the linked endpoint
  /// group.
  /// - "CREATING" : The association is being created.
  /// - "DELETING" : The association is being deleted.
  /// - "CLOSED" : The association is disabled due to a breaking change in
  /// another resource.
  /// - "OUT_OF_SYNC" : The association is out of sync with the linked endpoint
  /// group. In most cases, this is a result of a transient issue within the
  /// system (e.g. an inaccessible location) and the system is expected to
  /// recover automatically. Check the `locations_details` field for more
  /// details.
  /// - "DELETE_FAILED" : An attempt to delete the association has failed. This
  /// is a terminal state and the association is not expected to be usable as
  /// some of its resources have been deleted. The only permitted operation is
  /// to retry deleting the association.
  core.String? state;

  $InterceptEndpointGroupAssociationDetails({
    this.name,
    this.network,
    this.state,
  });

  $InterceptEndpointGroupAssociationDetails.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectApplicationAwareInterconnectBandwidthPercentage
/// - compute:beta : InterconnectApplicationAwareInterconnectBandwidthPercentage
class $InterconnectApplicationAwareInterconnectBandwidthPercentage {
  /// Bandwidth percentage for a specific traffic class.
  core.int? percentage;

  /// TrafficClass whose bandwidth percentage is being specified.
  /// Possible string values are:
  /// - "TC1" : Traffic Class 1, corresponding to DSCP ranges (0-7) 000xxx.
  /// - "TC2" : Traffic Class 2, corresponding to DSCP ranges (8-15) 001xxx.
  /// - "TC3" : Traffic Class 3, corresponding to DSCP ranges (16-23) 010xxx.
  /// - "TC4" : Traffic Class 4, corresponding to DSCP ranges (24-31) 011xxx.
  /// - "TC5" : Traffic Class 5, corresponding to DSCP ranges (32-47) 10xxxx.
  /// - "TC6" : Traffic Class 6, corresponding to DSCP ranges (48-63) 11xxxx.
  core.String? trafficClass;

  $InterconnectApplicationAwareInterconnectBandwidthPercentage({
    this.percentage,
    this.trafficClass,
  });

  $InterconnectApplicationAwareInterconnectBandwidthPercentage.fromJson(
    core.Map json_,
  ) : this(
        percentage: json_['percentage'] as core.int?,
        trafficClass: json_['trafficClass'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (percentage != null) 'percentage': percentage!,
    if (trafficClass != null) 'trafficClass': trafficClass!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange
/// - compute:beta : InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange
/// - compute:v1 : InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange
class $InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange {
  core.int? max;
  core.int? min;

  $InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange({
    this.max,
    this.min,
  });

  $InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange.fromJson(
    core.Map json_,
  ) : this(max: json_['max'] as core.int?, min: json_['min'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (max != null) 'max': max!,
    if (min != null) 'min': min!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentGroupAttachment
/// - compute:beta : InterconnectAttachmentGroupAttachment
/// - compute:v1 : InterconnectAttachmentGroupAttachment
class $InterconnectAttachmentGroupAttachment {
  core.String? attachment;

  $InterconnectAttachmentGroupAttachment({this.attachment});

  $InterconnectAttachmentGroupAttachment.fromJson(core.Map json_)
    : this(attachment: json_['attachment'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachment != null) 'attachment': attachment!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers
/// - compute:beta : InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers
/// - compute:v1 : InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers
class $InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers {
  /// URLs of any particular Attachments to explain this blocker in more detail.
  ///
  /// Output only.
  core.List<core.String>? attachments;

  ///
  /// Possible string values are:
  /// - "BLOCKER_TYPE_UNSPECIFIED"
  /// - "INCOMPATIBLE_METROS"
  /// - "INCOMPATIBLE_REGIONS"
  /// - "MISSING_GLOBAL_ROUTING"
  /// - "NO_ATTACHMENTS"
  /// - "NO_ATTACHMENTS_IN_METRO_AND_ZONE"
  /// - "OTHER"
  core.String? blockerType;

  /// The url of Google Cloud public documentation explaining this requirement.
  ///
  /// This is set for every type of requirement.
  ///
  /// Output only.
  core.String? documentationLink;

  /// A human-readable explanation of this requirement and why it's not met.
  ///
  /// This is set for every type of requirement.
  ///
  /// Output only.
  core.String? explanation;

  /// Metros used to explain this blocker in more detail.
  ///
  /// These are three-letter lowercase strings like "iad". This will be set for
  /// some blockers (like NO_ATTACHMENTS_IN_METRO_AND_ZONE) but does not apply
  /// to others.
  ///
  /// Output only.
  core.List<core.String>? metros;

  /// Regions used to explain this blocker in more detail.
  ///
  /// These are region names formatted like "us-central1". This will be set for
  /// some blockers (like INCOMPATIBLE_REGIONS) but does not apply to others.
  ///
  /// Output only.
  core.List<core.String>? regions;

  /// Zones used to explain this blocker in more detail.
  ///
  /// Format is "zone1" and/or "zone2". This will be set for some blockers (like
  /// MISSING_ZONE) but does not apply to others.
  ///
  /// Output only.
  core.List<core.String>? zones;

  $InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers({
    this.attachments,
    this.blockerType,
    this.documentationLink,
    this.explanation,
    this.metros,
    this.regions,
    this.zones,
  });

  $InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers.fromJson(
    core.Map json_,
  ) : this(
        attachments:
            (json_['attachments'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        blockerType: json_['blockerType'] as core.String?,
        documentationLink: json_['documentationLink'] as core.String?,
        explanation: json_['explanation'] as core.String?,
        metros:
            (json_['metros'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        regions:
            (json_['regions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        zones:
            (json_['zones'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachments != null) 'attachments': attachments!,
    if (blockerType != null) 'blockerType': blockerType!,
    if (documentationLink != null) 'documentationLink': documentationLink!,
    if (explanation != null) 'explanation': explanation!,
    if (metros != null) 'metros': metros!,
    if (regions != null) 'regions': regions!,
    if (zones != null) 'zones': zones!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentGroupIntent
/// - compute:beta : InterconnectAttachmentGroupIntent
/// - compute:v1 : InterconnectAttachmentGroupIntent
class $InterconnectAttachmentGroupIntent {
  ///
  /// Possible string values are:
  /// - "AVAILABILITY_SLA_UNSPECIFIED"
  /// - "NO_SLA"
  /// - "PRODUCTION_CRITICAL"
  /// - "PRODUCTION_NON_CRITICAL"
  core.String? availabilitySla;

  $InterconnectAttachmentGroupIntent({this.availabilitySla});

  $InterconnectAttachmentGroupIntent.fromJson(core.Map json_)
    : this(availabilitySla: json_['availabilitySla'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (availabilitySla != null) 'availabilitySla': availabilitySla!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone
/// - compute:beta : InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone
/// - compute:v1 : InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone
class $InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone {
  /// URLs of Attachments in the given zone, to the given region, on
  /// Interconnects in the given facility and metro.
  ///
  /// Every Attachment in the AG has such an entry.
  ///
  /// Output only.
  core.List<core.String>? attachments;

  /// The name of a zone, either "zone1" or "zone2".
  ///
  /// Output only.
  core.String? zone;

  $InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone({
    this.attachments,
    this.zone,
  });

  $InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone.fromJson(
    core.Map json_,
  ) : this(
        attachments:
            (json_['attachments'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachments != null) 'attachments': attachments!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentGroupsOperationalStatusAttachmentStatus
/// - compute:beta : InterconnectAttachmentGroupsOperationalStatusAttachmentStatus
/// - compute:v1 : InterconnectAttachmentGroupsOperationalStatusAttachmentStatus
class $InterconnectAttachmentGroupsOperationalStatusAttachmentStatus {
  /// Whether this Attachment is enabled.
  ///
  /// This becomes false when the customer drains their Attachment.
  core.bool? adminEnabled;

  /// The URL of the Attachment being described.
  core.String? attachment;

  /// Whether this Attachment is participating in the redundant configuration.
  ///
  /// This will be ACTIVE if and only if the status below is CONNECTION_UP. Any
  /// INACTIVE Attachments are excluded from the analysis that generates
  /// operational.availabilitySLA.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  /// - "UNSPECIFIED"
  core.String? isActive;

  /// Whether this Attachment is active, and if so, whether BGP is up.
  ///
  /// This is based on the statuses available in the Pantheon UI here:
  /// http://google3/java/com/google/cloud/boq/clientapi/gce/hybrid/api/interconnect_models.proto
  /// Possible string values are:
  /// - "ATTACHMENT_STATUS_UNKNOWN"
  /// - "CONNECTION_DISABLED"
  /// - "CONNECTION_DOWN"
  /// - "CONNECTION_UP"
  /// - "DEFUNCT"
  /// - "IPSEC_CONFIGURATION_NEEDED_STATUS"
  /// - "IPSEC_READY_TO_RESUME_FLOW_STATUS"
  /// - "IPV4_DOWN_IPV6_UP"
  /// - "IPV4_UP_IPV6_DOWN"
  /// - "PARTNER_REQUEST_RECEIVED"
  /// - "PENDING_CUSTOMER"
  /// - "PENDING_PARTNER"
  /// - "PROVISIONED"
  /// - "ROUTER_CONFIGURATION_BROKEN"
  /// - "UNPROVISIONED"
  core.String? status;

  $InterconnectAttachmentGroupsOperationalStatusAttachmentStatus({
    this.adminEnabled,
    this.attachment,
    this.isActive,
    this.status,
  });

  $InterconnectAttachmentGroupsOperationalStatusAttachmentStatus.fromJson(
    core.Map json_,
  ) : this(
        adminEnabled: json_['adminEnabled'] as core.bool?,
        attachment: json_['attachment'] as core.String?,
        isActive: json_['isActive'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adminEnabled != null) 'adminEnabled': adminEnabled!,
    if (attachment != null) 'attachment': attachment!,
    if (isActive != null) 'isActive': isActive!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentPartnerMetadata
/// - compute:beta : InterconnectAttachmentPartnerMetadata
/// - compute:v1 : InterconnectAttachmentPartnerMetadata
class $InterconnectAttachmentPartnerMetadata {
  /// Plain text name of the Interconnect this attachment is connected to, as
  /// displayed in the Partner's portal.
  ///
  /// For instance "Chicago 1". This value may be validated to match approved
  /// Partner values.
  core.String? interconnectName;

  /// Plain text name of the Partner providing this attachment.
  ///
  /// This value may be validated to match approved Partner values.
  core.String? partnerName;

  /// URL of the Partner's portal for this Attachment.
  ///
  /// Partners may customise this to be a deep link to the specific resource on
  /// the Partner portal. This value may be validated to match approved Partner
  /// values.
  core.String? portalUrl;

  $InterconnectAttachmentPartnerMetadata({
    this.interconnectName,
    this.partnerName,
    this.portalUrl,
  });

  $InterconnectAttachmentPartnerMetadata.fromJson(core.Map json_)
    : this(
        interconnectName: json_['interconnectName'] as core.String?,
        partnerName: json_['partnerName'] as core.String?,
        portalUrl: json_['portalUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnectName != null) 'interconnectName': interconnectName!,
    if (partnerName != null) 'partnerName': partnerName!,
    if (portalUrl != null) 'portalUrl': portalUrl!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectAttachmentPrivateInfo
/// - compute:beta : InterconnectAttachmentPrivateInfo
/// - compute:v1 : InterconnectAttachmentPrivateInfo
class $InterconnectAttachmentPrivateInfo {
  /// 802.1q encapsulation tag to be used for traffic between Google and the
  /// customer, going to and from this network and region.
  ///
  /// Output only.
  core.int? tag8021q;

  $InterconnectAttachmentPrivateInfo({this.tag8021q});

  $InterconnectAttachmentPrivateInfo.fromJson(core.Map json_)
    : this(tag8021q: json_['tag8021q'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (tag8021q != null) 'tag8021q': tag8021q!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectCircuitInfo
/// - compute:beta : InterconnectCircuitInfo
/// - compute:v1 : InterconnectCircuitInfo
class $InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String? customerDemarcId;

  /// Google-assigned unique ID for this circuit.
  ///
  /// Assigned at circuit turn-up.
  core.String? googleCircuitId;

  /// Google-side demarc ID for this circuit.
  ///
  /// Assigned at circuit turn-up and provided by Google to the customer in the
  /// LOA.
  core.String? googleDemarcId;

  $InterconnectCircuitInfo({
    this.customerDemarcId,
    this.googleCircuitId,
    this.googleDemarcId,
  });

  $InterconnectCircuitInfo.fromJson(core.Map json_)
    : this(
        customerDemarcId: json_['customerDemarcId'] as core.String?,
        googleCircuitId: json_['googleCircuitId'] as core.String?,
        googleDemarcId: json_['googleDemarcId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customerDemarcId != null) 'customerDemarcId': customerDemarcId!,
    if (googleCircuitId != null) 'googleCircuitId': googleCircuitId!,
    if (googleDemarcId != null) 'googleDemarcId': googleDemarcId!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectDiagnosticsARPEntry
/// - compute:beta : InterconnectDiagnosticsARPEntry
/// - compute:v1 : InterconnectDiagnosticsARPEntry
class $InterconnectDiagnosticsARPEntry {
  /// The IP address of this ARP neighbor.
  core.String? ipAddress;

  /// The MAC address of this ARP neighbor.
  core.String? macAddress;

  $InterconnectDiagnosticsARPEntry({this.ipAddress, this.macAddress});

  $InterconnectDiagnosticsARPEntry.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        macAddress: json_['macAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (macAddress != null) 'macAddress': macAddress!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectDiagnosticsLinkLACPStatus
/// - compute:beta : InterconnectDiagnosticsLinkLACPStatus
/// - compute:v1 : InterconnectDiagnosticsLinkLACPStatus
class $InterconnectDiagnosticsLinkLACPStatus {
  /// System ID of the port on Google's side of the LACP exchange.
  core.String? googleSystemId;

  /// System ID of the port on the neighbor's side of the LACP exchange.
  core.String? neighborSystemId;

  /// The state of a LACP link, which can take one of the following values: -
  /// ACTIVE: The link is configured and active within the bundle.
  ///
  /// - DETACHED: The link is not configured within the bundle. This means that
  /// the rest of the object should be empty.
  /// Possible string values are:
  /// - "ACTIVE" : The link is configured and active within the bundle.
  /// - "DETACHED" : The link is not configured within the bundle, this means
  /// the rest of the object should be empty.
  core.String? state;

  $InterconnectDiagnosticsLinkLACPStatus({
    this.googleSystemId,
    this.neighborSystemId,
    this.state,
  });

  $InterconnectDiagnosticsLinkLACPStatus.fromJson(core.Map json_)
    : this(
        googleSystemId: json_['googleSystemId'] as core.String?,
        neighborSystemId: json_['neighborSystemId'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleSystemId != null) 'googleSystemId': googleSystemId!,
    if (neighborSystemId != null) 'neighborSystemId': neighborSystemId!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectDiagnosticsLinkOpticalPower
/// - compute:beta : InterconnectDiagnosticsLinkOpticalPower
/// - compute:v1 : InterconnectDiagnosticsLinkOpticalPower
class $InterconnectDiagnosticsLinkOpticalPower {
  /// The status of the current value when compared to the warning and alarm
  /// levels for the receiving or transmitting transceiver.
  ///
  /// Possible states include: - OK: The value has not crossed a warning
  /// threshold. - LOW_WARNING: The value has crossed below the low warning
  /// threshold. - HIGH_WARNING: The value has crossed above the high warning
  /// threshold. - LOW_ALARM: The value has crossed below the low alarm
  /// threshold. - HIGH_ALARM: The value has crossed above the high alarm
  /// threshold.
  /// Possible string values are:
  /// - "HIGH_ALARM" : The value has crossed above the high alarm threshold.
  /// - "HIGH_WARNING" : The value of the current optical power has crossed
  /// above the high warning threshold.
  /// - "LOW_ALARM" : The value of the current optical power has crossed below
  /// the low alarm threshold.
  /// - "LOW_WARNING" : The value of the current optical power has crossed below
  /// the low warning threshold.
  /// - "OK" : The value of the current optical power has not crossed a warning
  /// threshold.
  core.String? state;

  /// Value of the current receiving or transmitting optical power, read in dBm.
  ///
  /// Take a known good optical value, give it a 10% margin and trigger warnings
  /// relative to that value. In general, a -7dBm warning and a -11dBm alarm are
  /// good optical value estimates for most links.
  core.double? value;

  $InterconnectDiagnosticsLinkOpticalPower({this.state, this.value});

  $InterconnectDiagnosticsLinkOpticalPower.fromJson(core.Map json_)
    : this(
        state: json_['state'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectDiagnosticsMacsecStatus
/// - compute:beta : InterconnectDiagnosticsMacsecStatus
/// - compute:v1 : InterconnectDiagnosticsMacsecStatus
class $InterconnectDiagnosticsMacsecStatus {
  /// Indicates the Connectivity Association Key Name (CKN) currently being used
  /// if MACsec is operational.
  core.String? ckn;

  /// Indicates whether or not MACsec is operational on this link.
  core.bool? operational;

  $InterconnectDiagnosticsMacsecStatus({this.ckn, this.operational});

  $InterconnectDiagnosticsMacsecStatus.fromJson(core.Map json_)
    : this(
        ckn: json_['ckn'] as core.String?,
        operational: json_['operational'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ckn != null) 'ckn': ckn!,
    if (operational != null) 'operational': operational!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers
/// - compute:beta : InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers
/// - compute:v1 : InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers
class $InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers {
  ///
  /// Possible string values are:
  /// - "INCOMPATIBLE_METROS"
  /// - "NOT_AVAILABLE"
  /// - "NO_INTERCONNECTS"
  /// - "NO_INTERCONNECTS_IN_METRO_AND_ZONE"
  /// - "OTHER"
  /// - "UNSPECIFIED"
  core.String? blockerType;

  /// The url of Google Cloud public documentation explaining this requirement.
  ///
  /// This is set for every type of requirement.
  ///
  /// Output only.
  core.String? documentationLink;

  /// A human-readable explanation of this requirement and why it's not met.
  ///
  /// This is set for every type of requirement.
  ///
  /// Output only.
  core.String? explanation;

  /// Facilities used to explain this blocker in more detail.
  ///
  /// Like physicalStructure.metros.facilities.facility, this is a numeric
  /// string like "5467".
  ///
  /// Output only.
  core.List<core.String>? facilities;

  /// Interconnects used to explain this blocker in more detail.
  ///
  /// Output only.
  core.List<core.String>? interconnects;

  /// Metros used to explain this blocker in more detail.
  ///
  /// These are three-letter lowercase strings like "iad". A blocker like
  /// INCOMPATIBLE_METROS will specify the problematic metros in this field.
  ///
  /// Output only.
  core.List<core.String>? metros;

  /// Zones used to explain this blocker in more detail.
  ///
  /// Zone names are "zone1" and/or "zone2".
  ///
  /// Output only.
  core.List<core.String>? zones;

  $InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers({
    this.blockerType,
    this.documentationLink,
    this.explanation,
    this.facilities,
    this.interconnects,
    this.metros,
    this.zones,
  });

  $InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers.fromJson(
    core.Map json_,
  ) : this(
        blockerType: json_['blockerType'] as core.String?,
        documentationLink: json_['documentationLink'] as core.String?,
        explanation: json_['explanation'] as core.String?,
        facilities:
            (json_['facilities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        interconnects:
            (json_['interconnects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        metros:
            (json_['metros'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        zones:
            (json_['zones'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blockerType != null) 'blockerType': blockerType!,
    if (documentationLink != null) 'documentationLink': documentationLink!,
    if (explanation != null) 'explanation': explanation!,
    if (facilities != null) 'facilities': facilities!,
    if (interconnects != null) 'interconnects': interconnects!,
    if (metros != null) 'metros': metros!,
    if (zones != null) 'zones': zones!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectGroupIntent
/// - compute:beta : InterconnectGroupIntent
/// - compute:v1 : InterconnectGroupIntent
class $InterconnectGroupIntent {
  ///
  /// Possible string values are:
  /// - "NO_SLA"
  /// - "PRODUCTION_CRITICAL"
  /// - "PRODUCTION_NON_CRITICAL"
  /// - "UNSPECIFIED"
  core.String? topologyCapability;

  $InterconnectGroupIntent({this.topologyCapability});

  $InterconnectGroupIntent.fromJson(core.Map json_)
    : this(topologyCapability: json_['topologyCapability'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (topologyCapability != null) 'topologyCapability': topologyCapability!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectGroupInterconnect
/// - compute:beta : InterconnectGroupInterconnect
/// - compute:v1 : InterconnectGroupInterconnect
class $InterconnectGroupInterconnect {
  /// The URL of an Interconnect in this group.
  ///
  /// All Interconnects in the group are unique.
  core.String? interconnect;

  $InterconnectGroupInterconnect({this.interconnect});

  $InterconnectGroupInterconnect.fromJson(core.Map json_)
    : this(interconnect: json_['interconnect'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnect != null) 'interconnect': interconnect!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectGroupPhysicalStructureMetrosFacilitiesZones
/// - compute:beta : InterconnectGroupPhysicalStructureMetrosFacilitiesZones
/// - compute:v1 : InterconnectGroupPhysicalStructureMetrosFacilitiesZones
class $InterconnectGroupPhysicalStructureMetrosFacilitiesZones {
  /// URLs of Interconnects in this redundancy group in the given metro,
  /// facility, and zone.
  ///
  /// Output only.
  core.List<core.String>? interconnects;

  /// The name of the zone, either "zone1" or "zone2".
  ///
  /// This is the second component of the location of Interconnects in this
  /// facility.
  ///
  /// Output only.
  core.String? zone;

  $InterconnectGroupPhysicalStructureMetrosFacilitiesZones({
    this.interconnects,
    this.zone,
  });

  $InterconnectGroupPhysicalStructureMetrosFacilitiesZones.fromJson(
    core.Map json_,
  ) : this(
        interconnects:
            (json_['interconnects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnects != null) 'interconnects': interconnects!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - compute:beta : InterconnectLocationRegionInfo
/// - compute:v1 : InterconnectLocationRegionInfo
class $InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String? expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL" : This region is not in any common network presence with this
  /// InterconnectLocation.
  /// - "LOCAL_REGION" : This region shares the same regional network presence
  /// as this InterconnectLocation.
  /// - "LP_GLOBAL" : \[Deprecated\] This region is not in any common network
  /// presence with this InterconnectLocation.
  /// - "LP_LOCAL_REGION" : \[Deprecated\] This region shares the same regional
  /// network presence as this InterconnectLocation.
  core.String? locationPresence;

  /// URL for the region of this location.
  core.String? region;

  $InterconnectLocationRegionInfo({
    this.expectedRttMs,
    this.locationPresence,
    this.region,
  });

  $InterconnectLocationRegionInfo.fromJson(core.Map json_)
    : this(
        expectedRttMs: json_['expectedRttMs'] as core.String?,
        locationPresence: json_['locationPresence'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expectedRttMs != null) 'expectedRttMs': expectedRttMs!,
    if (locationPresence != null) 'locationPresence': locationPresence!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectMacsecConfigPreSharedKey
/// - compute:beta : InterconnectMacsecConfigPreSharedKey
/// - compute:v1 : InterconnectMacsecConfigPreSharedKey
class $InterconnectMacsecConfigPreSharedKey {
  /// An auto-generated Connectivity Association Key (CAK) for this key.
  core.String? cak;

  /// An auto-generated Connectivity Association Key Name (CKN) for this key.
  core.String? ckn;

  /// User provided name for this pre-shared key.
  core.String? name;

  /// User provided timestamp on or after which this key is valid.
  core.String? startTime;

  $InterconnectMacsecConfigPreSharedKey({
    this.cak,
    this.ckn,
    this.name,
    this.startTime,
  });

  $InterconnectMacsecConfigPreSharedKey.fromJson(core.Map json_)
    : this(
        cak: json_['cak'] as core.String?,
        ckn: json_['ckn'] as core.String?,
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cak != null) 'cak': cak!,
    if (ckn != null) 'ckn': ckn!,
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectMacsecPreSharedKey
/// - compute:beta : InterconnectMacsecPreSharedKey
/// - compute:v1 : InterconnectMacsecPreSharedKey
class $InterconnectMacsecPreSharedKey {
  /// A name for this pre-shared key.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  ///
  /// Required.
  core.String? name;

  /// A RFC3339 timestamp on or after which the key is valid.
  ///
  /// startTime can be in the future. If the keychain has a single key,
  /// startTime can be omitted. If the keychain has multiple keys, startTime is
  /// mandatory for each key. The start times of keys must be in increasing
  /// order. The start times of two consecutive keys must be at least 6 hours
  /// apart.
  core.String? startTime;

  $InterconnectMacsecPreSharedKey({this.name, this.startTime});

  $InterconnectMacsecPreSharedKey.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectOutageNotification
/// - compute:beta : InterconnectOutageNotification
/// - compute:v1 : InterconnectOutageNotification
class $InterconnectOutageNotification {
  /// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String>? affectedCircuits;

  /// A description about the purpose of the outage.
  core.String? description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String? endTime;

  /// Form this outage is expected to take, which can take one of the following
  /// values: - OUTAGE: The Interconnect may be completely out of service for
  /// some or all of the specified window.
  ///
  /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole
  /// should remain up, but with reduced bandwidth. Note that the versions of
  /// this enum prefixed with "IT_" have been deprecated in favor of the
  /// unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE" : \[Deprecated\] The Interconnect may be completely out of
  /// service for some or all of the specified window.
  /// - "IT_PARTIAL_OUTAGE" : \[Deprecated\] Some circuits comprising the
  /// Interconnect will be out of service during the expected window. The
  /// interconnect as a whole should remain up, albeit with reduced bandwidth.
  /// - "OUTAGE" : The Interconnect may be completely out of service for some or
  /// all of the specified window.
  /// - "PARTIAL_OUTAGE" : Some circuits comprising the Interconnect will be out
  /// of service during the expected window. The interconnect as a whole should
  /// remain up, albeit with reduced bandwidth.
  core.String? issueType;

  /// Unique identifier for this outage notification.
  core.String? name;

  /// The party that generated this notification, which can take the following
  /// value: - GOOGLE: this notification as generated by Google.
  ///
  /// Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
  /// Possible string values are:
  /// - "GOOGLE" : This notification was generated by Google.
  /// - "NSRC_GOOGLE" : \[Deprecated\] This notification was generated by
  /// Google.
  core.String? source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String? startTime;

  /// State of this notification, which can take one of the following values: -
  /// ACTIVE: This outage notification is active.
  ///
  /// The event could be in the past, present, or future. See start_time and
  /// end_time for scheduling. - CANCELLED: The outage associated with this
  /// notification was cancelled before the outage was due to start. -
  /// COMPLETED: The outage associated with this notification is complete. Note
  /// that the versions of this enum prefixed with "NS_" have been deprecated in
  /// favor of the unprefixed values.
  /// Possible string values are:
  /// - "ACTIVE" : This outage notification is active. The event could be in the
  /// future, present, or past. See start_time and end_time for scheduling.
  /// - "CANCELLED" : The outage associated with this notification was cancelled
  /// before the outage was due to start.
  /// - "COMPLETED" : The outage associated with this notification is complete.
  /// - "NS_ACTIVE" : \[Deprecated\] This outage notification is active. The
  /// event could be in the future, present, or past. See start_time and
  /// end_time for scheduling.
  /// - "NS_CANCELED" : \[Deprecated\] The outage associated with this
  /// notification was canceled before the outage was due to start.
  core.String? state;

  $InterconnectOutageNotification({
    this.affectedCircuits,
    this.description,
    this.endTime,
    this.issueType,
    this.name,
    this.source,
    this.startTime,
    this.state,
  });

  $InterconnectOutageNotification.fromJson(core.Map json_)
    : this(
        affectedCircuits:
            (json_['affectedCircuits'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        description: json_['description'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        issueType: json_['issueType'] as core.String?,
        name: json_['name'] as core.String?,
        source: json_['source'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (affectedCircuits != null) 'affectedCircuits': affectedCircuits!,
    if (description != null) 'description': description!,
    if (endTime != null) 'endTime': endTime!,
    if (issueType != null) 'issueType': issueType!,
    if (name != null) 'name': name!,
    if (source != null) 'source': source!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectRemoteLocationConstraintsSubnetLengthRange
/// - compute:beta : InterconnectRemoteLocationConstraintsSubnetLengthRange
/// - compute:v1 : InterconnectRemoteLocationConstraintsSubnetLengthRange
class $InterconnectRemoteLocationConstraintsSubnetLengthRange {
  core.int? max;
  core.int? min;

  $InterconnectRemoteLocationConstraintsSubnetLengthRange({this.max, this.min});

  $InterconnectRemoteLocationConstraintsSubnetLengthRange.fromJson(
    core.Map json_,
  ) : this(max: json_['max'] as core.int?, min: json_['min'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (max != null) 'max': max!,
    if (min != null) 'min': min!,
  };
}

/// Used by:
///
/// - compute:alpha : InterconnectRemoteLocationPermittedConnections
/// - compute:beta : InterconnectRemoteLocationPermittedConnections
/// - compute:v1 : InterconnectRemoteLocationPermittedConnections
class $InterconnectRemoteLocationPermittedConnections {
  /// URL of an Interconnect location that is permitted to connect to this
  /// Interconnect remote location.
  ///
  /// Output only.
  core.String? interconnectLocation;

  $InterconnectRemoteLocationPermittedConnections({this.interconnectLocation});

  $InterconnectRemoteLocationPermittedConnections.fromJson(core.Map json_)
    : this(interconnectLocation: json_['interconnectLocation'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnectLocation != null)
      'interconnectLocation': interconnectLocation!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpSecuritygatewaysV1InternetGateway
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpSecuritygatewaysV1alphaInternetGateway
class $InternetGateway {
  /// List of IP addresses assigned to the Cloud NAT.
  ///
  /// Output only.
  core.List<core.String>? assignedIps;

  $InternetGateway({this.assignedIps});

  $InternetGateway.fromJson(core.Map json_)
    : this(
        assignedIps:
            (json_['assignedIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignedIps != null) 'assignedIps': assignedIps!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleTypeInterval
/// - aiplatform:v1beta1 : GoogleTypeInterval
/// - airquality:v1 : Interval
/// - apigee:v1 : GoogleTypeInterval
/// - contentwarehouse:v1 : GoogleTypeInterval
/// - dataform:v1beta1 : Interval
/// - merchantapi:inventories_v1beta : Interval
/// - merchantapi:products_v1beta : Interval
/// - merchantapi:promotions_v1beta : Interval
/// - sheets:v4 : Interval
/// - sqladmin:v1 : Interval
/// - sqladmin:v1beta4 : Interval
/// - tpu:v2 : Interval
/// - tpu:v2alpha1 : Interval
/// - versionhistory:v1 : Interval
/// - vmwareengine:v1 : Interval
class $Interval00 {
  /// Exclusive end of the interval.
  ///
  /// If specified, a Timestamp matching this interval will have to be before
  /// the end.
  ///
  /// Optional.
  core.String? endTime;

  /// Inclusive start of the interval.
  ///
  /// If specified, a Timestamp matching this interval will have to be the same
  /// or after the start.
  ///
  /// Optional.
  core.String? startTime;

  $Interval00({this.endTime, this.startTime});

  $Interval00.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Interval
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaInterval
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaInterval
/// - retail:v2 : GoogleCloudRetailV2Interval
/// - retail:v2alpha : GoogleCloudRetailV2alphaInterval
/// - retail:v2beta : GoogleCloudRetailV2betaInterval
class $Interval01 {
  /// Exclusive upper bound.
  core.double? exclusiveMaximum;

  /// Exclusive lower bound.
  core.double? exclusiveMinimum;

  /// Inclusive upper bound.
  core.double? maximum;

  /// Inclusive lower bound.
  core.double? minimum;

  $Interval01({
    this.exclusiveMaximum,
    this.exclusiveMinimum,
    this.maximum,
    this.minimum,
  });

  $Interval01.fromJson(core.Map json_)
    : this(
        exclusiveMaximum: (json_['exclusiveMaximum'] as core.num?)?.toDouble(),
        exclusiveMinimum: (json_['exclusiveMinimum'] as core.num?)?.toDouble(),
        maximum: (json_['maximum'] as core.num?)?.toDouble(),
        minimum: (json_['minimum'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exclusiveMaximum != null) 'exclusiveMaximum': exclusiveMaximum!,
    if (exclusiveMinimum != null) 'exclusiveMinimum': exclusiveMinimum!,
    if (maximum != null) 'maximum': maximum!,
    if (minimum != null) 'minimum': minimum!,
  };
}

/// Used by:
///
/// - dataproc:v1 : Interval
/// - monitoring:v1 : Interval
class $Interval02 {
  /// Exclusive end of the interval.If specified, a Timestamp matching this
  /// interval will have to be before the end.
  ///
  /// Optional.
  core.String? endTime;

  /// Inclusive start of the interval.If specified, a Timestamp matching this
  /// interval will have to be the same or after the start.
  ///
  /// Optional.
  core.String? startTime;

  $Interval02({this.endTime, this.startTime});

  $Interval02.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - container:v1 : IntraNodeVisibilityConfig
/// - container:v1beta1 : IntraNodeVisibilityConfig
class $IntraNodeVisibilityConfig {
  /// Enables intra node visibility for this cluster.
  core.bool? enabled;

  $IntraNodeVisibilityConfig({this.enabled});

  $IntraNodeVisibilityConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceAccessorsAdvertiserAccessors
/// - displayvideo:v3 : InventorySourceAccessorsAdvertiserAccessors
/// - displayvideo:v4 : InventorySourceAccessorsAdvertiserAccessors
class $InventorySourceAccessorsAdvertiserAccessors {
  /// The IDs of the advertisers.
  core.List<core.String>? advertiserIds;

  $InventorySourceAccessorsAdvertiserAccessors({this.advertiserIds});

  $InventorySourceAccessorsAdvertiserAccessors.fromJson(core.Map json_)
    : this(
        advertiserIds:
            (json_['advertiserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserIds != null) 'advertiserIds': advertiserIds!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceAccessorsPartnerAccessor
/// - displayvideo:v3 : InventorySourceAccessorsPartnerAccessor
/// - displayvideo:v4 : InventorySourceAccessorsPartnerAccessor
class $InventorySourceAccessorsPartnerAccessor {
  /// The ID of the partner.
  core.String? partnerId;

  $InventorySourceAccessorsPartnerAccessor({this.partnerId});

  $InventorySourceAccessorsPartnerAccessor.fromJson(core.Map json_)
    : this(partnerId: json_['partnerId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (partnerId != null) 'partnerId': partnerId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceAssignedTargetingOptionDetails
/// - displayvideo:v3 : InventorySourceAssignedTargetingOptionDetails
/// - displayvideo:v4 : InventorySourceAssignedTargetingOptionDetails
class $InventorySourceAssignedTargetingOptionDetails {
  /// ID of the inventory source.
  ///
  /// Should refer to the inventory_source_id field of an InventorySource
  /// resource.
  ///
  /// Required.
  core.String? inventorySourceId;

  $InventorySourceAssignedTargetingOptionDetails({this.inventorySourceId});

  $InventorySourceAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(inventorySourceId: json_['inventorySourceId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (inventorySourceId != null) 'inventorySourceId': inventorySourceId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceFilter
/// - displayvideo:v3 : InventorySourceFilter
/// - displayvideo:v4 : InventorySourceFilter
class $InventorySourceFilter {
  /// Inventory Sources to download by ID.
  ///
  /// All IDs must belong to the same Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest. Leave empty to download all Inventory
  /// Sources for the selected Advertiser or Partner.
  core.List<core.String>? inventorySourceIds;

  $InventorySourceFilter({this.inventorySourceIds});

  $InventorySourceFilter.fromJson(core.Map json_)
    : this(
        inventorySourceIds:
            (json_['inventorySourceIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inventorySourceIds != null) 'inventorySourceIds': inventorySourceIds!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceGroup
/// - displayvideo:v3 : InventorySourceGroup
/// - displayvideo:v4 : InventorySourceGroup
class $InventorySourceGroup {
  /// The display name of the inventory source group.
  ///
  /// Must be UTF-8 encoded with a maximum size of 240 bytes.
  ///
  /// Required.
  core.String? displayName;

  /// The unique ID of the inventory source group.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? inventorySourceGroupId;

  /// The resource name of the inventory source group.
  ///
  /// Output only.
  core.String? name;

  $InventorySourceGroup({
    this.displayName,
    this.inventorySourceGroupId,
    this.name,
  });

  $InventorySourceGroup.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        inventorySourceGroupId: json_['inventorySourceGroupId'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (inventorySourceGroupId != null)
      'inventorySourceGroupId': inventorySourceGroupId!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceGroupAssignedTargetingOptionDetails
/// - displayvideo:v3 : InventorySourceGroupAssignedTargetingOptionDetails
/// - displayvideo:v4 : InventorySourceGroupAssignedTargetingOptionDetails
class $InventorySourceGroupAssignedTargetingOptionDetails {
  /// ID of the inventory source group.
  ///
  /// Should refer to the inventory_source_group_id field of an
  /// InventorySourceGroup resource.
  ///
  /// Required.
  core.String? inventorySourceGroupId;

  $InventorySourceGroupAssignedTargetingOptionDetails({
    this.inventorySourceGroupId,
  });

  $InventorySourceGroupAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        inventorySourceGroupId: json_['inventorySourceGroupId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inventorySourceGroupId != null)
      'inventorySourceGroupId': inventorySourceGroupId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceStatus
/// - displayvideo:v3 : InventorySourceStatus
/// - displayvideo:v4 : InventorySourceStatus
class $InventorySourceStatus {
  /// The configuration status of the inventory source.
  ///
  /// Only applicable for guaranteed inventory sources. Acceptable values are
  /// `INVENTORY_SOURCE_CONFIG_STATUS_PENDING` and
  /// `INVENTORY_SOURCE_CONFIG_STATUS_COMPLETED`. An inventory source must be
  /// configured (fill in the required fields, choose creatives, and select a
  /// default campaign) before it can serve.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "INVENTORY_SOURCE_CONFIG_STATUS_UNSPECIFIED" : The approval status is
  /// not specified or is unknown in this version.
  /// - "INVENTORY_SOURCE_CONFIG_STATUS_PENDING" : The beginning state of a
  /// guaranteed inventory source. The inventory source in this state needs to
  /// be configured.
  /// - "INVENTORY_SOURCE_CONFIG_STATUS_COMPLETED" : The state after the buyer
  /// configures a guaranteed inventory source.
  core.String? configStatus;

  /// The user-provided reason for pausing this inventory source.
  ///
  /// Must not exceed 100 characters. Only applicable when entity_status is set
  /// to `ENTITY_STATUS_PAUSED`.
  core.String? entityPauseReason;

  /// Whether or not the inventory source is servable.
  ///
  /// Acceptable values are `ENTITY_STATUS_ACTIVE`, `ENTITY_STATUS_ARCHIVED`,
  /// and `ENTITY_STATUS_PAUSED`. Default value is `ENTITY_STATUS_ACTIVE`.
  /// Possible string values are:
  /// - "ENTITY_STATUS_UNSPECIFIED" : Default value when status is not specified
  /// or is unknown in this version.
  /// - "ENTITY_STATUS_ACTIVE" : The entity is enabled to bid and spend budget.
  /// - "ENTITY_STATUS_ARCHIVED" : The entity is archived. Bidding and budget
  /// spending are disabled. An entity can be deleted after archived. Deleted
  /// entities cannot be retrieved.
  /// - "ENTITY_STATUS_DRAFT" : The entity is under draft. Bidding and budget
  /// spending are disabled.
  /// - "ENTITY_STATUS_PAUSED" : Bidding and budget spending are paused for the
  /// entity.
  /// - "ENTITY_STATUS_SCHEDULED_FOR_DELETION" : The entity is scheduled for
  /// deletion.
  core.String? entityStatus;

  /// The seller-provided reason for pausing this inventory source.
  ///
  /// Only applicable for inventory sources synced directly from the publishers
  /// and when seller_status is set to `ENTITY_STATUS_PAUSED`.
  ///
  /// Output only.
  core.String? sellerPauseReason;

  /// The status set by the seller for the inventory source.
  ///
  /// Only applicable for inventory sources synced directly from the publishers.
  /// Acceptable values are `ENTITY_STATUS_ACTIVE` and `ENTITY_STATUS_PAUSED`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ENTITY_STATUS_UNSPECIFIED" : Default value when status is not specified
  /// or is unknown in this version.
  /// - "ENTITY_STATUS_ACTIVE" : The entity is enabled to bid and spend budget.
  /// - "ENTITY_STATUS_ARCHIVED" : The entity is archived. Bidding and budget
  /// spending are disabled. An entity can be deleted after archived. Deleted
  /// entities cannot be retrieved.
  /// - "ENTITY_STATUS_DRAFT" : The entity is under draft. Bidding and budget
  /// spending are disabled.
  /// - "ENTITY_STATUS_PAUSED" : Bidding and budget spending are paused for the
  /// entity.
  /// - "ENTITY_STATUS_SCHEDULED_FOR_DELETION" : The entity is scheduled for
  /// deletion.
  core.String? sellerStatus;

  $InventorySourceStatus({
    this.configStatus,
    this.entityPauseReason,
    this.entityStatus,
    this.sellerPauseReason,
    this.sellerStatus,
  });

  $InventorySourceStatus.fromJson(core.Map json_)
    : this(
        configStatus: json_['configStatus'] as core.String?,
        entityPauseReason: json_['entityPauseReason'] as core.String?,
        entityStatus: json_['entityStatus'] as core.String?,
        sellerPauseReason: json_['sellerPauseReason'] as core.String?,
        sellerStatus: json_['sellerStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configStatus != null) 'configStatus': configStatus!,
    if (entityPauseReason != null) 'entityPauseReason': entityPauseReason!,
    if (entityStatus != null) 'entityStatus': entityStatus!,
    if (sellerPauseReason != null) 'sellerPauseReason': sellerPauseReason!,
    if (sellerStatus != null) 'sellerStatus': sellerStatus!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : InventorySourceVideoCreativeConfig
/// - displayvideo:v3 : InventorySourceVideoCreativeConfig
/// - displayvideo:v4 : InventorySourceVideoCreativeConfig
class $InventorySourceVideoCreativeConfig {
  /// The duration requirements for the video creatives that can be assigned to
  /// the inventory source.
  core.String? duration;

  $InventorySourceVideoCreativeConfig({this.duration});

  $InventorySourceVideoCreativeConfig.fromJson(core.Map json_)
    : this(duration: json_['duration'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (duration != null) 'duration': duration!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : InventoryTypeTargeting
/// - authorizedbuyersmarketplace:v1alpha : InventoryTypeTargeting
class $InventoryTypeTargeting {
  /// The list of targeted inventory types for the bid request.
  core.List<core.String>? inventoryTypes;

  $InventoryTypeTargeting({this.inventoryTypes});

  $InventoryTypeTargeting.fromJson(core.Map json_)
    : this(
        inventoryTypes:
            (json_['inventoryTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inventoryTypes != null) 'inventoryTypes': inventoryTypes!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : IpMapping
/// - sqladmin:v1beta4 : IpMapping
class $IpMapping {
  /// The IP address assigned.
  core.String? ipAddress;

  /// The due time for this IP to be retired in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
  /// `2012-11-15T16:19:00.094Z`.
  ///
  /// This field is only available when the IP is scheduled to be retired.
  core.String? timeToRetire;

  /// The type of this IP address.
  ///
  /// A `PRIMARY` address is a public address that can accept incoming
  /// connections. A `PRIVATE` address is a private address that can accept
  /// incoming connections. An `OUTGOING` address is the source address of
  /// connections originating from the instance, if supported.
  /// Possible string values are:
  /// - "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" : This is an unknown IP address type.
  /// - "PRIMARY" : IP address the customer is supposed to connect to. Usually
  /// this is the load balancer's IP address
  /// - "OUTGOING" : Source IP address of the connection a read replica
  /// establishes to its external primary instance. This IP address can be
  /// allowlisted by the customer in case it has a firewall that filters
  /// incoming connection to its on premises primary instance.
  /// - "PRIVATE" : Private IP used when using private IPs and network peering.
  /// - "MIGRATED_1ST_GEN" : V1 IP of a migrated instance. We want the user to
  /// decommission this IP as soon as the migration is complete. Note: V1
  /// instances with V1 ip addresses will be counted as PRIMARY.
  core.String? type;

  $IpMapping({this.ipAddress, this.timeToRetire, this.type});

  $IpMapping.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        timeToRetire: json_['timeToRetire'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (timeToRetire != null) 'timeToRetire': timeToRetire!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : IsInvitableUserResponse
/// - cloudidentity:v1beta1 : IsInvitableUserResponse
class $IsInvitableUserResponse {
  /// Returns true if the email address is invitable.
  core.bool? isInvitableUser;

  $IsInvitableUserResponse({this.isInvitableUser});

  $IsInvitableUserResponse.fromJson(core.Map json_)
    : this(isInvitableUser: json_['isInvitableUser'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (isInvitableUser != null) 'isInvitableUser': isInvitableUser!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1IssueAnnotation
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1IssueAnnotation
class $IssueAnnotation {
  /// Contains the contents of the annotation message.
  core.String? body;

  /// Category that the annotation belongs to.
  ///
  /// An annotation will belong to a single category. Example categories:
  /// "Potential fix", "Insight".
  core.String? category;

  /// Title for the annotation.
  core.String? title;

  $IssueAnnotation({this.body, this.category, this.title});

  $IssueAnnotation.fromJson(core.Map json_)
    : this(
        body: json_['body'] as core.String?,
        category: json_['category'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (body != null) 'body': body!,
    if (category != null) 'category': category!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - content:v2.1 : RenderAccountIssuesRequestPayload
/// - content:v2.1 : RenderProductIssuesRequestPayload
class $IssuesRequestPayload {
  /// How the detailed content should be returned.
  ///
  /// Default option is to return the content as a pre-rendered HTML text.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CONTENT_OPTION_UNSPECIFIED" : Default value. Will never be provided by
  /// the API.
  /// - "PRE_RENDERED_HTML" : Returns the detail of the issue as a pre-rendered
  /// HTML text.
  core.String? contentOption;

  /// How actions with user input form should be handled.
  ///
  /// If not provided, actions will be returned as links that points merchant to
  /// Merchant Center where they can request the action.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "USER_INPUT_ACTION_RENDERING_OPTION_UNSPECIFIED" : Default value. Will
  /// never be provided by the API.
  /// - "REDIRECT_TO_MERCHANT_CENTER" : Actions that require user input are
  /// represented only as links that points merchant to Merchant Center where
  /// they can request the action. Provides easier to implement alternative to
  /// `BUILT_IN_USER_INPUT_ACTIONS`.
  /// - "BUILT_IN_USER_INPUT_ACTIONS" : Returns content and input form
  /// definition for each complex action. Your application needs to display this
  /// content and input form to the merchant before they can request processing
  /// of the action. To start the action, your application needs to call the
  /// `triggeraction` method.
  core.String? userInputActionOption;

  $IssuesRequestPayload({this.contentOption, this.userInputActionOption});

  $IssuesRequestPayload.fromJson(core.Map json_)
    : this(
        contentOption: json_['contentOption'] as core.String?,
        userInputActionOption: json_['userInputActionOption'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentOption != null) 'contentOption': contentOption!,
    if (userInputActionOption != null)
      'userInputActionOption': userInputActionOption!,
  };
}

/// Used by:
///
/// - jobs:v3 : JobEvent
/// - jobs:v3p1beta1 : JobEvent
class $JobEvent {
  /// The job name(s) associated with this event.
  ///
  /// For example, if this is an impression event, this field contains the
  /// identifiers of all jobs shown to the job seeker. If this was a view event,
  /// this field contains the identifier of the viewed job.
  ///
  /// Required.
  core.List<core.String>? jobs;

  /// The type of the event (see JobEventType).
  ///
  /// Required.
  /// Possible string values are:
  /// - "JOB_EVENT_TYPE_UNSPECIFIED" : The event is unspecified by other
  /// provided values.
  /// - "IMPRESSION" : The job seeker or other entity interacting with the
  /// service has had a job rendered in their view, such as in a list of search
  /// results in a compressed or clipped format. This event is typically
  /// associated with the viewing of a jobs list on a single page by a job
  /// seeker.
  /// - "VIEW" : The job seeker, or other entity interacting with the service,
  /// has viewed the details of a job, including the full description. This
  /// event doesn't apply to the viewing a snippet of a job appearing as a part
  /// of the job search results. Viewing a snippet is associated with an
  /// impression).
  /// - "VIEW_REDIRECT" : The job seeker or other entity interacting with the
  /// service performed an action to view a job and was redirected to a
  /// different website for job.
  /// - "APPLICATION_START" : The job seeker or other entity interacting with
  /// the service began the process or demonstrated the intention of applying
  /// for a job.
  /// - "APPLICATION_FINISH" : The job seeker or other entity interacting with
  /// the service submitted an application for a job.
  /// - "APPLICATION_QUICK_SUBMISSION" : The job seeker or other entity
  /// interacting with the service submitted an application for a job with a
  /// single click without entering information. If a job seeker performs this
  /// action, send only this event to the service. Do not also send
  /// JobEventType.APPLICATION_START or JobEventType.APPLICATION_FINISH events.
  /// - "APPLICATION_REDIRECT" : The job seeker or other entity interacting with
  /// the service performed an action to apply to a job and was redirected to a
  /// different website to complete the application.
  /// - "APPLICATION_START_FROM_SEARCH" : The job seeker or other entity
  /// interacting with the service began the process or demonstrated the
  /// intention of applying for a job from the search results page without
  /// viewing the details of the job posting. If sending this event,
  /// JobEventType.VIEW event shouldn't be sent.
  /// - "APPLICATION_REDIRECT_FROM_SEARCH" : The job seeker, or other entity
  /// interacting with the service, performs an action with a single click from
  /// the search results page to apply to a job (without viewing the details of
  /// the job posting), and is redirected to a different website to complete the
  /// application. If a candidate performs this action, send only this event to
  /// the service. Do not also send JobEventType.APPLICATION_START,
  /// JobEventType.APPLICATION_FINISH or JobEventType.VIEW events.
  /// - "APPLICATION_COMPANY_SUBMIT" : This event should be used when a company
  /// submits an application on behalf of a job seeker. This event is intended
  /// for use by staffing agencies attempting to place candidates.
  /// - "BOOKMARK" : The job seeker or other entity interacting with the service
  /// demonstrated an interest in a job by bookmarking or saving it.
  /// - "NOTIFICATION" : The job seeker or other entity interacting with the
  /// service was sent a notification, such as an email alert or device
  /// notification, containing one or more jobs listings generated by the
  /// service.
  /// - "HIRED" : The job seeker or other entity interacting with the service
  /// was employed by the hiring entity (employer). Send this event only if the
  /// job seeker was hired through an application that was initiated by a search
  /// conducted through the Cloud Talent Solution service.
  /// - "SENT_CV" : A recruiter or staffing agency submitted an application on
  /// behalf of the candidate after interacting with the service to identify a
  /// suitable job posting.
  /// - "INTERVIEW_GRANTED" : The entity interacting with the service (for
  /// example, the job seeker), was granted an initial interview by the hiring
  /// entity (employer). This event should only be sent if the job seeker was
  /// granted an interview as part of an application that was initiated by a
  /// search conducted through / recommendation provided by the Cloud Talent
  /// Solution service.
  /// - "NOT_INTERESTED" : The job seeker or other entity interacting with the
  /// service showed no interest in the job.
  core.String? type;

  $JobEvent({this.jobs, this.type});

  $JobEvent.fromJson(core.Map json_)
    : this(
        jobs:
            (json_['jobs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (jobs != null) 'jobs': jobs!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - datastream:v1 : JsonFileFormat
/// - datastream:v1alpha1 : JsonFileFormat
class $JsonFileFormat {
  /// Compression of the loaded JSON file.
  /// Possible string values are:
  /// - "JSON_COMPRESSION_UNSPECIFIED" : Unspecified json file compression.
  /// - "NO_COMPRESSION" : Do not compress JSON file.
  /// - "GZIP" : Gzip compression.
  core.String? compression;

  /// The schema file format along JSON data files.
  /// Possible string values are:
  /// - "SCHEMA_FILE_FORMAT_UNSPECIFIED" : Unspecified schema file format.
  /// - "NO_SCHEMA_FILE" : Do not attach schema file.
  /// - "AVRO_SCHEMA_FILE" : Avro schema format.
  core.String? schemaFileFormat;

  $JsonFileFormat({this.compression, this.schemaFileFormat});

  $JsonFileFormat.fromJson(core.Map json_)
    : this(
        compression: json_['compression'] as core.String?,
        schemaFileFormat: json_['schemaFileFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (compression != null) 'compression': compression!,
    if (schemaFileFormat != null) 'schemaFileFormat': schemaFileFormat!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Justification
/// - containeranalysis:v1alpha1 : Justification
/// - containeranalysis:v1beta1 : Justification
/// - ondemandscanning:v1 : Justification
/// - ondemandscanning:v1beta1 : Justification
class $Justification {
  /// Additional details on why this justification was chosen.
  core.String? details;

  /// The justification type for this vulnerability.
  /// Possible string values are:
  /// - "JUSTIFICATION_TYPE_UNSPECIFIED" : JUSTIFICATION_TYPE_UNSPECIFIED.
  /// - "COMPONENT_NOT_PRESENT" : The vulnerable component is not present in the
  /// product.
  /// - "VULNERABLE_CODE_NOT_PRESENT" : The vulnerable code is not present.
  /// Typically this case occurs when source code is configured or built in a
  /// way that excludes the vulnerable code.
  /// - "VULNERABLE_CODE_NOT_IN_EXECUTE_PATH" : The vulnerable code can not be
  /// executed. Typically this case occurs when the product includes the
  /// vulnerable code but does not call or use the vulnerable code.
  /// - "VULNERABLE_CODE_CANNOT_BE_CONTROLLED_BY_ADVERSARY" : The vulnerable
  /// code cannot be controlled by an attacker to exploit the vulnerability.
  /// - "INLINE_MITIGATIONS_ALREADY_EXIST" : The product includes built-in
  /// protections or features that prevent exploitation of the vulnerability.
  /// These built-in protections cannot be subverted by the attacker and cannot
  /// be configured or disabled by the user. These mitigations completely
  /// prevent exploitation based on known attack vectors.
  core.String? justificationType;

  $Justification({this.details, this.justificationType});

  $Justification.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        justificationType: json_['justificationType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (justificationType != null) 'justificationType': justificationType!,
  };
}

/// Used by:
///
/// - container:v1 : Jwk
/// - container:v1beta1 : Jwk
class $Jwk {
  /// Algorithm.
  core.String? alg;

  /// Used for ECDSA keys.
  core.String? crv;

  /// Used for RSA keys.
  core.String? e;

  /// Key ID.
  core.String? kid;

  /// Key Type.
  core.String? kty;

  /// Used for RSA keys.
  core.String? n;

  /// Permitted uses for the public keys.
  core.String? use;

  /// Used for ECDSA keys.
  core.String? x;

  /// Used for ECDSA keys.
  core.String? y;

  $Jwk({
    this.alg,
    this.crv,
    this.e,
    this.kid,
    this.kty,
    this.n,
    this.use,
    this.x,
    this.y,
  });

  $Jwk.fromJson(core.Map json_)
    : this(
        alg: json_['alg'] as core.String?,
        crv: json_['crv'] as core.String?,
        e: json_['e'] as core.String?,
        kid: json_['kid'] as core.String?,
        kty: json_['kty'] as core.String?,
        n: json_['n'] as core.String?,
        use: json_['use'] as core.String?,
        x: json_['x'] as core.String?,
        y: json_['y'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alg != null) 'alg': alg!,
    if (crv != null) 'crv': crv!,
    if (e != null) 'e': e!,
    if (kid != null) 'kid': kid!,
    if (kty != null) 'kty': kty!,
    if (n != null) 'n': n!,
    if (use != null) 'use': use!,
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
  };
}

/// Used by:
///
/// - binaryauthorization:v1 : Jwt
/// - binaryauthorization:v1beta1 : Jwt
/// - containeranalysis:v1 : Jwt
/// - ondemandscanning:v1 : Jwt
/// - ondemandscanning:v1beta1 : Jwt
class $Jwt {
  /// The compact encoding of a JWS, which is always three base64 encoded
  /// strings joined by periods.
  ///
  /// For details, see: https://tools.ietf.org/html/rfc7515.html#section-3.1
  core.String? compactJwt;

  $Jwt({this.compactJwt});

  $Jwt.fromJson(core.Map json_)
    : this(compactJwt: json_['compactJwt'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (compactJwt != null) 'compactJwt': compactJwt!,
  };
}

/// Used by:
///
/// - connectors:v1 : JwtClaims
/// - integrations:v1 : GoogleCloudConnectorsV1AuthConfigOauth2JwtBearerJwtClaims
class $JwtClaims {
  /// Value for the "aud" claim.
  ///
  /// Optional.
  core.String? audience;

  /// Value for the "iss" claim.
  ///
  /// Optional.
  core.String? issuer;

  /// Value for the "sub" claim.
  ///
  /// Optional.
  core.String? subject;

  $JwtClaims({this.audience, this.issuer, this.subject});

  $JwtClaims.fromJson(core.Map json_)
    : this(
        audience: json_['audience'] as core.String?,
        issuer: json_['issuer'] as core.String?,
        subject: json_['subject'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audience != null) 'audience': audience!,
    if (issuer != null) 'issuer': issuer!,
    if (subject != null) 'subject': subject!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : JwtLocation
/// - serviceusage:v1 : JwtLocation
/// - serviceusage:v1beta1 : JwtLocation
class $JwtLocation {
  /// Specifies cookie name to extract JWT token.
  core.String? cookie;

  /// Specifies HTTP header name to extract JWT token.
  core.String? header;

  /// Specifies URL query parameter name to extract JWT token.
  core.String? query;

  /// The value prefix.
  ///
  /// The value format is "value_prefix{token}" Only applies to "in" header
  /// type. Must be empty for "in" query type. If not empty, the header value
  /// has to match (case sensitive) this prefix. If not matched, JWT will not be
  /// extracted. If matched, JWT will be extracted after the prefix is removed.
  /// For example, for "Authorization: Bearer {JWT}", value_prefix="Bearer "
  /// with a space at the end.
  core.String? valuePrefix;

  $JwtLocation({this.cookie, this.header, this.query, this.valuePrefix});

  $JwtLocation.fromJson(core.Map json_)
    : this(
        cookie: json_['cookie'] as core.String?,
        header: json_['header'] as core.String?,
        query: json_['query'] as core.String?,
        valuePrefix: json_['valuePrefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cookie != null) 'cookie': cookie!,
    if (header != null) 'header': header!,
    if (query != null) 'query': query!,
    if (valuePrefix != null) 'valuePrefix': valuePrefix!,
  };
}

/// Used by:
///
/// - batch:v1 : AgentKMSEnvMap
/// - batch:v1 : KMSEnvMap
class $KMSEnvMap {
  /// The value of the cipherText response from the `encrypt` method.
  core.String? cipherText;

  /// The name of the KMS key that will be used to decrypt the cipher text.
  core.String? keyName;

  $KMSEnvMap({this.cipherText, this.keyName});

  $KMSEnvMap.fromJson(core.Map json_)
    : this(
        cipherText: json_['cipherText'] as core.String?,
        keyName: json_['keyName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cipherText != null) 'cipherText': cipherText!,
    if (keyName != null) 'keyName': keyName!,
  };
}

/// Used by:
///
/// - cloudkms:v1 : KeyAccessJustificationsPolicy
/// - kmsinventory:v1 : GoogleCloudKmsV1KeyAccessJustificationsPolicy
class $KeyAccessJustificationsPolicy {
  /// The list of allowed reasons for access to a CryptoKey.
  ///
  /// Zero allowed access reasons means all encrypt, decrypt, and sign
  /// operations for the CryptoKey associated with this policy will fail.
  core.List<core.String>? allowedAccessReasons;

  $KeyAccessJustificationsPolicy({this.allowedAccessReasons});

  $KeyAccessJustificationsPolicy.fromJson(core.Map json_)
    : this(
        allowedAccessReasons:
            (json_['allowedAccessReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedAccessReasons != null)
      'allowedAccessReasons': allowedAccessReasons!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaKeyEventDefaultValue
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaKeyEventDefaultValue
class $KeyEventDefaultValue {
  /// When an occurrence of this Key Event (specified by event_name) has no set
  /// currency this currency will be applied as the default.
  ///
  /// Must be in ISO 4217 currency code format. See
  /// https://en.wikipedia.org/wiki/ISO_4217 for more information.
  ///
  /// Required.
  core.String? currencyCode;

  /// This will be used to populate the "value" parameter for all occurrences of
  /// this Key Event (specified by event_name) where that parameter is unset.
  ///
  /// Required.
  core.double? numericValue;

  $KeyEventDefaultValue({this.currencyCode, this.numericValue});

  $KeyEventDefaultValue.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        numericValue: (json_['numericValue'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (numericValue != null) 'numericValue': numericValue!,
  };
}

/// Used by:
///
/// - vision:v1 : KeyValue
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1ProductKeyValue
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1ProductKeyValue
class $KeyValue {
  /// The key of the label attached to the product.
  ///
  /// Cannot be empty and cannot exceed 128 bytes.
  core.String? key;

  /// The value of the label attached to the product.
  ///
  /// Cannot be empty and cannot exceed 128 bytes.
  core.String? value;

  $KeyValue({this.key, this.value});

  $KeyValue.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : KeywordAssignedTargetingOptionDetails
/// - displayvideo:v3 : KeywordAssignedTargetingOptionDetails
/// - displayvideo:v4 : KeywordAssignedTargetingOptionDetails
class $KeywordAssignedTargetingOptionDetails {
  /// The keyword, for example `car insurance`.
  ///
  /// Positive keyword cannot be offensive word. Must be UTF-8 encoded with a
  /// maximum size of 255 bytes. Maximum number of characters is 80. Maximum
  /// number of words is 10.
  ///
  /// Required.
  core.String? keyword;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  $KeywordAssignedTargetingOptionDetails({this.keyword, this.negative});

  $KeywordAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        keyword: json_['keyword'] as core.String?,
        negative: json_['negative'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (keyword != null) 'keyword': keyword!,
    if (negative != null) 'negative': negative!,
  };
}

/// Used by:
///
/// - datastore:v1 : KindExpression
/// - datastore:v1beta3 : KindExpression
/// - dlp:v2 : GooglePrivacyDlpV2KindExpression
class $KindExpression {
  /// The name of the kind.
  core.String? name;

  $KindExpression({this.name});

  $KindExpression.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - netapp:v1 : KmsConfig
/// - netapp:v1beta1 : KmsConfig
class $KmsConfig {
  /// Create time of the KmsConfig.
  ///
  /// Output only.
  core.String? createTime;

  /// Customer managed crypto key resource full name.
  ///
  /// Format:
  /// projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}.
  ///
  /// Required.
  core.String? cryptoKeyName;

  /// Description of the KmsConfig.
  core.String? description;

  /// Instructions to provide the access to the customer provided encryption
  /// key.
  ///
  /// Output only.
  core.String? instructions;

  /// Labels as key value pairs
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the KmsConfig.
  core.String? name;

  /// The Service account which will have access to the customer provided
  /// encryption key.
  ///
  /// Output only.
  core.String? serviceAccount;

  /// State of the KmsConfig.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified KmsConfig State
  /// - "READY" : KmsConfig State is Ready
  /// - "CREATING" : KmsConfig State is Creating
  /// - "DELETING" : KmsConfig State is Deleting
  /// - "UPDATING" : KmsConfig State is Updating
  /// - "IN_USE" : KmsConfig State is In Use.
  /// - "ERROR" : KmsConfig State is Error
  /// - "KEY_CHECK_PENDING" : KmsConfig State is Pending to verify crypto key
  /// access.
  /// - "KEY_NOT_REACHABLE" : KmsConfig State is Not accessbile by the SDE
  /// service account to the crypto key.
  /// - "DISABLING" : KmsConfig State is Disabling.
  /// - "DISABLED" : KmsConfig State is Disabled.
  /// - "MIGRATING" : KmsConfig State is Migrating. The existing volumes are
  /// migrating from SMEK to CMEK.
  core.String? state;

  /// State details of the KmsConfig.
  ///
  /// Output only.
  core.String? stateDetails;

  $KmsConfig({
    this.createTime,
    this.cryptoKeyName,
    this.description,
    this.instructions,
    this.labels,
    this.name,
    this.serviceAccount,
    this.state,
    this.stateDetails,
  });

  $KmsConfig.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        cryptoKeyName: json_['cryptoKeyName'] as core.String?,
        description: json_['description'] as core.String?,
        instructions: json_['instructions'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        state: json_['state'] as core.String?,
        stateDetails: json_['stateDetails'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (cryptoKeyName != null) 'cryptoKeyName': cryptoKeyName!,
    if (description != null) 'description': description!,
    if (instructions != null) 'instructions': instructions!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (state != null) 'state': state!,
    if (stateDetails != null) 'stateDetails': stateDetails!,
  };
}

/// Used by:
///
/// - healthcare:v1 : KmsWrappedCryptoKey
/// - healthcare:v1beta1 : KmsWrappedCryptoKey
class $KmsWrappedCryptoKey {
  /// The resource name of the KMS CryptoKey to use for unwrapping.
  ///
  /// For example,
  /// `projects/{project_id}/locations/{location_id}/keyRings/{keyring}/cryptoKeys/{key}`.
  ///
  /// Required.
  core.String? cryptoKey;

  /// The wrapped data crypto key.
  ///
  /// Required.
  core.String? wrappedKey;
  core.List<core.int> get wrappedKeyAsBytes =>
      convert.base64.decode(wrappedKey!);

  set wrappedKeyAsBytes(core.List<core.int> bytes_) {
    wrappedKey = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $KmsWrappedCryptoKey({this.cryptoKey, this.wrappedKey});

  $KmsWrappedCryptoKey.fromJson(core.Map json_)
    : this(
        cryptoKey: json_['cryptoKey'] as core.String?,
        wrappedKey: json_['wrappedKey'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cryptoKey != null) 'cryptoKey': cryptoKey!,
    if (wrappedKey != null) 'wrappedKey': wrappedKey!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2KnowledgeAssistAnswerKnowledgeAnswerFaqSource
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1KnowledgeAssistAnswerKnowledgeAnswerFaqSource
class $KnowledgeAssistAnswerKnowledgeAnswerFaqSource {
  /// The corresponding FAQ question.
  core.String? question;

  $KnowledgeAssistAnswerKnowledgeAnswerFaqSource({this.question});

  $KnowledgeAssistAnswerKnowledgeAnswerFaqSource.fromJson(core.Map json_)
    : this(question: json_['question'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (question != null) 'question': question!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2KnowledgeAssistAnswerKnowledgeAnswerGenerativeSourceSnippet
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1KnowledgeAssistAnswerKnowledgeAnswerGenerativeSourceSnippet
class $KnowledgeAssistAnswerKnowledgeAnswerGenerativeSourceSnippet {
  /// Metadata of the document.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Text taken from that URI.
  core.String? text;

  /// Title of the document.
  core.String? title;

  /// URI the data is sourced from.
  core.String? uri;

  $KnowledgeAssistAnswerKnowledgeAnswerGenerativeSourceSnippet({
    this.metadata,
    this.text,
    this.title,
    this.uri,
  });

  $KnowledgeAssistAnswerKnowledgeAnswerGenerativeSourceSnippet.fromJson(
    core.Map json_,
  ) : this(
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        text: json_['text'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
    if (text != null) 'text': text!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2KnowledgeAssistAnswerSuggestedQuery
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1KnowledgeAssistAnswerSuggestedQuery
class $KnowledgeAssistAnswerSuggestedQuery {
  /// Suggested query text.
  core.String? queryText;

  $KnowledgeAssistAnswerSuggestedQuery({this.queryText});

  $KnowledgeAssistAnswerSuggestedQuery.fromJson(core.Map json_)
    : this(queryText: json_['queryText'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryText != null) 'queryText': queryText!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : Kpi
/// - displayvideo:v4 : Kpi
class $Kpi {
  /// Custom Bidding Algorithm ID associated with
  /// KPI_CUSTOM_IMPRESSION_VALUE_OVER_COST.
  ///
  /// This field is ignored if the proper KPI is not selected.
  ///
  /// Optional.
  core.String? kpiAlgorithmId;

  /// The goal amount, in micros of the advertiser's currency.
  ///
  /// Applicable when kpi_type is one of: * `KPI_TYPE_CPM` * `KPI_TYPE_CPC` *
  /// `KPI_TYPE_CPA` * `KPI_TYPE_CPIAVC` * `KPI_TYPE_VCPM` For example: 1500000
  /// represents 1.5 standard units of the currency.
  core.String? kpiAmountMicros;

  /// The decimal representation of the goal percentage in micros.
  ///
  /// Applicable when kpi_type is one of: * `KPI_TYPE_CTR` *
  /// `KPI_TYPE_VIEWABILITY` * `KPI_TYPE_CLICK_CVR` * `KPI_TYPE_IMPRESSION_CVR`
  /// * `KPI_TYPE_VTR` * `KPI_TYPE_AUDIO_COMPLETION_RATE` *
  /// `KPI_TYPE_VIDEO_COMPLETION_RATE` For example: 70000 represents 7% (decimal
  /// 0.07).
  core.String? kpiPercentageMicros;

  /// A KPI string, which can be empty.
  ///
  /// Must be UTF-8 encoded with a length of no more than 100 characters.
  /// Applicable when kpi_type is `KPI_TYPE_OTHER`.
  core.String? kpiString;

  /// The type of KPI.
  ///
  /// Required.
  /// Possible string values are:
  /// - "KPI_TYPE_UNSPECIFIED" : KPI type is not specified or is unknown in this
  /// version.
  /// - "KPI_TYPE_CPM" : The KPI is CPM (cost per mille).
  /// - "KPI_TYPE_CPC" : The KPI is CPC (cost per click).
  /// - "KPI_TYPE_CPA" : The KPI is CPA (cost per action).
  /// - "KPI_TYPE_CTR" : The KPI is CTR (click-through rate) percentage.
  /// - "KPI_TYPE_VIEWABILITY" : The KPI is Viewability percentage.
  /// - "KPI_TYPE_CPIAVC" : The KPI is CPIAVC (cost per impression audible and
  /// visible at completion).
  /// - "KPI_TYPE_CPE" : The KPI is CPE (cost per engagement).
  /// - "KPI_TYPE_CPV" : The KPI is set in CPV (cost per view).
  /// - "KPI_TYPE_CLICK_CVR" : The KPI is click conversion rate (conversions per
  /// click) percentage.
  /// - "KPI_TYPE_IMPRESSION_CVR" : The KPI is impression conversion rate
  /// (conversions per impression) percentage.
  /// - "KPI_TYPE_VCPM" : The KPI is VCPM (cost per thousand viewable
  /// impressions).
  /// - "KPI_TYPE_VTR" : The KPI is YouTube view rate (YouTube views per
  /// impression) percentage.
  /// - "KPI_TYPE_AUDIO_COMPLETION_RATE" : The KPI is audio completion rate
  /// (complete audio listens per impression) percentage.
  /// - "KPI_TYPE_VIDEO_COMPLETION_RATE" : The KPI is video completion rate
  /// (complete video views per impression) percentage.
  /// - "KPI_TYPE_CPCL" : The KPI is set in CPCL (cost per complete audio
  /// listen).
  /// - "KPI_TYPE_CPCV" : The KPI is set in CPCV (cost per complete video view).
  /// - "KPI_TYPE_TOS10" : The KPI is set in rate of time on screen 10+ seconds
  /// (Percentage of measurable, non-skippable impressions that were on the
  /// screen for at least 10 seconds).
  /// - "KPI_TYPE_MAXIMIZE_PACING" : The KPI is set to maximize brand impact
  /// while prioritizing spending the full budget.
  /// - "KPI_TYPE_CUSTOM_IMPRESSION_VALUE_OVER_COST" : The KPI is set in custom
  /// impression value divided by cost.
  /// - "KPI_TYPE_OTHER" : The KPI is some other value.
  core.String? kpiType;

  $Kpi({
    this.kpiAlgorithmId,
    this.kpiAmountMicros,
    this.kpiPercentageMicros,
    this.kpiString,
    this.kpiType,
  });

  $Kpi.fromJson(core.Map json_)
    : this(
        kpiAlgorithmId: json_['kpiAlgorithmId'] as core.String?,
        kpiAmountMicros: json_['kpiAmountMicros'] as core.String?,
        kpiPercentageMicros: json_['kpiPercentageMicros'] as core.String?,
        kpiString: json_['kpiString'] as core.String?,
        kpiType: json_['kpiType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kpiAlgorithmId != null) 'kpiAlgorithmId': kpiAlgorithmId!,
    if (kpiAmountMicros != null) 'kpiAmountMicros': kpiAmountMicros!,
    if (kpiPercentageMicros != null)
      'kpiPercentageMicros': kpiPercentageMicros!,
    if (kpiString != null) 'kpiString': kpiString!,
    if (kpiType != null) 'kpiType': kpiType!,
  };
}

/// Used by:
///
/// - container:v1 : KubernetesDashboard
/// - container:v1beta1 : KubernetesDashboard
class $KubernetesDashboard {
  /// Whether the Kubernetes Dashboard is enabled for this cluster.
  core.bool? disabled;

  $KubernetesDashboard({this.disabled});

  $KubernetesDashboard.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - gkehub:v1 : KubernetesMetadata
/// - gkehub:v1alpha : KubernetesMetadata
/// - gkehub:v1beta : KubernetesMetadata
class $KubernetesMetadata {
  /// Kubernetes API server version string as reported by `/version`.
  ///
  /// Output only.
  core.String? kubernetesApiServerVersion;

  /// The total memory capacity as reported by the sum of all Kubernetes nodes
  /// resources, defined in MB.
  ///
  /// Output only.
  core.int? memoryMb;

  /// Node count as reported by Kubernetes nodes resources.
  ///
  /// Output only.
  core.int? nodeCount;

  /// Node providerID as reported by the first node in the list of nodes on the
  /// Kubernetes endpoint.
  ///
  /// On Kubernetes platforms that support zero-node clusters (like GKE-on-GCP),
  /// the node_count will be zero and the node_provider_id will be empty.
  ///
  /// Output only.
  core.String? nodeProviderId;

  /// The time at which these details were last updated.
  ///
  /// This update_time is different from the Membership-level update_time since
  /// EndpointDetails are updated internally for API consumers.
  ///
  /// Output only.
  core.String? updateTime;

  /// vCPU count as reported by Kubernetes nodes resources.
  ///
  /// Output only.
  core.int? vcpuCount;

  $KubernetesMetadata({
    this.kubernetesApiServerVersion,
    this.memoryMb,
    this.nodeCount,
    this.nodeProviderId,
    this.updateTime,
    this.vcpuCount,
  });

  $KubernetesMetadata.fromJson(core.Map json_)
    : this(
        kubernetesApiServerVersion:
            json_['kubernetesApiServerVersion'] as core.String?,
        memoryMb: json_['memoryMb'] as core.int?,
        nodeCount: json_['nodeCount'] as core.int?,
        nodeProviderId: json_['nodeProviderId'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        vcpuCount: json_['vcpuCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kubernetesApiServerVersion != null)
      'kubernetesApiServerVersion': kubernetesApiServerVersion!,
    if (memoryMb != null) 'memoryMb': memoryMb!,
    if (nodeCount != null) 'nodeCount': nodeCount!,
    if (nodeProviderId != null) 'nodeProviderId': nodeProviderId!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (vcpuCount != null) 'vcpuCount': vcpuCount!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelAppliedCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelAppliedCapabilities
class $LabelAppliedCapabilities {
  /// Whether the user can apply this label to items.
  core.bool? canApply;

  /// Whether the user can read applied metadata related to this label.
  core.bool? canRead;

  /// Whether the user can remove this label from items.
  core.bool? canRemove;

  $LabelAppliedCapabilities({this.canApply, this.canRead, this.canRemove});

  $LabelAppliedCapabilities.fromJson(core.Map json_)
    : this(
        canApply: json_['canApply'] as core.bool?,
        canRead: json_['canRead'] as core.bool?,
        canRemove: json_['canRemove'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canApply != null) 'canApply': canApply!,
    if (canRead != null) 'canRead': canRead!,
    if (canRemove != null) 'canRemove': canRemove!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelAppliedLabelPolicy
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelAppliedLabelPolicy
class $LabelAppliedLabelPolicy {
  /// Indicates how the applied label and field values should be copied when a
  /// Drive item is copied.
  /// Possible string values are:
  /// - "COPY_MODE_UNSPECIFIED" : Copy mode unspecified.
  /// - "DO_NOT_COPY" : The applied label and field values are not copied by
  /// default when the Drive item it's applied to is copied.
  /// - "ALWAYS_COPY" : The applied label and field values are always copied
  /// when the Drive item it's applied to is copied. Only admins can use this
  /// mode.
  /// - "COPY_APPLIABLE" : The applied label and field values are copied if the
  /// label is appliable by the user making the copy.
  core.String? copyMode;

  $LabelAppliedLabelPolicy({this.copyMode});

  $LabelAppliedLabelPolicy.fromJson(core.Map json_)
    : this(copyMode: json_['copyMode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (copyMode != null) 'copyMode': copyMode!,
  };
}

/// Used by:
///
/// - logging:v2 : LabelDescriptor
/// - servicemanagement:v1 : LabelDescriptor
/// - serviceusage:v1 : LabelDescriptor
/// - serviceusage:v1beta1 : LabelDescriptor
class $LabelDescriptor {
  /// A human-readable description for the label.
  core.String? description;

  /// The label key.
  core.String? key;

  /// The type of data that can be assigned to the label.
  /// Possible string values are:
  /// - "STRING" : A variable-length string. This is the default.
  /// - "BOOL" : Boolean; true or false.
  /// - "INT64" : A 64-bit signed integer.
  core.String? valueType;

  $LabelDescriptor({this.description, this.key, this.valueType});

  $LabelDescriptor.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        key: json_['key'] as core.String?,
        valueType: json_['valueType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (key != null) 'key': key!,
    if (valueType != null) 'valueType': valueType!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_LabelDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_LabelDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_LabelDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_LabelDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_LabelDetectionConfig
class $LabelDetectionConfig {
  /// The confidence threshold we perform filtering on the labels from
  /// frame-level detection.
  ///
  /// If not set, it is set to 0.4 by default. The valid range for this
  /// threshold is \[0.1, 0.9\]. Any value set outside of this range will be
  /// clipped. Note: For best results, follow the default threshold. We will
  /// update the default threshold everytime when we release a new model.
  core.double? frameConfidenceThreshold;

  /// What labels should be detected with LABEL_DETECTION, in addition to
  /// video-level labels or segment-level labels.
  ///
  /// If unspecified, defaults to `SHOT_MODE`.
  /// Possible string values are:
  /// - "LABEL_DETECTION_MODE_UNSPECIFIED" : Unspecified.
  /// - "SHOT_MODE" : Detect shot-level labels.
  /// - "FRAME_MODE" : Detect frame-level labels.
  /// - "SHOT_AND_FRAME_MODE" : Detect both shot-level and frame-level labels.
  core.String? labelDetectionMode;

  /// Model to use for label detection.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest".
  core.String? model;

  /// Whether the video has been shot from a stationary (i.e., non-moving)
  /// camera.
  ///
  /// When set to true, might improve detection accuracy for moving objects.
  /// Should be used with `SHOT_AND_FRAME_MODE` enabled.
  core.bool? stationaryCamera;

  /// The confidence threshold we perform filtering on the labels from
  /// video-level and shot-level detections.
  ///
  /// If not set, it's set to 0.3 by default. The valid range for this threshold
  /// is \[0.1, 0.9\]. Any value set outside of this range will be clipped.
  /// Note: For best results, follow the default threshold. We will update the
  /// default threshold everytime when we release a new model.
  core.double? videoConfidenceThreshold;

  $LabelDetectionConfig({
    this.frameConfidenceThreshold,
    this.labelDetectionMode,
    this.model,
    this.stationaryCamera,
    this.videoConfidenceThreshold,
  });

  $LabelDetectionConfig.fromJson(core.Map json_)
    : this(
        frameConfidenceThreshold:
            (json_['frameConfidenceThreshold'] as core.num?)?.toDouble(),
        labelDetectionMode: json_['labelDetectionMode'] as core.String?,
        model: json_['model'] as core.String?,
        stationaryCamera: json_['stationaryCamera'] as core.bool?,
        videoConfidenceThreshold:
            (json_['videoConfidenceThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (frameConfidenceThreshold != null)
      'frameConfidenceThreshold': frameConfidenceThreshold!,
    if (labelDetectionMode != null) 'labelDetectionMode': labelDetectionMode!,
    if (model != null) 'model': model!,
    if (stationaryCamera != null) 'stationaryCamera': stationaryCamera!,
    if (videoConfidenceThreshold != null)
      'videoConfidenceThreshold': videoConfidenceThreshold!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelDisplayHints
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelDisplayHints
class $LabelDisplayHints {
  /// Whether the label should be shown in the UI as disabled.
  core.bool? disabled;

  /// This label should be hidden in the search menu when searching for Drive
  /// items.
  core.bool? hiddenInSearch;

  /// Order to display label in a list.
  core.String? priority;

  /// This label should be shown in the apply menu when applying values to a
  /// Drive item.
  core.bool? shownInApply;

  $LabelDisplayHints({
    this.disabled,
    this.hiddenInSearch,
    this.priority,
    this.shownInApply,
  });

  $LabelDisplayHints.fromJson(core.Map json_)
    : this(
        disabled: json_['disabled'] as core.bool?,
        hiddenInSearch: json_['hiddenInSearch'] as core.bool?,
        priority: json_['priority'] as core.String?,
        shownInApply: json_['shownInApply'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
    if (hiddenInSearch != null) 'hiddenInSearch': hiddenInSearch!,
    if (priority != null) 'priority': priority!,
    if (shownInApply != null) 'shownInApply': shownInApply!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelEnabledAppSettingsEnabledApp
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelEnabledAppSettingsEnabledApp
class $LabelEnabledAppSettingsEnabledApp {
  /// The name of the App.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "APP_UNSPECIFIED" : Unspecified
  /// - "DRIVE" : Drive.
  /// - "GMAIL" : Gmail
  core.String? app;

  $LabelEnabledAppSettingsEnabledApp({this.app});

  $LabelEnabledAppSettingsEnabledApp.fromJson(core.Map json_)
    : this(app: json_['app'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (app != null) 'app': app!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : CompositeTypeLabelEntry
/// - deploymentmanager:alpha : DeploymentLabelEntry
/// - deploymentmanager:alpha : DeploymentUpdateLabelEntry
/// - deploymentmanager:alpha : TypeLabelEntry
/// - deploymentmanager:alpha : TypeProviderLabelEntry
/// - deploymentmanager:v2 : DeploymentLabelEntry
/// - deploymentmanager:v2 : DeploymentUpdateLabelEntry
/// - deploymentmanager:v2beta : CompositeTypeLabelEntry
/// - deploymentmanager:v2beta : DeploymentLabelEntry
/// - deploymentmanager:v2beta : DeploymentUpdateLabelEntry
/// - deploymentmanager:v2beta : TypeLabelEntry
/// - deploymentmanager:v2beta : TypeProviderLabelEntry
class $LabelEntry {
  /// Key of the label
  core.String? key;

  /// Value of the label
  core.String? value;

  $LabelEntry({this.key, this.value});

  $LabelEntry.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelLockCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelLockCapabilities
class $LabelLockCapabilities {
  /// True if the user is authorized to view the policy.
  core.bool? canViewPolicy;

  $LabelLockCapabilities({this.canViewPolicy});

  $LabelLockCapabilities.fromJson(core.Map json_)
    : this(canViewPolicy: json_['canViewPolicy'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (canViewPolicy != null) 'canViewPolicy': canViewPolicy!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelPermission
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelPermission
class $LabelPermission {
  /// Audience to grant a role to.
  ///
  /// The magic value of `audiences/default` may be used to apply the role to
  /// the default audience in the context of the organization that owns the
  /// Label.
  core.String? audience;

  /// Specifies the email address for a user or group pricinpal.
  ///
  /// Not populated for audience principals. User and Group permissions may only
  /// be inserted using email address. On update requests, if email address is
  /// specified, no principal should be specified.
  core.String? email;

  /// Group resource name.
  core.String? group;

  /// Resource name of this permission.
  core.String? name;

  /// Person resource name.
  core.String? person;

  /// The role the principal should have.
  /// Possible string values are:
  /// - "LABEL_ROLE_UNSPECIFIED" : Unknown role.
  /// - "READER" : A reader can read the label and associated metadata applied
  /// to Drive items.
  /// - "APPLIER" : An applier can write associated metadata on Drive items in
  /// which they also have write access to. Implies `READER`.
  /// - "ORGANIZER" : An organizer can pin this label in shared drives they
  /// manage and add new appliers to the label.
  /// - "EDITOR" : Editors can make any update including deleting the label
  /// which also deletes the associated Drive item metadata. Implies `APPLIER`.
  core.String? role;

  $LabelPermission({
    this.audience,
    this.email,
    this.group,
    this.name,
    this.person,
    this.role,
  });

  $LabelPermission.fromJson(core.Map json_)
    : this(
        audience: json_['audience'] as core.String?,
        email: json_['email'] as core.String?,
        group: json_['group'] as core.String?,
        name: json_['name'] as core.String?,
        person: json_['person'] as core.String?,
        role: json_['role'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audience != null) 'audience': audience!,
    if (email != null) 'email': email!,
    if (group != null) 'group': group!,
    if (name != null) 'name': name!,
    if (person != null) 'person': person!,
    if (role != null) 'role': role!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelProperties
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelProperties
class $LabelProperties {
  /// The description of the label.
  core.String? description;

  /// Title of the label.
  ///
  /// Required.
  core.String? title;

  $LabelProperties({this.description, this.title});

  $LabelProperties.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LabelSchemaCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLabelSchemaCapabilities
class $LabelSchemaCapabilities {
  /// Whether the user can delete this label.
  ///
  /// The user must have permission and the label must be disabled.
  core.bool? canDelete;

  /// Whether the user can disable this label.
  ///
  /// The user must have permission and this label must not already be disabled.
  core.bool? canDisable;

  /// Whether the user can enable this label.
  ///
  /// The user must have permission and this label must be disabled.
  core.bool? canEnable;

  /// Whether the user can change this label.
  core.bool? canUpdate;

  $LabelSchemaCapabilities({
    this.canDelete,
    this.canDisable,
    this.canEnable,
    this.canUpdate,
  });

  $LabelSchemaCapabilities.fromJson(core.Map json_)
    : this(
        canDelete: json_['canDelete'] as core.bool?,
        canDisable: json_['canDisable'] as core.bool?,
        canEnable: json_['canEnable'] as core.bool?,
        canUpdate: json_['canUpdate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canDelete != null) 'canDelete': canDelete!,
    if (canDisable != null) 'canDisable': canDisable!,
    if (canEnable != null) 'canEnable': canEnable!,
    if (canUpdate != null) 'canUpdate': canUpdate!,
  };
}

/// Used by:
///
/// - container:v1 : NodeLabels
/// - container:v1 : ResourceLabels
/// - container:v1beta1 : NodeLabels
/// - container:v1beta1 : ResourceLabels
class $Labels {
  /// Map of node label keys and node label values.
  core.Map<core.String, core.String>? labels;

  $Labels({this.labels});

  $Labels.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : Lake
/// - metastore:v1beta : Lake
class $Lake {
  /// The Lake resource name.
  ///
  /// Example: projects/{project_number}/locations/{location_id}/lakes/{lake_id}
  core.String? name;

  $Lake({this.name});

  $Lake.fromJson(core.Map json_) : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LanguageAssignedTargetingOptionDetails
/// - displayvideo:v3 : LanguageAssignedTargetingOptionDetails
/// - displayvideo:v4 : LanguageAssignedTargetingOptionDetails
class $LanguageAssignedTargetingOptionDetails {
  /// The display name of the language (e.g., "French").
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  ///
  /// All assigned language targeting options on the same resource must have the
  /// same value for this field.
  core.bool? negative;

  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_LANGUAGE`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $LanguageAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $LanguageAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaLanguageInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaLanguageInfo
class $LanguageInfo {
  /// Language part of normalized_language_code.
  ///
  /// E.g.: `en-US` -\> `en`, `zh-Hans-HK` -\> `zh`, `en` -\> `en`.
  ///
  /// Output only.
  core.String? language;

  /// The language code for the DataStore.
  core.String? languageCode;

  /// This is the normalized form of language_code.
  ///
  /// E.g.: language_code of `en-GB`, `en_GB`, `en-UK` or `en-gb` will have
  /// normalized_language_code of `en-GB`.
  ///
  /// Output only.
  core.String? normalizedLanguageCode;

  /// Region part of normalized_language_code, if present.
  ///
  /// E.g.: `en-US` -\> `US`, `zh-Hans-HK` -\> `HK`, `en` -\> ``.
  ///
  /// Output only.
  core.String? region;

  $LanguageInfo({
    this.language,
    this.languageCode,
    this.normalizedLanguageCode,
    this.region,
  });

  $LanguageInfo.fromJson(core.Map json_)
    : this(
        language: json_['language'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        normalizedLanguageCode: json_['normalizedLanguageCode'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (language != null) 'language': language!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (normalizedLanguageCode != null)
      'normalizedLanguageCode': normalizedLanguageCode!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - ondemandscanning:v1 : LanguagePackageDependency
/// - ondemandscanning:v1beta1 : LanguagePackageDependency
class $LanguagePackageDependency {
  core.String? package;
  core.String? version;

  $LanguagePackageDependency({this.package, this.version});

  $LanguagePackageDependency.fromJson(core.Map json_)
    : this(
        package: json_['package'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (package != null) 'package': package!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LanguageTargetingOptionDetails
/// - displayvideo:v3 : LanguageTargetingOptionDetails
/// - displayvideo:v4 : LanguageTargetingOptionDetails
class $LanguageTargetingOptionDetails {
  /// The display name of the language (e.g., "French").
  ///
  /// Output only.
  core.String? displayName;

  $LanguageTargetingOptionDetails({this.displayName});

  $LanguageTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1LargeModelReference
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1LargeModelReference
class $LargeModelReference {
  /// The unique name of the large Foundation or pre-built model.
  ///
  /// Like "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  ///
  /// Required.
  core.String? name;

  $LargeModelReference({this.name});

  $LargeModelReference.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - addressvalidation:v1 : GoogleTypeLatLng
/// - aiplatform:v1 : GoogleTypeLatLng
/// - aiplatform:v1beta1 : GoogleTypeLatLng
/// - airquality:v1 : LatLng
/// - areainsights:v1 : LatLng
/// - datastore:v1 : LatLng
/// - datastore:v1beta3 : LatLng
/// - dialogflow:v2 : GoogleTypeLatLng
/// - dialogflow:v2beta1 : GoogleTypeLatLng
/// - dialogflow:v3 : GoogleTypeLatLng
/// - dialogflow:v3beta1 : GoogleTypeLatLng
/// - firebaseml:v2beta : LatLng
/// - firestore:v1 : LatLng
/// - firestore:v1beta1 : LatLng
/// - jobs:v3 : LatLng
/// - jobs:v3p1beta1 : LatLng
/// - jobs:v4 : LatLng
/// - mybusinessbusinessinformation:v1 : LatLng
/// - places:v1 : GoogleTypeLatLng
/// - solar:v1 : LatLng
/// - streetviewpublish:v1 : LatLng
/// - vision:v1 : LatLng
/// - vision:v1p1beta1 : LatLng
/// - vision:v1p2beta1 : LatLng
class $LatLng {
  /// The latitude in degrees.
  ///
  /// It must be in the range \[-90.0, +90.0\].
  core.double? latitude;

  /// The longitude in degrees.
  ///
  /// It must be in the range \[-180.0, +180.0\].
  core.double? longitude;

  $LatLng({this.latitude, this.longitude});

  $LatLng.fromJson(core.Map json_)
    : this(
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : LatencyPercentile
/// - networkmanagement:v1beta1 : LatencyPercentile
class $LatencyPercentile {
  /// percent-th percentile of latency observed, in microseconds.
  ///
  /// Fraction of percent/100 of samples have latency lower or equal to the
  /// value of this field.
  core.String? latencyMicros;

  /// Percentage of samples this data point applies to.
  core.int? percent;

  $LatencyPercentile({this.latencyMicros, this.percent});

  $LatencyPercentile.fromJson(core.Map json_)
    : this(
        latencyMicros: json_['latencyMicros'] as core.String?,
        percent: json_['percent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (latencyMicros != null) 'latencyMicros': latencyMicros!,
    if (percent != null) 'percent': percent!,
  };
}

/// Used by:
///
/// - metastore:v1 : LatestBackup
/// - metastore:v1alpha : LatestBackup
/// - metastore:v1beta : LatestBackup
class $LatestBackup {
  /// The ID of an in-progress scheduled backup.
  ///
  /// Empty if no backup is in progress.
  ///
  /// Output only.
  core.String? backupId;

  /// The duration of the backup completion.
  ///
  /// Output only.
  core.String? duration;

  /// The time when the backup was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The current state of the backup.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The state of the backup is unknown.
  /// - "IN_PROGRESS" : The backup is in progress.
  /// - "SUCCEEDED" : The backup completed.
  /// - "FAILED" : The backup failed.
  core.String? state;

  $LatestBackup({this.backupId, this.duration, this.startTime, this.state});

  $LatestBackup.fromJson(core.Map json_)
    : this(
        backupId: json_['backupId'] as core.String?,
        duration: json_['duration'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupId != null) 'backupId': backupId!,
    if (duration != null) 'duration': duration!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Layer
/// - ondemandscanning:v1 : Layer
/// - ondemandscanning:v1beta1 : Layer
class $Layer {
  /// The recovered arguments to the Dockerfile directive.
  core.String? arguments;

  /// The recovered Dockerfile directive used to construct this layer.
  ///
  /// See https://docs.docker.com/engine/reference/builder/ for more
  /// information.
  ///
  /// Required.
  core.String? directive;

  $Layer({this.arguments, this.directive});

  $Layer.fromJson(core.Map json_)
    : this(
        arguments: json_['arguments'] as core.String?,
        directive: json_['directive'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (arguments != null) 'arguments': arguments!,
    if (directive != null) 'directive': directive!,
  };
}

/// Used by:
///
/// - container:v1 : LegacyAbac
/// - container:v1beta1 : LegacyAbac
class $LegacyAbac {
  /// Whether the ABAC authorizer is enabled for this cluster.
  ///
  /// When enabled, identities in the system, including service accounts, nodes,
  /// and controllers, will have statically granted permissions beyond those
  /// provided by the RBAC configuration or IAM.
  core.bool? enabled;

  $LegacyAbac({this.enabled});

  $LegacyAbac.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - appengine:v1 : Library
/// - appengine:v1beta : Library
class $Library {
  /// Name of the library.
  ///
  /// Example: "django".
  core.String? name;

  /// Version of the library to select, or "latest".
  core.String? version;

  $Library({this.name, this.version});

  $Library.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : License
/// - containeranalysis:v1alpha1 : License
/// - containeranalysis:v1beta1 : License
/// - ondemandscanning:v1 : License
/// - ondemandscanning:v1beta1 : License
class $License {
  /// Comments
  core.String? comments;

  /// Often a single license can be used to represent the licensing terms.
  ///
  /// Sometimes it is necessary to include a choice of one or more licenses or
  /// some combination of license identifiers. Examples: "LGPL-2.1-only OR MIT",
  /// "LGPL-2.1-only AND MIT", "GPL-2.0-or-later WITH Bison-exception-2.2".
  core.String? expression;

  $License({this.comments, this.expression});

  $License.fromJson(core.Map json_)
    : this(
        comments: json_['comments'] as core.String?,
        expression: json_['expression'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (comments != null) 'comments': comments!,
    if (expression != null) 'expression': expression!,
  };
}

/// Used by:
///
/// - compute:alpha : LicenseCodeLicenseAlias
/// - compute:beta : LicenseCodeLicenseAlias
/// - compute:v1 : LicenseCodeLicenseAlias
class $LicenseCodeLicenseAlias {
  /// Description of this License Code.
  ///
  /// Output only.
  core.String? description;

  /// URL of license corresponding to this License Code.
  ///
  /// Output only.
  core.String? selfLink;

  $LicenseCodeLicenseAlias({this.description, this.selfLink});

  $LicenseCodeLicenseAlias.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (selfLink != null) 'selfLink': selfLink!,
  };
}

/// Used by:
///
/// - compute:alpha : LicenseResourceCommitment
/// - compute:beta : LicenseResourceCommitment
/// - compute:v1 : LicenseResourceCommitment
class $LicenseResourceCommitment {
  /// The number of licenses you plan to purchase.
  core.String? amount;

  /// The number of cores per license.
  core.String? coresPerLicense;

  /// The applicable license URI.
  core.String? license;

  $LicenseResourceCommitment({this.amount, this.coresPerLicense, this.license});

  $LicenseResourceCommitment.fromJson(core.Map json_)
    : this(
        amount: json_['amount'] as core.String?,
        coresPerLicense: json_['coresPerLicense'] as core.String?,
        license: json_['license'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (amount != null) 'amount': amount!,
    if (coresPerLicense != null) 'coresPerLicense': coresPerLicense!,
    if (license != null) 'license': license!,
  };
}

/// Used by:
///
/// - compute:alpha : LicenseResourceRequirements
/// - compute:beta : LicenseResourceRequirements
/// - compute:v1 : LicenseResourceRequirements
class $LicenseResourceRequirements {
  /// \[Input Only\] Deprecated.
  ///
  /// This field no longer reflects the minimum number of guest cpus required to
  /// use the Instance.
  core.int? minGuestCpuCount;

  /// \[Input Only\] Deprecated.
  ///
  /// This field no longer reflects the minimum memory required to use the
  /// Instance.
  core.int? minMemoryMb;

  $LicenseResourceRequirements({this.minGuestCpuCount, this.minMemoryMb});

  $LicenseResourceRequirements.fromJson(core.Map json_)
    : this(
        minGuestCpuCount: json_['minGuestCpuCount'] as core.int?,
        minMemoryMb: json_['minMemoryMb'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (minGuestCpuCount != null) 'minGuestCpuCount': minGuestCpuCount!,
    if (minMemoryMb != null) 'minMemoryMb': minMemoryMb!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v1 : Lien
/// - cloudresourcemanager:v3 : Lien
class $Lien {
  /// The creation time of this Lien.
  core.String? createTime;

  /// A system-generated unique identifier for this Lien.
  ///
  /// Example: `liens/1234abcd`
  core.String? name;

  /// A stable, user-visible/meaningful string identifying the origin of the
  /// Lien, intended to be inspected programmatically.
  ///
  /// Maximum length of 200 characters. Example: 'compute.googleapis.com'
  core.String? origin;

  /// A reference to the resource this Lien is attached to.
  ///
  /// The server will validate the parent against those for which Liens are
  /// supported. Example: `projects/1234`
  core.String? parent;

  /// Concise user-visible strings indicating why an action cannot be performed
  /// on a resource.
  ///
  /// Maximum length of 200 characters. Example: 'Holds production API key'
  core.String? reason;

  /// The types of operations which should be blocked as a result of this Lien.
  ///
  /// Each value should correspond to an IAM permission. The server will
  /// validate the permissions against those for which Liens are supported. An
  /// empty list is meaningless and will be rejected. Example:
  /// \['resourcemanager.projects.delete'\]
  core.List<core.String>? restrictions;

  $Lien({
    this.createTime,
    this.name,
    this.origin,
    this.parent,
    this.reason,
    this.restrictions,
  });

  $Lien.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        origin: json_['origin'] as core.String?,
        parent: json_['parent'] as core.String?,
        reason: json_['reason'] as core.String?,
        restrictions:
            (json_['restrictions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (origin != null) 'origin': origin!,
    if (parent != null) 'parent': parent!,
    if (reason != null) 'reason': reason!,
    if (restrictions != null) 'restrictions': restrictions!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LifecycleDisabledPolicy
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLifecycleDisabledPolicy
class $LifecycleDisabledPolicy {
  /// Whether to hide this disabled object in the search menu for Drive items.
  ///
  /// * When `false`, the object is generally shown in the UI as disabled but it
  /// appears in the search results when searching for Drive items. * When
  /// `true`, the object is generally hidden in the UI when searching for Drive
  /// items.
  core.bool? hideInSearch;

  /// Whether to show this disabled object in the apply menu on Drive items.
  ///
  /// * When `true`, the object is generally shown in the UI as disabled and is
  /// unselectable. * When `false`, the object is generally hidden in the UI.
  core.bool? showInApply;

  $LifecycleDisabledPolicy({this.hideInSearch, this.showInApply});

  $LifecycleDisabledPolicy.fromJson(core.Map json_)
    : this(
        hideInSearch: json_['hideInSearch'] as core.bool?,
        showInApply: json_['showInApply'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hideInSearch != null) 'hideInSearch': hideInSearch!,
    if (showInApply != null) 'showInApply': showInApply!,
  };
}

/// Used by:
///
/// - gkehub:v2 : LifecycleState
/// - gkehub:v2alpha : LifecycleState
/// - gkehub:v2beta : LifecycleState
class $LifecycleState {
  /// The current state of the Feature resource in the Hub API.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State is unknown or not set.
  /// - "ENABLING" : The MembershipFeature is being enabled, and the
  /// MembershipFeature resource is being created. Once complete, the
  /// corresponding MembershipFeature will be enabled in this Hub.
  /// - "ACTIVE" : The MembershipFeature is enabled in this Hub, and the
  /// MembershipFeature resource is fully available.
  /// - "DISABLING" : The MembershipFeature is being disabled in this Hub, and
  /// the MembershipFeature resource is being deleted.
  /// - "UPDATING" : The MembershipFeature resource is being updated.
  /// - "SERVICE_UPDATING" : The MembershipFeature resource is being updated by
  /// the Hub Service.
  core.String? state;

  $LifecycleState({this.state});

  $LifecycleState.fromJson(core.Map json_)
    : this(state: json_['state'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - metastore:v1 : LimitConfig
/// - metastore:v1alpha : LimitConfig
/// - metastore:v1beta : LimitConfig
class $LimitConfig {
  /// The highest scaling factor that the service should be autoscaled to.
  ///
  /// Optional.
  core.double? maxScalingFactor;

  /// The lowest scaling factor that the service should be autoscaled to.
  ///
  /// Optional.
  core.double? minScalingFactor;

  $LimitConfig({this.maxScalingFactor, this.minScalingFactor});

  $LimitConfig.fromJson(core.Map json_)
    : this(
        maxScalingFactor: (json_['maxScalingFactor'] as core.num?)?.toDouble(),
        minScalingFactor: (json_['minScalingFactor'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxScalingFactor != null) 'maxScalingFactor': maxScalingFactor!,
    if (minScalingFactor != null) 'minScalingFactor': minScalingFactor!,
  };
}

/// Used by:
///
/// - composer:v1 : Line
/// - composer:v1beta1 : Line
class $Line {
  /// Text content of the log line.
  core.String? content;

  /// Number of the line.
  core.int? lineNumber;

  $Line({this.content, this.lineNumber});

  $Line.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        lineNumber: json_['lineNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (lineNumber != null) 'lineNumber': lineNumber!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LineItemBudget
/// - displayvideo:v3 : LineItemBudget
/// - displayvideo:v4 : LineItemBudget
class $LineItemBudget {
  /// The type of the budget allocation.
  ///
  /// `LINE_ITEM_BUDGET_ALLOCATION_TYPE_AUTOMATIC` is only applicable when
  /// automatic budget allocation is enabled for the parent insertion order.
  ///
  /// Required.
  /// Possible string values are:
  /// - "LINE_ITEM_BUDGET_ALLOCATION_TYPE_UNSPECIFIED" : Type value is not
  /// specified or is unknown in this version.
  /// - "LINE_ITEM_BUDGET_ALLOCATION_TYPE_AUTOMATIC" : Automatic budget
  /// allocation is enabled for the line item.
  /// - "LINE_ITEM_BUDGET_ALLOCATION_TYPE_FIXED" : A fixed max budget amount is
  /// allocated for the line item.
  /// - "LINE_ITEM_BUDGET_ALLOCATION_TYPE_UNLIMITED" : No budget limit is
  /// applied to the line item.
  core.String? budgetAllocationType;

  /// The budget unit specifies whether the budget is currency based or
  /// impression based.
  ///
  /// This value is inherited from the parent insertion order.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BUDGET_UNIT_UNSPECIFIED" : Type value is not specified or is unknown in
  /// this version.
  /// - "BUDGET_UNIT_CURRENCY" : Budgeting in currency amounts.
  /// - "BUDGET_UNIT_IMPRESSIONS" : Budgeting in impression amounts.
  core.String? budgetUnit;

  /// The maximum budget amount the line item will spend.
  ///
  /// Must be greater than 0. When budget_allocation_type is: *
  /// `LINE_ITEM_BUDGET_ALLOCATION_TYPE_AUTOMATIC`, this field is immutable and
  /// is set by the system. * `LINE_ITEM_BUDGET_ALLOCATION_TYPE_FIXED`, if
  /// budget_unit is: - `BUDGET_UNIT_CURRENCY`, this field represents maximum
  /// budget amount to spend, in micros of the advertiser's currency. For
  /// example, 1500000 represents 1.5 standard units of the currency. -
  /// `BUDGET_UNIT_IMPRESSIONS`, this field represents the maximum number of
  /// impressions to serve. * `LINE_ITEM_BUDGET_ALLOCATION_TYPE_UNLIMITED`, this
  /// field is not applicable and will be ignored by the system.
  core.String? maxAmount;

  $LineItemBudget({this.budgetAllocationType, this.budgetUnit, this.maxAmount});

  $LineItemBudget.fromJson(core.Map json_)
    : this(
        budgetAllocationType: json_['budgetAllocationType'] as core.String?,
        budgetUnit: json_['budgetUnit'] as core.String?,
        maxAmount: json_['maxAmount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (budgetAllocationType != null)
      'budgetAllocationType': budgetAllocationType!,
    if (budgetUnit != null) 'budgetUnit': budgetUnit!,
    if (maxAmount != null) 'maxAmount': maxAmount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiDistributionBucketOptionsLinear
/// - discoveryengine:v1beta : GoogleApiDistributionBucketOptionsLinear
/// - logging:v2 : Linear
/// - monitoring:v3 : Linear
class $Linear {
  /// Must be greater than 0.
  core.int? numFiniteBuckets;

  /// Lower bound of the first bucket.
  core.double? offset;

  /// Must be greater than 0.
  core.double? width;

  $Linear({this.numFiniteBuckets, this.offset, this.width});

  $Linear.fromJson(core.Map json_)
    : this(
        numFiniteBuckets: json_['numFiniteBuckets'] as core.int?,
        offset: (json_['offset'] as core.num?)?.toDouble(),
        width: (json_['width'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numFiniteBuckets != null) 'numFiniteBuckets': numFiniteBuckets!,
    if (offset != null) 'offset': offset!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - compute:alpha : HelpLink
/// - compute:beta : HelpLink
/// - compute:v1 : HelpLink
/// - deploymentmanager:alpha : HelpLink
/// - deploymentmanager:v2 : HelpLink
/// - deploymentmanager:v2beta : HelpLink
/// - vmmigration:v1 : Link
/// - vmmigration:v1alpha1 : Link
class $Link {
  /// Describes what the link offers.
  core.String? description;

  /// The URL of the link.
  core.String? url;

  $Link({this.description, this.url});

  $Link.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - healthcare:v1 : LinkedEntity
/// - healthcare:v1beta1 : LinkedEntity
class $LinkedEntity {
  /// entity_id is a concept unique identifier.
  ///
  /// These are prefixed by a string that identifies the entity coding system,
  /// followed by the unique identifier within that system. For example,
  /// "UMLS/C0000970". This also supports ad hoc entities, which are formed by
  /// normalizing entity mention content.
  core.String? entityId;

  $LinkedEntity({this.entityId});

  $LinkedEntity.fromJson(core.Map json_)
    : this(entityId: json_['entityId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityId != null) 'entityId': entityId!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : ListAddressGroupReferencesResponseAddressGroupReference
/// - networksecurity:v1beta1 : ListAddressGroupReferencesResponseAddressGroupReference
class $ListAddressGroupReferencesResponseAddressGroupReference {
  /// FirewallPolicy that is using the Address Group.
  core.String? firewallPolicy;

  /// Rule priority of the FirewallPolicy that is using the Address Group.
  core.int? rulePriority;

  /// Cloud Armor SecurityPolicy that is using the Address Group.
  core.String? securityPolicy;

  $ListAddressGroupReferencesResponseAddressGroupReference({
    this.firewallPolicy,
    this.rulePriority,
    this.securityPolicy,
  });

  $ListAddressGroupReferencesResponseAddressGroupReference.fromJson(
    core.Map json_,
  ) : this(
        firewallPolicy: json_['firewallPolicy'] as core.String?,
        rulePriority: json_['rulePriority'] as core.int?,
        securityPolicy: json_['securityPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (firewallPolicy != null) 'firewallPolicy': firewallPolicy!,
    if (rulePriority != null) 'rulePriority': rulePriority!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
  };
}

/// Used by:
///
/// - firestore:v1 : ListCollectionIdsRequest
/// - firestore:v1beta1 : ListCollectionIdsRequest
class $ListCollectionIdsRequest {
  /// The maximum number of results to return.
  core.int? pageSize;

  /// A page token.
  ///
  /// Must be a value from ListCollectionIdsResponse.
  core.String? pageToken;

  /// Reads documents as they were at the given time.
  ///
  /// This must be a microsecond precision timestamp within the past one hour,
  /// or if Point-in-Time Recovery is enabled, can additionally be a whole
  /// minute timestamp within the past 7 days.
  core.String? readTime;

  $ListCollectionIdsRequest({this.pageSize, this.pageToken, this.readTime});

  $ListCollectionIdsRequest.fromJson(core.Map json_)
    : this(
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        readTime: json_['readTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (readTime != null) 'readTime': readTime!,
  };
}

/// Used by:
///
/// - firestore:v1 : ListCollectionIdsResponse
/// - firestore:v1beta1 : ListCollectionIdsResponse
class $ListCollectionIdsResponse {
  /// The collection ids.
  core.List<core.String>? collectionIds;

  /// A page token that may be used to continue the list.
  core.String? nextPageToken;

  $ListCollectionIdsResponse({this.collectionIds, this.nextPageToken});

  $ListCollectionIdsResponse.fromJson(core.Map json_)
    : this(
        collectionIds:
            (json_['collectionIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collectionIds != null) 'collectionIds': collectionIds!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2ListLimits
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaListLimits
class $ListLimits {
  /// Maximum number of values allowed for the Field type.
  core.int? maxEntries;

  $ListLimits({this.maxEntries});

  $ListLimits.fromJson(core.Map json_)
    : this(maxEntries: json_['maxEntries'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxEntries != null) 'maxEntries': maxEntries!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : GoogleCloudOrgpolicyV1ListPolicy
/// - cloudasset:v1beta1 : GoogleCloudOrgpolicyV1ListPolicy
/// - cloudasset:v1p5beta1 : GoogleCloudOrgpolicyV1ListPolicy
/// - cloudresourcemanager:v1 : ListPolicy
class $ListPolicy {
  /// The policy all_values state.
  /// Possible string values are:
  /// - "ALL_VALUES_UNSPECIFIED" : Indicates that allowed_values or
  /// denied_values must be set.
  /// - "ALLOW" : A policy with this set allows all values.
  /// - "DENY" : A policy with this set denies all values.
  core.String? allValues;

  /// List of values allowed at this resource.
  ///
  /// Can only be set if `all_values` is set to `ALL_VALUES_UNSPECIFIED`.
  core.List<core.String>? allowedValues;

  /// List of values denied at this resource.
  ///
  /// Can only be set if `all_values` is set to `ALL_VALUES_UNSPECIFIED`.
  core.List<core.String>? deniedValues;

  /// Determines the inheritance behavior for this `Policy`.
  ///
  /// By default, a `ListPolicy` set at a resource supersedes any `Policy` set
  /// anywhere up the resource hierarchy. However, if `inherit_from_parent` is
  /// set to `true`, then the values from the effective `Policy` of the parent
  /// resource are inherited, meaning the values set in this `Policy` are added
  /// to the values inherited up the hierarchy. Setting `Policy` hierarchies
  /// that inherit both allowed values and denied values isn't recommended in
  /// most circumstances to keep the configuration simple and understandable.
  /// However, it is possible to set a `Policy` with `allowed_values` set that
  /// inherits a `Policy` with `denied_values` set. In this case, the values
  /// that are allowed must be in `allowed_values` and not present in
  /// `denied_values`. For example, suppose you have a `Constraint`
  /// `constraints/serviceuser.services`, which has a `constraint_type` of
  /// `list_constraint`, and with `constraint_default` set to `ALLOW`. Suppose
  /// that at the Organization level, a `Policy` is applied that restricts the
  /// allowed API activations to {`E1`, `E2`}. Then, if a `Policy` is applied to
  /// a project below the Organization that has `inherit_from_parent` set to
  /// `false` and field all_values set to DENY, then an attempt to activate any
  /// API will be denied. The following examples demonstrate different possible
  /// layerings for `projects/bar` parented by `organizations/foo`: Example 1
  /// (no inherited values): `organizations/foo` has a `Policy` with values:
  /// {allowed_values: "E1" allowed_values:"E2"} `projects/bar` has
  /// `inherit_from_parent` `false` and values: {allowed_values: "E3"
  /// allowed_values: "E4"} The accepted values at `organizations/foo` are `E1`,
  /// `E2`. The accepted values at `projects/bar` are `E3`, and `E4`. Example 2
  /// (inherited values): `organizations/foo` has a `Policy` with values:
  /// {allowed_values: "E1" allowed_values:"E2"} `projects/bar` has a `Policy`
  /// with values: {value: "E3" value: "E4" inherit_from_parent: true} The
  /// accepted values at `organizations/foo` are `E1`, `E2`. The accepted values
  /// at `projects/bar` are `E1`, `E2`, `E3`, and `E4`. Example 3 (inheriting
  /// both allowed and denied values): `organizations/foo` has a `Policy` with
  /// values: {allowed_values: "E1" allowed_values: "E2"} `projects/bar` has a
  /// `Policy` with: {denied_values: "E1"} The accepted values at
  /// `organizations/foo` are `E1`, `E2`. The value accepted at `projects/bar`
  /// is `E2`. Example 4 (RestoreDefault): `organizations/foo` has a `Policy`
  /// with values: {allowed_values: "E1" allowed_values:"E2"} `projects/bar` has
  /// a `Policy` with values: {RestoreDefault: {}} The accepted values at
  /// `organizations/foo` are `E1`, `E2`. The accepted values at `projects/bar`
  /// are either all or none depending on the value of `constraint_default` (if
  /// `ALLOW`, all; if `DENY`, none). Example 5 (no policy inherits parent
  /// policy): `organizations/foo` has no `Policy` set. `projects/bar` has no
  /// `Policy` set. The accepted values at both levels are either all or none
  /// depending on the value of `constraint_default` (if `ALLOW`, all; if
  /// `DENY`, none). Example 6 (ListConstraint allowing all):
  /// `organizations/foo` has a `Policy` with values: {allowed_values: "E1"
  /// allowed_values: "E2"} `projects/bar` has a `Policy` with: {all: ALLOW} The
  /// accepted values at `organizations/foo` are `E1`, E2`. Any value is
  /// accepted at `projects/bar`. Example 7 (ListConstraint allowing none):
  /// `organizations/foo` has a `Policy` with values: {allowed_values: "E1"
  /// allowed_values: "E2"} `projects/bar` has a `Policy` with: {all: DENY} The
  /// accepted values at `organizations/foo` are `E1`, E2`. No value is accepted
  /// at `projects/bar`. Example 10 (allowed and denied subtrees of Resource
  /// Manager hierarchy): Given the following resource hierarchy O1-\>{F1, F2};
  /// F1-\>{P1}; F2-\>{P2, P3}, `organizations/foo` has a `Policy` with values:
  /// {allowed_values: "under:organizations/O1"} `projects/bar` has a `Policy`
  /// with: {allowed_values: "under:projects/P3"} {denied_values:
  /// "under:folders/F2"} The accepted values at `organizations/foo` are
  /// `organizations/O1`, `folders/F1`, `folders/F2`, `projects/P1`,
  /// `projects/P2`, `projects/P3`. The accepted values at `projects/bar` are
  /// `organizations/O1`, `folders/F1`, `projects/P1`.
  core.bool? inheritFromParent;

  /// The Google Cloud Console will try to default to a configuration that
  /// matches the value specified in this `Policy`.
  ///
  /// If `suggested_value` is not set, it will inherit the value specified
  /// higher in the hierarchy, unless `inherit_from_parent` is `false`.
  ///
  /// Optional.
  core.String? suggestedValue;

  $ListPolicy({
    this.allValues,
    this.allowedValues,
    this.deniedValues,
    this.inheritFromParent,
    this.suggestedValue,
  });

  $ListPolicy.fromJson(core.Map json_)
    : this(
        allValues: json_['allValues'] as core.String?,
        allowedValues:
            (json_['allowedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        deniedValues:
            (json_['deniedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        inheritFromParent: json_['inheritFromParent'] as core.bool?,
        suggestedValue: json_['suggestedValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allValues != null) 'allValues': allValues!,
    if (allowedValues != null) 'allowedValues': allowedValues!,
    if (deniedValues != null) 'deniedValues': deniedValues!,
    if (inheritFromParent != null) 'inheritFromParent': inheritFromParent!,
    if (suggestedValue != null) 'suggestedValue': suggestedValue!,
  };
}

/// Used by:
///
/// - appengine:v1 : LivenessCheck
/// - appengine:v1beta : LivenessCheck
class $LivenessCheck {
  /// Interval between health checks.
  core.String? checkInterval;

  /// Number of consecutive failed checks required before considering the VM
  /// unhealthy.
  core.int? failureThreshold;

  /// Host header to send when performing a HTTP Liveness check.
  ///
  /// Example: "myapp.appspot.com"
  core.String? host;

  /// The initial delay before starting to execute the checks.
  core.String? initialDelay;

  /// The request path.
  core.String? path;

  /// Number of consecutive successful checks required before considering the VM
  /// healthy.
  core.int? successThreshold;

  /// Time before the check is considered failed.
  core.String? timeout;

  $LivenessCheck({
    this.checkInterval,
    this.failureThreshold,
    this.host,
    this.initialDelay,
    this.path,
    this.successThreshold,
    this.timeout,
  });

  $LivenessCheck.fromJson(core.Map json_)
    : this(
        checkInterval: json_['checkInterval'] as core.String?,
        failureThreshold: json_['failureThreshold'] as core.int?,
        host: json_['host'] as core.String?,
        initialDelay: json_['initialDelay'] as core.String?,
        path: json_['path'] as core.String?,
        successThreshold: json_['successThreshold'] as core.int?,
        timeout: json_['timeout'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkInterval != null) 'checkInterval': checkInterval!,
    if (failureThreshold != null) 'failureThreshold': failureThreshold!,
    if (host != null) 'host': host!,
    if (initialDelay != null) 'initialDelay': initialDelay!,
    if (path != null) 'path': path!,
    if (successThreshold != null) 'successThreshold': successThreshold!,
    if (timeout != null) 'timeout': timeout!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3LlmModelSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1LlmModelSettings
class $LlmModelSettings {
  /// The selected LLM model.
  core.String? model;

  /// The custom prompt to use.
  core.String? promptText;

  $LlmModelSettings({this.model, this.promptText});

  $LlmModelSettings.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        promptText: json_['promptText'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (promptText != null) 'promptText': promptText!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : LoadBalancerBackend
/// - networkmanagement:v1beta1 : LoadBalancerBackend
class $LoadBalancerBackend {
  /// Name of a Compute Engine instance or network endpoint.
  core.String? displayName;

  /// A list of firewall rule URIs allowing probes from health check IP ranges.
  core.List<core.String>? healthCheckAllowingFirewallRules;

  /// A list of firewall rule URIs blocking probes from health check IP ranges.
  core.List<core.String>? healthCheckBlockingFirewallRules;

  /// State of the health check firewall configuration.
  /// Possible string values are:
  /// - "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED" : State is unspecified.
  /// Default state if not populated.
  /// - "CONFIGURED" : There are configured firewall rules to allow health check
  /// probes to the backend.
  /// - "MISCONFIGURED" : There are firewall rules configured to allow partial
  /// health check ranges or block all health check ranges. If a health check
  /// probe is sent from denied IP ranges, the health check to the backend will
  /// fail. Then, the backend will be marked unhealthy and will not receive
  /// traffic sent to the load balancer.
  core.String? healthCheckFirewallState;

  /// URI of a Compute Engine instance or network endpoint.
  core.String? uri;

  $LoadBalancerBackend({
    this.displayName,
    this.healthCheckAllowingFirewallRules,
    this.healthCheckBlockingFirewallRules,
    this.healthCheckFirewallState,
    this.uri,
  });

  $LoadBalancerBackend.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        healthCheckAllowingFirewallRules:
            (json_['healthCheckAllowingFirewallRules'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        healthCheckBlockingFirewallRules:
            (json_['healthCheckBlockingFirewallRules'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        healthCheckFirewallState:
            json_['healthCheckFirewallState'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (healthCheckAllowingFirewallRules != null)
      'healthCheckAllowingFirewallRules': healthCheckAllowingFirewallRules!,
    if (healthCheckBlockingFirewallRules != null)
      'healthCheckBlockingFirewallRules': healthCheckBlockingFirewallRules!,
    if (healthCheckFirewallState != null)
      'healthCheckFirewallState': healthCheckFirewallState!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : LoadBalancerBackendInfo
/// - networkmanagement:v1beta1 : LoadBalancerBackendInfo
class $LoadBalancerBackendInfo {
  /// URI of the backend bucket this backend targets (if applicable).
  core.String? backendBucketUri;

  /// URI of the backend service this backend belongs to (if applicable).
  core.String? backendServiceUri;

  /// Health check firewalls configuration state for the backend.
  ///
  /// This is a result of the static firewall analysis (verifying that health
  /// check traffic from required IP ranges to the backend is allowed or not).
  /// The backend might still be unhealthy even if these firewalls are
  /// configured. Please refer to the documentation for more information:
  /// https://cloud.google.com/load-balancing/docs/firewall-rules
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED" : Configuration state
  /// unspecified. It usually means that the backend has no health check
  /// attached, or there was an unexpected configuration error preventing
  /// Connectivity tests from verifying health check configuration.
  /// - "FIREWALLS_CONFIGURED" : Firewall rules (policies) allowing health check
  /// traffic from all required IP ranges to the backend are configured.
  /// - "FIREWALLS_PARTIALLY_CONFIGURED" : Firewall rules (policies) allow
  /// health check traffic only from a part of required IP ranges.
  /// - "FIREWALLS_NOT_CONFIGURED" : Firewall rules (policies) deny health check
  /// traffic from all required IP ranges to the backend.
  /// - "FIREWALLS_UNSUPPORTED" : The network contains firewall rules of
  /// unsupported types, so Connectivity tests were not able to verify health
  /// check configuration status. Please refer to the documentation for the list
  /// of unsupported configurations:
  /// https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs
  core.String? healthCheckFirewallsConfigState;

  /// URI of the health check attached to this backend (if applicable).
  core.String? healthCheckUri;

  /// URI of the instance group this backend belongs to (if applicable).
  core.String? instanceGroupUri;

  /// URI of the backend instance (if applicable).
  ///
  /// Populated for instance group backends, and zonal NEG backends.
  core.String? instanceUri;

  /// Display name of the backend.
  ///
  /// For example, it might be an instance name for the instance group backends,
  /// or an IP address and port for zonal network endpoint group backends.
  core.String? name;

  /// URI of the network endpoint group this backend belongs to (if applicable).
  core.String? networkEndpointGroupUri;

  /// PSC Google API target this PSC NEG backend targets (if applicable).
  core.String? pscGoogleApiTarget;

  /// URI of the PSC service attachment this PSC NEG backend targets (if
  /// applicable).
  core.String? pscServiceAttachmentUri;

  $LoadBalancerBackendInfo({
    this.backendBucketUri,
    this.backendServiceUri,
    this.healthCheckFirewallsConfigState,
    this.healthCheckUri,
    this.instanceGroupUri,
    this.instanceUri,
    this.name,
    this.networkEndpointGroupUri,
    this.pscGoogleApiTarget,
    this.pscServiceAttachmentUri,
  });

  $LoadBalancerBackendInfo.fromJson(core.Map json_)
    : this(
        backendBucketUri: json_['backendBucketUri'] as core.String?,
        backendServiceUri: json_['backendServiceUri'] as core.String?,
        healthCheckFirewallsConfigState:
            json_['healthCheckFirewallsConfigState'] as core.String?,
        healthCheckUri: json_['healthCheckUri'] as core.String?,
        instanceGroupUri: json_['instanceGroupUri'] as core.String?,
        instanceUri: json_['instanceUri'] as core.String?,
        name: json_['name'] as core.String?,
        networkEndpointGroupUri:
            json_['networkEndpointGroupUri'] as core.String?,
        pscGoogleApiTarget: json_['pscGoogleApiTarget'] as core.String?,
        pscServiceAttachmentUri:
            json_['pscServiceAttachmentUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backendBucketUri != null) 'backendBucketUri': backendBucketUri!,
    if (backendServiceUri != null) 'backendServiceUri': backendServiceUri!,
    if (healthCheckFirewallsConfigState != null)
      'healthCheckFirewallsConfigState': healthCheckFirewallsConfigState!,
    if (healthCheckUri != null) 'healthCheckUri': healthCheckUri!,
    if (instanceGroupUri != null) 'instanceGroupUri': instanceGroupUri!,
    if (instanceUri != null) 'instanceUri': instanceUri!,
    if (name != null) 'name': name!,
    if (networkEndpointGroupUri != null)
      'networkEndpointGroupUri': networkEndpointGroupUri!,
    if (pscGoogleApiTarget != null) 'pscGoogleApiTarget': pscGoogleApiTarget!,
    if (pscServiceAttachmentUri != null)
      'pscServiceAttachmentUri': pscServiceAttachmentUri!,
  };
}

/// Used by:
///
/// - domains:v1 : LoadBalancerTarget
/// - domains:v1alpha2 : LoadBalancerTarget
/// - domains:v1beta1 : LoadBalancerTarget
class $LoadBalancerTarget {
  /// The frontend IP address of the load balancer to health check.
  core.String? ipAddress;

  /// The protocol of the load balancer to health check.
  /// Possible string values are:
  /// - "UNDEFINED"
  /// - "TCP" : Indicates the load balancer is accessible via TCP.
  /// - "UDP" : Indicates the load balancer is accessible via UDP.
  core.String? ipProtocol;

  /// The type of load balancer specified by this target.
  ///
  /// This value must match the configuration of the load balancer located at
  /// the LoadBalancerTarget's IP address, port, and region. Use the following:
  /// - *regionalL4ilb*: for a regional internal passthrough Network Load
  /// Balancer. - *regionalL7ilb*: for a regional internal Application Load
  /// Balancer. - *globalL7ilb*: for a global internal Application Load
  /// Balancer.
  /// Possible string values are:
  /// - "NONE"
  /// - "GLOBAL_L7ILB" : Indicates the load balancer is a Cross-Region
  /// Application Load Balancer.
  /// - "REGIONAL_L4ILB" : Indicates the load balancer is a Regional Network
  /// Passthrough Load Balancer.
  /// - "REGIONAL_L7ILB" : Indicates the load balancer is a Regional Application
  /// Load Balancer.
  core.String? loadBalancerType;

  /// The fully qualified URL of the network that the load balancer is attached
  /// to.
  ///
  /// This should be formatted like
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
  core.String? networkUrl;

  /// The configured port of the load balancer.
  core.String? port;

  /// The project ID in which the load balancer is located.
  core.String? project;

  /// The region in which the load balancer is located.
  core.String? region;

  $LoadBalancerTarget({
    this.ipAddress,
    this.ipProtocol,
    this.loadBalancerType,
    this.networkUrl,
    this.port,
    this.project,
    this.region,
  });

  $LoadBalancerTarget.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        ipProtocol: json_['ipProtocol'] as core.String?,
        loadBalancerType: json_['loadBalancerType'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
        port: json_['port'] as core.String?,
        project: json_['project'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipProtocol != null) 'ipProtocol': ipProtocol!,
    if (loadBalancerType != null) 'loadBalancerType': loadBalancerType!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
    if (port != null) 'port': port!,
    if (project != null) 'project': project!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - composer:v1 : LoadSnapshotRequest
/// - composer:v1beta1 : LoadSnapshotRequest
class $LoadSnapshotRequest {
  /// Whether or not to skip setting Airflow overrides when loading the
  /// environment's state.
  core.bool? skipAirflowOverridesSetting;

  /// Whether or not to skip setting environment variables when loading the
  /// environment's state.
  core.bool? skipEnvironmentVariablesSetting;

  /// Whether or not to skip copying Cloud Storage data when loading the
  /// environment's state.
  core.bool? skipGcsDataCopying;

  /// Whether or not to skip installing Pypi packages when loading the
  /// environment's state.
  core.bool? skipPypiPackagesInstallation;

  /// A Cloud Storage path to a snapshot to load, e.g.:
  /// "gs://my-bucket/snapshots/project_location_environment_timestamp".
  core.String? snapshotPath;

  $LoadSnapshotRequest({
    this.skipAirflowOverridesSetting,
    this.skipEnvironmentVariablesSetting,
    this.skipGcsDataCopying,
    this.skipPypiPackagesInstallation,
    this.snapshotPath,
  });

  $LoadSnapshotRequest.fromJson(core.Map json_)
    : this(
        skipAirflowOverridesSetting:
            json_['skipAirflowOverridesSetting'] as core.bool?,
        skipEnvironmentVariablesSetting:
            json_['skipEnvironmentVariablesSetting'] as core.bool?,
        skipGcsDataCopying: json_['skipGcsDataCopying'] as core.bool?,
        skipPypiPackagesInstallation:
            json_['skipPypiPackagesInstallation'] as core.bool?,
        snapshotPath: json_['snapshotPath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (skipAirflowOverridesSetting != null)
      'skipAirflowOverridesSetting': skipAirflowOverridesSetting!,
    if (skipEnvironmentVariablesSetting != null)
      'skipEnvironmentVariablesSetting': skipEnvironmentVariablesSetting!,
    if (skipGcsDataCopying != null) 'skipGcsDataCopying': skipGcsDataCopying!,
    if (skipPypiPackagesInstallation != null)
      'skipPypiPackagesInstallation': skipPypiPackagesInstallation!,
    if (snapshotPath != null) 'snapshotPath': snapshotPath!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3LoadVersionRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1LoadVersionRequest
class $LoadVersionRequest {
  /// This field is used to prevent accidental overwrite of other agent
  /// resources, which can potentially impact other flow's behavior.
  ///
  /// If `allow_override_agent_resources` is false, conflicted agent-level
  /// resources will not be overridden (i.e. intents, entities, webhooks).
  core.bool? allowOverrideAgentResources;

  $LoadVersionRequest({this.allowOverrideAgentResources});

  $LoadVersionRequest.fromJson(core.Map json_)
    : this(
        allowOverrideAgentResources:
            json_['allowOverrideAgentResources'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowOverrideAgentResources != null)
      'allowOverrideAgentResources': allowOverrideAgentResources!,
  };
}

/// Used by:
///
/// - content:v2.1 : ServiceStoreConfigCutoffConfigLocalCutoffTime
/// - merchantapi:accounts_v1beta : LocalCutoffTime
class $LocalCutoffTime {
  /// Hour local delivery orders must be placed by to process the same day.
  core.String? hour;

  /// Minute local delivery orders must be placed by to process the same day.
  core.String? minute;

  $LocalCutoffTime({this.hour, this.minute});

  $LocalCutoffTime.fromJson(core.Map json_)
    : this(
        hour: json_['hour'] as core.String?,
        minute: json_['minute'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hour != null) 'hour': hour!,
    if (minute != null) 'minute': minute!,
  };
}

/// Used by:
///
/// - compute:alpha : LocalDisk
/// - compute:beta : LocalDisk
/// - compute:v1 : LocalDisk
class $LocalDisk {
  /// Specifies the number of such disks.
  core.int? diskCount;

  /// Specifies the size of the disk in base-2 GB.
  core.int? diskSizeGb;

  /// Specifies the desired disk type on the node.
  ///
  /// This disk type must be a local storage type (e.g.: local-ssd). Note that
  /// for nodeTemplates, this should be the name of the disk type and not its
  /// URL.
  core.String? diskType;

  $LocalDisk({this.diskCount, this.diskSizeGb, this.diskType});

  $LocalDisk.fromJson(core.Map json_)
    : this(
        diskCount: json_['diskCount'] as core.int?,
        diskSizeGb: json_['diskSizeGb'] as core.int?,
        diskType: json_['diskType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskCount != null) 'diskCount': diskCount!,
    if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
    if (diskType != null) 'diskType': diskType!,
  };
}

/// Used by:
///
/// - container:v1 : LocalNvmeSsdBlockConfig
/// - container:v1beta1 : LocalNvmeSsdBlockConfig
class $LocalNvmeSsdBlockConfig {
  /// Number of local NVMe SSDs to use.
  ///
  /// The limit for this value is dependent upon the maximum number of disk
  /// available on a machine per zone. See:
  /// https://{$universe.dns_names.final_documentation_domain}/compute/docs/disks/local-ssd
  /// for more information. A zero (or unset) value has different meanings
  /// depending on machine type being used: 1. For pre-Gen3 machines, which
  /// support flexible numbers of local ssds, zero (or unset) means to disable
  /// using local SSDs as ephemeral storage. 2. For Gen3 machines which dictate
  /// a specific number of local ssds, zero (or unset) means to use the default
  /// number of local ssds that goes with that machine type. For example, for a
  /// c3-standard-8-lssd machine, 2 local ssds would be provisioned. For
  /// c3-standard-8 (which doesn't support local ssds), 0 will be provisioned.
  /// See
  /// https://{$universe.dns_names.final_documentation_domain}/compute/docs/disks/local-ssd#choose_number_local_ssds
  /// for more info.
  core.int? localSsdCount;

  $LocalNvmeSsdBlockConfig({this.localSsdCount});

  $LocalNvmeSsdBlockConfig.fromJson(core.Map json_)
    : this(localSsdCount: json_['localSsdCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (localSsdCount != null) 'localSsdCount': localSsdCount!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : Locality
/// - trafficdirector:v3 : Locality
class $Locality {
  /// Region this :ref:`zone ` belongs to.
  core.String? region;

  /// When used for locality of upstream hosts, this field further splits zone
  /// into smaller chunks of sub-zones so they can be load balanced
  /// independently.
  core.String? subZone;

  /// Defines the local service zone where Envoy is running.
  ///
  /// Though optional, it should be set if discovery service routing is used and
  /// the discovery service exposes :ref:`zone data `, either in this message or
  /// via :option:`--service-zone`. The meaning of zone is context dependent,
  /// e.g. `Availability Zone (AZ) `_ on AWS, `Zone `_ on GCP, etc.
  core.String? zone;

  $Locality({this.region, this.subZone, this.zone});

  $Locality.fromJson(core.Map json_)
    : this(
        region: json_['region'] as core.String?,
        subZone: json_['subZone'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (region != null) 'region': region!,
    if (subZone != null) 'subZone': subZone!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - admob:v1 : LocalizationSettings
/// - admob:v1beta : LocalizationSettings
class $LocalizationSettings {
  /// Currency code of the earning related metrics, which is the 3-letter code
  /// defined in ISO 4217.
  ///
  /// The daily average rate is used for the currency conversion. Defaults to
  /// the account currency code if unspecified.
  core.String? currencyCode;

  /// Language used for any localized text, such as some dimension value display
  /// labels.
  ///
  /// The language tag defined in the IETF BCP47. Defaults to 'en-US' if
  /// unspecified.
  core.String? languageCode;

  $LocalizationSettings({this.currencyCode, this.languageCode});

  $LocalizationSettings.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - compute:alpha : LocalizedMessage
/// - compute:beta : LocalizedMessage
/// - compute:v1 : LocalizedMessage
/// - deploymentmanager:alpha : LocalizedMessage
/// - deploymentmanager:v2 : LocalizedMessage
/// - deploymentmanager:v2beta : LocalizedMessage
/// - vmmigration:v1 : LocalizedMessage
/// - vmmigration:v1alpha1 : LocalizedMessage
class $LocalizedMessage {
  /// The locale used following the specification defined at
  /// https://www.rfc-editor.org/rfc/bcp/bcp47.txt.
  ///
  /// Examples are: "en-US", "fr-CH", "es-MX"
  core.String? locale;

  /// The localized error message in the above locale.
  core.String? message;

  $LocalizedMessage({this.locale, this.message});

  $LocalizedMessage.fromJson(core.Map json_)
    : this(
        locale: json_['locale'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (locale != null) 'locale': locale!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudLocationLocation
/// - aiplatform:v1beta1 : GoogleCloudLocationLocation
/// - alloydb:v1 : GoogleCloudLocationLocation
/// - alloydb:v1alpha : GoogleCloudLocationLocation
/// - alloydb:v1beta : GoogleCloudLocationLocation
/// - apigateway:v1 : ApigatewayLocation
/// - apigateway:v1beta : ApigatewayLocation
/// - apigeeregistry:v1 : Location
/// - apihub:v1 : GoogleCloudLocationLocation
/// - apim:v1alpha : Location
/// - apphub:v1 : Location
/// - apphub:v1alpha : Location
/// - artifactregistry:v1 : Location
/// - artifactregistry:v1beta1 : Location
/// - artifactregistry:v1beta2 : Location
/// - backupdr:v1 : Location
/// - baremetalsolution:v2 : Location
/// - batch:v1 : Location
/// - beyondcorp:v1 : GoogleCloudLocationLocation
/// - beyondcorp:v1alpha : GoogleCloudLocationLocation
/// - bigquerydatatransfer:v1 : Location
/// - bigtableadmin:v2 : Location
/// - blockchainnodeengine:v1 : Location
/// - certificatemanager:v1 : Location
/// - cloudbuild:v2 : Location
/// - clouddeploy:v1 : Location
/// - cloudfunctions:v1 : Location
/// - cloudfunctions:v2 : Location
/// - cloudfunctions:v2alpha : Location
/// - cloudfunctions:v2beta : Location
/// - cloudkms:v1 : Location
/// - cloudlocationfinder:v1alpha : Location
/// - cloudscheduler:v1 : Location
/// - cloudscheduler:v1beta1 : Location
/// - cloudtasks:v2 : Location
/// - cloudtasks:v2beta2 : Location
/// - cloudtasks:v2beta3 : Location
/// - config:v1 : Location
/// - connectors:v1 : Location
/// - contactcenteraiplatform:v1alpha1 : Location
/// - dataform:v1beta1 : Location
/// - datafusion:v1 : Location
/// - datafusion:v1beta1 : Location
/// - datamigration:v1 : Location
/// - datamigration:v1beta1 : Location
/// - datastream:v1 : Location
/// - datastream:v1alpha1 : Location
/// - developerconnect:v1 : Location
/// - dialogflow:v2 : GoogleCloudLocationLocation
/// - dialogflow:v2beta1 : GoogleCloudLocationLocation
/// - dialogflow:v3 : GoogleCloudLocationLocation
/// - dialogflow:v3beta1 : GoogleCloudLocationLocation
/// - documentai:v1 : GoogleCloudLocationLocation
/// - documentai:v1beta3 : GoogleCloudLocationLocation
/// - domains:v1 : Location
/// - domains:v1alpha2 : Location
/// - domains:v1beta1 : Location
/// - eventarc:v1 : Location
/// - file:v1 : Location
/// - file:v1beta1 : Location
/// - firebaseapphosting:v1 : Location
/// - firebaseapphosting:v1beta : Location
/// - firebasedataconnect:v1 : Location
/// - firebasedataconnect:v1beta : Location
/// - firestore:v1 : Location
/// - gkebackup:v1 : Location
/// - gkehub:v1 : Location
/// - gkehub:v1alpha : Location
/// - gkehub:v1beta : Location
/// - gkehub:v1beta1 : Location
/// - gkehub:v2 : Location
/// - gkehub:v2alpha : Location
/// - gkehub:v2beta : Location
/// - gkeonprem:v1 : Location
/// - healthcare:v1 : Location
/// - healthcare:v1beta1 : Location
/// - ids:v1 : Location
/// - lifesciences:v2beta : Location
/// - looker:v1 : Location
/// - managedidentities:v1 : Location
/// - managedidentities:v1alpha1 : Location
/// - managedidentities:v1beta1 : Location
/// - managedkafka:v1 : Location
/// - memcache:v1 : Location
/// - memcache:v1beta2 : Location
/// - migrationcenter:v1 : Location
/// - migrationcenter:v1alpha1 : Location
/// - netapp:v1 : Location
/// - netapp:v1beta1 : Location
/// - networkconnectivity:v1 : Location
/// - networkconnectivity:v1alpha1 : Location
/// - networkmanagement:v1 : Location
/// - networkmanagement:v1beta1 : Location
/// - networksecurity:v1 : Location
/// - networksecurity:v1beta1 : Location
/// - networkservices:v1 : Location
/// - networkservices:v1beta1 : Location
/// - notebooks:v1 : Location
/// - notebooks:v2 : Location
/// - observability:v1 : Location
/// - oracledatabase:v1 : Location
/// - parallelstore:v1 : Location
/// - parallelstore:v1beta : Location
/// - parametermanager:v1 : Location
/// - privateca:v1 : Location
/// - privateca:v1beta1 : Location
/// - rapidmigrationassessment:v1 : Location
/// - recommender:v1beta1 : GoogleCloudLocationLocation
/// - run:v1 : Location
/// - saasservicemgmt:v1beta1 : GoogleCloudLocationLocation
/// - secretmanager:v1 : Location
/// - secretmanager:v1beta1 : Location
/// - secretmanager:v1beta2 : Location
/// - securesourcemanager:v1 : Location
/// - securityposture:v1 : Location
/// - servicedirectory:v1 : Location
/// - servicedirectory:v1beta1 : Location
/// - storagebatchoperations:v1 : Location
/// - tpu:v1 : Location
/// - tpu:v1alpha1 : Location
/// - tpu:v2 : Location
/// - tpu:v2alpha1 : Location
/// - translate:v3 : Location
/// - translate:v3beta1 : Location
/// - vmmigration:v1 : Location
/// - vmmigration:v1alpha1 : Location
/// - vmwareengine:v1 : Location
/// - vpcaccess:v1 : Location
/// - vpcaccess:v1beta1 : Location
/// - workflows:v1 : Location
/// - workflows:v1beta : Location
/// - workloadmanager:v1 : Location
/// - workstations:v1 : Location
class $Location00 {
  /// The friendly name for this location, typically a nearby city name.
  ///
  /// For example, "Tokyo".
  core.String? displayName;

  /// Cross-service attributes for the location.
  ///
  /// For example {"cloud.googleapis.com/region": "us-east1"}
  core.Map<core.String, core.String>? labels;

  /// The canonical id for this location.
  ///
  /// For example: `"us-east1"`.
  core.String? locationId;

  /// Service-specific metadata.
  ///
  /// For example the available capacity at the given location.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Resource name for the location, which may vary between implementations.
  ///
  /// For example: `"projects/example-project/locations/us-east1"`
  core.String? name;

  $Location00({
    this.displayName,
    this.labels,
    this.locationId,
    this.metadata,
    this.name,
  });

  $Location00.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        locationId: json_['locationId'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (locationId != null) 'locationId': locationId!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - appengine:v1 : Location
/// - appengine:v1alpha : Location
/// - appengine:v1beta : Location
/// - dataplex:v1 : GoogleCloudLocationLocation
/// - logging:v2 : Location
/// - metastore:v1 : Location
/// - metastore:v1alpha : Location
/// - metastore:v1beta : Location
class $Location01 {
  /// The friendly name for this location, typically a nearby city name.
  ///
  /// For example, "Tokyo".
  core.String? displayName;

  /// Cross-service attributes for the location.
  ///
  /// For example {"cloud.googleapis.com/region": "us-east1"}
  core.Map<core.String, core.String>? labels;

  /// The canonical id for this location.
  ///
  /// For example: "us-east1".
  core.String? locationId;

  /// Service-specific metadata.
  ///
  /// For example the available capacity at the given location.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Resource name for the location, which may vary between implementations.
  ///
  /// For example: "projects/example-project/locations/us-east1"
  core.String? name;

  $Location01({
    this.displayName,
    this.labels,
    this.locationId,
    this.metadata,
    this.name,
  });

  $Location01.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        locationId: json_['locationId'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (locationId != null) 'locationId': locationId!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : InterceptLocation
/// - networksecurity:v1 : MirroringLocation
/// - networksecurity:v1beta1 : InterceptLocation
/// - networksecurity:v1beta1 : MirroringLocation
class $Location02 {
  /// The cloud location, e.g. "us-central1-a" or "asia-south1".
  ///
  /// Output only.
  core.String? location;

  /// The current state of the association in this location.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set (this is not a valid state).
  /// - "ACTIVE" : The resource is ready and in sync in the location.
  /// - "OUT_OF_SYNC" : The resource is out of sync in the location. In most
  /// cases, this is a result of a transient issue within the system (e.g. an
  /// inaccessible location) and the system is expected to recover
  /// automatically.
  core.String? state;

  $Location02({this.location, this.state});

  $Location02.fromJson(core.Map json_)
    : this(
        location: json_['location'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (location != null) 'location': location!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - redis:v1 : Location
/// - redis:v1beta1 : Location
class $Location03 {
  /// The friendly name for this location, typically a nearby city name.
  ///
  /// For example, "Tokyo".
  core.String? displayName;

  /// Cross-service attributes for the location.
  ///
  /// For example {"cloud.googleapis.com/region": "us-east1"}
  core.Map<core.String, core.String>? labels;

  /// Resource ID for the region.
  ///
  /// For example: "us-east1".
  core.String? locationId;

  /// The set of available zones in the location.
  ///
  /// The map is keyed by the lowercase ID of each zone, as defined by Compute
  /// Engine. These keys can be specified in `location_id` or
  /// `alternative_location_id` fields when creating a Redis instance.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// Full resource name for the region.
  ///
  /// For example: "projects/example-project/locations/us-east1".
  core.String? name;

  $Location03({
    this.displayName,
    this.labels,
    this.locationId,
    this.metadata,
    this.name,
  });

  $Location03.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        locationId: json_['locationId'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (labels != null) 'labels': labels!,
    if (locationId != null) 'locationId': locationId!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LocationList
/// - displayvideo:v3 : LocationList
/// - displayvideo:v4 : LocationList
class $LocationList {
  /// The unique ID of the advertiser the location list belongs to.
  ///
  /// Required. Immutable.
  core.String? advertiserId;

  /// The display name of the location list.
  ///
  /// Must be UTF-8 encoded with a maximum size of 240 bytes.
  ///
  /// Required.
  core.String? displayName;

  /// The unique ID of the location list.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? locationListId;

  /// The type of location.
  ///
  /// All locations in the list will share this type.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "TARGETING_LOCATION_TYPE_UNSPECIFIED" : Default value when type is not
  /// specified or is unknown.
  /// - "TARGETING_LOCATION_TYPE_PROXIMITY" : The type for proximity geo
  /// location.
  /// - "TARGETING_LOCATION_TYPE_REGIONAL" : The type for regional geo location.
  core.String? locationType;

  /// The resource name of the location list.
  ///
  /// Output only.
  core.String? name;

  $LocationList({
    this.advertiserId,
    this.displayName,
    this.locationListId,
    this.locationType,
    this.name,
  });

  $LocationList.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        locationListId: json_['locationListId'] as core.String?,
        locationType: json_['locationType'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (displayName != null) 'displayName': displayName!,
    if (locationListId != null) 'locationListId': locationListId!,
    if (locationType != null) 'locationType': locationType!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : LocationPolicyLocationConstraints
/// - compute:beta : LocationPolicyLocationConstraints
/// - compute:v1 : LocationPolicyLocationConstraints
class $LocationPolicyLocationConstraints {
  /// Maximum number of items that are allowed to be placed in this zone.
  ///
  /// The value must be non-negative.
  core.int? maxCount;

  $LocationPolicyLocationConstraints({this.maxCount});

  $LocationPolicyLocationConstraints.fromJson(core.Map json_)
    : this(maxCount: json_['maxCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxCount != null) 'maxCount': maxCount!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : LocationPreference
/// - sqladmin:v1beta4 : LocationPreference
class $LocationPreference {
  /// The App Engine application to follow, it must be in the same region as the
  /// Cloud SQL instance.
  ///
  /// WARNING: Changing this might restart the instance.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? followGaeApplication;

  /// This is always `sql#locationPreference`.
  core.String? kind;

  /// The preferred Compute Engine zone for the secondary/failover (for example:
  /// us-central1-a, us-central1-b, etc.).
  ///
  /// To disable this field, set it to 'no_secondary_zone'.
  core.String? secondaryZone;

  /// The preferred Compute Engine zone (for example: us-central1-a,
  /// us-central1-b, etc.).
  ///
  /// WARNING: Changing this might restart the instance.
  core.String? zone;

  $LocationPreference({
    this.followGaeApplication,
    this.kind,
    this.secondaryZone,
    this.zone,
  });

  $LocationPreference.fromJson(core.Map json_)
    : this(
        followGaeApplication: json_['followGaeApplication'] as core.String?,
        kind: json_['kind'] as core.String?,
        secondaryZone: json_['secondaryZone'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (followGaeApplication != null)
      'followGaeApplication': followGaeApplication!,
    if (kind != null) 'kind': kind!,
    if (secondaryZone != null) 'secondaryZone': secondaryZone!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - connectors:v1 : LockConfig
/// - integrations:v1 : GoogleCloudConnectorsV1LockConfig
class $LockConfig {
  /// Indicates whether or not the connection is locked.
  ///
  /// Optional.
  core.bool? locked;

  /// Describes why a connection is locked.
  ///
  /// Optional.
  core.String? reason;

  $LockConfig({this.locked, this.reason});

  $LockConfig.fromJson(core.Map json_)
    : this(
        locked: json_['locked'] as core.bool?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (locked != null) 'locked': locked!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LockStatus
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLockStatus
class $LockStatus {
  /// Indicates whether this label component is the (direct) target of a
  /// LabelLock.
  ///
  /// A label component can be implicitly locked even if it's not the direct
  /// target of a LabelLock, in which case this field is set to false.
  ///
  /// Output only.
  core.bool? locked;

  $LockStatus({this.locked});

  $LockStatus.fromJson(core.Map json_)
    : this(locked: json_['locked'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (locked != null) 'locked': locked!,
  };
}

/// Used by:
///
/// - connectors:v1 : ConnectorsLogConfig
/// - integrations:v1 : GoogleCloudConnectorsV1LogConfig
class $LogConfig {
  /// Enabled represents whether logging is enabled or not for a connection.
  ///
  /// Optional.
  core.bool? enabled;

  /// Log configuration level.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LOG_LEVEL_UNSPECIFIED" : Log level unspecified.
  /// - "ERROR" : Only error logs are enabled.
  /// - "INFO" : Info and error logs are enabled.
  /// - "DEBUG" : Debug and high verbosity logs are enabled.
  core.String? level;

  $LogConfig({this.enabled, this.level});

  $LogConfig.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        level: json_['level'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (level != null) 'level': level!,
  };
}

/// Used by:
///
/// - datamigration:v1 : LogFileDirectories
/// - datastream:v1 : LogFileDirectories
class $LogFileDirectories {
  /// Oracle directory for archived logs.
  ///
  /// Required.
  core.String? archivedLogDirectory;

  /// Oracle directory for online logs.
  ///
  /// Required.
  core.String? onlineLogDirectory;

  $LogFileDirectories({this.archivedLogDirectory, this.onlineLogDirectory});

  $LogFileDirectories.fromJson(core.Map json_)
    : this(
        archivedLogDirectory: json_['archivedLogDirectory'] as core.String?,
        onlineLogDirectory: json_['onlineLogDirectory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (archivedLogDirectory != null)
      'archivedLogDirectory': archivedLogDirectory!,
    if (onlineLogDirectory != null) 'onlineLogDirectory': onlineLogDirectory!,
  };
}

/// Used by:
///
/// - container:v1 : LoggingComponentConfig
/// - container:v1beta1 : LoggingComponentConfig
class $LoggingComponentConfig {
  /// Select components to collect logs.
  ///
  /// An empty set would disable all logging.
  core.List<core.String>? enableComponents;

  $LoggingComponentConfig({this.enableComponents});

  $LoggingComponentConfig.fromJson(core.Map json_)
    : this(
        enableComponents:
            (json_['enableComponents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableComponents != null) 'enableComponents': enableComponents!,
  };
}

/// Used by:
///
/// - datafusion:v1 : LoggingConfig
/// - datafusion:v1beta1 : LoggingConfig
class $LoggingConfig00 {
  /// Option to determine whether instance logs should be written to Cloud
  /// Logging.
  ///
  /// By default, instance logs are written to Cloud Logging.
  ///
  /// Optional.
  core.bool? instanceCloudLoggingDisabled;

  $LoggingConfig00({this.instanceCloudLoggingDisabled});

  $LoggingConfig00.fromJson(core.Map json_)
    : this(
        instanceCloudLoggingDisabled:
            json_['instanceCloudLoggingDisabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceCloudLoggingDisabled != null)
      'instanceCloudLoggingDisabled': instanceCloudLoggingDisabled!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2LoggingConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1LoggingConfig
class $LoggingConfig01 {
  /// Whether to log conversation events like CONVERSATION_STARTED to
  /// Stackdriver in the conversation project as JSON format ConversationEvent
  /// protos.
  core.bool? enableStackdriverLogging;

  $LoggingConfig01({this.enableStackdriverLogging});

  $LoggingConfig01.fromJson(core.Map json_)
    : this(
        enableStackdriverLogging:
            json_['enableStackdriverLogging'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableStackdriverLogging != null)
      'enableStackdriverLogging': enableStackdriverLogging!,
  };
}

/// Used by:
///
/// - container:v1 : LoggingVariantConfig
/// - container:v1beta1 : LoggingVariantConfig
class $LoggingVariantConfig {
  /// Logging variant deployed on nodes.
  /// Possible string values are:
  /// - "VARIANT_UNSPECIFIED" : Default value. This shouldn't be used.
  /// - "DEFAULT" : default logging variant.
  /// - "MAX_THROUGHPUT" : maximum logging throughput variant.
  core.String? variant;

  $LoggingVariantConfig({this.variant});

  $LoggingVariantConfig.fromJson(core.Map json_)
    : this(variant: json_['variant'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (variant != null) 'variant': variant!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1LogprobsResultCandidate
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1LogprobsResultCandidate
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1LogprobsResultCandidate
class $LogprobsResultCandidate {
  /// The candidate's log probability.
  core.double? logProbability;

  /// The candidate's token string value.
  core.String? token;

  /// The candidate's token id value.
  core.int? tokenId;

  $LogprobsResultCandidate({this.logProbability, this.token, this.tokenId});

  $LogprobsResultCandidate.fromJson(core.Map json_)
    : this(
        logProbability: (json_['logProbability'] as core.num?)?.toDouble(),
        token: json_['token'] as core.String?,
        tokenId: json_['tokenId'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (logProbability != null) 'logProbability': logProbability!,
    if (token != null) 'token': token!,
    if (tokenId != null) 'tokenId': tokenId!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2LongTextLimits
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaLongTextLimits
class $LongTextLimits {
  /// Maximum length allowed for a long text Field type.
  core.int? maxLength;

  /// Minimum length allowed for a long text Field type.
  core.int? minLength;

  $LongTextLimits({this.maxLength, this.minLength});

  $LongTextLimits.fromJson(core.Map json_)
    : this(
        maxLength: json_['maxLength'] as core.int?,
        minLength: json_['minLength'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxLength != null) 'maxLength': maxLength!,
    if (minLength != null) 'minLength': minLength!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LookbackWindow
/// - displayvideo:v3 : LookbackWindow
/// - displayvideo:v4 : LookbackWindow
class $LookbackWindow {
  /// Lookback window, in days, from the last time a given user clicked on one
  /// of your ads.
  core.int? clickDays;

  /// Lookback window, in days, from the last time a given user viewed one of
  /// your ads.
  core.int? impressionDays;

  $LookbackWindow({this.clickDays, this.impressionDays});

  $LookbackWindow.fromJson(core.Map json_)
    : this(
        clickDays: json_['clickDays'] as core.int?,
        impressionDays: json_['impressionDays'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clickDays != null) 'clickDays': clickDays!,
    if (impressionDays != null) 'impressionDays': impressionDays!,
  };
}

/// Used by:
///
/// - adsenseplatform:v1 : LookupAccountResponse
/// - adsenseplatform:v1alpha : LookupAccountResponse
class $LookupAccountResponse {
  /// The name of the Account Format: platforms/{platform}/accounts/{account_id}
  core.String? name;

  $LookupAccountResponse({this.name});

  $LookupAccountResponse.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : LookupInvoiceCurrencyResponse
/// - displayvideo:v3 : LookupInvoiceCurrencyResponse
/// - displayvideo:v4 : LookupInvoiceCurrencyResponse
class $LookupInvoiceCurrencyResponse {
  /// Currency used by the advertiser in ISO 4217 format.
  core.String? currencyCode;

  $LookupInvoiceCurrencyResponse({this.currencyCode});

  $LookupInvoiceCurrencyResponse.fromJson(core.Map json_)
    : this(currencyCode: json_['currencyCode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1LookupStudyRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1LookupStudyRequest
class $LookupStudyRequest {
  /// The user-defined display name of the Study
  ///
  /// Required.
  core.String? displayName;

  $LookupStudyRequest({this.displayName});

  $LookupStudyRequest.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - container:v1 : LustreCsiDriverConfig
/// - container:v1beta1 : LustreCsiDriverConfig
class $LustreCsiDriverConfig {
  /// If set to true, the Lustre CSI driver will install Lustre kernel modules
  /// using port 6988.
  core.bool? enableLegacyLustrePort;

  /// Whether the Lustre CSI driver is enabled for this cluster.
  core.bool? enabled;

  $LustreCsiDriverConfig({this.enableLegacyLustrePort, this.enabled});

  $LustreCsiDriverConfig.fromJson(core.Map json_)
    : this(
        enableLegacyLustrePort: json_['enableLegacyLustrePort'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableLegacyLustrePort != null)
      'enableLegacyLustrePort': enableLegacyLustrePort!,
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - alloydb:v1 : MachineConfig
/// - alloydb:v1alpha : MachineConfig
/// - alloydb:v1beta : MachineConfig
class $MachineConfig {
  /// The number of CPU's in the VM instance.
  core.int? cpuCount;

  /// Machine type of the VM instance.
  ///
  /// E.g. "n2-highmem-4", "n2-highmem-8", "c4a-highmem-4-lssd". cpu_count must
  /// match the number of vCPUs in the machine type.
  core.String? machineType;

  $MachineConfig({this.cpuCount, this.machineType});

  $MachineConfig.fromJson(core.Map json_)
    : this(
        cpuCount: json_['cpuCount'] as core.int?,
        machineType: json_['machineType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpuCount != null) 'cpuCount': cpuCount!,
    if (machineType != null) 'machineType': machineType!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : MachineImageParametersOverrides
/// - vmmigration:v1alpha1 : MachineImageParametersOverrides
class $MachineImageParametersOverrides {
  /// The machine type to create the MachineImage with.
  ///
  /// If empty, the service will choose a relevant machine type based on the
  /// information from the source image. For more information about machine
  /// types, please refer to
  /// https://cloud.google.com/compute/docs/machine-resource.
  ///
  /// Optional.
  core.String? machineType;

  $MachineImageParametersOverrides({this.machineType});

  $MachineImageParametersOverrides.fromJson(core.Map json_)
    : this(machineType: json_['machineType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineType != null) 'machineType': machineType!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MachineSeries
/// - migrationcenter:v1alpha1 : MachineSeries
class $MachineSeries {
  /// Code to identify a machine series.
  ///
  /// Consult this for more details on the available series for Compute Engine:
  /// https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison
  /// Consult this for more details on the available series for Google Cloud
  /// VMware Engine: https://cloud.google.com/vmware-engine/pricing
  core.String? code;

  $MachineSeries({this.code});

  $MachineSeries.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - ondemandscanning:v1 : Maintainer
/// - ondemandscanning:v1beta1 : Maintainer
class $Maintainer {
  core.String? email;
  core.String? kind;
  core.String? name;
  core.String? url;

  $Maintainer({this.email, this.kind, this.name, this.url});

  $Maintainer.fromJson(core.Map json_)
    : this(
        email: json_['email'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminMaintenanceConfig
/// - gkeonprem:v1 : BareMetalMaintenanceConfig
class $MaintenanceConfig {
  /// All IPv4 address from these ranges will be placed into maintenance mode.
  ///
  /// Nodes in maintenance mode will be cordoned and drained. When both of these
  /// are true, the "baremetal.cluster.gke.io/maintenance" annotation will be
  /// set on the node resource.
  ///
  /// Required.
  core.List<core.String>? maintenanceAddressCidrBlocks;

  $MaintenanceConfig({this.maintenanceAddressCidrBlocks});

  $MaintenanceConfig.fromJson(core.Map json_)
    : this(
        maintenanceAddressCidrBlocks:
            (json_['maintenanceAddressCidrBlocks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maintenanceAddressCidrBlocks != null)
      'maintenanceAddressCidrBlocks': maintenanceAddressCidrBlocks!,
  };
}

/// Used by:
///
/// - datafusion:v1 : MaintenanceEvent
/// - datafusion:v1beta1 : MaintenanceEvent
class $MaintenanceEvent {
  /// The end time of the maintenance event provided in
  /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
  ///
  /// Example: "2024-01-02T12:04:06-06:00" This field will be empty if the
  /// maintenance event is not yet complete.
  ///
  /// Output only.
  core.String? endTime;

  /// The start time of the maintenance event provided in
  /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
  ///
  /// Example: "2024-01-01T12:04:06-04:00"
  ///
  /// Output only.
  core.String? startTime;

  /// The state of the maintenance event.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The state of the maintenance event is unspecified.
  /// - "SCHEDULED" : The maintenance is scheduled but has not started.
  /// - "STARTED" : The maintenance has been started.
  /// - "COMPLETED" : The maintenance has been completed.
  core.String? state;

  $MaintenanceEvent({this.endTime, this.startTime, this.state});

  $MaintenanceEvent.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - container:v1 : MaintenanceExclusionOptions
/// - container:v1beta1 : MaintenanceExclusionOptions
class $MaintenanceExclusionOptions {
  /// Scope specifies the upgrade scope which upgrades are blocked by the
  /// exclusion.
  /// Possible string values are:
  /// - "NO_UPGRADES" : NO_UPGRADES excludes all upgrades, including patch
  /// upgrades and minor upgrades across control planes and nodes. This is the
  /// default exclusion behavior.
  /// - "NO_MINOR_UPGRADES" : NO_MINOR_UPGRADES excludes all minor upgrades for
  /// the cluster, only patches are allowed.
  /// - "NO_MINOR_OR_NODE_UPGRADES" : NO_MINOR_OR_NODE_UPGRADES excludes all
  /// minor upgrades for the cluster, and also exclude all node pool upgrades.
  /// Only control plane patches are allowed.
  core.String? scope;

  $MaintenanceExclusionOptions({this.scope});

  $MaintenanceExclusionOptions.fromJson(core.Map json_)
    : this(scope: json_['scope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - alloydb:v1 : MaintenanceSchedule
/// - alloydb:v1alpha : MaintenanceSchedule
/// - alloydb:v1beta : MaintenanceSchedule
class $MaintenanceSchedule00 {
  /// The scheduled start time for the maintenance.
  ///
  /// Output only.
  core.String? startTime;

  $MaintenanceSchedule00({this.startTime});

  $MaintenanceSchedule00.fromJson(core.Map json_)
    : this(startTime: json_['startTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - memcache:v1 : MaintenanceSchedule
/// - memcache:v1beta2 : MaintenanceSchedule
class $MaintenanceSchedule01 {
  /// The end time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? endTime;

  /// The deadline that the maintenance schedule start time can not go beyond,
  /// including reschedule.
  ///
  /// Output only.
  core.String? scheduleDeadlineTime;

  /// The start time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? startTime;

  $MaintenanceSchedule01({
    this.endTime,
    this.scheduleDeadlineTime,
    this.startTime,
  });

  $MaintenanceSchedule01.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        scheduleDeadlineTime: json_['scheduleDeadlineTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (scheduleDeadlineTime != null)
      'scheduleDeadlineTime': scheduleDeadlineTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - redis:v1 : MaintenanceSchedule
/// - redis:v1beta1 : MaintenanceSchedule
class $MaintenanceSchedule02 {
  /// If the scheduled maintenance can be rescheduled, default is true.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? canReschedule;

  /// The end time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? endTime;

  /// The deadline that the maintenance schedule start time can not go beyond,
  /// including reschedule.
  ///
  /// Output only.
  core.String? scheduleDeadlineTime;

  /// The start time of any upcoming scheduled maintenance for this instance.
  ///
  /// Output only.
  core.String? startTime;

  $MaintenanceSchedule02({
    this.canReschedule,
    this.endTime,
    this.scheduleDeadlineTime,
    this.startTime,
  });

  $MaintenanceSchedule02.fromJson(core.Map json_)
    : this(
        canReschedule: json_['canReschedule'] as core.bool?,
        endTime: json_['endTime'] as core.String?,
        scheduleDeadlineTime: json_['scheduleDeadlineTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canReschedule != null) 'canReschedule': canReschedule!,
    if (endTime != null) 'endTime': endTime!,
    if (scheduleDeadlineTime != null)
      'scheduleDeadlineTime': scheduleDeadlineTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - metastore:v1 : MaintenanceWindow
/// - metastore:v1alpha : MaintenanceWindow
/// - metastore:v1beta : MaintenanceWindow
class $MaintenanceWindow00 {
  /// The day of week, when the window starts.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DAY_OF_WEEK_UNSPECIFIED" : The day of the week is unspecified.
  /// - "MONDAY" : Monday
  /// - "TUESDAY" : Tuesday
  /// - "WEDNESDAY" : Wednesday
  /// - "THURSDAY" : Thursday
  /// - "FRIDAY" : Friday
  /// - "SATURDAY" : Saturday
  /// - "SUNDAY" : Sunday
  core.String? dayOfWeek;

  /// The hour of day (0-23) when the window starts.
  ///
  /// Optional.
  core.int? hourOfDay;

  $MaintenanceWindow00({this.dayOfWeek, this.hourOfDay});

  $MaintenanceWindow00.fromJson(core.Map json_)
    : this(
        dayOfWeek: json_['dayOfWeek'] as core.String?,
        hourOfDay: json_['hourOfDay'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dayOfWeek != null) 'dayOfWeek': dayOfWeek!,
    if (hourOfDay != null) 'hourOfDay': hourOfDay!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : MaintenanceWindow
/// - sqladmin:v1beta4 : MaintenanceWindow
class $MaintenanceWindow01 {
  /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
  /// `SATURDAY`, or `SUNDAY`.
  ///
  /// Specify in the UTC time zone. Returned in output as an integer, 1 to 7,
  /// where `1` equals Monday.
  core.int? day;

  /// Hour of day - 0 to 23.
  ///
  /// Specify in the UTC time zone.
  core.int? hour;

  /// This is always `sql#maintenanceWindow`.
  core.String? kind;

  /// Maintenance timing settings: `canary`, `stable`, or `week5`.
  ///
  /// For more information, see
  /// [About maintenance on Cloud SQL instances](https://cloud.google.com/sql/docs/mysql/maintenance).
  /// Possible string values are:
  /// - "SQL_UPDATE_TRACK_UNSPECIFIED" : This is an unknown maintenance timing
  /// preference.
  /// - "canary" : For an instance with a scheduled maintenance window, this
  /// maintenance timing indicates that the maintenance update is scheduled 7 to
  /// 14 days after the notification is sent out. Also referred to as `Week 1`
  /// (Console) and `preview` (gcloud CLI).
  /// - "stable" : For an instance with a scheduled maintenance window, this
  /// maintenance timing indicates that the maintenance update is scheduled 15
  /// to 21 days after the notification is sent out. Also referred to as `Week
  /// 2` (Console) and `production` (gcloud CLI).
  /// - "week5" : For instance with a scheduled maintenance window, this
  /// maintenance timing indicates that the maintenance update is scheduled 35
  /// to 42 days after the notification is sent out.
  core.String? updateTrack;

  $MaintenanceWindow01({this.day, this.hour, this.kind, this.updateTrack});

  $MaintenanceWindow01.fromJson(core.Map json_)
    : this(
        day: json_['day'] as core.int?,
        hour: json_['hour'] as core.int?,
        kind: json_['kind'] as core.String?,
        updateTrack: json_['updateTrack'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (day != null) 'day': day!,
    if (hour != null) 'hour': hour!,
    if (kind != null) 'kind': kind!,
    if (updateTrack != null) 'updateTrack': updateTrack!,
  };
}

/// Used by:
///
/// - redis:v1 : ManagedBackupSource
/// - redis:v1beta1 : ManagedBackupSource
class $ManagedBackupSource {
  /// Example:
  /// //redis.googleapis.com/projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}
  /// A shorter version (without the prefix) of the backup name is also
  /// supported, like
  /// projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup_id}
  /// In this case, it assumes the backup is under redis.googleapis.com.
  ///
  /// Optional.
  core.String? backup;

  $ManagedBackupSource({this.backup});

  $ManagedBackupSource.fromJson(core.Map json_)
    : this(backup: json_['backup'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (backup != null) 'backup': backup!,
  };
}

/// Used by:
///
/// - appengine:v1 : ManagedCertificate
/// - appengine:v1beta : ManagedCertificate
class $ManagedCertificate {
  /// Time at which the certificate was last renewed.
  ///
  /// The renewal process is fully managed. Certificate renewal will
  /// automatically occur before the certificate expires. Renewal errors can be
  /// tracked via ManagementStatus.@OutputOnly
  core.String? lastRenewalTime;

  /// Status of certificate management.
  ///
  /// Refers to the most recent certificate acquisition or renewal
  /// attempt.@OutputOnly
  /// Possible string values are:
  /// - "MANAGEMENT_STATUS_UNSPECIFIED"
  /// - "OK" : Certificate was successfully obtained and inserted into the
  /// serving system.
  /// - "PENDING" : Certificate is under active attempts to acquire or renew.
  /// - "FAILED_RETRYING_NOT_VISIBLE" : Most recent renewal failed due to an
  /// invalid DNS setup and will be retried. Renewal attempts will continue to
  /// fail until the certificate domain's DNS configuration is fixed. The last
  /// successfully provisioned certificate may still be serving.
  /// - "FAILED_PERMANENT" : All renewal attempts have been exhausted, likely
  /// due to an invalid DNS setup.
  /// - "FAILED_RETRYING_CAA_FORBIDDEN" : Most recent renewal failed due to an
  /// explicit CAA record that does not include one of the in-use CAs (Google CA
  /// and Let's Encrypt). Renewals will continue to fail until the CAA is
  /// reconfigured. The last successfully provisioned certificate may still be
  /// serving.
  /// - "FAILED_RETRYING_CAA_CHECKING" : Most recent renewal failed due to a CAA
  /// retrieval failure. This means that the domain's DNS provider does not
  /// properly handle CAA records, failing requests for CAA records when no CAA
  /// records are defined. Renewals will continue to fail until the DNS provider
  /// is changed or a CAA record is added for the given domain. The last
  /// successfully provisioned certificate may still be serving.
  core.String? status;

  $ManagedCertificate({this.lastRenewalTime, this.status});

  $ManagedCertificate.fromJson(core.Map json_)
    : this(
        lastRenewalTime: json_['lastRenewalTime'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastRenewalTime != null) 'lastRenewalTime': lastRenewalTime!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:alpha : ManagedInstanceAllInstancesConfig
/// - compute:beta : ManagedInstanceAllInstancesConfig
class $ManagedInstanceAllInstancesConfig {
  /// Current all-instances configuration revision.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? revision;

  $ManagedInstanceAllInstancesConfig({this.revision});

  $ManagedInstanceAllInstancesConfig.fromJson(core.Map json_)
    : this(revision: json_['revision'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (revision != null) 'revision': revision!,
  };
}

/// Used by:
///
/// - compute:beta : ManagedInstanceInstanceHealth
/// - compute:v1 : ManagedInstanceInstanceHealth
class $ManagedInstanceInstanceHealth {
  /// The current detailed instance health state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DRAINING" : The instance is being drained. The existing connections to
  /// the instance have time to complete, but the new ones are being refused.
  /// - "HEALTHY" : The instance is reachable i.e. a connection to the
  /// application health checking endpoint can be established, and conforms to
  /// the requirements defined by the health check.
  /// - "TIMEOUT" : The instance is unreachable i.e. a connection to the
  /// application health checking endpoint cannot be established, or the server
  /// does not respond within the specified timeout.
  /// - "UNHEALTHY" : The instance is reachable, but does not conform to the
  /// requirements defined by the health check.
  /// - "UNKNOWN" : The health checking system is aware of the instance but its
  /// health is not known at the moment.
  core.String? detailedHealthState;

  /// The URL for the health check that verifies whether the instance is
  /// healthy.
  ///
  /// Output only.
  core.String? healthCheck;

  $ManagedInstanceInstanceHealth({this.detailedHealthState, this.healthCheck});

  $ManagedInstanceInstanceHealth.fromJson(core.Map json_)
    : this(
        detailedHealthState: json_['detailedHealthState'] as core.String?,
        healthCheck: json_['healthCheck'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (detailedHealthState != null)
      'detailedHealthState': detailedHealthState!,
    if (healthCheck != null) 'healthCheck': healthCheck!,
  };
}

/// Used by:
///
/// - compute:alpha : ManagedInstanceLastAttempt
/// - compute:beta : ManagedInstanceLastAttempt
/// - compute:v1 : ManagedInstanceLastAttempt
class $ManagedInstanceLastAttempt {
  /// Encountered errors during the last attempt to create or delete the
  /// instance.
  ///
  /// Output only.
  ManagedInstanceLastAttemptErrors? errors;

  $ManagedInstanceLastAttempt({this.errors});

  $ManagedInstanceLastAttempt.fromJson(core.Map json_)
    : this(
        errors:
            json_.containsKey('errors')
                ? ManagedInstanceLastAttemptErrors.fromJson(
                  json_['errors'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errors != null) 'errors': errors!,
  };
}

/// Used by:
///
/// - compute:alpha : ManagedInstanceVersion
/// - compute:beta : ManagedInstanceVersion
/// - compute:v1 : ManagedInstanceVersion
class $ManagedInstanceVersion {
  /// The intended template of the instance.
  ///
  /// This field is empty when current_action is one of { DELETING, ABANDONING
  /// }.
  ///
  /// Output only.
  core.String? instanceTemplate;

  /// Name of the version.
  ///
  /// Output only.
  core.String? name;

  $ManagedInstanceVersion({this.instanceTemplate, this.name});

  $ManagedInstanceVersion.fromJson(core.Map json_)
    : this(
        instanceTemplate: json_['instanceTemplate'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZoneCloudLoggingConfig
/// - dns:v1beta2 : ManagedZoneCloudLoggingConfig
class $ManagedZoneCloudLoggingConfig {
  /// If set, enable query logging for this ManagedZone.
  ///
  /// False by default, making logging opt-in.
  core.bool? enableLogging;
  core.String? kind;

  $ManagedZoneCloudLoggingConfig({this.enableLogging, this.kind});

  $ManagedZoneCloudLoggingConfig.fromJson(core.Map json_)
    : this(
        enableLogging: json_['enableLogging'] as core.bool?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableLogging != null) 'enableLogging': enableLogging!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZoneForwardingConfigNameServerTarget
/// - dns:v1beta2 : ManagedZoneForwardingConfigNameServerTarget
class $ManagedZoneForwardingConfigNameServerTarget {
  /// Fully qualified domain name for the forwarding target.
  core.String? domainName;

  /// Forwarding path for this NameServerTarget.
  ///
  /// If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on
  /// IP address ranges; that is, RFC1918 addresses go to the VPC network,
  /// non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS
  /// always sends queries through the VPC network for this target.
  /// Possible string values are:
  /// - "default" : Cloud DNS makes forwarding decisions based on address
  /// ranges; that is, RFC1918 addresses forward to the target through the VPC
  /// and non-RFC1918 addresses forward to the target through the internet
  /// - "private" : Cloud DNS always forwards to this target through the VPC.
  core.String? forwardingPath;

  /// IPv4 address of a target name server.
  core.String? ipv4Address;

  /// IPv6 address of a target name server.
  ///
  /// Does not accept both fields (ipv4 & ipv6) being populated. Public preview
  /// as of November 2022.
  core.String? ipv6Address;
  core.String? kind;

  $ManagedZoneForwardingConfigNameServerTarget({
    this.domainName,
    this.forwardingPath,
    this.ipv4Address,
    this.ipv6Address,
    this.kind,
  });

  $ManagedZoneForwardingConfigNameServerTarget.fromJson(core.Map json_)
    : this(
        domainName: json_['domainName'] as core.String?,
        forwardingPath: json_['forwardingPath'] as core.String?,
        ipv4Address: json_['ipv4Address'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domainName != null) 'domainName': domainName!,
    if (forwardingPath != null) 'forwardingPath': forwardingPath!,
    if (ipv4Address != null) 'ipv4Address': ipv4Address!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZonePeeringConfigTargetNetwork
/// - dns:v1beta2 : ManagedZonePeeringConfigTargetNetwork
class $ManagedZonePeeringConfigTargetNetwork {
  /// The time at which the zone was deactivated, in RFC 3339 date-time format.
  ///
  /// An empty string indicates that the peering connection is active. The
  /// producer network can deactivate a zone. The zone is automatically
  /// deactivated if the producer network that the zone targeted is deleted.
  /// Output only.
  core.String? deactivateTime;
  core.String? kind;

  /// The fully qualified URL of the VPC network to forward queries to.
  ///
  /// This should be formatted like
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
  core.String? networkUrl;

  $ManagedZonePeeringConfigTargetNetwork({
    this.deactivateTime,
    this.kind,
    this.networkUrl,
  });

  $ManagedZonePeeringConfigTargetNetwork.fromJson(core.Map json_)
    : this(
        deactivateTime: json_['deactivateTime'] as core.String?,
        kind: json_['kind'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deactivateTime != null) 'deactivateTime': deactivateTime!,
    if (kind != null) 'kind': kind!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZonePrivateVisibilityConfigGKECluster
/// - dns:v1beta2 : ManagedZonePrivateVisibilityConfigGKECluster
class $ManagedZonePrivateVisibilityConfigGKECluster {
  /// The resource name of the cluster to bind this ManagedZone to.
  ///
  /// This should be specified in the format like: projects / * /locations / *
  /// /clusters / * . This is referenced from GKE
  /// projects.locations.clusters.get API:
  /// https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/get
  core.String? gkeClusterName;
  core.String? kind;

  $ManagedZonePrivateVisibilityConfigGKECluster({
    this.gkeClusterName,
    this.kind,
  });

  $ManagedZonePrivateVisibilityConfigGKECluster.fromJson(core.Map json_)
    : this(
        gkeClusterName: json_['gkeClusterName'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gkeClusterName != null) 'gkeClusterName': gkeClusterName!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZonePrivateVisibilityConfigNetwork
/// - dns:v1beta2 : ManagedZonePrivateVisibilityConfigNetwork
class $ManagedZonePrivateVisibilityConfigNetwork {
  core.String? kind;

  /// The fully qualified URL of the VPC network to bind to.
  ///
  /// Format this URL like
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
  core.String? networkUrl;

  $ManagedZonePrivateVisibilityConfigNetwork({this.kind, this.networkUrl});

  $ManagedZonePrivateVisibilityConfigNetwork.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZoneReverseLookupConfig
/// - dns:v1beta2 : ManagedZoneReverseLookupConfig
class $ManagedZoneReverseLookupConfig {
  core.String? kind;

  $ManagedZoneReverseLookupConfig({this.kind});

  $ManagedZoneReverseLookupConfig.fromJson(core.Map json_)
    : this(kind: json_['kind'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : ManagedZoneServiceDirectoryConfigNamespace
/// - dns:v1beta2 : ManagedZoneServiceDirectoryConfigNamespace
class $ManagedZoneServiceDirectoryConfigNamespace {
  /// The time that the namespace backing this zone was deleted; an empty string
  /// if it still exists.
  ///
  /// This is in RFC3339 text format. Output only.
  core.String? deletionTime;
  core.String? kind;

  /// The fully qualified URL of the namespace associated with the zone.
  ///
  /// Format must be
  /// `https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace}`
  core.String? namespaceUrl;

  $ManagedZoneServiceDirectoryConfigNamespace({
    this.deletionTime,
    this.kind,
    this.namespaceUrl,
  });

  $ManagedZoneServiceDirectoryConfigNamespace.fromJson(core.Map json_)
    : this(
        deletionTime: json_['deletionTime'] as core.String?,
        kind: json_['kind'] as core.String?,
        namespaceUrl: json_['namespaceUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deletionTime != null) 'deletionTime': deletionTime!,
    if (kind != null) 'kind': kind!,
    if (namespaceUrl != null) 'namespaceUrl': namespaceUrl!,
  };
}

/// Used by:
///
/// - domains:v1 : ManagementSettings
/// - domains:v1alpha2 : ManagementSettings
/// - domains:v1beta1 : ManagementSettings
class $ManagementSettings {
  /// The actual transfer lock state for this `Registration`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TRANSFER_LOCK_STATE_UNSPECIFIED" : The state is unspecified.
  /// - "UNLOCKED" : The domain is unlocked and can be transferred to another
  /// registrar.
  /// - "LOCKED" : The domain is locked and cannot be transferred to another
  /// registrar.
  core.String? effectiveTransferLockState;

  /// The desired renewal method for this `Registration`.
  ///
  /// The actual `renewal_method` is automatically updated to reflect this
  /// choice. If unset or equal to `RENEWAL_METHOD_UNSPECIFIED`, the actual
  /// `renewalMethod` is treated as if it were set to `AUTOMATIC_RENEWAL`. You
  /// cannot use `RENEWAL_DISABLED` during resource creation, and you can update
  /// the renewal status only when the `Registration` resource has state
  /// `ACTIVE` or `SUSPENDED`. When `preferred_renewal_method` is set to
  /// `AUTOMATIC_RENEWAL`, the actual `renewal_method` can be set to
  /// `RENEWAL_DISABLED` in case of problems with the billing account or
  /// reported domain abuse. In such cases, check the `issues` field on the
  /// `Registration`. After the problem is resolved, the `renewal_method` is
  /// automatically updated to `preferred_renewal_method` in a few hours.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "RENEWAL_METHOD_UNSPECIFIED" : The renewal method is undefined.
  /// - "AUTOMATIC_RENEWAL" : The domain is automatically renewed each year.
  /// - "MANUAL_RENEWAL" : Deprecated: For more information, see
  /// [Cloud Domains feature deprecation](https://cloud.google.com/domains/docs/deprecations/feature-deprecations).
  /// This option was never used. Use `RENEWAL_DISABLED` instead.
  /// - "RENEWAL_DISABLED" : The domain won't be renewed and will expire at its
  /// expiration time.
  core.String? preferredRenewalMethod;

  /// The actual renewal method for this `Registration`.
  ///
  /// When `preferred_renewal_method` is set to `AUTOMATIC_RENEWAL`, the actual
  /// `renewal_method` can be equal to `RENEWAL_DISABLED`for example, when
  /// there are problems with the billing account or reported domain abuse. In
  /// such cases, check the `issues` field on the `Registration`. After the
  /// problem is resolved, the `renewal_method` is automatically updated to
  /// `preferred_renewal_method` in a few hours.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RENEWAL_METHOD_UNSPECIFIED" : The renewal method is undefined.
  /// - "AUTOMATIC_RENEWAL" : The domain is automatically renewed each year.
  /// - "MANUAL_RENEWAL" : Deprecated: For more information, see
  /// [Cloud Domains feature deprecation](https://cloud.google.com/domains/docs/deprecations/feature-deprecations).
  /// This option was never used. Use `RENEWAL_DISABLED` instead.
  /// - "RENEWAL_DISABLED" : The domain won't be renewed and will expire at its
  /// expiration time.
  core.String? renewalMethod;

  /// This is the desired transfer lock state for this `Registration`.
  ///
  /// A transfer lock controls whether the domain can be transferred to another
  /// registrar. The transfer lock state of the domain is returned in the
  /// `effective_transfer_lock_state` property. The transfer lock state values
  /// might be different for the following reasons: * `transfer_lock_state` was
  /// updated only a short time ago. * Domains with the
  /// `TRANSFER_LOCK_UNSUPPORTED_BY_REGISTRY` state are in the list of
  /// `domain_properties`. These domains are always in the `UNLOCKED` state.
  /// Possible string values are:
  /// - "TRANSFER_LOCK_STATE_UNSPECIFIED" : The state is unspecified.
  /// - "UNLOCKED" : The domain is unlocked and can be transferred to another
  /// registrar.
  /// - "LOCKED" : The domain is locked and cannot be transferred to another
  /// registrar.
  core.String? transferLockState;

  $ManagementSettings({
    this.effectiveTransferLockState,
    this.preferredRenewalMethod,
    this.renewalMethod,
    this.transferLockState,
  });

  $ManagementSettings.fromJson(core.Map json_)
    : this(
        effectiveTransferLockState:
            json_['effectiveTransferLockState'] as core.String?,
        preferredRenewalMethod: json_['preferredRenewalMethod'] as core.String?,
        renewalMethod: json_['renewalMethod'] as core.String?,
        transferLockState: json_['transferLockState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (effectiveTransferLockState != null)
      'effectiveTransferLockState': effectiveTransferLockState!,
    if (preferredRenewalMethod != null)
      'preferredRenewalMethod': preferredRenewalMethod!,
    if (renewalMethod != null) 'renewalMethod': renewalMethod!,
    if (transferLockState != null) 'transferLockState': transferLockState!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ManualBatchTuningParameters
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ManualBatchTuningParameters
class $ManualBatchTuningParameters {
  /// The number of the records (e.g. instances) of the operation given in each
  /// batch to a machine replica.
  ///
  /// Machine type, and size of a single record should be considered when
  /// setting this parameter, higher value speeds up the batch operation's
  /// execution, but too high value will result in a whole batch not fitting in
  /// a machine's memory, and the whole operation will fail. The default value
  /// is 64.
  ///
  /// Immutable.
  core.int? batchSize;

  $ManualBatchTuningParameters({this.batchSize});

  $ManualBatchTuningParameters.fromJson(core.Map json_)
    : this(batchSize: json_['batchSize'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchSize != null) 'batchSize': batchSize!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminManualLbConfig
/// - gkeonprem:v1 : BareMetalManualLbConfig
class $ManualLbConfig {
  /// Whether manual load balancing is enabled.
  core.bool? enabled;

  $ManualLbConfig({this.enabled});

  $ManualLbConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - appengine:v1 : ManualScaling
/// - appengine:v1beta : ManualScaling
class $ManualScaling {
  /// Number of instances to assign to the service at the start.
  ///
  /// This number can later be altered by using the Modules API
  /// (https://cloud.google.com/appengine/docs/python/modules/functions)
  /// set_num_instances() function.
  core.int? instances;

  $ManualScaling({this.instances});

  $ManualScaling.fromJson(core.Map json_)
    : this(instances: json_['instances'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1MarkInsightAcceptedRequest
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1MarkInsightAcceptedRequest
class $MarkInsightAcceptedRequest {
  /// Fingerprint of the Insight.
  ///
  /// Provides optimistic locking.
  ///
  /// Required.
  core.String? etag;

  /// State properties user wish to include with this state.
  ///
  /// Full replace of the current state_metadata.
  ///
  /// Optional.
  core.Map<core.String, core.String>? stateMetadata;

  $MarkInsightAcceptedRequest({this.etag, this.stateMetadata});

  $MarkInsightAcceptedRequest.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        stateMetadata: (json_['stateMetadata']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (stateMetadata != null) 'stateMetadata': stateMetadata!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1MarkRecommendationDismissedRequest
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1MarkRecommendationDismissedRequest
class $MarkRecommendationDismissedRequest {
  /// Fingerprint of the Recommendation.
  ///
  /// Provides optimistic locking.
  core.String? etag;

  $MarkRecommendationDismissedRequest({this.etag});

  $MarkRecommendationDismissedRequest.fromJson(core.Map json_)
    : this(etag: json_['etag'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial
/// - containeranalysis:v1 : Material
/// - ondemandscanning:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial
/// - ondemandscanning:v1 : Material
/// - ondemandscanning:v1beta1 : GrafeasV1SlsaProvenanceZeroTwoSlsaMaterial
/// - ondemandscanning:v1beta1 : Material
class $Material {
  core.Map<core.String, core.String>? digest;
  core.String? uri;

  $Material({this.digest, this.uri});

  $Material.fromJson(core.Map json_)
    : this(
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : MavenRepositoryConfig
/// - artifactregistry:v1beta2 : MavenRepositoryConfig
class $MavenRepositoryConfig {
  /// The repository with this flag will allow publishing the same snapshot
  /// versions.
  core.bool? allowSnapshotOverwrites;

  /// Version policy defines the versions that the registry will accept.
  /// Possible string values are:
  /// - "VERSION_POLICY_UNSPECIFIED" : VERSION_POLICY_UNSPECIFIED - the version
  /// policy is not defined. When the version policy is not defined, no
  /// validation is performed for the versions.
  /// - "RELEASE" : RELEASE - repository will accept only Release versions.
  /// - "SNAPSHOT" : SNAPSHOT - repository will accept only Snapshot versions.
  core.String? versionPolicy;

  $MavenRepositoryConfig({this.allowSnapshotOverwrites, this.versionPolicy});

  $MavenRepositoryConfig.fromJson(core.Map json_)
    : this(
        allowSnapshotOverwrites: json_['allowSnapshotOverwrites'] as core.bool?,
        versionPolicy: json_['versionPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowSnapshotOverwrites != null)
      'allowSnapshotOverwrites': allowSnapshotOverwrites!,
    if (versionPolicy != null) 'versionPolicy': versionPolicy!,
  };
}

/// Used by:
///
/// - container:v1 : MaxPodsConstraint
/// - container:v1beta1 : MaxPodsConstraint
class $MaxPodsConstraint {
  /// Constraint enforced on the max num of pods per node.
  core.String? maxPodsPerNode;

  $MaxPodsConstraint({this.maxPodsPerNode});

  $MaxPodsConstraint.fromJson(core.Map json_)
    : this(maxPodsPerNode: json_['maxPodsPerNode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxPodsPerNode != null) 'maxPodsPerNode': maxPodsPerNode!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : MaximizeSpendBidStrategy
/// - displayvideo:v3 : MaximizeSpendBidStrategy
/// - displayvideo:v4 : MaximizeSpendBidStrategy
class $MaximizeSpendBidStrategy {
  /// The ID of the Custom Bidding Algorithm used by this strategy.
  ///
  /// Only applicable when performance_goal_type is set to
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO`. Assigning a custom
  /// bidding algorithm that uses floodlight activities not identified in
  /// floodlightActivityConfigs will return an error.
  core.String? customBiddingAlgorithmId;

  /// The maximum average CPM that may be bid, in micros of the advertiser's
  /// currency.
  ///
  /// Must be greater than or equal to a billable unit of the given currency.
  /// For example, 1500000 represents 1.5 standard units of the currency.
  core.String? maxAverageCpmBidAmountMicros;

  /// The type of the performance goal that the bidding strategy tries to
  /// minimize while spending the full budget.
  ///
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM` is not supported for
  /// this strategy.
  ///
  /// Required.
  /// Possible string values are:
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_UNSPECIFIED" : Type value is not
  /// specified or is unknown in this version.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPA" : Cost per action.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPC" : Cost per click.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM" : Viewable CPM.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO" : Custom bidding
  /// algorithm.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CIVA" : Completed inview and
  /// audible views.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_IVO_TEN" : Inview time over 10
  /// secs views.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_AV_VIEWED" : Viewable
  /// impressions.
  core.String? performanceGoalType;

  /// Whether the strategy takes deal floor prices into account.
  core.bool? raiseBidForDeals;

  $MaximizeSpendBidStrategy({
    this.customBiddingAlgorithmId,
    this.maxAverageCpmBidAmountMicros,
    this.performanceGoalType,
    this.raiseBidForDeals,
  });

  $MaximizeSpendBidStrategy.fromJson(core.Map json_)
    : this(
        customBiddingAlgorithmId:
            json_['customBiddingAlgorithmId'] as core.String?,
        maxAverageCpmBidAmountMicros:
            json_['maxAverageCpmBidAmountMicros'] as core.String?,
        performanceGoalType: json_['performanceGoalType'] as core.String?,
        raiseBidForDeals: json_['raiseBidForDeals'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customBiddingAlgorithmId != null)
      'customBiddingAlgorithmId': customBiddingAlgorithmId!,
    if (maxAverageCpmBidAmountMicros != null)
      'maxAverageCpmBidAmountMicros': maxAverageCpmBidAmountMicros!,
    if (performanceGoalType != null)
      'performanceGoalType': performanceGoalType!,
    if (raiseBidForDeals != null) 'raiseBidForDeals': raiseBidForDeals!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : MeasurementConfig
/// - displayvideo:v3 : MeasurementConfig
/// - displayvideo:v4 : MeasurementConfig
class $MeasurementConfig {
  /// Whether or not to report DV360 cost to CM360.
  core.bool? dv360ToCmCostReportingEnabled;

  /// Whether or not to include DV360 data in CM360 data transfer reports.
  core.bool? dv360ToCmDataSharingEnabled;

  $MeasurementConfig({
    this.dv360ToCmCostReportingEnabled,
    this.dv360ToCmDataSharingEnabled,
  });

  $MeasurementConfig.fromJson(core.Map json_)
    : this(
        dv360ToCmCostReportingEnabled:
            json_['dv360ToCmCostReportingEnabled'] as core.bool?,
        dv360ToCmDataSharingEnabled:
            json_['dv360ToCmDataSharingEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dv360ToCmCostReportingEnabled != null)
      'dv360ToCmCostReportingEnabled': dv360ToCmCostReportingEnabled!,
    if (dv360ToCmDataSharingEnabled != null)
      'dv360ToCmDataSharingEnabled': dv360ToCmDataSharingEnabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MeasurementMetric
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MeasurementMetric
class $MeasurementMetric {
  /// The ID of the Metric.
  ///
  /// The Metric should be defined in StudySpec's Metrics.
  ///
  /// Output only.
  core.String? metricId;

  /// The value for this metric.
  ///
  /// Output only.
  core.double? value;

  $MeasurementMetric({this.metricId, this.value});

  $MeasurementMetric.fromJson(core.Map json_)
    : this(
        metricId: json_['metricId'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricId != null) 'metricId': metricId!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaMeasurementProtocolSecret
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaMeasurementProtocolSecret
class $MeasurementProtocolSecret {
  /// Human-readable display name for this secret.
  ///
  /// Required.
  core.String? displayName;

  /// Resource name of this secret.
  ///
  /// This secret may be a child of any type of stream. Format:
  /// properties/{property}/dataStreams/{dataStream}/measurementProtocolSecrets/{measurementProtocolSecret}
  ///
  /// Output only.
  core.String? name;

  /// The measurement protocol secret value.
  ///
  /// Pass this value to the api_secret field of the Measurement Protocol API
  /// when sending hits to this secret's parent property.
  ///
  /// Output only.
  core.String? secretValue;

  $MeasurementProtocolSecret({this.displayName, this.name, this.secretValue});

  $MeasurementProtocolSecret.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        secretValue: json_['secretValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (secretValue != null) 'secretValue': secretValue!,
  };
}

/// Used by:
///
/// - chat:v1 : Media
/// - cloudsearch:v1 : Media
/// - displayvideo:v2 : GoogleBytestreamMedia
/// - displayvideo:v3 : GoogleBytestreamMedia
/// - displayvideo:v4 : GoogleBytestreamMedia
class $Media {
  /// Name of the media resource.
  core.String? resourceName;

  $Media({this.resourceName});

  $Media.fromJson(core.Map json_)
    : this(resourceName: json_['resourceName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceName != null) 'resourceName': resourceName!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1MediaInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaMediaInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaMediaInfo
class $MediaInfo {
  /// The media progress time in seconds, if applicable.
  ///
  /// For example, if the end user has finished 90 seconds of a playback video,
  /// then MediaInfo.media_progress_duration.seconds should be set to 90.
  core.String? mediaProgressDuration;

  /// Media progress should be computed using only the media_progress_duration
  /// relative to the media total length.
  ///
  /// This value must be between `[0, 1.0]` inclusive. If this is not a playback
  /// or the progress cannot be computed (e.g. ongoing livestream), this field
  /// should be unset.
  core.double? mediaProgressPercentage;

  $MediaInfo({this.mediaProgressDuration, this.mediaProgressPercentage});

  $MediaInfo.fromJson(core.Map json_)
    : this(
        mediaProgressDuration: json_['mediaProgressDuration'] as core.String?,
        mediaProgressPercentage:
            (json_['mediaProgressPercentage'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mediaProgressDuration != null)
      'mediaProgressDuration': mediaProgressDuration!,
    if (mediaProgressPercentage != null)
      'mediaProgressPercentage': mediaProgressPercentage!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : MediaPlanner
/// - authorizedbuyersmarketplace:v1alpha : MediaPlanner
class $MediaPlanner {
  /// Account ID of the media planner.
  ///
  /// Output only.
  core.String? accountId;

  $MediaPlanner({this.accountId});

  $MediaPlanner.fromJson(core.Map json_)
    : this(accountId: json_['accountId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (accountId != null) 'accountId': accountId!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : ApiservingMediaRequestInfo
/// - walletobjects:v1 : MediaRequestInfo
class $MediaRequestInfo {
  /// The number of current bytes uploaded or downloaded.
  core.String? currentBytes;

  /// Data to be copied to backend requests.
  ///
  /// Custom data is returned to Scotty in the agent_state field, which Scotty
  /// will then provide in subsequent upload notifications.
  core.String? customData;

  /// Set if the http request info is diff encoded.
  ///
  /// The value of this field is the version number of the base revision. This
  /// is corresponding to Apiary's mediaDiffObjectVersion
  /// (//depot/google3/java/com/google/api/server/media/variable/DiffObjectVersionVariable.java).
  /// See go/esf-scotty-diff-upload for more information.
  core.String? diffObjectVersion;

  /// The existence of the final_status field indicates that this is the last
  /// call to the agent for this request_id.
  ///
  /// http://google3/uploader/agent/scotty_agent.proto?l=737&rcl=347601929
  core.int? finalStatus;

  /// The type of notification received from Scotty.
  /// Possible string values are:
  /// - "START" : Such requests signals the start of a request containing media
  /// upload. Only the media field(s) in the inserted/updated resource are set.
  /// The response should either return an error or succeed. On success,
  /// responses don't need to contain anything.
  /// - "PROGRESS" : Such requests signals that the upload has progressed and
  /// that the backend might want to access the media file specified in relevant
  /// fields in the resource. Only the media field(s) in the inserted/updated
  /// resource are set. The response should either return an error or succeed.
  /// On success, responses don't need to contain anything.
  /// - "END" : Such requests signals the end of a request containing media
  /// upload. END should be handled just like normal Insert/Upload requests,
  /// that is, they should process the request and return a complete resource in
  /// the response. Pointers to media data (a GFS path usually) appear in the
  /// relevant fields in the inserted/updated resource. See gdata.Media in
  /// data.proto.
  /// - "RESPONSE_SENT" : Such requests occur after an END and signal that the
  /// response has been sent back to the client. RESPONSE_SENT is only sent to
  /// the backend if it is configured to receive them. The response does not
  /// need to contain anything.
  /// - "ERROR" : Such requests indicate that an error occurred while processing
  /// the request. ERROR is only sent to the backend if it is configured to
  /// receive them. It is not guaranteed that all errors will result in this
  /// notification to the backend, even if the backend requests them. Since
  /// these requests are just for informational purposes, the response does not
  /// need to contain anything.
  core.String? notificationType;

  /// The Scotty request ID.
  core.String? requestId;

  /// The partition of the Scotty server handling this request.
  ///
  /// type is uploader_service.RequestReceivedParamsServingInfo
  /// LINT.IfChange(request_received_params_serving_info_annotations)
  /// LINT.ThenChange()
  core.String? requestReceivedParamsServingInfo;
  core.List<core.int> get requestReceivedParamsServingInfoAsBytes =>
      convert.base64.decode(requestReceivedParamsServingInfo!);

  set requestReceivedParamsServingInfoAsBytes(core.List<core.int> bytes_) {
    requestReceivedParamsServingInfo = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The total size of the file.
  core.String? totalBytes;

  /// Whether the total bytes field contains an estimated data.
  core.bool? totalBytesIsEstimated;

  $MediaRequestInfo({
    this.currentBytes,
    this.customData,
    this.diffObjectVersion,
    this.finalStatus,
    this.notificationType,
    this.requestId,
    this.requestReceivedParamsServingInfo,
    this.totalBytes,
    this.totalBytesIsEstimated,
  });

  $MediaRequestInfo.fromJson(core.Map json_)
    : this(
        currentBytes: json_['currentBytes'] as core.String?,
        customData: json_['customData'] as core.String?,
        diffObjectVersion: json_['diffObjectVersion'] as core.String?,
        finalStatus: json_['finalStatus'] as core.int?,
        notificationType: json_['notificationType'] as core.String?,
        requestId: json_['requestId'] as core.String?,
        requestReceivedParamsServingInfo:
            json_['requestReceivedParamsServingInfo'] as core.String?,
        totalBytes: json_['totalBytes'] as core.String?,
        totalBytesIsEstimated: json_['totalBytesIsEstimated'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currentBytes != null) 'currentBytes': currentBytes!,
    if (customData != null) 'customData': customData!,
    if (diffObjectVersion != null) 'diffObjectVersion': diffObjectVersion!,
    if (finalStatus != null) 'finalStatus': finalStatus!,
    if (notificationType != null) 'notificationType': notificationType!,
    if (requestId != null) 'requestId': requestId!,
    if (requestReceivedParamsServingInfo != null)
      'requestReceivedParamsServingInfo': requestReceivedParamsServingInfo!,
    if (totalBytes != null) 'totalBytes': totalBytes!,
    if (totalBytesIsEstimated != null)
      'totalBytesIsEstimated': totalBytesIsEstimated!,
  };
}

/// Used by:
///
/// - admob:v1 : MediationReportSpecSortCondition
/// - admob:v1beta : MediationReportSpecSortCondition
class $MediationReportSpecSortCondition {
  /// Sort by the specified dimension.
  /// Possible string values are:
  /// - "DIMENSION_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "DATE" : A date in the YYYYMMDD format (for example, "20210701").
  /// Requests can specify at most one time dimension.
  /// - "MONTH" : A month in the YYYYMM format (for example, "202107"). Requests
  /// can specify at most one time dimension.
  /// - "WEEK" : The date of the first day of a week in the YYYYMMDD format (for
  /// example, "20210701"). Requests can specify at most one time dimension.
  /// - "AD_SOURCE" : The \[unique ID of the ad
  /// source\](/admob/api/v1/ad_sources) (for example, "5450213213286189855" and
  /// "AdMob Network" as label value).
  /// - "AD_SOURCE_INSTANCE" : The unique ID of the ad source instance (for
  /// example, "ca-app-pub-1234:asi:5678" and "AdMob (default)" as label value).
  /// - "AD_UNIT" : The unique ID of the ad unit (for example,
  /// "ca-app-pub-1234/8790"). If AD_UNIT dimension is specified, then APP is
  /// included automatically.
  /// - "APP" : The unique ID of the mobile application (for example,
  /// "ca-app-pub-1234~1234").
  /// - "MEDIATION_GROUP" : The unique ID of the mediation group (for example,
  /// "ca-app-pub-1234:mg:1234" and "AdMob (default)" as label value).
  /// - "COUNTRY" : CLDR country code of the place where the ad views/clicks
  /// occur (for example, "US" or "FR"). This is a geography dimension.
  /// - "FORMAT" : Format of the ad unit (for example, "banner", "native"), an
  /// ad delivery dimension.
  /// - "PLATFORM" : Mobile OS platform of the app (for example, "Android" or
  /// "iOS").
  /// - "MOBILE_OS_VERSION" : Mobile operating system version, e.g. "iOS
  /// 13.5.1".
  /// - "GMA_SDK_VERSION" : GMA SDK version, e.g. "iOS 7.62.0".
  /// - "APP_VERSION_NAME" : For Android, the app version name can be found in
  /// versionName in PackageInfo. For iOS, the app version name can be found in
  /// CFBundleShortVersionString.
  /// - "SERVING_RESTRICTION" : Restriction mode for ads serving (e.g.
  /// "Non-personalized ads").
  core.String? dimension;

  /// Sort by the specified metric.
  /// Possible string values are:
  /// - "METRIC_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "AD_REQUESTS" : The number of requests. The value is an integer.
  /// - "CLICKS" : The number of times a user clicks an ad. The value is an
  /// integer.
  /// - "ESTIMATED_EARNINGS" : The estimated earnings of the AdMob publisher.
  /// The currency unit (USD, EUR, or other) of the earning metrics are
  /// determined by the localization setting for currency. The amount is in
  /// micros. For example, $6.50 would be represented as 6500000. Estimated
  /// earnings per mediation group and per ad source instance level is supported
  /// dating back to October 20, 2019. Third-party estimated earnings will show
  /// 0 for dates prior to October 20, 2019.
  /// - "IMPRESSIONS" : The total number of ads shown to users. The value is an
  /// integer.
  /// - "IMPRESSION_CTR" : The ratio of clicks over impressions. The value is a
  /// double precision (approximate) decimal value.
  /// - "MATCHED_REQUESTS" : The number of times ads are returned in response to
  /// a request. The value is an integer.
  /// - "MATCH_RATE" : The ratio of matched ad requests over the total ad
  /// requests. The value is a double precision (approximate) decimal value.
  /// - "OBSERVED_ECPM" : The third-party ad network's estimated average eCPM.
  /// The currency unit (USD, EUR, or other) of the earning metrics are
  /// determined by the localization setting for currency. The amount is in
  /// micros. For example, $2.30 would be represented as 2300000. The estimated
  /// average eCPM per mediation group and per ad source instance level is
  /// supported dating back to October 20, 2019. Third-party estimated average
  /// eCPM will show 0 for dates prior to October 20, 2019.
  core.String? metric;

  /// Sorting order of the dimension or metric.
  /// Possible string values are:
  /// - "SORT_ORDER_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "ASCENDING" : Sort dimension value or metric value in ascending order.
  /// - "DESCENDING" : Sort dimension value or metric value in descending order.
  core.String? order;

  $MediationReportSpecSortCondition({this.dimension, this.metric, this.order});

  $MediationReportSpecSortCondition.fromJson(core.Map json_)
    : this(
        dimension: json_['dimension'] as core.String?,
        metric: json_['metric'] as core.String?,
        order: json_['order'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimension != null) 'dimension': dimension!,
    if (metric != null) 'metric': metric!,
    if (order != null) 'order': order!,
  };
}

/// Used by:
///
/// - gkehub:v1 : MembershipBindingLifecycleState
/// - gkehub:v1alpha : MembershipBindingLifecycleState
/// - gkehub:v1beta : MembershipBindingLifecycleState
class $MembershipBindingLifecycleState {
  /// The current state of the MembershipBinding resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The membershipbinding is being created.
  /// - "READY" : The membershipbinding active.
  /// - "DELETING" : The membershipbinding is being deleted.
  /// - "UPDATING" : The membershipbinding is being updated.
  core.String? code;

  $MembershipBindingLifecycleState({this.code});

  $MembershipBindingLifecycleState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : MembershipRoleRestrictionEvaluation
/// - cloudidentity:v1beta1 : MembershipRoleRestrictionEvaluation
class $MembershipRoleRestrictionEvaluation {
  /// The current state of the restriction
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default. Should not be used.
  /// - "COMPLIANT" : The member adheres to the parent group's restriction.
  /// - "FORWARD_COMPLIANT" : The group-group membership might be currently
  /// violating some parent group's restriction but in future, it will never
  /// allow any new member in the child group which can violate parent group's
  /// restriction.
  /// - "NON_COMPLIANT" : The member violates the parent group's restriction.
  /// - "EVALUATING" : The state of the membership is under evaluation.
  core.String? state;

  $MembershipRoleRestrictionEvaluation({this.state});

  $MembershipRoleRestrictionEvaluation.fromJson(core.Map json_)
    : this(state: json_['state'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - gkehub:v1 : MembershipState
/// - gkehub:v1alpha : MembershipState
/// - gkehub:v1beta : MembershipState
class $MembershipState {
  /// The current state of the Membership resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The cluster is being registered.
  /// - "READY" : The cluster is registered.
  /// - "DELETING" : The cluster is being unregistered.
  /// - "UPDATING" : The Membership is being updated.
  /// - "SERVICE_UPDATING" : The Membership is being updated by the Hub Service.
  core.String? code;

  $MembershipState({this.code});

  $MembershipState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - memcache:v1 : MemcacheParameters
/// - memcache:v1beta2 : MemcacheParameters
class $MemcacheParameters {
  /// The unique ID associated with this set of parameters.
  ///
  /// Users can use this id to determine if the parameters associated with the
  /// instance differ from the parameters associated with the nodes. A
  /// discrepancy between parameter ids can inform users that they may need to
  /// take action to apply parameters on nodes.
  ///
  /// Output only.
  core.String? id;

  /// User defined set of parameters to use in the memcached process.
  core.Map<core.String, core.String>? params;

  $MemcacheParameters({this.id, this.params});

  $MemcacheParameters.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        params: (json_['params'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (params != null) 'params': params!,
  };
}

/// Used by:
///
/// - container:v1 : MemoryManager
/// - container:v1beta1 : MemoryManager
class $MemoryManager {
  /// Controls the memory management policy on the Node.
  ///
  /// See
  /// https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/#policies
  /// The following values are allowed. * "none" * "static" The default value is
  /// 'none' if unspecified.
  core.String? policy;

  $MemoryManager({this.policy});

  $MemoryManager.fromJson(core.Map json_)
    : this(policy: json_['policy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (policy != null) 'policy': policy!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MemoryUsageSample
/// - migrationcenter:v1alpha1 : MemoryUsageSample
class $MemoryUsageSample {
  /// Percentage of system memory utilized.
  ///
  /// Must be in the interval \[0, 100\].
  core.double? utilizedPercentage;

  $MemoryUsageSample({this.utilizedPercentage});

  $MemoryUsageSample.fromJson(core.Map json_)
    : this(
        utilizedPercentage:
            (json_['utilizedPercentage'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (utilizedPercentage != null) 'utilizedPercentage': utilizedPercentage!,
  };
}

/// Used by:
///
/// - retail:v2alpha : GoogleCloudRetailV2alphaMerchantCenterAccountLinkMerchantCenterFeedFilter
/// - retail:v2alpha : GoogleCloudRetailV2alphaMerchantCenterFeedFilter
/// - retail:v2beta : GoogleCloudRetailV2betaMerchantCenterFeedFilter
class $MerchantCenterFeedFilter {
  /// AFM data source ID.
  core.String? dataSourceId;

  /// Merchant Center primary feed ID.
  ///
  /// Deprecated: use data_source_id instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? primaryFeedId;

  /// Merchant Center primary feed name.
  ///
  /// The name is used for the display purposes only.
  core.String? primaryFeedName;

  $MerchantCenterFeedFilter({
    this.dataSourceId,
    this.primaryFeedId,
    this.primaryFeedName,
  });

  $MerchantCenterFeedFilter.fromJson(core.Map json_)
    : this(
        dataSourceId: json_['dataSourceId'] as core.String?,
        primaryFeedId: json_['primaryFeedId'] as core.String?,
        primaryFeedName: json_['primaryFeedName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataSourceId != null) 'dataSourceId': dataSourceId!,
    if (primaryFeedId != null) 'primaryFeedId': primaryFeedId!,
    if (primaryFeedName != null) 'primaryFeedName': primaryFeedName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MergeVersionAliasesRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MergeVersionAliasesRequest
class $MergeVersionAliasesRequest {
  /// The set of version aliases to merge.
  ///
  /// The alias should be at most 128 characters, and match
  /// `a-z{0,126}[a-z-0-9]`. Add the `-` prefix to an alias means removing that
  /// alias from the version. `-` is NOT counted in the 128 characters. Example:
  /// `-golden` means removing the `golden` alias from the version. There is NO
  /// ordering in aliases, which means 1) The aliases returned from GetModel API
  /// might not have the exactly same order from this MergeVersionAliases API.
  /// 2) Adding and deleting the same alias in the request is not recommended,
  /// and the 2 operations will be cancelled out.
  ///
  /// Required.
  core.List<core.String>? versionAliases;

  $MergeVersionAliasesRequest({this.versionAliases});

  $MergeVersionAliasesRequest.fromJson(core.Map json_)
    : this(
        versionAliases:
            (json_['versionAliases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (versionAliases != null) 'versionAliases': versionAliases!,
  };
}

/// Used by:
///
/// - networkservices:v1 : Mesh
/// - networkservices:v1beta1 : Mesh
class $Mesh {
  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A free-text description of the resource.
  ///
  /// Max length 1024 characters.
  ///
  /// Optional.
  core.String? description;

  /// Determines if envoy will insert internal debug headers into upstream
  /// requests.
  ///
  /// Other Envoy headers may still be injected. By default, envoy will not
  /// insert any debug headers.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ENVOY_HEADERS_UNSPECIFIED" : Defaults to NONE.
  /// - "NONE" : Suppress envoy debug headers.
  /// - "DEBUG_HEADERS" : Envoy will insert default internal debug headers into
  /// upstream requests: x-envoy-attempt-count x-envoy-is-timeout-retry
  /// x-envoy-expected-rq-timeout-ms x-envoy-original-path
  /// x-envoy-upstream-stream-duration-ms
  core.String? envoyHeaders;

  /// If set to a valid TCP port (1-65535), instructs the SIDECAR proxy to
  /// listen on the specified port of localhost (127.0.0.1) address.
  ///
  /// The SIDECAR proxy will expect all traffic to be redirected to this port
  /// regardless of its actual ip:port destination. If unset, a port '15001' is
  /// used as the interception port. This is applicable only for sidecar proxy
  /// deployments.
  ///
  /// Optional.
  core.int? interceptionPort;

  /// Set of label tags associated with the Mesh resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the Mesh resource. It matches pattern `projects / *
  /// /locations/global/meshes/`.
  core.String? name;

  /// Server-defined URL of this resource
  ///
  /// Output only.
  core.String? selfLink;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Mesh({
    this.createTime,
    this.description,
    this.envoyHeaders,
    this.interceptionPort,
    this.labels,
    this.name,
    this.selfLink,
    this.updateTime,
  });

  $Mesh.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        envoyHeaders: json_['envoyHeaders'] as core.String?,
        interceptionPort: json_['interceptionPort'] as core.int?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (envoyHeaders != null) 'envoyHeaders': envoyHeaders!,
    if (interceptionPort != null) 'interceptionPort': interceptionPort!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networkservices:v1 : MeshRouteView
/// - networkservices:v1beta1 : MeshRouteView
class $MeshRouteView {
  /// Identifier.
  ///
  /// Full path name of the MeshRouteView resource. Format:
  /// projects/{project_number}/locations/{location}/meshes/{mesh}/routeViews/{route_view}
  ///
  /// Output only.
  core.String? name;

  /// The resource id for the route.
  ///
  /// Output only.
  core.String? routeId;

  /// Location where the route exists.
  ///
  /// Output only.
  core.String? routeLocation;

  /// Project number where the route exists.
  ///
  /// Output only.
  core.String? routeProjectNumber;

  /// Type of the route: HttpRoute,GrpcRoute,TcpRoute, or TlsRoute
  ///
  /// Output only.
  core.String? routeType;

  $MeshRouteView({
    this.name,
    this.routeId,
    this.routeLocation,
    this.routeProjectNumber,
    this.routeType,
  });

  $MeshRouteView.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        routeId: json_['routeId'] as core.String?,
        routeLocation: json_['routeLocation'] as core.String?,
        routeProjectNumber: json_['routeProjectNumber'] as core.String?,
        routeType: json_['routeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (routeId != null) 'routeId': routeId!,
    if (routeLocation != null) 'routeLocation': routeLocation!,
    if (routeProjectNumber != null) 'routeProjectNumber': routeProjectNumber!,
    if (routeType != null) 'routeType': routeType!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2MessageEntry
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1MessageEntry
class $MessageEntry {
  /// Create time of the message entry.
  ///
  /// Optional.
  core.String? createTime;

  /// The language of the text.
  ///
  /// See
  /// [Language Support](https://cloud.google.com/dialogflow/docs/reference/language)
  /// for a list of the currently supported language codes.
  ///
  /// Optional.
  core.String? languageCode;

  /// Participant role of the message.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ROLE_UNSPECIFIED" : Participant role not set.
  /// - "HUMAN_AGENT" : Participant is a human agent.
  /// - "AUTOMATED_AGENT" : Participant is an automated agent, such as a
  /// Dialogflow agent.
  /// - "END_USER" : Participant is an end user that has called or chatted with
  /// Dialogflow services.
  core.String? role;

  /// Transcript content of the message.
  ///
  /// Optional.
  core.String? text;

  $MessageEntry({this.createTime, this.languageCode, this.role, this.text});

  $MessageEntry.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        role: json_['role'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (role != null) 'role': role!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - compute:alpha : Metadata
/// - compute:beta : Metadata
/// - compute:v1 : Metadata
class $Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet. To see the
  /// latest fingerprint, make a get() request to retrieve the resource.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Array of key/value pairs.
  ///
  /// The total size of all keys and values must be less than 512 KB.
  core.List<MetadataItems>? items;

  /// Type of the resource.
  ///
  /// Always compute#metadata for metadata.
  ///
  /// Output only.
  core.String? kind;

  $Metadata({this.fingerprint, this.items, this.kind});

  $Metadata.fromJson(core.Map json_)
    : this(
        fingerprint: json_['fingerprint'] as core.String?,
        items:
            (json_['items'] as core.List?)
                ?.map(
                  (value) => MetadataItems.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (items != null) 'items': items!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - metastore:v1 : MetadataExport
/// - metastore:v1alpha : MetadataExport
/// - metastore:v1beta : MetadataExport
class $MetadataExport {
  /// The type of the database dump.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type of the database dump is unknown.
  /// - "MYSQL" : Database dump is a MySQL dump file.
  /// - "AVRO" : Database dump contains Avro files.
  core.String? databaseDumpType;

  /// A Cloud Storage URI of a folder that metadata are exported to, in the form
  /// of gs:////, where is automatically generated.
  ///
  /// Output only.
  core.String? destinationGcsUri;

  /// The time when the export ended.
  ///
  /// Output only.
  core.String? endTime;

  /// The time when the export started.
  ///
  /// Output only.
  core.String? startTime;

  /// The current state of the export.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The state of the metadata export is unknown.
  /// - "RUNNING" : The metadata export is running.
  /// - "SUCCEEDED" : The metadata export completed successfully.
  /// - "FAILED" : The metadata export failed.
  /// - "CANCELLED" : The metadata export is cancelled.
  core.String? state;

  $MetadataExport({
    this.databaseDumpType,
    this.destinationGcsUri,
    this.endTime,
    this.startTime,
    this.state,
  });

  $MetadataExport.fromJson(core.Map json_)
    : this(
        databaseDumpType: json_['databaseDumpType'] as core.String?,
        destinationGcsUri: json_['destinationGcsUri'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseDumpType != null) 'databaseDumpType': databaseDumpType!,
    if (destinationGcsUri != null) 'destinationGcsUri': destinationGcsUri!,
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - compute:alpha : MetadataFilterLabelMatch
/// - compute:beta : MetadataFilterLabelMatch
/// - compute:v1 : MetadataFilterLabelMatch
class $MetadataFilterLabelMatch {
  /// Name of metadata label.
  ///
  /// The name can have a maximum length of 1024 characters and must be at least
  /// 1 character long.
  core.String? name;

  /// The value of the label must match the specified value.
  ///
  /// value can have a maximum length of 1024 characters.
  core.String? value;

  $MetadataFilterLabelMatch({this.name, this.value});

  $MetadataFilterLabelMatch.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - networkservices:v1 : EndpointMatcherMetadataLabelMatcherMetadataLabels
/// - networkservices:v1beta1 : MetadataLabels
class $MetadataLabels {
  /// Label name presented as key in xDS Node Metadata.
  ///
  /// Required.
  core.String? labelName;

  /// Label value presented as value corresponding to the above key, in xDS Node
  /// Metadata.
  ///
  /// Required.
  core.String? labelValue;

  $MetadataLabels({this.labelName, this.labelValue});

  $MetadataLabels.fromJson(core.Map json_)
    : this(
        labelName: json_['labelName'] as core.String?,
        labelValue: json_['labelValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labelName != null) 'labelName': labelName!,
    if (labelValue != null) 'labelValue': labelValue!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetadataSchema
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetadataSchema
class $MetadataSchema {
  /// Timestamp when this MetadataSchema was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Metadata Schema
  core.String? description;

  /// The resource name of the MetadataSchema.
  ///
  /// Output only.
  core.String? name;

  /// The raw YAML string representation of the MetadataSchema.
  ///
  /// The combination of \[MetadataSchema.version\] and the schema name given by
  /// `title` in \[MetadataSchema.schema\] must be unique within a
  /// MetadataStore. The schema is defined as an OpenAPI 3.0.2
  /// [MetadataSchema Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
  ///
  /// Required.
  core.String? schema;

  /// The type of the MetadataSchema.
  ///
  /// This is a property that identifies which metadata types will use the
  /// MetadataSchema.
  /// Possible string values are:
  /// - "METADATA_SCHEMA_TYPE_UNSPECIFIED" : Unspecified type for the
  /// MetadataSchema.
  /// - "ARTIFACT_TYPE" : A type indicating that the MetadataSchema will be used
  /// by Artifacts.
  /// - "EXECUTION_TYPE" : A typee indicating that the MetadataSchema will be
  /// used by Executions.
  /// - "CONTEXT_TYPE" : A state indicating that the MetadataSchema will be used
  /// by Contexts.
  core.String? schemaType;

  /// The version of the MetadataSchema.
  ///
  /// The version's format must match the following regular expression:
  /// `^[0-9]+.+.+$`, which would allow to order/compare different versions.
  /// Example: 1.0.0, 1.0.1, etc.
  core.String? schemaVersion;

  $MetadataSchema({
    this.createTime,
    this.description,
    this.name,
    this.schema,
    this.schemaType,
    this.schemaVersion,
  });

  $MetadataSchema.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        schema: json_['schema'] as core.String?,
        schemaType: json_['schemaType'] as core.String?,
        schemaVersion: json_['schemaVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (schema != null) 'schema': schema!,
    if (schemaType != null) 'schemaType': schemaType!,
    if (schemaVersion != null) 'schemaVersion': schemaVersion!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetadataStoreDataplexConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetadataStoreDataplexConfig
class $MetadataStoreDataplexConfig {
  /// Whether or not Data Lineage synchronization is enabled for Vertex
  /// Pipelines.
  ///
  /// Optional.
  core.bool? enabledPipelinesLineage;

  $MetadataStoreDataplexConfig({this.enabledPipelinesLineage});

  $MetadataStoreDataplexConfig.fromJson(core.Map json_)
    : this(
        enabledPipelinesLineage: json_['enabledPipelinesLineage'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabledPipelinesLineage != null)
      'enabledPipelinesLineage': enabledPipelinesLineage!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetadataStoreMetadataStoreState
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetadataStoreMetadataStoreState
class $MetadataStoreMetadataStoreState {
  /// The disk utilization of the MetadataStore in bytes.
  core.String? diskUtilizationBytes;

  $MetadataStoreMetadataStoreState({this.diskUtilizationBytes});

  $MetadataStoreMetadataStoreState.fromJson(core.Map json_)
    : this(diskUtilizationBytes: json_['diskUtilizationBytes'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskUtilizationBytes != null)
      'diskUtilizationBytes': diskUtilizationBytes!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : MethodSelector
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1MethodSelector
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1MethodSelector
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1MethodSelector
class $MethodSelector {
  /// A valid method name for the corresponding `service_name` in ApiOperation.
  ///
  /// If `*` is used as the value for the `method`, then ALL methods and
  /// permissions are allowed.
  core.String? method;

  /// A valid Cloud IAM permission for the corresponding `service_name` in
  /// ApiOperation.
  core.String? permission;

  $MethodSelector({this.method, this.permission});

  $MethodSelector.fromJson(core.Map json_)
    : this(
        method: json_['method'] as core.String?,
        permission: json_['permission'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (method != null) 'method': method!,
    if (permission != null) 'permission': permission!,
  };
}

/// Used by:
///
/// - container:v1 : Metric
/// - container:v1beta1 : Metric
class $Metric {
  /// For metrics with floating point value.
  core.double? doubleValue;

  /// For metrics with integer value.
  core.String? intValue;

  /// Metric name, e.g., "nodes total", "percent done".
  ///
  /// Required.
  core.String? name;

  /// For metrics with custom values (ratios, visual progress, etc.).
  core.String? stringValue;

  $Metric({this.doubleValue, this.intValue, this.name, this.stringValue});

  $Metric.fromJson(core.Map json_)
    : this(
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        intValue: json_['intValue'] as core.String?,
        name: json_['name'] as core.String?,
        stringValue: json_['stringValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (intValue != null) 'intValue': intValue!,
    if (name != null) 'name': name!,
    if (stringValue != null) 'stringValue': stringValue!,
  };
}

/// Used by:
///
/// - logging:v2 : MetricDescriptorMetadata
/// - monitoring:v3 : MetricDescriptorMetadata
class $MetricDescriptorMetadata {
  /// The delay of data points caused by ingestion.
  ///
  /// Data points older than this age are guaranteed to be ingested and
  /// available to be read, excluding data loss due to errors.
  core.String? ingestDelay;

  /// Must use the MetricDescriptor.launch_stage instead.
  ///
  /// Deprecated.
  /// Possible string values are:
  /// - "LAUNCH_STAGE_UNSPECIFIED" : Do not use this default value.
  /// - "UNIMPLEMENTED" : The feature is not yet implemented. Users can not use
  /// it.
  /// - "PRELAUNCH" : Prelaunch features are hidden from users and are only
  /// visible internally.
  /// - "EARLY_ACCESS" : Early Access features are limited to a closed group of
  /// testers. To use these features, you must sign up in advance and sign a
  /// Trusted Tester agreement (which includes confidentiality provisions).
  /// These features may be unstable, changed in backward-incompatible ways, and
  /// are not guaranteed to be released.
  /// - "ALPHA" : Alpha is a limited availability test for releases before they
  /// are cleared for widespread use. By Alpha, all significant design issues
  /// are resolved and we are in the process of verifying functionality. Alpha
  /// customers need to apply for access, agree to applicable terms, and have
  /// their projects allowlisted. Alpha releases don't have to be feature
  /// complete, no SLAs are provided, and there are no technical support
  /// obligations, but they will be far enough along that customers can actually
  /// use them in test environments or for limited-use tests -- just like they
  /// would in normal production cases.
  /// - "BETA" : Beta is the point at which we are ready to open a release for
  /// any customer to use. There are no SLA or technical support obligations in
  /// a Beta release. Products will be complete from a feature perspective, but
  /// may have some open outstanding issues. Beta releases are suitable for
  /// limited production use cases.
  /// - "GA" : GA features are open to all developers and are considered stable
  /// and fully qualified for production use.
  /// - "DEPRECATED" : Deprecated features are scheduled to be shut down and
  /// removed. For more information, see the "Deprecation Policy" section of our
  /// Terms of Service (https://cloud.google.com/terms/) and the Google Cloud
  /// Platform Subject to the Deprecation Policy
  /// (https://cloud.google.com/terms/deprecation) documentation.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? launchStage;

  /// The sampling period of metric data points.
  ///
  /// For metrics which are written periodically, consecutive data points are
  /// stored at this time interval, excluding data loss due to errors. Metrics
  /// with a higher granularity have a smaller sampling period.
  core.String? samplePeriod;

  /// The scope of the timeseries data of the metric.
  core.List<core.String>? timeSeriesResourceHierarchyLevel;

  $MetricDescriptorMetadata({
    this.ingestDelay,
    this.launchStage,
    this.samplePeriod,
    this.timeSeriesResourceHierarchyLevel,
  });

  $MetricDescriptorMetadata.fromJson(core.Map json_)
    : this(
        ingestDelay: json_['ingestDelay'] as core.String?,
        launchStage: json_['launchStage'] as core.String?,
        samplePeriod: json_['samplePeriod'] as core.String?,
        timeSeriesResourceHierarchyLevel:
            (json_['timeSeriesResourceHierarchyLevel'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ingestDelay != null) 'ingestDelay': ingestDelay!,
    if (launchStage != null) 'launchStage': launchStage!,
    if (samplePeriod != null) 'samplePeriod': samplePeriod!,
    if (timeSeriesResourceHierarchyLevel != null)
      'timeSeriesResourceHierarchyLevel': timeSeriesResourceHierarchyLevel!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessOrderByMetricOrderBy
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessOrderByMetricOrderBy
/// - analyticsdata:v1beta : MetricOrderBy
class $MetricOrderBy {
  /// A metric name in the request to order by.
  core.String? metricName;

  $MetricOrderBy({this.metricName});

  $MetricOrderBy.fromJson(core.Map json_)
    : this(metricName: json_['metricName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricName != null) 'metricName': metricName!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : MetricRule
/// - serviceusage:v1 : MetricRule
/// - serviceusage:v1beta1 : MetricRule
class $MetricRule {
  /// Metrics to update when the selected methods are called, and the associated
  /// cost applied to each metric.
  ///
  /// The key of the map is the metric name, and the values are the amount
  /// increased for the metric against which the quota limits are defined. The
  /// value must not be negative.
  core.Map<core.String, core.String>? metricCosts;

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to selector for syntax details.
  core.String? selector;

  $MetricRule({this.metricCosts, this.selector});

  $MetricRule.fromJson(core.Map json_)
    : this(
        metricCosts: (json_['metricCosts']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        selector: json_['selector'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricCosts != null) 'metricCosts': metricCosts!,
    if (selector != null) 'selector': selector!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetricxResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetricxResult
class $MetricxResult {
  /// MetricX score.
  ///
  /// Range depends on version.
  ///
  /// Output only.
  core.double? score;

  $MetricxResult({this.score});

  $MetricxResult.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MetricxSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MetricxSpec
class $MetricxSpec {
  /// Source language in BCP-47 format.
  ///
  /// Optional.
  core.String? sourceLanguage;

  /// Target language in BCP-47 format.
  ///
  /// Covers both prediction and reference.
  ///
  /// Optional.
  core.String? targetLanguage;

  /// Which version to use for evaluation.
  ///
  /// Required.
  /// Possible string values are:
  /// - "METRICX_VERSION_UNSPECIFIED" : MetricX version unspecified.
  /// - "METRICX_24_REF" : MetricX 2024 (2.6) for translation + reference
  /// (reference-based).
  /// - "METRICX_24_SRC" : MetricX 2024 (2.6) for translation + source (QE).
  /// - "METRICX_24_SRC_REF" : MetricX 2024 (2.6) for translation + source +
  /// reference (source-reference-combined).
  core.String? version;

  $MetricxSpec({this.sourceLanguage, this.targetLanguage, this.version});

  $MetricxSpec.fromJson(core.Map json_)
    : this(
        sourceLanguage: json_['sourceLanguage'] as core.String?,
        targetLanguage: json_['targetLanguage'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceLanguage != null) 'sourceLanguage': sourceLanguage!,
    if (targetLanguage != null) 'targetLanguage': targetLanguage!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigratableResourceAutomlDataset
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigratableResourceAutomlDataset
class $MigratableResourceAutomlDataset {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in automl.googleapis.com.
  core.String? datasetDisplayName;

  $MigratableResourceAutomlDataset({this.dataset, this.datasetDisplayName});

  $MigratableResourceAutomlDataset.fromJson(core.Map json_)
    : this(
        dataset: json_['dataset'] as core.String?,
        datasetDisplayName: json_['datasetDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataset != null) 'dataset': dataset!,
    if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigratableResourceAutomlModel
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigratableResourceAutomlModel
class $MigratableResourceAutomlModel {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  core.String? model;

  /// The Model's display name in automl.googleapis.com.
  core.String? modelDisplayName;

  $MigratableResourceAutomlModel({this.model, this.modelDisplayName});

  $MigratableResourceAutomlModel.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
class $MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  core.String? annotatedDataset;

  /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
  core.String? annotatedDatasetDisplayName;

  $MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset({
    this.annotatedDataset,
    this.annotatedDatasetDisplayName,
  });

  $MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset.fromJson(
    core.Map json_,
  ) : this(
        annotatedDataset: json_['annotatedDataset'] as core.String?,
        annotatedDatasetDisplayName:
            json_['annotatedDatasetDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
    if (annotatedDatasetDisplayName != null)
      'annotatedDatasetDisplayName': annotatedDatasetDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigratableResourceMlEngineModelVersion
class $MigratableResourceMlEngineModelVersion {
  /// The ml.googleapis.com endpoint that this model Version currently lives in.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  core.String? endpoint;

  /// Full resource name of ml engine model Version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  core.String? version;

  $MigratableResourceMlEngineModelVersion({this.endpoint, this.version});

  $MigratableResourceMlEngineModelVersion.fromJson(core.Map json_)
    : this(
        endpoint: json_['endpoint'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoint != null) 'endpoint': endpoint!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlDatasetConfig
class $MigrateResourceRequestMigrateAutomlDatasetConfig {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? datasetDisplayName;

  $MigrateResourceRequestMigrateAutomlDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
  });

  $MigrateResourceRequestMigrateAutomlDatasetConfig.fromJson(core.Map json_)
    : this(
        dataset: json_['dataset'] as core.String?,
        datasetDisplayName: json_['datasetDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataset != null) 'dataset': dataset!,
    if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlModelConfig
class $MigrateResourceRequestMigrateAutomlModelConfig {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  ///
  /// Required.
  core.String? model;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? modelDisplayName;

  $MigrateResourceRequestMigrateAutomlModelConfig({
    this.model,
    this.modelDisplayName,
  });

  $MigrateResourceRequestMigrateAutomlModelConfig.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
class $MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  ///
  /// Required.
  core.String? annotatedDataset;

  $MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig({
    this.annotatedDataset,
  });

  $MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig.fromJson(
    core.Map json_,
  ) : this(annotatedDataset: json_['annotatedDataset'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateMlEngineModelVersionConfig
class $MigrateResourceRequestMigrateMlEngineModelVersionConfig {
  /// The ml.googleapis.com endpoint that this model version should be migrated
  /// from.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  ///
  /// Required.
  core.String? endpoint;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? modelDisplayName;

  /// Full resource name of ml engine model version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  ///
  /// Required.
  core.String? modelVersion;

  $MigrateResourceRequestMigrateMlEngineModelVersionConfig({
    this.endpoint,
    this.modelDisplayName,
    this.modelVersion,
  });

  $MigrateResourceRequestMigrateMlEngineModelVersionConfig.fromJson(
    core.Map json_,
  ) : this(
        endpoint: json_['endpoint'] as core.String?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
        modelVersion: json_['modelVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoint != null) 'endpoint': endpoint!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
    if (modelVersion != null) 'modelVersion': modelVersion!,
  };
}

/// Used by:
///
/// - networkconnectivity:v1 : Migration
/// - networkconnectivity:v1alpha1 : Migration
class $Migration {
  /// Resource path as an URI of the source resource, for example a subnet.
  ///
  /// The project for the source resource should match the project for the
  /// InternalRange. An example:
  /// /projects/{project}/regions/{region}/subnetworks/{subnet}
  ///
  /// Immutable.
  core.String? source;

  /// Resource path of the target resource.
  ///
  /// The target project can be different, as in the cases when migrating to
  /// peer networks. For example:
  /// /projects/{project}/regions/{region}/subnetworks/{subnet}
  ///
  /// Immutable.
  core.String? target;

  $Migration({this.source, this.target});

  $Migration.fromJson(core.Map json_)
    : this(
        source: json_['source'] as core.String?,
        target: json_['target'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (source != null) 'source': source!,
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - alloydb:v1 : MigrationSource
/// - alloydb:v1alpha : MigrationSource
/// - alloydb:v1beta : MigrationSource
class $MigrationSource {
  /// The host and port of the on-premises instance in host:port format
  ///
  /// Output only.
  core.String? hostPort;

  /// Place holder for the external source identifier(e.g DMS job name) that
  /// created the cluster.
  ///
  /// Output only.
  core.String? referenceId;

  /// Type of migration source.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MIGRATION_SOURCE_TYPE_UNSPECIFIED" : Migration source is unknown.
  /// - "DMS" : DMS source means the cluster was created via DMS migration job.
  core.String? sourceType;

  $MigrationSource({this.hostPort, this.referenceId, this.sourceType});

  $MigrationSource.fromJson(core.Map json_)
    : this(
        hostPort: json_['hostPort'] as core.String?,
        referenceId: json_['referenceId'] as core.String?,
        sourceType: json_['sourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostPort != null) 'hostPort': hostPort!,
    if (referenceId != null) 'referenceId': referenceId!,
    if (sourceType != null) 'sourceType': sourceType!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : MirroringDeployment
/// - networksecurity:v1beta1 : MirroringDeployment
class $MirroringDeployment {
  /// The timestamp when the resource was created.
  ///
  /// See https://google.aip.dev/148#timestamps.
  ///
  /// Output only.
  core.String? createTime;

  /// User-provided description of the deployment.
  ///
  /// Used as additional context for the deployment.
  ///
  /// Optional.
  core.String? description;

  /// The regional forwarding rule that fronts the mirroring collectors, for
  /// example: `projects/123456789/regions/us-central1/forwardingRules/my-rule`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Required. Immutable.
  core.String? forwardingRule;

  /// Labels are key/value pairs that help to organize and filter resources.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The deployment group that this deployment is a part of, for example:
  /// `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Required. Immutable.
  core.String? mirroringDeploymentGroup;

  /// Identifier.
  ///
  /// The resource name of this deployment, for example:
  /// `projects/123456789/locations/us-central1-a/mirroringDeployments/my-dep`.
  /// See https://google.aip.dev/122 for more details.
  ///
  /// Immutable.
  core.String? name;

  /// The current state of the resource does not match the user's intended
  /// state, and the system is working to reconcile them.
  ///
  /// This part of the normal operation (e.g. linking a new association to the
  /// parent group). See https://google.aip.dev/128.
  ///
  /// Output only.
  core.bool? reconciling;

  /// The current state of the deployment.
  ///
  /// See https://google.aip.dev/216.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set (this is not a valid state).
  /// - "ACTIVE" : The deployment is ready and in sync with the parent group.
  /// - "CREATING" : The deployment is being created.
  /// - "DELETING" : The deployment is being deleted.
  /// - "OUT_OF_SYNC" : The deployment is out of sync with the parent group. In
  /// most cases, this is a result of a transient issue within the system (e.g.
  /// a delayed data-path config) and the system is expected to recover
  /// automatically. See the parent deployment group's state for more details.
  /// - "DELETE_FAILED" : An attempt to delete the deployment has failed. This
  /// is a terminal state and the deployment is not expected to recover. The
  /// only permitted operation is to retry deleting the deployment.
  core.String? state;

  /// The timestamp when the resource was most recently updated.
  ///
  /// See https://google.aip.dev/148#timestamps.
  ///
  /// Output only.
  core.String? updateTime;

  $MirroringDeployment({
    this.createTime,
    this.description,
    this.forwardingRule,
    this.labels,
    this.mirroringDeploymentGroup,
    this.name,
    this.reconciling,
    this.state,
    this.updateTime,
  });

  $MirroringDeployment.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        forwardingRule: json_['forwardingRule'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        mirroringDeploymentGroup:
            json_['mirroringDeploymentGroup'] as core.String?,
        name: json_['name'] as core.String?,
        reconciling: json_['reconciling'] as core.bool?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (labels != null) 'labels': labels!,
    if (mirroringDeploymentGroup != null)
      'mirroringDeploymentGroup': mirroringDeploymentGroup!,
    if (name != null) 'name': name!,
    if (reconciling != null) 'reconciling': reconciling!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : MirroringDeploymentGroupConnectedEndpointGroup
/// - networksecurity:v1beta1 : MirroringDeploymentGroupConnectedEndpointGroup
class $MirroringDeploymentGroupConnectedEndpointGroup {
  /// The connected endpoint group's resource name, for example:
  /// `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? name;

  $MirroringDeploymentGroupConnectedEndpointGroup({this.name});

  $MirroringDeploymentGroupConnectedEndpointGroup.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : MirroringDeploymentGroupDeployment
/// - networksecurity:v1beta1 : MirroringDeploymentGroupDeployment
class $MirroringDeploymentGroupDeployment {
  /// The name of the Mirroring Deployment, in the format:
  /// `projects/{project}/locations/{location}/mirroringDeployments/{mirroring_deployment}`.
  ///
  /// Output only.
  core.String? name;

  /// Most recent known state of the deployment.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set (this is not a valid state).
  /// - "ACTIVE" : The deployment is ready and in sync with the parent group.
  /// - "CREATING" : The deployment is being created.
  /// - "DELETING" : The deployment is being deleted.
  /// - "OUT_OF_SYNC" : The deployment is out of sync with the parent group. In
  /// most cases, this is a result of a transient issue within the system (e.g.
  /// a delayed data-path config) and the system is expected to recover
  /// automatically. See the parent deployment group's state for more details.
  /// - "DELETE_FAILED" : An attempt to delete the deployment has failed. This
  /// is a terminal state and the deployment is not expected to recover. The
  /// only permitted operation is to retry deleting the deployment.
  core.String? state;

  $MirroringDeploymentGroupDeployment({this.name, this.state});

  $MirroringDeploymentGroupDeployment.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : MirroringEndpointGroupAssociationDetails
/// - networksecurity:v1beta1 : MirroringEndpointGroupAssociationDetails
class $MirroringEndpointGroupAssociationDetails {
  /// The connected association's resource name, for example:
  /// `projects/123456789/locations/global/mirroringEndpointGroupAssociations/my-ega`.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? name;

  /// The associated network, for example:
  /// projects/123456789/global/networks/my-network.
  ///
  /// See https://google.aip.dev/124.
  ///
  /// Output only.
  core.String? network;

  /// Most recent known state of the association.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "ACTIVE" : The association is ready and in sync with the linked endpoint
  /// group.
  /// - "CREATING" : The association is being created.
  /// - "DELETING" : The association is being deleted.
  /// - "CLOSED" : The association is disabled due to a breaking change in
  /// another resource.
  /// - "OUT_OF_SYNC" : The association is out of sync with the linked endpoint
  /// group. In most cases, this is a result of a transient issue within the
  /// system (e.g. an inaccessible location) and the system is expected to
  /// recover automatically. Check the `locations_details` field for more
  /// details.
  /// - "DELETE_FAILED" : An attempt to delete the association has failed. This
  /// is a terminal state and the association is not expected to be usable as
  /// some of its resources have been deleted. The only permitted operation is
  /// to retry deleting the association.
  core.String? state;

  $MirroringEndpointGroupAssociationDetails({
    this.name,
    this.network,
    this.state,
  });

  $MirroringEndpointGroupAssociationDetails.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : Mixin
/// - serviceusage:v1 : Mixin
/// - serviceusage:v1beta1 : Mixin
class $Mixin {
  /// The fully qualified name of the interface which is included.
  core.String? name;

  /// If non-empty specifies a path under which inherited HTTP paths are rooted.
  core.String? root;

  $Mixin({this.name, this.root});

  $Mixin.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        root: json_['root'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (root != null) 'root': root!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : MobileApp
/// - displayvideo:v3 : MobileApp
/// - displayvideo:v4 : MobileApp
class $MobileApp {
  /// The ID of the app provided by the platform store.
  ///
  /// Android apps are identified by the bundle ID used by Android's Play store,
  /// such as `com.google.android.gm`. iOS apps are identified by a nine-digit
  /// app ID used by Apple's App store, such as `422689480`.
  ///
  /// Required.
  core.String? appId;

  /// The app name.
  ///
  /// Output only.
  core.String? displayName;

  /// The app platform.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PLATFORM_UNSPECIFIED" : Platform is not specified.
  /// - "IOS" : iOS platform.
  /// - "ANDROID" : Android platform.
  core.String? platform;

  /// The app publisher.
  ///
  /// Output only.
  core.String? publisher;

  $MobileApp({this.appId, this.displayName, this.platform, this.publisher});

  $MobileApp.fromJson(core.Map json_)
    : this(
        appId: json_['appId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        platform: json_['platform'] as core.String?,
        publisher: json_['publisher'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appId != null) 'appId': appId!,
    if (displayName != null) 'displayName': displayName!,
    if (platform != null) 'platform': platform!,
    if (publisher != null) 'publisher': publisher!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModalityTokenCount
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModalityTokenCount
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ModalityTokenCount
class $ModalityTokenCount {
  /// The modality associated with this token count.
  /// Possible string values are:
  /// - "MODALITY_UNSPECIFIED" : Unspecified modality.
  /// - "TEXT" : Plain text.
  /// - "IMAGE" : Image.
  /// - "VIDEO" : Video.
  /// - "AUDIO" : Audio.
  /// - "DOCUMENT" : Document, e.g. PDF.
  core.String? modality;

  /// Number of tokens.
  core.int? tokenCount;

  $ModalityTokenCount({this.modality, this.tokenCount});

  $ModalityTokenCount.fromJson(core.Map json_)
    : this(
        modality: json_['modality'] as core.String?,
        tokenCount: json_['tokenCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modality != null) 'modality': modality!,
    if (tokenCount != null) 'tokenCount': tokenCount!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsAnswerGenerationModelCallSignals
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3DataStoreConnectionSignalsRewriterModelCallSignals
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsAnswerGenerationModelCallSignals
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1DataStoreConnectionSignalsRewriterModelCallSignals
class $ModelCallSignals {
  /// Name of the generative model.
  ///
  /// For example, "gemini-ultra", "gemini-pro", "gemini-1.5-flash" etc.
  /// Defaults to "Other" if the model is unknown.
  core.String? model;

  /// Output of the generative model.
  core.String? modelOutput;

  /// Prompt as sent to the model.
  core.String? renderedPrompt;

  $ModelCallSignals({this.model, this.modelOutput, this.renderedPrompt});

  $ModelCallSignals.fromJson(core.Map json_)
    : this(
        model: json_['model'] as core.String?,
        modelOutput: json_['modelOutput'] as core.String?,
        renderedPrompt: json_['renderedPrompt'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelOutput != null) 'modelOutput': modelOutput!,
    if (renderedPrompt != null) 'renderedPrompt': renderedPrompt!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringBigQueryTable
class $ModelDeploymentMonitoringBigQueryTable {
  /// The created BigQuery table to store logs.
  ///
  /// Customer could do their own query & analysis. Format:
  /// `bq://.model_deployment_monitoring_._`
  core.String? bigqueryTablePath;

  /// The source of log.
  /// Possible string values are:
  /// - "LOG_SOURCE_UNSPECIFIED" : Unspecified source.
  /// - "TRAINING" : Logs coming from Training dataset.
  /// - "SERVING" : Logs coming from Serving traffic.
  core.String? logSource;

  /// The type of log.
  /// Possible string values are:
  /// - "LOG_TYPE_UNSPECIFIED" : Unspecified type.
  /// - "PREDICT" : Predict logs.
  /// - "EXPLAIN" : Explain logs.
  core.String? logType;

  /// The schema version of the request/response logging BigQuery table.
  ///
  /// Default to v1 if unset.
  ///
  /// Output only.
  core.String? requestResponseLoggingSchemaVersion;

  $ModelDeploymentMonitoringBigQueryTable({
    this.bigqueryTablePath,
    this.logSource,
    this.logType,
    this.requestResponseLoggingSchemaVersion,
  });

  $ModelDeploymentMonitoringBigQueryTable.fromJson(core.Map json_)
    : this(
        bigqueryTablePath: json_['bigqueryTablePath'] as core.String?,
        logSource: json_['logSource'] as core.String?,
        logType: json_['logType'] as core.String?,
        requestResponseLoggingSchemaVersion:
            json_['requestResponseLoggingSchemaVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryTablePath != null) 'bigqueryTablePath': bigqueryTablePath!,
    if (logSource != null) 'logSource': logSource!,
    if (logType != null) 'logType': logType!,
    if (requestResponseLoggingSchemaVersion != null)
      'requestResponseLoggingSchemaVersion':
          requestResponseLoggingSchemaVersion!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringScheduleConfig
class $ModelDeploymentMonitoringScheduleConfig {
  /// The model monitoring job scheduling interval.
  ///
  /// It will be rounded up to next full hour. This defines how often the
  /// monitoring jobs are triggered.
  ///
  /// Required.
  core.String? monitorInterval;

  /// The time window of the prediction data being included in each prediction
  /// dataset.
  ///
  /// This window specifies how long the data should be collected from
  /// historical model results for each run. If not set,
  /// ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used.
  /// e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the
  /// monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
  /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
  /// monitoring statistics.
  core.String? monitorWindow;

  $ModelDeploymentMonitoringScheduleConfig({
    this.monitorInterval,
    this.monitorWindow,
  });

  $ModelDeploymentMonitoringScheduleConfig.fromJson(core.Map json_)
    : this(
        monitorInterval: json_['monitorInterval'] as core.String?,
        monitorWindow: json_['monitorWindow'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (monitorInterval != null) 'monitorInterval': monitorInterval!,
    if (monitorWindow != null) 'monitorWindow': monitorWindow!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecRange
class $ModelEvaluationSliceSliceSliceSpecRange {
  /// Exclusive high value for the range.
  core.double? high;

  /// Inclusive low value for the range.
  core.double? low;

  $ModelEvaluationSliceSliceSliceSpecRange({this.high, this.low});

  $ModelEvaluationSliceSliceSliceSpecRange.fromJson(core.Map json_)
    : this(
        high: (json_['high'] as core.num?)?.toDouble(),
        low: (json_['low'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (high != null) 'high': high!,
    if (low != null) 'low': low!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecValue
class $ModelEvaluationSliceSliceSliceSpecValue {
  /// Float type.
  core.double? floatValue;

  /// String type.
  core.String? stringValue;

  $ModelEvaluationSliceSliceSliceSpecValue({this.floatValue, this.stringValue});

  $ModelEvaluationSliceSliceSliceSpecValue.fromJson(core.Map json_)
    : this(
        floatValue: (json_['floatValue'] as core.num?)?.toDouble(),
        stringValue: json_['stringValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (floatValue != null) 'floatValue': floatValue!,
    if (stringValue != null) 'stringValue': stringValue!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelExportFormat
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelExportFormat
class $ModelExportFormat {
  /// The content of this Model that may be exported.
  ///
  /// Output only.
  core.List<core.String>? exportableContents;

  /// The ID of the export format.
  ///
  /// The possible format IDs are: * `tflite` Used for Android mobile devices. *
  /// `edgetpu-tflite` Used for [Edge TPU](https://cloud.google.com/edge-tpu/)
  /// devices. * `tf-saved-model` A tensorflow model in SavedModel format. *
  /// `tf-js` A [TensorFlow.js](https://www.tensorflow.org/js) model that can be
  /// used in the browser and in Node.js using JavaScript. * `core-ml` Used for
  /// iOS mobile devices. * `custom-trained` A Model that was uploaded or
  /// trained by custom code. * `genie` A tuned Model Garden model.
  ///
  /// Output only.
  core.String? id;

  $ModelExportFormat({this.exportableContents, this.id});

  $ModelExportFormat.fromJson(core.Map json_)
    : this(
        exportableContents:
            (json_['exportableContents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportableContents != null) 'exportableContents': exportableContents!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ModelFrequentlyBoughtTogetherFeaturesConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaModelFrequentlyBoughtTogetherFeaturesConfig
/// - retail:v2beta : GoogleCloudRetailV2betaModelFrequentlyBoughtTogetherFeaturesConfig
class $ModelFrequentlyBoughtTogetherFeaturesConfig {
  /// Specifies the context of the model when it is used in predict requests.
  ///
  /// Can only be set for the `frequently-bought-together` type. If it isn't
  /// specified, it defaults to MULTIPLE_CONTEXT_PRODUCTS.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED" : Unspecified default value, should
  /// never be explicitly set. Defaults to MULTIPLE_CONTEXT_PRODUCTS.
  /// - "SINGLE_CONTEXT_PRODUCT" : Use only a single product as context for the
  /// recommendation. Typically used on pages like add-to-cart or product
  /// details.
  /// - "MULTIPLE_CONTEXT_PRODUCTS" : Use one or multiple products as context
  /// for the recommendation. Typically used on shopping cart pages.
  core.String? contextProductsType;

  $ModelFrequentlyBoughtTogetherFeaturesConfig({this.contextProductsType});

  $ModelFrequentlyBoughtTogetherFeaturesConfig.fromJson(core.Map json_)
    : this(contextProductsType: json_['contextProductsType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contextProductsType != null)
      'contextProductsType': contextProductsType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelGardenSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelGardenSource
class $ModelGardenSource {
  /// The model garden source model resource name.
  ///
  /// Required.
  core.String? publicModelName;

  /// Whether to avoid pulling the model from the HF cache.
  ///
  /// Optional.
  core.bool? skipHfModelCache;

  /// The model garden source model version ID.
  ///
  /// Optional.
  core.String? versionId;

  $ModelGardenSource({
    this.publicModelName,
    this.skipHfModelCache,
    this.versionId,
  });

  $ModelGardenSource.fromJson(core.Map json_)
    : this(
        publicModelName: json_['publicModelName'] as core.String?,
        skipHfModelCache: json_['skipHfModelCache'] as core.bool?,
        versionId: json_['versionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (publicModelName != null) 'publicModelName': publicModelName!,
    if (skipHfModelCache != null) 'skipHfModelCache': skipHfModelCache!,
    if (versionId != null) 'versionId': versionId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfigEmailAlertConfig
class $ModelMonitoringAlertConfigEmailAlertConfig {
  /// The email addresses to send the alert.
  core.List<core.String>? userEmails;

  $ModelMonitoringAlertConfigEmailAlertConfig({this.userEmails});

  $ModelMonitoringAlertConfigEmailAlertConfig.fromJson(core.Map json_)
    : this(
        userEmails:
            (json_['userEmails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userEmails != null) 'userEmails': userEmails!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelOriginalModelInfo
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelOriginalModelInfo
class $ModelOriginalModelInfo {
  /// The resource name of the Model this Model is a copy of, including the
  /// revision.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
  ///
  /// Output only.
  core.String? model;

  $ModelOriginalModelInfo({this.model});

  $ModelOriginalModelInfo.fromJson(core.Map json_)
    : this(model: json_['model'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ModelServingConfigList
/// - retail:v2alpha : GoogleCloudRetailV2alphaModelServingConfigList
/// - retail:v2beta : GoogleCloudRetailV2betaModelServingConfigList
class $ModelServingConfigList {
  /// A set of valid serving configs that may be used for `PAGE_OPTIMIZATION`.
  ///
  /// Optional.
  core.List<core.String>? servingConfigIds;

  $ModelServingConfigList({this.servingConfigIds});

  $ModelServingConfigList.fromJson(core.Map json_)
    : this(
        servingConfigIds:
            (json_['servingConfigIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (servingConfigIds != null) 'servingConfigIds': servingConfigIds!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelSourceInfo
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelSourceInfo
/// - datacatalog:v1 : GoogleCloudDatacatalogV1VertexModelSourceInfo
class $ModelSourceInfo {
  /// If this Model is copy of another Model.
  ///
  /// If true then source_type pertains to the original.
  core.bool? copy;

  /// Type of the model source.
  /// Possible string values are:
  /// - "MODEL_SOURCE_TYPE_UNSPECIFIED" : Should not be used.
  /// - "AUTOML" : The Model is uploaded by automl training pipeline.
  /// - "CUSTOM" : The Model is uploaded by user or custom training pipeline.
  /// - "BQML" : The Model is registered and sync'ed from BigQuery ML.
  /// - "MODEL_GARDEN" : The Model is saved or tuned from Model Garden.
  /// - "GENIE" : The Model is saved or tuned from Genie.
  /// - "CUSTOM_TEXT_EMBEDDING" : The Model is uploaded by text embedding
  /// finetuning pipeline.
  /// - "MARKETPLACE" : The Model is saved or tuned from Marketplace.
  core.String? sourceType;

  $ModelSourceInfo({this.copy, this.sourceType});

  $ModelSourceInfo.fromJson(core.Map json_)
    : this(
        copy: json_['copy'] as core.bool?,
        sourceType: json_['sourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (copy != null) 'copy': copy!,
    if (sourceType != null) 'sourceType': sourceType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ModelVersionCheckpoint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ModelVersionCheckpoint
class $ModelVersionCheckpoint {
  /// The ID of the checkpoint.
  core.String? checkpointId;

  /// The epoch of the checkpoint.
  core.String? epoch;

  /// The step of the checkpoint.
  core.String? step;

  $ModelVersionCheckpoint({this.checkpointId, this.epoch, this.step});

  $ModelVersionCheckpoint.fromJson(core.Map json_)
    : this(
        checkpointId: json_['checkpointId'] as core.String?,
        epoch: json_['epoch'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (epoch != null) 'epoch': epoch!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : Money
/// - aiplatform:v1 : GoogleTypeMoney
/// - aiplatform:v1beta1 : GoogleTypeMoney
/// - androidpublisher:v3 : Money
/// - apigee:v1 : GoogleTypeMoney
/// - authorizedbuyersmarketplace:v1 : Money
/// - authorizedbuyersmarketplace:v1alpha : Money
/// - authorizedbuyersmarketplace:v1beta : Money
/// - billingbudgets:v1 : GoogleTypeMoney
/// - billingbudgets:v1beta1 : GoogleTypeMoney
/// - cloudbilling:v1 : Money
/// - cloudbilling:v1beta : Money
/// - cloudchannel:v1 : GoogleTypeMoney
/// - compute:alpha : Money
/// - contentwarehouse:v1 : GoogleTypeMoney
/// - displayvideo:v2 : Money
/// - displayvideo:v3 : Money
/// - displayvideo:v4 : Money
/// - documentai:v1 : GoogleTypeMoney
/// - documentai:v1beta3 : GoogleTypeMoney
/// - domains:v1 : Money
/// - domains:v1alpha2 : Money
/// - domains:v1beta1 : Money
/// - jobs:v3 : Money
/// - jobs:v3p1beta1 : Money
/// - jobs:v4 : Money
/// - migrationcenter:v1 : Money
/// - migrationcenter:v1alpha1 : Money
/// - mybusinessbusinessinformation:v1 : Money
/// - places:v1 : GoogleTypeMoney
/// - recommender:v1 : GoogleTypeMoney
/// - recommender:v1beta1 : GoogleTypeMoney
/// - servicecontrol:v1 : Money
/// - solar:v1 : Money
class $Money {
  /// The three-letter currency code defined in ISO 4217.
  core.String? currencyCode;

  /// Number of nano (10^-9) units of the amount.
  ///
  /// The value must be between -999,999,999 and +999,999,999 inclusive. If
  /// `units` is positive, `nanos` must be positive or zero. If `units` is zero,
  /// `nanos` can be positive, zero, or negative. If `units` is negative,
  /// `nanos` must be negative or zero. For example $-1.75 is represented as
  /// `units`=-1 and `nanos`=-750,000,000.
  core.int? nanos;

  /// The whole units of the amount.
  ///
  /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
  core.String? units;

  $Money({this.currencyCode, this.nanos, this.units});

  $Money.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        nanos: json_['nanos'] as core.int?,
        units: json_['units'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (nanos != null) 'nanos': nanos!,
    if (units != null) 'units': units!,
  };
}

/// Used by:
///
/// - monitoring:v1 : MonitoredResource
/// - monitoring:v3 : MonitoredResource
class $MonitoredResource {
  /// Values for all of the labels listed in the associated monitored resource
  /// descriptor.
  ///
  /// For example, Compute Engine VM instances use the labels "project_id",
  /// "instance_id", and "zone".
  ///
  /// Required.
  core.Map<core.String, core.String>? labels;

  /// The monitored resource type.
  ///
  /// This field must match the type field of a MonitoredResourceDescriptor
  /// object. For example, the type of a Compute Engine VM instance is
  /// gce_instance. For a list of types, see Monitoring resource types
  /// (https://cloud.google.com/monitoring/api/resources) and Logging resource
  /// types (https://cloud.google.com/logging/docs/api/v2/resource-list).
  ///
  /// Required.
  core.String? type;

  $MonitoredResource({this.labels, this.type});

  $MonitoredResource.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - logging:v2 : MonitoredResourceMetadata
/// - monitoring:v3 : MonitoredResourceMetadata
class $MonitoredResourceMetadata {
  /// Values for predefined system metadata labels.
  ///
  /// System labels are a kind of metadata extracted by Google, including
  /// "machine_image", "vpc", "subnet_id", "security_group", "name", etc. System
  /// label values can be only strings, Boolean values, or a list of strings.
  /// For example: { "name": "my-test-instance", "security_group": \["a", "b",
  /// "c"\], "spot_instance": false }
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? systemLabels;

  /// A map of user-defined metadata labels.
  ///
  /// Output only.
  core.Map<core.String, core.String>? userLabels;

  $MonitoredResourceMetadata({this.systemLabels, this.userLabels});

  $MonitoredResourceMetadata.fromJson(core.Map json_)
    : this(
        systemLabels:
            json_.containsKey('systemLabels')
                ? json_['systemLabels'] as core.Map<core.String, core.dynamic>
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (systemLabels != null) 'systemLabels': systemLabels!,
    if (userLabels != null) 'userLabels': userLabels!,
  };
}

/// Used by:
///
/// - gkehub:v1 : MonitoringConfig
/// - gkehub:v1alpha : MonitoringConfig
/// - gkehub:v1beta : MonitoringConfig
/// - gkehub:v1beta1 : MonitoringConfig
class $MonitoringConfig {
  /// Cluster name used to report metrics.
  ///
  /// For Anthos on VMWare/Baremetal/MultiCloud clusters, it would be in format
  /// {cluster_type}/{cluster_name}, e.g., "awsClusters/cluster_1".
  ///
  /// Optional.
  core.String? cluster;

  /// For GKE and Multicloud clusters, this is the UUID of the cluster resource.
  ///
  /// For VMWare and Baremetal clusters, this is the kube-system UID.
  ///
  /// Optional.
  core.String? clusterHash;

  /// Kubernetes system metrics, if available, are written to this prefix.
  ///
  /// This defaults to kubernetes.io for GKE, and kubernetes.io/anthos for
  /// Anthos eventually. Noted: Anthos MultiCloud will have kubernetes.io prefix
  /// today but will migration to be under kubernetes.io/anthos.
  ///
  /// Optional.
  core.String? kubernetesMetricsPrefix;

  /// Location used to report Metrics
  ///
  /// Optional.
  core.String? location;

  /// Project used to report Metrics
  ///
  /// Optional.
  core.String? projectId;

  $MonitoringConfig({
    this.cluster,
    this.clusterHash,
    this.kubernetesMetricsPrefix,
    this.location,
    this.projectId,
  });

  $MonitoringConfig.fromJson(core.Map json_)
    : this(
        cluster: json_['cluster'] as core.String?,
        clusterHash: json_['clusterHash'] as core.String?,
        kubernetesMetricsPrefix:
            json_['kubernetesMetricsPrefix'] as core.String?,
        location: json_['location'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cluster != null) 'cluster': cluster!,
    if (clusterHash != null) 'clusterHash': clusterHash!,
    if (kubernetesMetricsPrefix != null)
      'kubernetesMetricsPrefix': kubernetesMetricsPrefix!,
    if (location != null) 'location': location!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : MonitoringDestination
/// - serviceusage:v1 : MonitoringDestination
/// - serviceusage:v1beta1 : MonitoringDestination
class $MonitoringDestination {
  /// Types of the metrics to report to this monitoring destination.
  ///
  /// Each type must be defined in Service.metrics section.
  core.List<core.String>? metrics;

  /// The monitored resource type.
  ///
  /// The type must be defined in Service.monitored_resources section.
  core.String? monitoredResource;

  $MonitoringDestination({this.metrics, this.monitoredResource});

  $MonitoringDestination.fromJson(core.Map json_)
    : this(
        metrics:
            (json_['metrics'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        monitoredResource: json_['monitoredResource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metrics != null) 'metrics': metrics!,
    if (monitoredResource != null) 'monitoredResource': monitoredResource!,
  };
}

/// Used by:
///
/// - netapp:v1 : MonthlySchedule
/// - netapp:v1beta1 : MonthlySchedule
class $MonthlySchedule {
  /// Set the day or days of the month to make a snapshot (1-31).
  ///
  /// Accepts a comma separated number of days. Defaults to '1'.
  core.String? daysOfMonth;

  /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
  core.double? hour;

  /// Set the minute of the hour to start the snapshot (0-59), defaults to the
  /// top of the hour (0).
  core.double? minute;

  /// The maximum number of Snapshots to keep for the hourly schedule
  core.double? snapshotsToKeep;

  $MonthlySchedule({
    this.daysOfMonth,
    this.hour,
    this.minute,
    this.snapshotsToKeep,
  });

  $MonthlySchedule.fromJson(core.Map json_)
    : this(
        daysOfMonth: json_['daysOfMonth'] as core.String?,
        hour: (json_['hour'] as core.num?)?.toDouble(),
        minute: (json_['minute'] as core.num?)?.toDouble(),
        snapshotsToKeep: (json_['snapshotsToKeep'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (daysOfMonth != null) 'daysOfMonth': daysOfMonth!,
    if (hour != null) 'hour': hour!,
    if (minute != null) 'minute': minute!,
    if (snapshotsToKeep != null) 'snapshotsToKeep': snapshotsToKeep!,
  };
}

/// Used by:
///
/// - netapp:v1 : MountOption
/// - netapp:v1beta1 : MountOption
class $MountOption {
  /// Export string
  core.String? export;

  /// Full export string
  core.String? exportFull;

  /// Instructions for mounting
  core.String? instructions;

  /// IP Address.
  ///
  /// Output only.
  core.String? ipAddress;

  /// Protocol to mount with.
  /// Possible string values are:
  /// - "PROTOCOLS_UNSPECIFIED" : Unspecified protocol
  /// - "NFSV3" : NFS V3 protocol
  /// - "NFSV4" : NFS V4 protocol
  /// - "SMB" : SMB protocol
  core.String? protocol;

  $MountOption({
    this.export,
    this.exportFull,
    this.instructions,
    this.ipAddress,
    this.protocol,
  });

  $MountOption.fromJson(core.Map json_)
    : this(
        export: json_['export'] as core.String?,
        exportFull: json_['exportFull'] as core.String?,
        instructions: json_['instructions'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        protocol: json_['protocol'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (export != null) 'export': export!,
    if (exportFull != null) 'exportFull': exportFull!,
    if (instructions != null) 'instructions': instructions!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (protocol != null) 'protocol': protocol!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v2 : MoveFolderRequest
/// - cloudresourcemanager:v2beta1 : MoveFolderRequest
class $MoveFolderRequest {
  /// The resource name of the Folder or Organization to reparent the folder
  /// under.
  ///
  /// Must be of the form `folders/{folder_id}` or `organizations/{org_id}`.
  ///
  /// Required.
  core.String? destinationParent;

  $MoveFolderRequest({this.destinationParent});

  $MoveFolderRequest.fromJson(core.Map json_)
    : this(destinationParent: json_['destinationParent'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationParent != null) 'destinationParent': destinationParent!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1MoveImpact
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1MoveImpact
class $MoveImpact {
  /// Explanation of the impact.
  core.String? detail;

  $MoveImpact({this.detail});

  $MoveImpact.fromJson(core.Map json_)
    : this(detail: json_['detail'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (detail != null) 'detail': detail!,
  };
}

/// Used by:
///
/// - metastore:v1 : MoveTableToDatabaseRequest
/// - metastore:v1alpha : MoveTableToDatabaseRequest
/// - metastore:v1beta : MoveTableToDatabaseRequest
class $MoveTableToDatabaseRequest {
  /// The name of the database where the table resides.
  ///
  /// Required.
  core.String? dbName;

  /// The name of the database where the table should be moved.
  ///
  /// Required.
  core.String? destinationDbName;

  /// The name of the table to be moved.
  ///
  /// Required.
  core.String? tableName;

  $MoveTableToDatabaseRequest({
    this.dbName,
    this.destinationDbName,
    this.tableName,
  });

  $MoveTableToDatabaseRequest.fromJson(core.Map json_)
    : this(
        dbName: json_['dbName'] as core.String?,
        destinationDbName: json_['destinationDbName'] as core.String?,
        tableName: json_['tableName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dbName != null) 'dbName': dbName!,
    if (destinationDbName != null) 'destinationDbName': destinationDbName!,
    if (tableName != null) 'tableName': tableName!,
  };
}

/// Used by:
///
/// - gkehub:v1 : MultiCloudCluster
/// - gkehub:v1alpha : MultiCloudCluster
/// - gkehub:v1beta : MultiCloudCluster
class $MultiCloudCluster {
  /// If cluster_missing is set then it denotes that
  /// API(gkemulticloud.googleapis.com) resource for this GKE Multi-Cloud
  /// cluster no longer exists.
  ///
  /// Output only.
  core.bool? clusterMissing;

  /// Self-link of the Google Cloud resource for the GKE Multi-Cloud cluster.
  ///
  /// For example:
  /// //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/awsClusters/my-cluster
  /// //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/azureClusters/my-cluster
  /// //gkemulticloud.googleapis.com/projects/my-project/locations/us-west1-a/attachedClusters/my-cluster
  ///
  /// Immutable.
  core.String? resourceLink;

  $MultiCloudCluster({this.clusterMissing, this.resourceLink});

  $MultiCloudCluster.fromJson(core.Map json_)
    : this(
        clusterMissing: json_['clusterMissing'] as core.bool?,
        resourceLink: json_['resourceLink'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterMissing != null) 'clusterMissing': clusterMissing!,
    if (resourceLink != null) 'resourceLink': resourceLink!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : MultiClusterIngressFeatureSpec
/// - gkehub:v1beta : MultiClusterIngressFeatureSpec
class $MultiClusterIngressFeatureSpec {
  /// Deprecated: This field will be ignored and should not be set.
  ///
  /// Customer's billing structure.
  /// Possible string values are:
  /// - "BILLING_UNSPECIFIED" : Unknown
  /// - "PAY_AS_YOU_GO" : User pays a fee per-endpoint.
  /// - "ANTHOS_LICENSE" : User is paying for Anthos as a whole.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? billing;

  /// Fully-qualified Membership name which hosts the MultiClusterIngress CRD.
  ///
  /// Example: `projects/foo-proj/locations/global/memberships/bar`
  core.String? configMembership;

  $MultiClusterIngressFeatureSpec({this.billing, this.configMembership});

  $MultiClusterIngressFeatureSpec.fromJson(core.Map json_)
    : this(
        billing: json_['billing'] as core.String?,
        configMembership: json_['configMembership'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (billing != null) 'billing': billing!,
    if (configMembership != null) 'configMembership': configMembership!,
  };
}

/// Used by:
///
/// - compute:alpha : MultiMigResourcePolicies
/// - compute:beta : MultiMigResourcePolicies
class $MultiMigResourcePolicies {
  /// The URL of the workload policy for this multi-MIG.
  ///
  /// It can be a full or partial URL. For example, the following are all valid
  /// URLs to a workload policy: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /resourcePolicies/resourcePolicy -
  /// projects/project/regions/region/resourcePolicies/resourcePolicy -
  /// regions/region/resourcePolicies/resourcePolicy
  core.String? workloadPolicy;

  $MultiMigResourcePolicies({this.workloadPolicy});

  $MultiMigResourcePolicies.fromJson(core.Map json_)
    : this(workloadPolicy: json_['workloadPolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (workloadPolicy != null) 'workloadPolicy': workloadPolicy!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MySqlPlugin
/// - migrationcenter:v1alpha1 : MySqlPlugin
class $MySqlPlugin {
  /// The plugin is active.
  ///
  /// Required.
  core.bool? enabled;

  /// The plugin name.
  ///
  /// Required.
  core.String? plugin;

  /// The plugin version.
  ///
  /// Required.
  core.String? version;

  $MySqlPlugin({this.enabled, this.plugin, this.version});

  $MySqlPlugin.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        plugin: json_['plugin'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (plugin != null) 'plugin': plugin!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : MySqlReplicaConfiguration
/// - sqladmin:v1beta4 : MySqlReplicaConfiguration
class $MySqlReplicaConfiguration {
  /// PEM representation of the trusted CA's x509 certificate.
  core.String? caCertificate;

  /// PEM representation of the replica's x509 certificate.
  core.String? clientCertificate;

  /// PEM representation of the replica's private key.
  ///
  /// The corresponding public key is encoded in the client's certificate.
  core.String? clientKey;

  /// Seconds to wait between connect retries.
  ///
  /// MySQL's default is 60 seconds.
  core.int? connectRetryInterval;

  /// Path to a SQL dump file in Google Cloud Storage from which the replica
  /// instance is to be created.
  ///
  /// The URI is in the form gs://bucketName/fileName. Compressed gzip files
  /// (.gz) are also supported. Dumps have the binlog co-ordinates from which
  /// replication begins. This can be accomplished by setting --master-data to 1
  /// when using mysqldump.
  core.String? dumpFilePath;

  /// This is always `sql#mysqlReplicaConfiguration`.
  core.String? kind;

  /// Interval in milliseconds between replication heartbeats.
  core.String? masterHeartbeatPeriod;

  /// The password for the replication connection.
  core.String? password;

  /// A list of permissible ciphers to use for SSL encryption.
  core.String? sslCipher;

  /// The username for the replication connection.
  core.String? username;

  /// Whether or not to check the primary instance's Common Name value in the
  /// certificate that it sends during the SSL handshake.
  core.bool? verifyServerCertificate;

  $MySqlReplicaConfiguration({
    this.caCertificate,
    this.clientCertificate,
    this.clientKey,
    this.connectRetryInterval,
    this.dumpFilePath,
    this.kind,
    this.masterHeartbeatPeriod,
    this.password,
    this.sslCipher,
    this.username,
    this.verifyServerCertificate,
  });

  $MySqlReplicaConfiguration.fromJson(core.Map json_)
    : this(
        caCertificate: json_['caCertificate'] as core.String?,
        clientCertificate: json_['clientCertificate'] as core.String?,
        clientKey: json_['clientKey'] as core.String?,
        connectRetryInterval: json_['connectRetryInterval'] as core.int?,
        dumpFilePath: json_['dumpFilePath'] as core.String?,
        kind: json_['kind'] as core.String?,
        masterHeartbeatPeriod: json_['masterHeartbeatPeriod'] as core.String?,
        password: json_['password'] as core.String?,
        sslCipher: json_['sslCipher'] as core.String?,
        username: json_['username'] as core.String?,
        verifyServerCertificate: json_['verifyServerCertificate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caCertificate != null) 'caCertificate': caCertificate!,
    if (clientCertificate != null) 'clientCertificate': clientCertificate!,
    if (clientKey != null) 'clientKey': clientKey!,
    if (connectRetryInterval != null)
      'connectRetryInterval': connectRetryInterval!,
    if (dumpFilePath != null) 'dumpFilePath': dumpFilePath!,
    if (kind != null) 'kind': kind!,
    if (masterHeartbeatPeriod != null)
      'masterHeartbeatPeriod': masterHeartbeatPeriod!,
    if (password != null) 'password': password!,
    if (sslCipher != null) 'sslCipher': sslCipher!,
    if (username != null) 'username': username!,
    if (verifyServerCertificate != null)
      'verifyServerCertificate': verifyServerCertificate!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MySqlStorageEngineDetails
/// - migrationcenter:v1alpha1 : MySqlStorageEngineDetails
class $MySqlStorageEngineDetails {
  /// The number of encrypted tables.
  ///
  /// Optional.
  core.int? encryptedTableCount;

  /// The storage engine.
  ///
  /// Required.
  /// Possible string values are:
  /// - "ENGINE_UNSPECIFIED" : Unspecified storage engine.
  /// - "INNODB" : InnoDB.
  /// - "MYISAM" : MyISAM.
  /// - "MEMORY" : Memory.
  /// - "CSV" : CSV.
  /// - "ARCHIVE" : Archive.
  /// - "BLACKHOLE" : Blackhole.
  /// - "NDB" : NDB.
  /// - "MERGE" : Merge.
  /// - "FEDERATED" : Federated.
  /// - "EXAMPLE" : Example.
  /// - "OTHER" : Other.
  core.String? engine;

  /// The number of tables.
  ///
  /// Optional.
  core.int? tableCount;

  $MySqlStorageEngineDetails({
    this.encryptedTableCount,
    this.engine,
    this.tableCount,
  });

  $MySqlStorageEngineDetails.fromJson(core.Map json_)
    : this(
        encryptedTableCount: json_['encryptedTableCount'] as core.int?,
        engine: json_['engine'] as core.String?,
        tableCount: json_['tableCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encryptedTableCount != null)
      'encryptedTableCount': encryptedTableCount!,
    if (engine != null) 'engine': engine!,
    if (tableCount != null) 'tableCount': tableCount!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MySqlVariable
/// - migrationcenter:v1alpha1 : MySqlVariable
class $MySqlVariable {
  /// The variable category.
  ///
  /// Required.
  core.String? category;

  /// The variable value.
  ///
  /// Required.
  core.String? value;

  /// The variable name.
  ///
  /// Required.
  core.String? variable;

  $MySqlVariable({this.category, this.value, this.variable});

  $MySqlVariable.fromJson(core.Map json_)
    : this(
        category: json_['category'] as core.String?,
        value: json_['value'] as core.String?,
        variable: json_['variable'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (value != null) 'value': value!,
    if (variable != null) 'variable': variable!,
  };
}

/// Used by:
///
/// - datastream:v1 : MysqlObjectIdentifier
/// - datastream:v1alpha1 : MysqlObjectIdentifier
class $MysqlObjectIdentifier {
  /// The database name.
  ///
  /// Required.
  core.String? database;

  /// The table name.
  ///
  /// Required.
  core.String? table;

  $MysqlObjectIdentifier({this.database, this.table});

  $MysqlObjectIdentifier.fromJson(core.Map json_)
    : this(
        database: json_['database'] as core.String?,
        table: json_['table'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (database != null) 'database': database!,
    if (table != null) 'table': table!,
  };
}

/// Used by:
///
/// - compute:alpha : NamedPort
/// - compute:beta : NamedPort
/// - compute:v1 : NamedPort
class $NamedPort {
  /// The name for this named port.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// The port number, which can be a value between 1 and 65535.
  core.int? port;

  $NamedPort({this.name, this.port});

  $NamedPort.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - gkehub:v1 : NamespaceLifecycleState
/// - gkehub:v1alpha : NamespaceLifecycleState
/// - gkehub:v1beta : NamespaceLifecycleState
class $NamespaceLifecycleState {
  /// The current state of the Namespace resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The namespace is being created.
  /// - "READY" : The namespace active.
  /// - "DELETING" : The namespace is being deleted.
  /// - "UPDATING" : The namespace is being updated.
  core.String? code;

  $NamespaceLifecycleState({this.code});

  $NamespaceLifecycleState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
class $NasJobSpecMultiTrialAlgorithmSpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces.
  ///
  /// Required.
  core.String? metricId;

  $NasJobSpecMultiTrialAlgorithmSpecMetricSpec({this.goal, this.metricId});

  $NasJobSpecMultiTrialAlgorithmSpecMetricSpec.fromJson(core.Map json_)
    : this(
        goal: json_['goal'] as core.String?,
        metricId: json_['metricId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (goal != null) 'goal': goal!,
    if (metricId != null) 'metricId': metricId!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : NatInfo
/// - networkmanagement:v1beta1 : NatInfo
class $NatInfo {
  /// The name of Cloud NAT Gateway.
  ///
  /// Only valid when type is CLOUD_NAT.
  core.String? natGatewayName;

  /// URI of the network where NAT translation takes place.
  core.String? networkUri;

  /// Destination IP address after NAT translation.
  core.String? newDestinationIp;

  /// Destination port after NAT translation.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? newDestinationPort;

  /// Source IP address after NAT translation.
  core.String? newSourceIp;

  /// Source port after NAT translation.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? newSourcePort;

  /// Destination IP address before NAT translation.
  core.String? oldDestinationIp;

  /// Destination port before NAT translation.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? oldDestinationPort;

  /// Source IP address before NAT translation.
  core.String? oldSourceIp;

  /// Source port before NAT translation.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? oldSourcePort;

  /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
  core.String? protocol;

  /// Uri of the Cloud Router.
  ///
  /// Only valid when type is CLOUD_NAT.
  core.String? routerUri;

  /// Type of NAT.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Type is unspecified.
  /// - "INTERNAL_TO_EXTERNAL" : From Compute Engine instance's internal address
  /// to external address.
  /// - "EXTERNAL_TO_INTERNAL" : From Compute Engine instance's external address
  /// to internal address.
  /// - "CLOUD_NAT" : Cloud NAT Gateway.
  /// - "PRIVATE_SERVICE_CONNECT" : Private service connect NAT.
  core.String? type;

  $NatInfo({
    this.natGatewayName,
    this.networkUri,
    this.newDestinationIp,
    this.newDestinationPort,
    this.newSourceIp,
    this.newSourcePort,
    this.oldDestinationIp,
    this.oldDestinationPort,
    this.oldSourceIp,
    this.oldSourcePort,
    this.protocol,
    this.routerUri,
    this.type,
  });

  $NatInfo.fromJson(core.Map json_)
    : this(
        natGatewayName: json_['natGatewayName'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        newDestinationIp: json_['newDestinationIp'] as core.String?,
        newDestinationPort: json_['newDestinationPort'] as core.int?,
        newSourceIp: json_['newSourceIp'] as core.String?,
        newSourcePort: json_['newSourcePort'] as core.int?,
        oldDestinationIp: json_['oldDestinationIp'] as core.String?,
        oldDestinationPort: json_['oldDestinationPort'] as core.int?,
        oldSourceIp: json_['oldSourceIp'] as core.String?,
        oldSourcePort: json_['oldSourcePort'] as core.int?,
        protocol: json_['protocol'] as core.String?,
        routerUri: json_['routerUri'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (natGatewayName != null) 'natGatewayName': natGatewayName!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (newDestinationIp != null) 'newDestinationIp': newDestinationIp!,
    if (newDestinationPort != null) 'newDestinationPort': newDestinationPort!,
    if (newSourceIp != null) 'newSourceIp': newSourceIp!,
    if (newSourcePort != null) 'newSourcePort': newSourcePort!,
    if (oldDestinationIp != null) 'oldDestinationIp': oldDestinationIp!,
    if (oldDestinationPort != null) 'oldDestinationPort': oldDestinationPort!,
    if (oldSourceIp != null) 'oldSourceIp': oldSourceIp!,
    if (oldSourcePort != null) 'oldSourcePort': oldSourcePort!,
    if (protocol != null) 'protocol': protocol!,
    if (routerUri != null) 'routerUri': routerUri!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : NatIpInfoNatIpInfoMapping
/// - compute:beta : NatIpInfoNatIpInfoMapping
/// - compute:v1 : NatIpInfoNatIpInfoMapping
class $NatIpInfoNatIpInfoMapping {
  /// Specifies whether NAT IP is auto or manual.
  /// Possible string values are:
  /// - "AUTO"
  /// - "MANUAL"
  core.String? mode;

  /// NAT IP address.
  ///
  /// For example: 203.0.113.11.
  core.String? natIp;

  /// Specifies whether NAT IP is currently serving at least one endpoint or
  /// not.
  /// Possible string values are:
  /// - "IN_USE"
  /// - "UNUSED"
  core.String? usage;

  $NatIpInfoNatIpInfoMapping({this.mode, this.natIp, this.usage});

  $NatIpInfoNatIpInfoMapping.fromJson(core.Map json_)
    : this(
        mode: json_['mode'] as core.String?,
        natIp: json_['natIp'] as core.String?,
        usage: json_['usage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
    if (natIp != null) 'natIp': natIp!,
    if (usage != null) 'usage': usage!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : NativeContentPositionAssignedTargetingOptionDetails
/// - displayvideo:v3 : NativeContentPositionAssignedTargetingOptionDetails
/// - displayvideo:v4 : NativeContentPositionAssignedTargetingOptionDetails
class $NativeContentPositionAssignedTargetingOptionDetails {
  /// The content position.
  ///
  /// Required.
  /// Possible string values are:
  /// - "NATIVE_CONTENT_POSITION_UNSPECIFIED" : Native content position is not
  /// specified in this version. This enum is a place holder for a default value
  /// and does not represent a real native content position.
  /// - "NATIVE_CONTENT_POSITION_UNKNOWN" : The native content position is
  /// unknown.
  /// - "NATIVE_CONTENT_POSITION_IN_ARTICLE" : Native content position is
  /// in-article, i.e., ads appear between the paragraphs of pages.
  /// - "NATIVE_CONTENT_POSITION_IN_FEED" : Native content position is in-feed,
  /// i.e., ads appear in a scrollable stream of content. A feed is typically
  /// editorial (e.g. a list of articles or news) or listings (e.g. a list of
  /// products or services).
  /// - "NATIVE_CONTENT_POSITION_PERIPHERAL" : Native content position is
  /// peripheral, i.e., ads appear outside of core content on pages, such as the
  /// right- or left-hand side of the page.
  /// - "NATIVE_CONTENT_POSITION_RECOMMENDATION" : Native content position is
  /// recommendation, i.e., ads appear in sections for recommended content.
  core.String? contentPosition;

  $NativeContentPositionAssignedTargetingOptionDetails({this.contentPosition});

  $NativeContentPositionAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentPosition: json_['contentPosition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentPosition != null) 'contentPosition': contentPosition!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : NativeContentPositionTargetingOptionDetails
/// - displayvideo:v3 : NativeContentPositionTargetingOptionDetails
/// - displayvideo:v4 : NativeContentPositionTargetingOptionDetails
class $NativeContentPositionTargetingOptionDetails {
  /// The content position.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NATIVE_CONTENT_POSITION_UNSPECIFIED" : Native content position is not
  /// specified in this version. This enum is a place holder for a default value
  /// and does not represent a real native content position.
  /// - "NATIVE_CONTENT_POSITION_UNKNOWN" : The native content position is
  /// unknown.
  /// - "NATIVE_CONTENT_POSITION_IN_ARTICLE" : Native content position is
  /// in-article, i.e., ads appear between the paragraphs of pages.
  /// - "NATIVE_CONTENT_POSITION_IN_FEED" : Native content position is in-feed,
  /// i.e., ads appear in a scrollable stream of content. A feed is typically
  /// editorial (e.g. a list of articles or news) or listings (e.g. a list of
  /// products or services).
  /// - "NATIVE_CONTENT_POSITION_PERIPHERAL" : Native content position is
  /// peripheral, i.e., ads appear outside of core content on pages, such as the
  /// right- or left-hand side of the page.
  /// - "NATIVE_CONTENT_POSITION_RECOMMENDATION" : Native content position is
  /// recommendation, i.e., ads appear in sections for recommended content.
  core.String? contentPosition;

  $NativeContentPositionTargetingOptionDetails({this.contentPosition});

  $NativeContentPositionTargetingOptionDetails.fromJson(core.Map json_)
    : this(contentPosition: json_['contentPosition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentPosition != null) 'contentPosition': contentPosition!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaNaturalLanguageQueryUnderstandingConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaNaturalLanguageQueryUnderstandingConfig
class $NaturalLanguageQueryUnderstandingConfig {
  /// Mode of Natural Language Query Understanding.
  ///
  /// If this field is unset, the behavior defaults to
  /// NaturalLanguageQueryUnderstandingConfig.Mode.DISABLED.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value.
  /// - "DISABLED" : Natural Language Query Understanding is disabled.
  /// - "ENABLED" : Natural Language Query Understanding is enabled.
  core.String? mode;

  $NaturalLanguageQueryUnderstandingConfig({this.mode});

  $NaturalLanguageQueryUnderstandingConfig.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NearestNeighborQueryEmbedding
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NearestNeighborQueryEmbedding
class $NearestNeighborQueryEmbedding {
  /// Individual value in the embedding.
  ///
  /// Optional.
  core.List<core.double>? value;

  $NearestNeighborQueryEmbedding({this.value});

  $NearestNeighborQueryEmbedding.fromJson(core.Map json_)
    : this(
        value:
            (json_['value'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NearestNeighborQueryNumericFilter
class $NearestNeighborQueryNumericFilter {
  /// Column name in BigQuery that used as filters.
  ///
  /// Required.
  core.String? name;

  /// This MUST be specified for queries and must NOT be specified for database
  /// points.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : Unspecified operator.
  /// - "LESS" : Entities are eligible if their value is \< the query's.
  /// - "LESS_EQUAL" : Entities are eligible if their value is \<= the query's.
  /// - "EQUAL" : Entities are eligible if their value is == the query's.
  /// - "GREATER_EQUAL" : Entities are eligible if their value is \>= the
  /// query's.
  /// - "GREATER" : Entities are eligible if their value is \> the query's.
  /// - "NOT_EQUAL" : Entities are eligible if their value is != the query's.
  core.String? op;

  /// double value type.
  core.double? valueDouble;

  /// float value type.
  core.double? valueFloat;

  /// int value type.
  core.String? valueInt;

  $NearestNeighborQueryNumericFilter({
    this.name,
    this.op,
    this.valueDouble,
    this.valueFloat,
    this.valueInt,
  });

  $NearestNeighborQueryNumericFilter.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        op: json_['op'] as core.String?,
        valueDouble: (json_['valueDouble'] as core.num?)?.toDouble(),
        valueFloat: (json_['valueFloat'] as core.num?)?.toDouble(),
        valueInt: json_['valueInt'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (op != null) 'op': op!,
    if (valueDouble != null) 'valueDouble': valueDouble!,
    if (valueFloat != null) 'valueFloat': valueFloat!,
    if (valueInt != null) 'valueInt': valueInt!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NearestNeighborQueryParameters
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NearestNeighborQueryParameters
class $NearestNeighborQueryParameters {
  /// The number of neighbors to find via approximate search before exact
  /// reordering is performed; if set, this value must be \> neighbor_count.
  ///
  /// Optional.
  core.int? approximateNeighborCandidates;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance.
  ///
  /// This value increase result in both search accuracy and latency increase.
  /// The value should be between 0.0 and 1.0.
  ///
  /// Optional.
  core.double? leafNodesSearchFraction;

  $NearestNeighborQueryParameters({
    this.approximateNeighborCandidates,
    this.leafNodesSearchFraction,
  });

  $NearestNeighborQueryParameters.fromJson(core.Map json_)
    : this(
        approximateNeighborCandidates:
            json_['approximateNeighborCandidates'] as core.int?,
        leafNodesSearchFraction:
            (json_['leafNodesSearchFraction'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (approximateNeighborCandidates != null)
      'approximateNeighborCandidates': approximateNeighborCandidates!,
    if (leafNodesSearchFraction != null)
      'leafNodesSearchFraction': leafNodesSearchFraction!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NearestNeighborQueryStringFilter
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NearestNeighborQueryStringFilter
class $NearestNeighborQueryStringFilter {
  /// The allowed tokens.
  ///
  /// Optional.
  core.List<core.String>? allowTokens;

  /// The denied tokens.
  ///
  /// Optional.
  core.List<core.String>? denyTokens;

  /// Column names in BigQuery that used as filters.
  ///
  /// Required.
  core.String? name;

  $NearestNeighborQueryStringFilter({
    this.allowTokens,
    this.denyTokens,
    this.name,
  });

  $NearestNeighborQueryStringFilter.fromJson(core.Map json_)
    : this(
        allowTokens:
            (json_['allowTokens'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        denyTokens:
            (json_['denyTokens'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowTokens != null) 'allowTokens': allowTokens!,
    if (denyTokens != null) 'denyTokens': denyTokens!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : NegativeKeyword
/// - displayvideo:v3 : NegativeKeyword
/// - displayvideo:v4 : NegativeKeyword
class $NegativeKeyword {
  /// The negatively targeted keyword, for example `car insurance`.
  ///
  /// Must be UTF-8 encoded with a maximum size of 255 bytes. Maximum number of
  /// characters is 80. Maximum number of words is 10. Valid characters are
  /// restricted to ASCII characters only. The only URL-escaping permitted is
  /// for representing whitespace between words. Leading or trailing whitespace
  /// is ignored.
  ///
  /// Required. Immutable.
  core.String? keywordValue;

  /// The resource name of the negative keyword.
  ///
  /// Output only.
  core.String? name;

  $NegativeKeyword({this.keywordValue, this.name});

  $NegativeKeyword.fromJson(core.Map json_)
    : this(
        keywordValue: json_['keywordValue'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (keywordValue != null) 'keywordValue': keywordValue!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : NegativeKeywordList
/// - displayvideo:v3 : NegativeKeywordList
/// - displayvideo:v4 : NegativeKeywordList
class $NegativeKeywordList {
  /// The unique ID of the advertiser the negative keyword list belongs to.
  ///
  /// Output only.
  core.String? advertiserId;

  /// The display name of the negative keyword list.
  ///
  /// Must be UTF-8 encoded with a maximum size of 255 bytes.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the negative keyword list.
  ///
  /// Output only.
  core.String? name;

  /// The unique ID of the negative keyword list.
  ///
  /// Assigned by the system.
  ///
  /// Output only.
  core.String? negativeKeywordListId;

  /// Number of line items that are directly targeting this negative keyword
  /// list.
  ///
  /// Output only.
  core.String? targetedLineItemCount;

  $NegativeKeywordList({
    this.advertiserId,
    this.displayName,
    this.name,
    this.negativeKeywordListId,
    this.targetedLineItemCount,
  });

  $NegativeKeywordList.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        negativeKeywordListId: json_['negativeKeywordListId'] as core.String?,
        targetedLineItemCount: json_['targetedLineItemCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (negativeKeywordListId != null)
      'negativeKeywordListId': negativeKeywordListId!,
    if (targetedLineItemCount != null)
      'targetedLineItemCount': targetedLineItemCount!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : NegativeKeywordListAssignedTargetingOptionDetails
/// - displayvideo:v3 : NegativeKeywordListAssignedTargetingOptionDetails
/// - displayvideo:v4 : NegativeKeywordListAssignedTargetingOptionDetails
class $NegativeKeywordListAssignedTargetingOptionDetails {
  /// ID of the negative keyword list.
  ///
  /// Should refer to the negative_keyword_list_id field of a
  /// NegativeKeywordList resource.
  ///
  /// Required.
  core.String? negativeKeywordListId;

  $NegativeKeywordListAssignedTargetingOptionDetails({
    this.negativeKeywordListId,
  });

  $NegativeKeywordListAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        negativeKeywordListId: json_['negativeKeywordListId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (negativeKeywordListId != null)
      'negativeKeywordListId': negativeKeywordListId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Neighbor
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Neighbor
class $Neighbor {
  /// The neighbor distance.
  ///
  /// Output only.
  core.double? neighborDistance;

  /// The neighbor id.
  ///
  /// Output only.
  core.String? neighborId;

  $Neighbor({this.neighborDistance, this.neighborId});

  $Neighbor.fromJson(core.Map json_)
    : this(
        neighborDistance: (json_['neighborDistance'] as core.num?)?.toDouble(),
        neighborId: json_['neighborId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (neighborDistance != null) 'neighborDistance': neighborDistance!,
    if (neighborId != null) 'neighborId': neighborId!,
  };
}

/// Used by:
///
/// - appengine:v1 : Network
/// - appengine:v1beta : Network
class $Network {
  /// List of ports, or port pairs, to forward from the virtual machine to the
  /// application container.
  ///
  /// Only applicable in the App Engine flexible environment.
  core.List<core.String>? forwardedPorts;

  /// The IP mode for instances.
  ///
  /// Only applicable in the App Engine flexible environment.
  /// Possible string values are:
  /// - "INSTANCE_IP_MODE_UNSPECIFIED" : Unspecified is treated as EXTERNAL.
  /// - "EXTERNAL" : Instances are created with both internal and external IP
  /// addresses.
  /// - "INTERNAL" : Instances are created with internal IP addresses only.
  core.String? instanceIpMode;

  /// Tag to apply to the instance during creation.
  ///
  /// Only applicable in the App Engine flexible environment.
  core.String? instanceTag;

  /// Google Compute Engine network where the virtual machines are created.
  ///
  /// Specify the short name, not the resource path.Defaults to default.
  core.String? name;

  /// Enable session affinity.
  ///
  /// Only applicable in the App Engine flexible environment.
  core.bool? sessionAffinity;

  /// Google Cloud Platform sub-network where the virtual machines are created.
  ///
  /// Specify the short name, not the resource path.If a subnetwork name is
  /// specified, a network name will also be required unless it is for the
  /// default network. If the network that the instance is being created in is a
  /// Legacy network, then the IP address is allocated from the IPv4Range. If
  /// the network that the instance is being created in is an auto Subnet Mode
  /// Network, then only network name should be specified (not the
  /// subnetwork_name) and the IP address is created from the IPCidrRange of the
  /// subnetwork that exists in that zone for that network. If the network that
  /// the instance is being created in is a custom Subnet Mode Network, then the
  /// subnetwork_name must be specified and the IP address is created from the
  /// IPCidrRange of the subnetwork.If specified, the subnetwork must exist in
  /// the same region as the App Engine flexible environment application.
  core.String? subnetworkName;

  $Network({
    this.forwardedPorts,
    this.instanceIpMode,
    this.instanceTag,
    this.name,
    this.sessionAffinity,
    this.subnetworkName,
  });

  $Network.fromJson(core.Map json_)
    : this(
        forwardedPorts:
            (json_['forwardedPorts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        instanceIpMode: json_['instanceIpMode'] as core.String?,
        instanceTag: json_['instanceTag'] as core.String?,
        name: json_['name'] as core.String?,
        sessionAffinity: json_['sessionAffinity'] as core.bool?,
        subnetworkName: json_['subnetworkName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (forwardedPorts != null) 'forwardedPorts': forwardedPorts!,
    if (instanceIpMode != null) 'instanceIpMode': instanceIpMode!,
    if (instanceTag != null) 'instanceTag': instanceTag!,
    if (name != null) 'name': name!,
    if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
    if (subnetworkName != null) 'subnetworkName': subnetworkName!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : NetworkAddress
/// - migrationcenter:v1alpha1 : NetworkAddress
class $NetworkAddress {
  /// Whether DHCP is used to assign addresses.
  /// Possible string values are:
  /// - "ADDRESS_ASSIGNMENT_UNSPECIFIED" : Unknown (default value).
  /// - "ADDRESS_ASSIGNMENT_STATIC" : Statically assigned IP.
  /// - "ADDRESS_ASSIGNMENT_DHCP" : Dynamically assigned IP (DHCP).
  core.String? assignment;

  /// Broadcast address.
  core.String? bcast;

  /// Fully qualified domain name.
  core.String? fqdn;

  /// Assigned or configured IP Address.
  core.String? ipAddress;

  /// Subnet mask.
  core.String? subnetMask;

  $NetworkAddress({
    this.assignment,
    this.bcast,
    this.fqdn,
    this.ipAddress,
    this.subnetMask,
  });

  $NetworkAddress.fromJson(core.Map json_)
    : this(
        assignment: json_['assignment'] as core.String?,
        bcast: json_['bcast'] as core.String?,
        fqdn: json_['fqdn'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        subnetMask: json_['subnetMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assignment != null) 'assignment': assignment!,
    if (bcast != null) 'bcast': bcast!,
    if (fqdn != null) 'fqdn': fqdn!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (subnetMask != null) 'subnetMask': subnetMask!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkAttachmentConnectedEndpoint
/// - compute:beta : NetworkAttachmentConnectedEndpoint
/// - compute:v1 : NetworkAttachmentConnectedEndpoint
class $NetworkAttachmentConnectedEndpoint {
  /// The IPv4 address assigned to the producer instance network interface.
  ///
  /// This value will be a range in case of Serverless.
  core.String? ipAddress;

  /// The IPv6 address assigned to the producer instance network interface.
  ///
  /// This is only assigned when the stack types of both the instance network
  /// interface and the consumer subnet are IPv4_IPv6.
  core.String? ipv6Address;

  /// The project id or number of the interface to which the IP was assigned.
  core.String? projectIdOrNum;

  /// Alias IP ranges from the same subnetwork.
  core.List<core.String>? secondaryIpCidrRanges;

  /// The status of a connected endpoint to this network attachment.
  /// Possible string values are:
  /// - "ACCEPTED" : The consumer allows traffic from the producer to reach its
  /// VPC.
  /// - "CLOSED" : The consumer network attachment no longer exists.
  /// - "NEEDS_ATTENTION" : The consumer needs to take further action before
  /// traffic can be served.
  /// - "PENDING" : The consumer neither allows nor prohibits traffic from the
  /// producer to reach its VPC.
  /// - "REJECTED" : The consumer prohibits traffic from the producer to reach
  /// its VPC.
  /// - "STATUS_UNSPECIFIED"
  core.String? status;

  /// The subnetwork used to assign the IP to the producer instance network
  /// interface.
  core.String? subnetwork;

  /// The CIDR range of the subnet from which the IPv4 internal IP was allocated
  /// from.
  ///
  /// Output only.
  core.String? subnetworkCidrRange;

  $NetworkAttachmentConnectedEndpoint({
    this.ipAddress,
    this.ipv6Address,
    this.projectIdOrNum,
    this.secondaryIpCidrRanges,
    this.status,
    this.subnetwork,
    this.subnetworkCidrRange,
  });

  $NetworkAttachmentConnectedEndpoint.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
        projectIdOrNum: json_['projectIdOrNum'] as core.String?,
        secondaryIpCidrRanges:
            (json_['secondaryIpCidrRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        status: json_['status'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
        subnetworkCidrRange: json_['subnetworkCidrRange'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
    if (projectIdOrNum != null) 'projectIdOrNum': projectIdOrNum!,
    if (secondaryIpCidrRanges != null)
      'secondaryIpCidrRanges': secondaryIpCidrRanges!,
    if (status != null) 'status': status!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
    if (subnetworkCidrRange != null)
      'subnetworkCidrRange': subnetworkCidrRange!,
  };
}

/// Used by:
///
/// - alloydb:v1 : NetworkConfig
/// - alloydb:v1alpha : NetworkConfig
/// - alloydb:v1beta : NetworkConfig
class $NetworkConfig00 {
  /// Name of the allocated IP range for the private IP AlloyDB cluster, for
  /// example: "google-managed-services-default".
  ///
  /// If set, the instance IPs for this cluster will be created in the allocated
  /// range. The range name must comply with RFC 1035. Specifically, the name
  /// must be 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with
  /// Cloud SQL.
  ///
  /// Optional.
  core.String? allocatedIpRange;

  /// The resource link for the VPC network in which cluster resources are
  /// created and from which they are accessible via Private IP.
  ///
  /// The network must belong to the same project as the cluster. It is
  /// specified in the form:
  /// `projects/{project_number}/global/networks/{network_id}`. This is required
  /// to create a cluster.
  ///
  /// Optional.
  core.String? network;

  $NetworkConfig00({this.allocatedIpRange, this.network});

  $NetworkConfig00.fromJson(core.Map json_)
    : this(
        allocatedIpRange: json_['allocatedIpRange'] as core.String?,
        network: json_['network'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allocatedIpRange != null) 'allocatedIpRange': allocatedIpRange!,
    if (network != null) 'network': network!,
  };
}

/// Used by:
///
/// - tpu:v2 : NetworkConfig
/// - tpu:v2alpha1 : NetworkConfig
class $NetworkConfig01 {
  /// Allows the TPU node to send and receive packets with non-matching
  /// destination or source IPs.
  ///
  /// This is required if you plan to use the TPU workers to forward routes.
  core.bool? canIpForward;

  /// Indicates that external IP addresses would be associated with the TPU
  /// workers.
  ///
  /// If set to false, the specified subnetwork or network should have Private
  /// Google Access enabled.
  core.bool? enableExternalIps;

  /// The name of the network for the TPU node.
  ///
  /// It must be a preexisting Google Compute Engine network. If none is
  /// provided, "default" will be used.
  core.String? network;

  /// Specifies networking queue count for TPU VM instance's network interface.
  ///
  /// Optional.
  core.int? queueCount;

  /// The name of the subnetwork for the TPU node.
  ///
  /// It must be a preexisting Google Compute Engine subnetwork. If none is
  /// provided, "default" will be used.
  core.String? subnetwork;

  $NetworkConfig01({
    this.canIpForward,
    this.enableExternalIps,
    this.network,
    this.queueCount,
    this.subnetwork,
  });

  $NetworkConfig01.fromJson(core.Map json_)
    : this(
        canIpForward: json_['canIpForward'] as core.bool?,
        enableExternalIps: json_['enableExternalIps'] as core.bool?,
        network: json_['network'] as core.String?,
        queueCount: json_['queueCount'] as core.int?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canIpForward != null) 'canIpForward': canIpForward!,
    if (enableExternalIps != null) 'enableExternalIps': enableExternalIps!,
    if (network != null) 'network': network!,
    if (queueCount != null) 'queueCount': queueCount!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEdgeSecurityService
/// - compute:beta : NetworkEdgeSecurityService
/// - compute:v1 : NetworkEdgeSecurityService
class $NetworkEdgeSecurityService {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// NetworkEdgeSecurityService. An up-to-date fingerprint must be provided in
  /// order to update the NetworkEdgeSecurityService, otherwise the request will
  /// fail with error 412 conditionNotMet. To see the latest fingerprint, make a
  /// get() request to retrieve a NetworkEdgeSecurityService.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#networkEdgeSecurityService for NetworkEdgeSecurityServices
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the resource resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// The resource URL for the network edge security service associated with
  /// this network edge security service.
  core.String? securityPolicy;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL for this resource with the resource id.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  $NetworkEdgeSecurityService({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.region,
    this.securityPolicy,
    this.selfLink,
    this.selfLinkWithId,
  });

  $NetworkEdgeSecurityService.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        fingerprint: json_['fingerprint'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        region: json_['region'] as core.String?,
        securityPolicy: json_['securityPolicy'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        selfLinkWithId: json_['selfLinkWithId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (region != null) 'region': region!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpoint
/// - compute:beta : NetworkEndpoint
/// - compute:v1 : NetworkEndpoint
class $NetworkEndpoint00 {
  /// Optional metadata defined as annotations on the network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// Represents the port number to which PSC consumer sends packets.
  ///
  /// Optional. Only valid for network endpoint groups created with
  /// GCE_VM_IP_PORTMAP endpoint type.
  core.int? clientDestinationPort;

  /// Optional fully qualified domain name of network endpoint.
  ///
  /// This can only be specified when NetworkEndpointGroup.network_endpoint_type
  /// is NON_GCP_FQDN_PORT.
  core.String? fqdn;

  /// The name or a URL of VM instance of this network endpoint.
  ///
  /// Optional, the field presence depends on the network endpoint type. The
  /// field is required for network endpoints of type GCE_VM_IP and
  /// GCE_VM_IP_PORT. The instance must be in the same zone of network endpoint
  /// group (for zonal NEGs) or in the zone within the region of the NEG (for
  /// regional NEGs). If the ipAddress is specified, it must belongs to the VM
  /// instance. The name must be 1-63 characters long, and comply with RFC1035
  /// or be a valid URL pointing to an existing instance.
  core.String? instance;

  /// Optional IPv4 address of network endpoint.
  ///
  /// The IP address must belong to a VM in Compute Engine (either the primary
  /// IP or as part of an aliased IP range). If the IP address is not specified,
  /// then the primary IP address for the VM instance in the network that the
  /// network endpoint group belongs to will be used. This field is redundant
  /// and need not be set for network endpoints of type GCE_VM_IP. If set, it
  /// must be set to the primary internal IP address of the attached VM instance
  /// that matches the subnetwork of the NEG. The primary internal IP address
  /// from any NIC of a multi-NIC VM instance can be added to a NEG as long as
  /// it matches the NEG subnetwork.
  core.String? ipAddress;

  /// Optional IPv6 address of network endpoint.
  core.String? ipv6Address;

  /// Optional port number of network endpoint.
  ///
  /// If not specified, the defaultPort for the network endpoint group will be
  /// used. This field can not be set for network endpoints of type GCE_VM_IP.
  core.int? port;

  $NetworkEndpoint00({
    this.annotations,
    this.clientDestinationPort,
    this.fqdn,
    this.instance,
    this.ipAddress,
    this.ipv6Address,
    this.port,
  });

  $NetworkEndpoint00.fromJson(core.Map json_)
    : this(
        annotations: (json_['annotations']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        clientDestinationPort: json_['clientDestinationPort'] as core.int?,
        fqdn: json_['fqdn'] as core.String?,
        instance: json_['instance'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (clientDestinationPort != null)
      'clientDestinationPort': clientDestinationPort!,
    if (fqdn != null) 'fqdn': fqdn!,
    if (instance != null) 'instance': instance!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - tpu:v1 : NetworkEndpoint
/// - tpu:v1alpha1 : NetworkEndpoint
class $NetworkEndpoint01 {
  /// The IP address of this network endpoint.
  core.String? ipAddress;

  /// The port of this network endpoint.
  core.int? port;

  $NetworkEndpoint01({this.ipAddress, this.port});

  $NetworkEndpoint01.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupAppEngine
/// - compute:beta : NetworkEndpointGroupAppEngine
/// - compute:v1 : NetworkEndpointGroupAppEngine
class $NetworkEndpointGroupAppEngine {
  /// Optional serving service.
  ///
  /// The service name is case-sensitive and must be 1-63 characters long.
  /// Example value: default, my-service.
  core.String? service;

  /// An URL mask is one of the main components of the Cloud Function.
  ///
  /// A template to parse service and version fields from a request URL. URL
  /// mask allows for routing to multiple App Engine services without having to
  /// create multiple Network Endpoint Groups and backend services. For example,
  /// the request URLs foo1-dot-appname.appspot.com/v1 and
  /// foo1-dot-appname.appspot.com/v2 can be backed by the same Serverless NEG
  /// with URL mask \<service\>-dot-appname.appspot.com/\<version\>. The URL
  /// mask will parse them to { service = "foo1", version = "v1" } and { service
  /// = "foo1", version = "v2" } respectively.
  core.String? urlMask;

  /// Optional serving version.
  ///
  /// The version name is case-sensitive and must be 1-100 characters long.
  /// Example value: v1, v2.
  core.String? version;

  $NetworkEndpointGroupAppEngine({this.service, this.urlMask, this.version});

  $NetworkEndpointGroupAppEngine.fromJson(core.Map json_)
    : this(
        service: json_['service'] as core.String?,
        urlMask: json_['urlMask'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
    if (urlMask != null) 'urlMask': urlMask!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupCloudFunction
/// - compute:beta : NetworkEndpointGroupCloudFunction
/// - compute:v1 : NetworkEndpointGroupCloudFunction
class $NetworkEndpointGroupCloudFunction {
  /// A user-defined name of the Cloud Function.
  ///
  /// The function name is case-sensitive and must be 1-63 characters long.
  /// Example value: func1.
  core.String? function;

  /// An URL mask is one of the main components of the Cloud Function.
  ///
  /// A template to parse function field from a request URL. URL mask allows for
  /// routing to multiple Cloud Functions without having to create multiple
  /// Network Endpoint Groups and backend services. For example, request URLs
  /// mydomain.com/function1 and mydomain.com/function2 can be backed by the
  /// same Serverless NEG with URL mask /\<function\>. The URL mask will parse
  /// them to { function = "function1" } and { function = "function2" }
  /// respectively.
  core.String? urlMask;

  $NetworkEndpointGroupCloudFunction({this.function, this.urlMask});

  $NetworkEndpointGroupCloudFunction.fromJson(core.Map json_)
    : this(
        function: json_['function'] as core.String?,
        urlMask: json_['urlMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (function != null) 'function': function!,
    if (urlMask != null) 'urlMask': urlMask!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupCloudRun
/// - compute:beta : NetworkEndpointGroupCloudRun
/// - compute:v1 : NetworkEndpointGroupCloudRun
class $NetworkEndpointGroupCloudRun {
  /// Cloud Run service is the main resource of Cloud Run.
  ///
  /// The service must be 1-63 characters long, and comply with RFC1035. Example
  /// value: "run-service".
  core.String? service;

  /// Optional Cloud Run tag represents the "named-revision" to provide
  /// additional fine-grained traffic routing information.
  ///
  /// The tag must be 1-63 characters long, and comply with RFC1035. Example
  /// value: "revision-0010".
  core.String? tag;

  /// An URL mask is one of the main components of the Cloud Function.
  ///
  /// A template to parse \<service\> and \<tag\> fields from a request URL. URL
  /// mask allows for routing to multiple Run services without having to create
  /// multiple network endpoint groups and backend services. For example,
  /// request URLs foo1.domain.com/bar1 and foo1.domain.com/bar2 can be backed
  /// by the same Serverless Network Endpoint Group (NEG) with URL mask
  /// \<tag\>.domain.com/\<service\>. The URL mask will parse them to {
  /// service="bar1", tag="foo1" } and { service="bar2", tag="foo2" }
  /// respectively.
  core.String? urlMask;

  $NetworkEndpointGroupCloudRun({this.service, this.tag, this.urlMask});

  $NetworkEndpointGroupCloudRun.fromJson(core.Map json_)
    : this(
        service: json_['service'] as core.String?,
        tag: json_['tag'] as core.String?,
        urlMask: json_['urlMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
    if (tag != null) 'tag': tag!,
    if (urlMask != null) 'urlMask': urlMask!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupLbNetworkEndpointGroup
/// - compute:beta : NetworkEndpointGroupLbNetworkEndpointGroup
class $NetworkEndpointGroupLbNetworkEndpointGroup {
  /// The default port used if the port number is not specified in the network
  /// endpoint.
  ///
  /// If the network endpoint type is either GCE_VM_IP, SERVERLESS or
  /// PRIVATE_SERVICE_CONNECT, this field must not be specified. \[Deprecated\]
  /// This field is deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? defaultPort;

  /// The URL of the network to which all network endpoints in the NEG belong.
  ///
  /// Uses default project network if unspecified. \[Deprecated\] This field is
  /// deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? network;

  /// Optional URL of the subnetwork to which all network endpoints in the NEG
  /// belong.
  ///
  /// \[Deprecated\] This field is deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? subnetwork;

  /// The URL of the zone where the network endpoint group is located.
  ///
  /// \[Deprecated\] This field is deprecated.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $NetworkEndpointGroupLbNetworkEndpointGroup({
    this.defaultPort,
    this.network,
    this.subnetwork,
    this.zone,
  });

  $NetworkEndpointGroupLbNetworkEndpointGroup.fromJson(core.Map json_)
    : this(
        defaultPort: json_['defaultPort'] as core.int?,
        network: json_['network'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultPort != null) 'defaultPort': defaultPort!,
    if (network != null) 'network': network!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupPscData
/// - compute:beta : NetworkEndpointGroupPscData
/// - compute:v1 : NetworkEndpointGroupPscData
class $NetworkEndpointGroupPscData {
  /// Address allocated from given subnetwork for PSC.
  ///
  /// This IP address acts as a VIP for a PSC NEG, allowing it to act as an
  /// endpoint in L7 PSC-XLB.
  ///
  /// Output only.
  core.String? consumerPscAddress;

  /// The psc producer port is used to connect PSC NEG with specific port on the
  /// PSC Producer side; should only be used for the PRIVATE_SERVICE_CONNECT NEG
  /// type
  core.int? producerPort;

  /// The PSC connection id of the PSC Network Endpoint Group Consumer.
  ///
  /// Output only.
  core.String? pscConnectionId;

  /// The connection status of the PSC Forwarding Rule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACCEPTED" : The connection has been accepted by the producer.
  /// - "CLOSED" : The connection has been closed by the producer and will not
  /// serve traffic going forward.
  /// - "NEEDS_ATTENTION" : The connection has been accepted by the producer,
  /// but the producer needs to take further action before the forwarding rule
  /// can serve traffic.
  /// - "PENDING" : The connection is pending acceptance by the producer.
  /// - "REJECTED" : The connection has been rejected by the producer.
  /// - "STATUS_UNSPECIFIED"
  core.String? pscConnectionStatus;

  $NetworkEndpointGroupPscData({
    this.consumerPscAddress,
    this.producerPort,
    this.pscConnectionId,
    this.pscConnectionStatus,
  });

  $NetworkEndpointGroupPscData.fromJson(core.Map json_)
    : this(
        consumerPscAddress: json_['consumerPscAddress'] as core.String?,
        producerPort: json_['producerPort'] as core.int?,
        pscConnectionId: json_['pscConnectionId'] as core.String?,
        pscConnectionStatus: json_['pscConnectionStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumerPscAddress != null) 'consumerPscAddress': consumerPscAddress!,
    if (producerPort != null) 'producerPort': producerPort!,
    if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
    if (pscConnectionStatus != null)
      'pscConnectionStatus': pscConnectionStatus!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkEndpointGroupServerlessDeployment
/// - compute:beta : NetworkEndpointGroupServerlessDeployment
class $NetworkEndpointGroupServerlessDeployment {
  /// The platform of the backend target(s) of this NEG.
  ///
  /// The only supported value is API Gateway: apigateway.googleapis.com.
  core.String? platform;

  /// The user-defined name of the workload/instance.
  ///
  /// This value must be provided explicitly or in the urlMask. The resource
  /// identified by this value is platform-specific and is as follows: 1. API
  /// Gateway: The gateway ID 2. App Engine: The service name 3. Cloud
  /// Functions: The function name 4. Cloud Run: The service name
  core.String? resource;

  /// An URL mask is one of the main components of the Cloud Function.
  ///
  /// A template to parse platform-specific fields from a request URL. URL mask
  /// allows for routing to multiple resources on the same serverless platform
  /// without having to create multiple Network Endpoint Groups and backend
  /// resources. The fields parsed by this template are platform-specific and
  /// are as follows: 1. API Gateway: The gateway ID 2. App Engine: The service
  /// and version 3. Cloud Functions: The function name 4. Cloud Run: The
  /// service and tag
  core.String? urlMask;

  /// The optional resource version.
  ///
  /// The version identified by this value is platform-specific and is follows:
  /// 1. API Gateway: Unused 2. App Engine: The service version 3. Cloud
  /// Functions: Unused 4. Cloud Run: The service tag
  core.String? version;

  $NetworkEndpointGroupServerlessDeployment({
    this.platform,
    this.resource,
    this.urlMask,
    this.version,
  });

  $NetworkEndpointGroupServerlessDeployment.fromJson(core.Map json_)
    : this(
        platform: json_['platform'] as core.String?,
        resource: json_['resource'] as core.String?,
        urlMask: json_['urlMask'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (platform != null) 'platform': platform!,
    if (resource != null) 'resource': resource!,
    if (urlMask != null) 'urlMask': urlMask!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : NetworkInfo
/// - networkmanagement:v1beta1 : NetworkInfo
class $NetworkInfo {
  /// Name of a Compute Engine network.
  core.String? displayName;

  /// The IP range of the subnet matching the source IP address of the test.
  core.String? matchedIpRange;

  /// URI of the subnet matching the source IP address of the test.
  core.String? matchedSubnetUri;

  /// The region of the subnet matching the source IP address of the test.
  core.String? region;

  /// URI of a Compute Engine network.
  core.String? uri;

  $NetworkInfo({
    this.displayName,
    this.matchedIpRange,
    this.matchedSubnetUri,
    this.region,
    this.uri,
  });

  $NetworkInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        matchedIpRange: json_['matchedIpRange'] as core.String?,
        matchedSubnetUri: json_['matchedSubnetUri'] as core.String?,
        region: json_['region'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (matchedIpRange != null) 'matchedIpRange': matchedIpRange!,
    if (matchedSubnetUri != null) 'matchedSubnetUri': matchedSubnetUri!,
    if (region != null) 'region': region!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : NetworkInterface
/// - vmmigration:v1alpha1 : NetworkInterface
class $NetworkInterface {
  /// The external IP to define in the NIC.
  ///
  /// Optional.
  core.String? externalIp;

  /// The internal IP to define in the NIC.
  ///
  /// The formats accepted are: `ephemeral` \ ipv4 address \ a named address
  /// resource full path.
  ///
  /// Optional.
  core.String? internalIp;

  /// The network to connect the NIC to.
  ///
  /// Optional.
  core.String? network;

  /// The networking tier used for optimizing connectivity between instances and
  /// systems on the internet.
  ///
  /// Applies only for external ephemeral IP addresses. If left empty, will
  /// default to PREMIUM.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "COMPUTE_ENGINE_NETWORK_TIER_UNSPECIFIED" : An unspecified network tier.
  /// Will be used as PREMIUM.
  /// - "NETWORK_TIER_STANDARD" : A standard network tier.
  /// - "NETWORK_TIER_PREMIUM" : A premium network tier.
  core.String? networkTier;

  /// The subnetwork to connect the NIC to.
  ///
  /// Optional.
  core.String? subnetwork;

  $NetworkInterface({
    this.externalIp,
    this.internalIp,
    this.network,
    this.networkTier,
    this.subnetwork,
  });

  $NetworkInterface.fromJson(core.Map json_)
    : this(
        externalIp: json_['externalIp'] as core.String?,
        internalIp: json_['internalIp'] as core.String?,
        network: json_['network'] as core.String?,
        networkTier: json_['networkTier'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalIp != null) 'externalIp': externalIp!,
    if (internalIp != null) 'internalIp': internalIp!,
    if (network != null) 'network': network!,
    if (networkTier != null) 'networkTier': networkTier!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkPeeringConnectionStatusConsensusState
/// - compute:beta : NetworkPeeringConnectionStatusConsensusState
class $NetworkPeeringConnectionStatusConsensusState {
  /// The status of the delete request.
  /// Possible string values are:
  /// - "DELETE_ACKNOWLEDGED" : Both network admins have agreed this consensus
  /// peering connection can be deleted.
  /// - "DELETE_STATUS_UNSPECIFIED"
  /// - "LOCAL_DELETE_REQUESTED" : Network admin has requested deletion of this
  /// peering connection.
  /// - "PEER_DELETE_REQUESTED" : The peer network admin has requested deletion
  /// of this peering connection.
  core.String? deleteStatus;

  /// The status of the update request.
  /// Possible string values are:
  /// - "IN_SYNC" : No pending configuration update proposals to the peering
  /// connection.
  /// - "PENDING_LOCAL_ACKNOWLEDMENT" : The peer network admin has made an
  /// updatePeering call. The change is awaiting acknowledgment from this
  /// peering's network admin.
  /// - "PENDING_PEER_ACKNOWLEDGEMENT" : The local network admin has made an
  /// updatePeering call. The change is awaiting acknowledgment from the peer
  /// network admin.
  /// - "UPDATE_STATUS_UNSPECIFIED"
  core.String? updateStatus;

  $NetworkPeeringConnectionStatusConsensusState({
    this.deleteStatus,
    this.updateStatus,
  });

  $NetworkPeeringConnectionStatusConsensusState.fromJson(core.Map json_)
    : this(
        deleteStatus: json_['deleteStatus'] as core.String?,
        updateStatus: json_['updateStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deleteStatus != null) 'deleteStatus': deleteStatus!,
    if (updateStatus != null) 'updateStatus': updateStatus!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkPeeringConnectionStatusTrafficConfiguration
/// - compute:beta : NetworkPeeringConnectionStatusTrafficConfiguration
class $NetworkPeeringConnectionStatusTrafficConfiguration {
  /// Whether custom routes are being exported to the peer network.
  core.bool? exportCustomRoutesToPeer;

  /// Whether subnet routes with public IP ranges are being exported to the peer
  /// network.
  core.bool? exportSubnetRoutesWithPublicIpToPeer;

  /// Whether custom routes are being imported from the peer network.
  core.bool? importCustomRoutesFromPeer;

  /// Whether subnet routes with public IP ranges are being imported from the
  /// peer network.
  core.bool? importSubnetRoutesWithPublicIpFromPeer;

  /// Which IP version(s) of traffic and routes are being imported or exported
  /// between peer networks.
  /// Possible string values are:
  /// - "IPV4_IPV6" : This Peering will allow IPv4 traffic and routes to be
  /// exchanged. Additionally if the matching peering is IPV4_IPV6, IPv6 traffic
  /// and routes will be exchanged as well.
  /// - "IPV4_ONLY" : This Peering will only allow IPv4 traffic and routes to be
  /// exchanged, even if the matching peering is IPV4_IPV6.
  core.String? stackType;

  $NetworkPeeringConnectionStatusTrafficConfiguration({
    this.exportCustomRoutesToPeer,
    this.exportSubnetRoutesWithPublicIpToPeer,
    this.importCustomRoutesFromPeer,
    this.importSubnetRoutesWithPublicIpFromPeer,
    this.stackType,
  });

  $NetworkPeeringConnectionStatusTrafficConfiguration.fromJson(core.Map json_)
    : this(
        exportCustomRoutesToPeer:
            json_['exportCustomRoutesToPeer'] as core.bool?,
        exportSubnetRoutesWithPublicIpToPeer:
            json_['exportSubnetRoutesWithPublicIpToPeer'] as core.bool?,
        importCustomRoutesFromPeer:
            json_['importCustomRoutesFromPeer'] as core.bool?,
        importSubnetRoutesWithPublicIpFromPeer:
            json_['importSubnetRoutesWithPublicIpFromPeer'] as core.bool?,
        stackType: json_['stackType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportCustomRoutesToPeer != null)
      'exportCustomRoutesToPeer': exportCustomRoutesToPeer!,
    if (exportSubnetRoutesWithPublicIpToPeer != null)
      'exportSubnetRoutesWithPublicIpToPeer':
          exportSubnetRoutesWithPublicIpToPeer!,
    if (importCustomRoutesFromPeer != null)
      'importCustomRoutesFromPeer': importCustomRoutesFromPeer!,
    if (importSubnetRoutesWithPublicIpFromPeer != null)
      'importSubnetRoutesWithPublicIpFromPeer':
          importSubnetRoutesWithPublicIpFromPeer!,
    if (stackType != null) 'stackType': stackType!,
  };
}

/// Used by:
///
/// - compute:beta : NetworkPerformanceConfig
/// - compute:v1 : NetworkPerformanceConfig
class $NetworkPerformanceConfig00 {
  ///
  /// Possible string values are:
  /// - "DEFAULT"
  /// - "TIER_1"
  core.String? totalEgressBandwidthTier;

  $NetworkPerformanceConfig00({this.totalEgressBandwidthTier});

  $NetworkPerformanceConfig00.fromJson(core.Map json_)
    : this(
        totalEgressBandwidthTier:
            json_['totalEgressBandwidthTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (totalEgressBandwidthTier != null)
      'totalEgressBandwidthTier': totalEgressBandwidthTier!,
  };
}

/// Used by:
///
/// - container:v1 : NetworkPerformanceConfig
/// - container:v1beta1 : ClusterNetworkPerformanceConfig
class $NetworkPerformanceConfig01 {
  /// Specifies the total network bandwidth tier for the NodePool.
  /// Possible string values are:
  /// - "TIER_UNSPECIFIED" : Default value
  /// - "TIER_1" : Higher bandwidth, actual values based on VM size.
  core.String? totalEgressBandwidthTier;

  $NetworkPerformanceConfig01({this.totalEgressBandwidthTier});

  $NetworkPerformanceConfig01.fromJson(core.Map json_)
    : this(
        totalEgressBandwidthTier:
            json_['totalEgressBandwidthTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (totalEgressBandwidthTier != null)
      'totalEgressBandwidthTier': totalEgressBandwidthTier!,
  };
}

/// Used by:
///
/// - container:v1 : NetworkPolicy
/// - container:v1beta1 : NetworkPolicy
class $NetworkPolicy {
  /// Whether network policy is enabled on the cluster.
  core.bool? enabled;

  /// The selected network policy provider.
  /// Possible string values are:
  /// - "PROVIDER_UNSPECIFIED" : Not set
  /// - "CALICO" : Tigera (Calico Felix).
  core.String? provider;

  $NetworkPolicy({this.enabled, this.provider});

  $NetworkPolicy.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        provider: json_['provider'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (provider != null) 'provider': provider!,
  };
}

/// Used by:
///
/// - container:v1 : NetworkPolicyConfig
/// - container:v1beta1 : NetworkPolicyConfig
class $NetworkPolicyConfig {
  /// Whether NetworkPolicy is enabled for this cluster.
  core.bool? disabled;

  $NetworkPolicyConfig({this.disabled});

  $NetworkPolicyConfig.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkProfileLocation
/// - compute:beta : NetworkProfileLocation
/// - compute:v1 : NetworkProfileLocation
class $NetworkProfileLocation {
  core.String? name;

  ///
  /// Possible string values are:
  /// - "REGION"
  /// - "ZONE"
  core.String? scope;

  $NetworkProfileLocation({this.name, this.scope});

  $NetworkProfileLocation.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        scope: json_['scope'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - compute:beta : NetworkProfileNetworkFeatures
/// - compute:v1 : NetworkProfileNetworkFeatures
class $NetworkProfileNetworkFeatures {
  /// Specifies what address purposes are supported.
  ///
  /// If empty, all address purposes are supported.
  core.List<core.String>? addressPurposes;

  /// Specifies whether alias IP ranges (and secondary address ranges) are
  /// allowed.
  /// Possible string values are:
  /// - "ALIAS_IP_RANGES_ALLOWED"
  /// - "ALIAS_IP_RANGES_BLOCKED"
  core.String? allowAliasIpRanges;

  /// Specifies whether auto mode subnet creation is allowed.
  /// Possible string values are:
  /// - "AUTO_MODE_SUBNET_ALLOWED"
  /// - "AUTO_MODE_SUBNET_BLOCKED"
  core.String? allowAutoModeSubnet;

  /// Specifies whether firewalls for Class D address ranges are supported.
  /// Possible string values are:
  /// - "CLASS_D_FIREWALLS_ALLOWED"
  /// - "CLASS_D_FIREWALLS_BLOCKED"
  core.String? allowClassDFirewalls;

  /// Specifies whether cloud NAT creation is allowed.
  /// Possible string values are:
  /// - "CLOUD_NAT_ALLOWED"
  /// - "CLOUD_NAT_BLOCKED"
  core.String? allowCloudNat;

  /// Specifies whether cloud router creation is allowed.
  /// Possible string values are:
  /// - "CLOUD_ROUTER_ALLOWED"
  /// - "CLOUD_ROUTER_BLOCKED"
  core.String? allowCloudRouter;

  /// Specifies whether default NIC attachment is allowed.
  /// Possible string values are:
  /// - "DEFAULT_NIC_ATTACHMENT_ALLOWED"
  /// - "DEFAULT_NIC_ATTACHMENT_BLOCKED"
  core.String? allowDefaultNicAttachment;

  /// Specifies whether VMs are allowed to have external IP access on network
  /// interfaces connected to this VPC.
  /// Possible string values are:
  /// - "EXTERNAL_IP_ACCESS_ALLOWED"
  /// - "EXTERNAL_IP_ACCESS_BLOCKED"
  core.String? allowExternalIpAccess;

  /// Specifies whether Cloud Interconnect creation is allowed.
  /// Possible string values are:
  /// - "INTERCONNECT_ALLOWED"
  /// - "INTERCONNECT_BLOCKED"
  core.String? allowInterconnect;

  /// Specifies whether IP forwarding is allowed.
  /// Possible string values are:
  /// - "IP_FORWARDING_ALLOWED"
  /// - "IP_FORWARDING_BLOCKED"
  core.String? allowIpForwarding;

  /// Specifies whether cloud load balancing is allowed.
  /// Possible string values are:
  /// - "LOAD_BALANCING_ALLOWED"
  /// - "LOAD_BALANCING_BLOCKED"
  core.String? allowLoadBalancing;

  /// Specifies whether multi-nic in the same network is allowed.
  /// Possible string values are:
  /// - "MULTI_NIC_IN_SAME_NETWORK_ALLOWED"
  /// - "MULTI_NIC_IN_SAME_NETWORK_BLOCKED"
  core.String? allowMultiNicInSameNetwork;

  /// Specifies whether NCC is allowed.
  /// Possible string values are:
  /// - "NCC_ALLOWED"
  /// - "NCC_BLOCKED"
  core.String? allowNcc;

  /// Specifies whether VM network migration is allowed.
  /// Possible string values are:
  /// - "NETWORK_MIGRATION_ALLOWED"
  /// - "NETWORK_MIGRATION_BLOCKED"
  core.String? allowNetworkMigration;

  /// Specifies whether Packet Mirroring 1.0 is supported.
  /// Possible string values are:
  /// - "PACKET_MIRRORING_ALLOWED"
  /// - "PACKET_MIRRORING_BLOCKED"
  core.String? allowPacketMirroring;

  /// Specifies whether private Google access is allowed.
  /// Possible string values are:
  /// - "PRIVATE_GOOGLE_ACCESS_ALLOWED"
  /// - "PRIVATE_GOOGLE_ACCESS_BLOCKED"
  core.String? allowPrivateGoogleAccess;

  /// Specifies whether PSC creation is allowed.
  /// Possible string values are:
  /// - "PSC_ALLOWED"
  /// - "PSC_BLOCKED"
  core.String? allowPsc;

  /// Specifies whether unicast within the same network is allowed.
  /// Possible string values are:
  /// - "SAME_NETWORK_UNICAST_ALLOWED"
  /// - "SAME_NETWORK_UNICAST_BLOCKED"
  core.String? allowSameNetworkUnicast;

  /// Specifies whether static route creation is allowed.
  /// Possible string values are:
  /// - "STATIC_ROUTES_ALLOWED"
  /// - "STATIC_ROUTES_BLOCKED"
  core.String? allowStaticRoutes;

  /// Specifies whether sub interfaces are allowed.
  /// Possible string values are:
  /// - "SUBINTERFACES_ALLOWED"
  /// - "SUBINTERFACES_BLOCKED"
  core.String? allowSubInterfaces;

  /// Specifies whether VPC peering is allowed.
  /// Possible string values are:
  /// - "VPC_PEERING_ALLOWED"
  /// - "VPC_PEERING_BLOCKED"
  core.String? allowVpcPeering;

  /// Specifies whether VPN creation is allowed.
  /// Possible string values are:
  /// - "VPN_ALLOWED"
  /// - "VPN_BLOCKED"
  core.String? allowVpn;

  /// If set, limits the interface types that the network supports.
  ///
  /// If empty, all interface types are supported.
  core.List<core.String>? interfaceTypes;

  /// Specifies which subnetwork purposes are supported.
  core.List<core.String>? subnetPurposes;

  /// Specifies which subnetwork stack types are supported.
  core.List<core.String>? subnetStackTypes;

  /// Specifies which subnetwork purposes are supported.
  core.List<core.String>? subnetworkPurposes;

  /// Specifies which subnetwork stack types are supported.
  core.List<core.String>? subnetworkStackTypes;

  /// Specifies which type of unicast is supported.
  /// Possible string values are:
  /// - "UNICAST_SDN"
  /// - "UNICAST_ULL"
  core.String? unicast;

  $NetworkProfileNetworkFeatures({
    this.addressPurposes,
    this.allowAliasIpRanges,
    this.allowAutoModeSubnet,
    this.allowClassDFirewalls,
    this.allowCloudNat,
    this.allowCloudRouter,
    this.allowDefaultNicAttachment,
    this.allowExternalIpAccess,
    this.allowInterconnect,
    this.allowIpForwarding,
    this.allowLoadBalancing,
    this.allowMultiNicInSameNetwork,
    this.allowNcc,
    this.allowNetworkMigration,
    this.allowPacketMirroring,
    this.allowPrivateGoogleAccess,
    this.allowPsc,
    this.allowSameNetworkUnicast,
    this.allowStaticRoutes,
    this.allowSubInterfaces,
    this.allowVpcPeering,
    this.allowVpn,
    this.interfaceTypes,
    this.subnetPurposes,
    this.subnetStackTypes,
    this.subnetworkPurposes,
    this.subnetworkStackTypes,
    this.unicast,
  });

  $NetworkProfileNetworkFeatures.fromJson(core.Map json_)
    : this(
        addressPurposes:
            (json_['addressPurposes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        allowAliasIpRanges: json_['allowAliasIpRanges'] as core.String?,
        allowAutoModeSubnet: json_['allowAutoModeSubnet'] as core.String?,
        allowClassDFirewalls: json_['allowClassDFirewalls'] as core.String?,
        allowCloudNat: json_['allowCloudNat'] as core.String?,
        allowCloudRouter: json_['allowCloudRouter'] as core.String?,
        allowDefaultNicAttachment:
            json_['allowDefaultNicAttachment'] as core.String?,
        allowExternalIpAccess: json_['allowExternalIpAccess'] as core.String?,
        allowInterconnect: json_['allowInterconnect'] as core.String?,
        allowIpForwarding: json_['allowIpForwarding'] as core.String?,
        allowLoadBalancing: json_['allowLoadBalancing'] as core.String?,
        allowMultiNicInSameNetwork:
            json_['allowMultiNicInSameNetwork'] as core.String?,
        allowNcc: json_['allowNcc'] as core.String?,
        allowNetworkMigration: json_['allowNetworkMigration'] as core.String?,
        allowPacketMirroring: json_['allowPacketMirroring'] as core.String?,
        allowPrivateGoogleAccess:
            json_['allowPrivateGoogleAccess'] as core.String?,
        allowPsc: json_['allowPsc'] as core.String?,
        allowSameNetworkUnicast:
            json_['allowSameNetworkUnicast'] as core.String?,
        allowStaticRoutes: json_['allowStaticRoutes'] as core.String?,
        allowSubInterfaces: json_['allowSubInterfaces'] as core.String?,
        allowVpcPeering: json_['allowVpcPeering'] as core.String?,
        allowVpn: json_['allowVpn'] as core.String?,
        interfaceTypes:
            (json_['interfaceTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subnetPurposes:
            (json_['subnetPurposes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subnetStackTypes:
            (json_['subnetStackTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subnetworkPurposes:
            (json_['subnetworkPurposes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        subnetworkStackTypes:
            (json_['subnetworkStackTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        unicast: json_['unicast'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addressPurposes != null) 'addressPurposes': addressPurposes!,
    if (allowAliasIpRanges != null) 'allowAliasIpRanges': allowAliasIpRanges!,
    if (allowAutoModeSubnet != null)
      'allowAutoModeSubnet': allowAutoModeSubnet!,
    if (allowClassDFirewalls != null)
      'allowClassDFirewalls': allowClassDFirewalls!,
    if (allowCloudNat != null) 'allowCloudNat': allowCloudNat!,
    if (allowCloudRouter != null) 'allowCloudRouter': allowCloudRouter!,
    if (allowDefaultNicAttachment != null)
      'allowDefaultNicAttachment': allowDefaultNicAttachment!,
    if (allowExternalIpAccess != null)
      'allowExternalIpAccess': allowExternalIpAccess!,
    if (allowInterconnect != null) 'allowInterconnect': allowInterconnect!,
    if (allowIpForwarding != null) 'allowIpForwarding': allowIpForwarding!,
    if (allowLoadBalancing != null) 'allowLoadBalancing': allowLoadBalancing!,
    if (allowMultiNicInSameNetwork != null)
      'allowMultiNicInSameNetwork': allowMultiNicInSameNetwork!,
    if (allowNcc != null) 'allowNcc': allowNcc!,
    if (allowNetworkMigration != null)
      'allowNetworkMigration': allowNetworkMigration!,
    if (allowPacketMirroring != null)
      'allowPacketMirroring': allowPacketMirroring!,
    if (allowPrivateGoogleAccess != null)
      'allowPrivateGoogleAccess': allowPrivateGoogleAccess!,
    if (allowPsc != null) 'allowPsc': allowPsc!,
    if (allowSameNetworkUnicast != null)
      'allowSameNetworkUnicast': allowSameNetworkUnicast!,
    if (allowStaticRoutes != null) 'allowStaticRoutes': allowStaticRoutes!,
    if (allowSubInterfaces != null) 'allowSubInterfaces': allowSubInterfaces!,
    if (allowVpcPeering != null) 'allowVpcPeering': allowVpcPeering!,
    if (allowVpn != null) 'allowVpn': allowVpn!,
    if (interfaceTypes != null) 'interfaceTypes': interfaceTypes!,
    if (subnetPurposes != null) 'subnetPurposes': subnetPurposes!,
    if (subnetStackTypes != null) 'subnetStackTypes': subnetStackTypes!,
    if (subnetworkPurposes != null) 'subnetworkPurposes': subnetworkPurposes!,
    if (subnetworkStackTypes != null)
      'subnetworkStackTypes': subnetworkStackTypes!,
    if (unicast != null) 'unicast': unicast!,
  };
}

/// Used by:
///
/// - admob:v1 : NetworkReportSpecSortCondition
/// - admob:v1beta : NetworkReportSpecSortCondition
class $NetworkReportSpecSortCondition {
  /// Sort by the specified dimension.
  /// Possible string values are:
  /// - "DIMENSION_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "DATE" : A date in the YYYYMMDD format (for example, "20210701").
  /// Requests can specify at most one time dimension.
  /// - "MONTH" : A month in the YYYYMM format (for example, "202107"). Requests
  /// can specify at most one time dimension.
  /// - "WEEK" : The date of the first day of a week in the YYYYMMDD format (for
  /// example, "20210701"). Requests can specify at most one time dimension.
  /// - "AD_UNIT" : The unique ID of the ad unit (for example,
  /// "ca-app-pub-1234/1234"). If AD_UNIT dimension is specified, then APP is
  /// included automatically.
  /// - "APP" : The unique ID of the mobile application (for example,
  /// "ca-app-pub-1234~1234").
  /// - "AD_TYPE" : Type of the ad (for example, "text" or "image"), an ad
  /// delivery dimension. **Warning:** The dimension is incompatible with
  /// \[AD_REQUESTS\](#Metric.ENUM_VALUES.AD_REQUESTS),
  /// \[MATCH_RATE\](#Metric.ENUM_VALUES.MATCH_RATE) and
  /// \[IMPRESSION_RPM\](#Metric.ENUM_VALUES.IMPRESSION_RPM) metrics.
  /// - "COUNTRY" : CLDR country code of the place where the ad views/clicks
  /// occur (for example, "US" or "FR"). This is a geography dimension.
  /// - "FORMAT" : Format of the ad unit (for example, "banner", "native"), an
  /// ad delivery dimension.
  /// - "PLATFORM" : Mobile OS platform of the app (for example, "Android" or
  /// "iOS").
  /// - "MOBILE_OS_VERSION" : Mobile operating system version, e.g. "iOS
  /// 13.5.1".
  /// - "GMA_SDK_VERSION" : GMA SDK version, e.g. "iOS 7.62.0".
  /// - "APP_VERSION_NAME" : For Android, the app version name can be found in
  /// versionName in PackageInfo. For iOS, the app version name can be found in
  /// CFBundleShortVersionString.
  /// - "SERVING_RESTRICTION" : Restriction mode for ads serving (e.g.
  /// "Non-personalized ads").
  core.String? dimension;

  /// Sort by the specified metric.
  /// Possible string values are:
  /// - "METRIC_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "AD_REQUESTS" : The number of ad requests. The value is an integer.
  /// **Warning:** The metric is incompatible with
  /// \[AD_TYPE\](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
  /// - "CLICKS" : The number of times a user clicks an ad. The value is an
  /// integer.
  /// - "ESTIMATED_EARNINGS" : The estimated earnings of the AdMob publisher.
  /// The currency unit (USD, EUR, or other) of the earning metrics are
  /// determined by the localization setting for currency. The amount is in
  /// micros. For example, $6.50 would be represented as 6500000.
  /// - "IMPRESSIONS" : The total number of ads shown to users. The value is an
  /// integer.
  /// - "IMPRESSION_CTR" : The ratio of clicks over impressions. The value is a
  /// double precision (approximate) decimal value.
  /// - "IMPRESSION_RPM" : The estimated earnings per thousand ad impressions.
  /// The value is in micros. For example, $1.03 would be represented as
  /// 1030000. Equivalent to eCPM in the AdMob UI. **Warning:** The metric is
  /// incompatible with \[AD_TYPE\](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
  /// - "MATCHED_REQUESTS" : The number of times ads are returned in response to
  /// a request. The value is an integer.
  /// - "MATCH_RATE" : The ratio of matched ad requests over the total ad
  /// requests. The value is a double precision (approximate) decimal value.
  /// **Warning:** The metric is incompatible with
  /// \[AD_TYPE\](#Dimension.ENUM_VALUES.AD_TYPE) dimension.
  /// - "SHOW_RATE" : The ratio of ads that are displayed over ads that are
  /// returned, defined as impressions / matched requests. The value is a double
  /// precision (approximate) decimal value.
  core.String? metric;

  /// Sorting order of the dimension or metric.
  /// Possible string values are:
  /// - "SORT_ORDER_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "ASCENDING" : Sort dimension value or metric value in ascending order.
  /// - "DESCENDING" : Sort dimension value or metric value in descending order.
  core.String? order;

  $NetworkReportSpecSortCondition({this.dimension, this.metric, this.order});

  $NetworkReportSpecSortCondition.fromJson(core.Map json_)
    : this(
        dimension: json_['dimension'] as core.String?,
        metric: json_['metric'] as core.String?,
        order: json_['order'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimension != null) 'dimension': dimension!,
    if (metric != null) 'metric': metric!,
    if (order != null) 'order': order!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworkRoutingConfig
/// - compute:beta : NetworkRoutingConfig
/// - compute:v1 : NetworkRoutingConfig
class $NetworkRoutingConfig {
  /// Enable comparison of Multi-Exit Discriminators (MED) across routes with
  /// different neighbor ASNs when using the STANDARD BGP best path selection
  /// algorithm.
  core.bool? bgpAlwaysCompareMed;

  /// The BGP best path selection algorithm to be employed within this network
  /// for dynamic routes learned by Cloud Routers.
  ///
  /// Can be LEGACY (default) or STANDARD.
  /// Possible string values are:
  /// - "LEGACY"
  /// - "STANDARD"
  core.String? bgpBestPathSelectionMode;

  /// Allows to define a preferred approach for handling inter-region cost in
  /// the selection process when using the STANDARD BGP best path selection
  /// algorithm.
  ///
  /// Can be DEFAULT or ADD_COST_TO_MED.
  /// Possible string values are:
  /// - "ADD_COST_TO_MED"
  /// - "DEFAULT"
  core.String? bgpInterRegionCost;

  /// Effective value of the bgp_always_compare_med field.
  ///
  /// Output only.
  core.bool? effectiveBgpAlwaysCompareMed;

  /// Effective value of the bgp_inter_region_cost field.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ADD_COST_TO_MED"
  /// - "DEFAULT"
  core.String? effectiveBgpInterRegionCost;

  /// The network-wide routing mode to use.
  ///
  /// If set to REGIONAL, this network's Cloud Routers will only advertise
  /// routes with subnets of this network in the same region as the router. If
  /// set to GLOBAL, this network's Cloud Routers will advertise routes with all
  /// subnets of this network, across regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String? routingMode;

  $NetworkRoutingConfig({
    this.bgpAlwaysCompareMed,
    this.bgpBestPathSelectionMode,
    this.bgpInterRegionCost,
    this.effectiveBgpAlwaysCompareMed,
    this.effectiveBgpInterRegionCost,
    this.routingMode,
  });

  $NetworkRoutingConfig.fromJson(core.Map json_)
    : this(
        bgpAlwaysCompareMed: json_['bgpAlwaysCompareMed'] as core.bool?,
        bgpBestPathSelectionMode:
            json_['bgpBestPathSelectionMode'] as core.String?,
        bgpInterRegionCost: json_['bgpInterRegionCost'] as core.String?,
        effectiveBgpAlwaysCompareMed:
            json_['effectiveBgpAlwaysCompareMed'] as core.bool?,
        effectiveBgpInterRegionCost:
            json_['effectiveBgpInterRegionCost'] as core.String?,
        routingMode: json_['routingMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bgpAlwaysCompareMed != null)
      'bgpAlwaysCompareMed': bgpAlwaysCompareMed!,
    if (bgpBestPathSelectionMode != null)
      'bgpBestPathSelectionMode': bgpBestPathSelectionMode!,
    if (bgpInterRegionCost != null) 'bgpInterRegionCost': bgpInterRegionCost!,
    if (effectiveBgpAlwaysCompareMed != null)
      'effectiveBgpAlwaysCompareMed': effectiveBgpAlwaysCompareMed!,
    if (effectiveBgpInterRegionCost != null)
      'effectiveBgpInterRegionCost': effectiveBgpInterRegionCost!,
    if (routingMode != null) 'routingMode': routingMode!,
  };
}

/// Used by:
///
/// - appengine:v1 : NetworkSettings
/// - appengine:v1beta : NetworkSettings
class $NetworkSettings {
  /// The ingress settings for version or service.
  /// Possible string values are:
  /// - "INGRESS_TRAFFIC_ALLOWED_UNSPECIFIED" : Unspecified
  /// - "INGRESS_TRAFFIC_ALLOWED_ALL" : Allow HTTP traffic from public and
  /// private sources.
  /// - "INGRESS_TRAFFIC_ALLOWED_INTERNAL_ONLY" : Allow HTTP traffic from only
  /// private VPC sources.
  /// - "INGRESS_TRAFFIC_ALLOWED_INTERNAL_AND_LB" : Allow HTTP traffic from
  /// private VPC sources and through load balancers.
  core.String? ingressTrafficAllowed;

  $NetworkSettings({this.ingressTrafficAllowed});

  $NetworkSettings.fromJson(core.Map json_)
    : this(
        ingressTrafficAllowed: json_['ingressTrafficAllowed'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ingressTrafficAllowed != null)
      'ingressTrafficAllowed': ingressTrafficAllowed!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NetworkSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NetworkSpec
class $NetworkSpec {
  /// Whether to enable public internet access.
  ///
  /// Default false.
  core.bool? enableInternetAccess;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  core.String? network;

  /// The name of the subnet that this instance is in.
  ///
  /// Format:
  /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
  core.String? subnetwork;

  $NetworkSpec({this.enableInternetAccess, this.network, this.subnetwork});

  $NetworkSpec.fromJson(core.Map json_)
    : this(
        enableInternetAccess: json_['enableInternetAccess'] as core.bool?,
        network: json_['network'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableInternetAccess != null)
      'enableInternetAccess': enableInternetAccess!,
    if (network != null) 'network': network!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - container:v1 : NetworkTags
/// - container:v1beta1 : NetworkTags
class $NetworkTags {
  /// List of network tags.
  core.List<core.String>? tags;

  $NetworkTags({this.tags});

  $NetworkTags.fromJson(core.Map json_)
    : this(
        tags:
            (json_['tags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tags != null) 'tags': tags!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : NetworkUsageSample
/// - migrationcenter:v1alpha1 : NetworkUsageSample
class $NetworkUsageSample {
  /// Average network egress in B/s sampled over a short window.
  ///
  /// Must be non-negative.
  core.double? averageEgressBps;

  /// Average network ingress in B/s sampled over a short window.
  ///
  /// Must be non-negative.
  core.double? averageIngressBps;

  $NetworkUsageSample({this.averageEgressBps, this.averageIngressBps});

  $NetworkUsageSample.fromJson(core.Map json_)
    : this(
        averageEgressBps: (json_['averageEgressBps'] as core.num?)?.toDouble(),
        averageIngressBps:
            (json_['averageIngressBps'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (averageEgressBps != null) 'averageEgressBps': averageEgressBps!,
    if (averageIngressBps != null) 'averageIngressBps': averageIngressBps!,
  };
}

/// Used by:
///
/// - appengine:v1 : NetworkUtilization
/// - appengine:v1beta : NetworkUtilization
class $NetworkUtilization {
  /// Target bytes received per second.
  core.int? targetReceivedBytesPerSecond;

  /// Target packets received per second.
  core.int? targetReceivedPacketsPerSecond;

  /// Target bytes sent per second.
  core.int? targetSentBytesPerSecond;

  /// Target packets sent per second.
  core.int? targetSentPacketsPerSecond;

  $NetworkUtilization({
    this.targetReceivedBytesPerSecond,
    this.targetReceivedPacketsPerSecond,
    this.targetSentBytesPerSecond,
    this.targetSentPacketsPerSecond,
  });

  $NetworkUtilization.fromJson(core.Map json_)
    : this(
        targetReceivedBytesPerSecond:
            json_['targetReceivedBytesPerSecond'] as core.int?,
        targetReceivedPacketsPerSecond:
            json_['targetReceivedPacketsPerSecond'] as core.int?,
        targetSentBytesPerSecond:
            json_['targetSentBytesPerSecond'] as core.int?,
        targetSentPacketsPerSecond:
            json_['targetSentPacketsPerSecond'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetReceivedBytesPerSecond != null)
      'targetReceivedBytesPerSecond': targetReceivedBytesPerSecond!,
    if (targetReceivedPacketsPerSecond != null)
      'targetReceivedPacketsPerSecond': targetReceivedPacketsPerSecond!,
    if (targetSentBytesPerSecond != null)
      'targetSentBytesPerSecond': targetSentBytesPerSecond!,
    if (targetSentPacketsPerSecond != null)
      'targetSentPacketsPerSecond': targetSentPacketsPerSecond!,
  };
}

/// Used by:
///
/// - composer:v1 : NetworkingConfig
/// - composer:v1beta1 : NetworkingConfig
class $NetworkingConfig {
  /// Indicates the user requested specific connection type between Tenant and
  /// Customer projects.
  ///
  /// You cannot set networking connection type in public IP environment.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CONNECTION_TYPE_UNSPECIFIED" : No specific connection type was
  /// requested, so the environment uses the default value corresponding to the
  /// rest of its configuration.
  /// - "VPC_PEERING" : Requests the use of VPC peerings for connecting the
  /// Customer and Tenant projects.
  /// - "PRIVATE_SERVICE_CONNECT" : Requests the use of Private Service Connect
  /// for connecting the Customer and Tenant projects.
  core.String? connectionType;

  $NetworkingConfig({this.connectionType});

  $NetworkingConfig.fromJson(core.Map json_)
    : this(connectionType: json_['connectionType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectionType != null) 'connectionType': connectionType!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : NfsExport
/// - migrationcenter:v1alpha1 : NfsExport
class $NfsExport {
  /// The directory being exported.
  core.String? exportDirectory;

  /// The hosts or networks to which the export is being shared.
  core.List<core.String>? hosts;

  $NfsExport({this.exportDirectory, this.hosts});

  $NfsExport.fromJson(core.Map json_)
    : this(
        exportDirectory: json_['exportDirectory'] as core.String?,
        hosts:
            (json_['hosts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportDirectory != null) 'exportDirectory': exportDirectory!,
    if (hosts != null) 'hosts': hosts!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NfsMount
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NfsMount
class $NfsMount {
  /// Destination mount path.
  ///
  /// The NFS will be mounted for the user under /mnt/nfs/
  ///
  /// Required.
  core.String? mountPoint;

  /// Source path exported from NFS server.
  ///
  /// Has to start with '/', and combined with the ip address, it indicates the
  /// source mount path in the form of `server:path`
  ///
  /// Required.
  core.String? path;

  /// IP address of the NFS server.
  ///
  /// Required.
  core.String? server;

  $NfsMount({this.mountPoint, this.path, this.server});

  $NfsMount.fromJson(core.Map json_)
    : this(
        mountPoint: json_['mountPoint'] as core.String?,
        path: json_['path'] as core.String?,
        server: json_['server'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mountPoint != null) 'mountPoint': mountPoint!,
    if (path != null) 'path': path!,
    if (server != null) 'server': server!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3NluSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1NluSettings
class $NluSettings {
  /// To filter out false positive results and still get variety in matched
  /// natural language inputs for your agent, you can tune the machine learning
  /// classification threshold.
  ///
  /// If the returned score value is less than the threshold value, then a
  /// no-match event will be triggered. The score values range from 0.0
  /// (completely uncertain) to 1.0 (completely certain). If set to 0.0, the
  /// default of 0.3 is used. You can set a separate classification threshold
  /// for the flow in each language enabled for the agent.
  core.double? classificationThreshold;

  /// Indicates NLU model training mode.
  /// Possible string values are:
  /// - "MODEL_TRAINING_MODE_UNSPECIFIED" : Not specified.
  /// `MODEL_TRAINING_MODE_AUTOMATIC` will be used.
  /// - "MODEL_TRAINING_MODE_AUTOMATIC" : NLU model training is automatically
  /// triggered when a flow gets modified. User can also manually trigger model
  /// training in this mode.
  /// - "MODEL_TRAINING_MODE_MANUAL" : User needs to manually trigger NLU model
  /// training. Best for large flows whose models take long time to train.
  core.String? modelTrainingMode;

  /// Indicates the type of NLU model.
  /// Possible string values are:
  /// - "MODEL_TYPE_UNSPECIFIED" : Not specified. `MODEL_TYPE_STANDARD` will be
  /// used.
  /// - "MODEL_TYPE_STANDARD" : Use standard NLU model.
  /// - "MODEL_TYPE_ADVANCED" : Use advanced NLU model.
  core.String? modelType;

  $NluSettings({
    this.classificationThreshold,
    this.modelTrainingMode,
    this.modelType,
  });

  $NluSettings.fromJson(core.Map json_)
    : this(
        classificationThreshold:
            (json_['classificationThreshold'] as core.num?)?.toDouble(),
        modelTrainingMode: json_['modelTrainingMode'] as core.String?,
        modelType: json_['modelType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classificationThreshold != null)
      'classificationThreshold': classificationThreshold!,
    if (modelTrainingMode != null) 'modelTrainingMode': modelTrainingMode!,
    if (modelType != null) 'modelType': modelType!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : NoWrapper
/// - pubsub:v1 : NoWrapper
class $NoWrapper {
  /// When true, writes the Pub/Sub message metadata to `x-goog-pubsub-:`
  /// headers of the HTTP request.
  ///
  /// Writes the Pub/Sub message attributes to `:` headers of the HTTP request.
  ///
  /// Optional.
  core.bool? writeMetadata;

  $NoWrapper({this.writeMetadata});

  $NoWrapper.fromJson(core.Map json_)
    : this(writeMetadata: json_['writeMetadata'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (writeMetadata != null) 'writeMetadata': writeMetadata!,
  };
}

/// Used by:
///
/// - alloydb:v1 : Node
/// - alloydb:v1alpha : Node
/// - alloydb:v1beta : Node
class $Node00 {
  /// The identifier of the VM e.g. "test-read-0601-407e52be-ms3l".
  ///
  /// Output only.
  core.String? id;

  /// The private IP address of the VM e.g. "10.57.0.34".
  ///
  /// Output only.
  core.String? ip;

  /// Determined by state of the compute VM and postgres-service health.
  ///
  /// Compute VM state can have values listed in
  /// https://cloud.google.com/compute/docs/instances/instance-life-cycle and
  /// postgres-service health can have values: HEALTHY and UNHEALTHY.
  ///
  /// Output only.
  core.String? state;

  /// The Compute Engine zone of the VM e.g. "us-central1-b".
  ///
  /// Output only.
  core.String? zoneId;

  $Node00({this.id, this.ip, this.state, this.zoneId});

  $Node00.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        ip: json_['ip'] as core.String?,
        state: json_['state'] as core.String?,
        zoneId: json_['zoneId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (ip != null) 'ip': ip!,
    if (state != null) 'state': state!,
    if (zoneId != null) 'zoneId': zoneId!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ReportSummaryVmwareNode
/// - migrationcenter:v1alpha1 : ReportSummaryVMWareNode
class $Node01 {
  /// Code to identify VMware Engine node series, e.g. "ve1-standard-72".
  ///
  /// Based on the displayName of
  /// cloud.google.com/vmware-engine/docs/reference/rest/v1/projects.locations.nodeTypes
  core.String? code;

  $Node01({this.code});

  $Node01.fromJson(core.Map json_) : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - container:v1 : NodeAffinity
/// - container:v1beta1 : NodeAffinity
class $NodeAffinity {
  /// Key for NodeAffinity.
  core.String? key;

  /// Operator for NodeAffinity.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : Invalid or unspecified affinity operator.
  /// - "IN" : Affinity operator.
  /// - "NOT_IN" : Anti-affinity operator.
  core.String? operator;

  /// Values for NodeAffinity.
  core.List<core.String>? values;

  $NodeAffinity({this.key, this.operator, this.values});

  $NodeAffinity.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        operator: json_['operator'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (operator != null) 'operator': operator!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - connectors:v1 : NodeConfig
/// - integrations:v1 : GoogleCloudConnectorsV1NodeConfig
class $NodeConfig00 {
  /// Maximum number of nodes in the runtime nodes.
  ///
  /// Optional.
  core.int? maxNodeCount;

  /// Minimum number of nodes in the runtime nodes.
  ///
  /// Optional.
  core.int? minNodeCount;

  $NodeConfig00({this.maxNodeCount, this.minNodeCount});

  $NodeConfig00.fromJson(core.Map json_)
    : this(
        maxNodeCount: json_['maxNodeCount'] as core.int?,
        minNodeCount: json_['minNodeCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
    if (minNodeCount != null) 'minNodeCount': minNodeCount!,
  };
}

/// Used by:
///
/// - memcache:v1 : NodeConfig
/// - memcache:v1beta2 : NodeConfig
class $NodeConfig01 {
  /// Number of cpus per Memcached node.
  ///
  /// Required.
  core.int? cpuCount;

  /// Memory size in MiB for each Memcached node.
  ///
  /// Required.
  core.int? memorySizeMb;

  $NodeConfig01({this.cpuCount, this.memorySizeMb});

  $NodeConfig01.fromJson(core.Map json_)
    : this(
        cpuCount: json_['cpuCount'] as core.int?,
        memorySizeMb: json_['memorySizeMb'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpuCount != null) 'cpuCount': cpuCount!,
    if (memorySizeMb != null) 'memorySizeMb': memorySizeMb!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupAutoscalingPolicy
/// - compute:beta : NodeGroupAutoscalingPolicy
/// - compute:v1 : NodeGroupAutoscalingPolicy
class $NodeGroupAutoscalingPolicy {
  /// The maximum number of nodes that the group should have.
  ///
  /// Must be set if autoscaling is enabled. Maximum value allowed is 100.
  core.int? maxNodes;

  /// The minimum number of nodes that the group should have.
  core.int? minNodes;

  /// The autoscaling mode.
  ///
  /// Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see
  /// Autoscaler modes.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED"
  /// - "OFF" : Autoscaling is disabled.
  /// - "ON" : Autocaling is fully enabled.
  /// - "ONLY_SCALE_OUT" : Autoscaling will only scale out and will not remove
  /// nodes.
  core.String? mode;

  $NodeGroupAutoscalingPolicy({this.maxNodes, this.minNodes, this.mode});

  $NodeGroupAutoscalingPolicy.fromJson(core.Map json_)
    : this(
        maxNodes: json_['maxNodes'] as core.int?,
        minNodes: json_['minNodes'] as core.int?,
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxNodes != null) 'maxNodes': maxNodes!,
    if (minNodes != null) 'minNodes': minNodes!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupsAddNodesRequest
/// - compute:beta : NodeGroupsAddNodesRequest
/// - compute:v1 : NodeGroupsAddNodesRequest
class $NodeGroupsAddNodesRequest {
  /// Count of additional nodes to be added to the node group.
  core.int? additionalNodeCount;

  $NodeGroupsAddNodesRequest({this.additionalNodeCount});

  $NodeGroupsAddNodesRequest.fromJson(core.Map json_)
    : this(additionalNodeCount: json_['additionalNodeCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (additionalNodeCount != null)
      'additionalNodeCount': additionalNodeCount!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupsDeleteNodesRequest
/// - compute:beta : NodeGroupsDeleteNodesRequest
/// - compute:v1 : NodeGroupsDeleteNodesRequest
class $NodeGroupsDeleteNodesRequest {
  /// Names of the nodes to delete.
  core.List<core.String>? nodes;

  $NodeGroupsDeleteNodesRequest({this.nodes});

  $NodeGroupsDeleteNodesRequest.fromJson(core.Map json_)
    : this(
        nodes:
            (json_['nodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodes != null) 'nodes': nodes!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupsPerformMaintenanceRequest
/// - compute:beta : NodeGroupsPerformMaintenanceRequest
/// - compute:v1 : NodeGroupsPerformMaintenanceRequest
class $NodeGroupsPerformMaintenanceRequest {
  /// List of nodes affected by the call.
  ///
  /// Required.
  core.List<core.String>? nodes;

  /// The start time of the schedule.
  ///
  /// The timestamp is an RFC3339 string.
  core.String? startTime;

  $NodeGroupsPerformMaintenanceRequest({this.nodes, this.startTime});

  $NodeGroupsPerformMaintenanceRequest.fromJson(core.Map json_)
    : this(
        nodes:
            (json_['nodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodes != null) 'nodes': nodes!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupsSetNodeTemplateRequest
/// - compute:beta : NodeGroupsSetNodeTemplateRequest
/// - compute:v1 : NodeGroupsSetNodeTemplateRequest
class $NodeGroupsSetNodeTemplateRequest {
  /// Full or partial URL of the node template resource to be updated for this
  /// node group.
  core.String? nodeTemplate;

  $NodeGroupsSetNodeTemplateRequest({this.nodeTemplate});

  $NodeGroupsSetNodeTemplateRequest.fromJson(core.Map json_)
    : this(nodeTemplate: json_['nodeTemplate'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeTemplate != null) 'nodeTemplate': nodeTemplate!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeGroupsSimulateMaintenanceEventRequest
/// - compute:beta : NodeGroupsSimulateMaintenanceEventRequest
/// - compute:v1 : NodeGroupsSimulateMaintenanceEventRequest
class $NodeGroupsSimulateMaintenanceEventRequest {
  /// Names of the nodes to go under maintenance simulation.
  core.List<core.String>? nodes;

  $NodeGroupsSimulateMaintenanceEventRequest({this.nodes});

  $NodeGroupsSimulateMaintenanceEventRequest.fromJson(core.Map json_)
    : this(
        nodes:
            (json_['nodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodes != null) 'nodes': nodes!,
  };
}

/// Used by:
///
/// - redis:v1 : NodeInfo
/// - redis:v1beta1 : NodeInfo
class $NodeInfo {
  /// Node identifying string.
  ///
  /// e.g. 'node-0', 'node-1'
  ///
  /// Output only.
  core.String? id;

  /// Location of the node.
  ///
  /// Output only.
  core.String? zone;

  $NodeInfo({this.id, this.zone});

  $NodeInfo.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : NodePoolAutoscaling
/// - container:v1beta1 : NodePoolAutoscaling
class $NodePoolAutoscaling {
  /// Can this node pool be deleted automatically.
  core.bool? autoprovisioned;

  /// Is autoscaling enabled for this node pool.
  core.bool? enabled;

  /// Location policy used when scaling up a nodepool.
  /// Possible string values are:
  /// - "LOCATION_POLICY_UNSPECIFIED" : Not set.
  /// - "BALANCED" : BALANCED is a best effort policy that aims to balance the
  /// sizes of different zones.
  /// - "ANY" : ANY policy picks zones that have the highest capacity available.
  core.String? locationPolicy;

  /// Maximum number of nodes for one location in the node pool.
  ///
  /// Must be \>= min_node_count. There has to be enough quota to scale up the
  /// cluster.
  core.int? maxNodeCount;

  /// Minimum number of nodes for one location in the node pool.
  ///
  /// Must be greater than or equal to 0 and less than or equal to
  /// max_node_count.
  core.int? minNodeCount;

  /// Maximum number of nodes in the node pool.
  ///
  /// Must be greater than or equal to total_min_node_count. There has to be
  /// enough quota to scale up the cluster. The total_*_node_count fields are
  /// mutually exclusive with the *_node_count fields.
  core.int? totalMaxNodeCount;

  /// Minimum number of nodes in the node pool.
  ///
  /// Must be greater than or equal to 0 and less than or equal to
  /// total_max_node_count. The total_*_node_count fields are mutually exclusive
  /// with the *_node_count fields.
  core.int? totalMinNodeCount;

  $NodePoolAutoscaling({
    this.autoprovisioned,
    this.enabled,
    this.locationPolicy,
    this.maxNodeCount,
    this.minNodeCount,
    this.totalMaxNodeCount,
    this.totalMinNodeCount,
  });

  $NodePoolAutoscaling.fromJson(core.Map json_)
    : this(
        autoprovisioned: json_['autoprovisioned'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
        locationPolicy: json_['locationPolicy'] as core.String?,
        maxNodeCount: json_['maxNodeCount'] as core.int?,
        minNodeCount: json_['minNodeCount'] as core.int?,
        totalMaxNodeCount: json_['totalMaxNodeCount'] as core.int?,
        totalMinNodeCount: json_['totalMinNodeCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoprovisioned != null) 'autoprovisioned': autoprovisioned!,
    if (enabled != null) 'enabled': enabled!,
    if (locationPolicy != null) 'locationPolicy': locationPolicy!,
    if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
    if (minNodeCount != null) 'minNodeCount': minNodeCount!,
    if (totalMaxNodeCount != null) 'totalMaxNodeCount': totalMaxNodeCount!,
    if (totalMinNodeCount != null) 'totalMinNodeCount': totalMinNodeCount!,
  };
}

/// Used by:
///
/// - container:v1 : NodeTaint
/// - container:v1beta1 : NodeTaint
class $NodeTaint {
  /// Effect for taint.
  /// Possible string values are:
  /// - "EFFECT_UNSPECIFIED" : Not set
  /// - "NO_SCHEDULE" : NoSchedule
  /// - "PREFER_NO_SCHEDULE" : PreferNoSchedule
  /// - "NO_EXECUTE" : NoExecute
  core.String? effect;

  /// Key for taint.
  core.String? key;

  /// Value for taint.
  core.String? value;

  $NodeTaint({this.effect, this.key, this.value});

  $NodeTaint.fromJson(core.Map json_)
    : this(
        effect: json_['effect'] as core.String?,
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (effect != null) 'effect': effect!,
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : NodeTemplateNodeTypeFlexibility
/// - compute:beta : NodeTemplateNodeTypeFlexibility
/// - compute:v1 : NodeTemplateNodeTypeFlexibility
class $NodeTemplateNodeTypeFlexibility {
  core.String? cpus;
  core.String? localSsd;
  core.String? memory;

  $NodeTemplateNodeTypeFlexibility({this.cpus, this.localSsd, this.memory});

  $NodeTemplateNodeTypeFlexibility.fromJson(core.Map json_)
    : this(
        cpus: json_['cpus'] as core.String?,
        localSsd: json_['localSsd'] as core.String?,
        memory: json_['memory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpus != null) 'cpus': cpus!,
    if (localSsd != null) 'localSsd': localSsd!,
    if (memory != null) 'memory': memory!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : NonCompliantFile
/// - ondemandscanning:v1 : NonCompliantFile
/// - ondemandscanning:v1beta1 : NonCompliantFile
class $NonCompliantFile {
  /// Command to display the non-compliant files.
  core.String? displayCommand;

  /// Empty if `display_command` is set.
  core.String? path;

  /// Explains why a file is non compliant for a CIS check.
  core.String? reason;

  $NonCompliantFile({this.displayCommand, this.path, this.reason});

  $NonCompliantFile.fromJson(core.Map json_)
    : this(
        displayCommand: json_['displayCommand'] as core.String?,
        path: json_['path'] as core.String?,
        reason: json_['reason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayCommand != null) 'displayCommand': displayCommand!,
    if (path != null) 'path': path!,
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1NormalizedVertex
/// - vision:v1 : NormalizedVertex
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1NormalizedVertex
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1NormalizedVertex
class $NormalizedVertex00 {
  /// X coordinate.
  core.double? x;

  /// Y coordinate.
  core.double? y;

  $NormalizedVertex00({this.x, this.y});

  $NormalizedVertex00.fromJson(core.Map json_)
    : this(
        x: (json_['x'] as core.num?)?.toDouble(),
        y: (json_['y'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1NormalizedVertex
/// - documentai:v1 : GoogleCloudDocumentaiV1NormalizedVertex
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3NormalizedVertex
class $NormalizedVertex01 {
  /// X coordinate.
  core.double? x;

  /// Y coordinate (starts from the top of the image).
  core.double? y;

  $NormalizedVertex01({this.x, this.y});

  $NormalizedVertex01.fromJson(core.Map json_)
    : this(
        x: (json_['x'] as core.num?)?.toDouble(),
        y: (json_['y'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : Note
/// - authorizedbuyersmarketplace:v1alpha : Note
class $Note {
  /// When this note was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The role who created the note.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BUYER_SELLER_ROLE_UNSPECIFIED" : A placeholder for an undefined
  /// buyer/seller role.
  /// - "BUYER" : Specifies the role as buyer.
  /// - "SELLER" : Specifies the role as seller.
  core.String? creatorRole;

  /// The text of the note.
  ///
  /// Maximum length is 1024 characters.
  core.String? note;

  $Note({this.createTime, this.creatorRole, this.note});

  $Note.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        creatorRole: json_['creatorRole'] as core.String?,
        note: json_['note'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (creatorRole != null) 'creatorRole': creatorRole!,
    if (note != null) 'note': note!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookEucConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookEucConfig
class $NotebookEucConfig {
  /// Whether ActAs check is bypassed for service account attached to the VM.
  ///
  /// If false, we need ActAs check for the default Compute Engine Service
  /// account. When a Runtime is created, a VM is allocated using Default
  /// Compute Engine Service Account. Any user requesting to use this Runtime
  /// requires Service Account User (ActAs) permission over this SA. If true,
  /// Runtime owner is using EUC and does not require the above permission as VM
  /// no longer use default Compute Engine SA, but a P4SA.
  ///
  /// Output only.
  core.bool? bypassActasCheck;

  /// Input only.
  ///
  /// Whether EUC is disabled in this NotebookRuntimeTemplate. In proto3, the
  /// default value of a boolean is false. In this way, by default EUC will be
  /// enabled for NotebookRuntimeTemplate.
  core.bool? eucDisabled;

  $NotebookEucConfig({this.bypassActasCheck, this.eucDisabled});

  $NotebookEucConfig.fromJson(core.Map json_)
    : this(
        bypassActasCheck: json_['bypassActasCheck'] as core.bool?,
        eucDisabled: json_['eucDisabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bypassActasCheck != null) 'bypassActasCheck': bypassActasCheck!,
    if (eucDisabled != null) 'eucDisabled': eucDisabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookExecutionJobDataformRepositorySource
class $NotebookExecutionJobDataformRepositorySource {
  /// The commit SHA to read repository with.
  ///
  /// If unset, the file will be read at HEAD.
  core.String? commitSha;

  /// The resource name of the Dataform Repository.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
  core.String? dataformRepositoryResourceName;

  $NotebookExecutionJobDataformRepositorySource({
    this.commitSha,
    this.dataformRepositoryResourceName,
  });

  $NotebookExecutionJobDataformRepositorySource.fromJson(core.Map json_)
    : this(
        commitSha: json_['commitSha'] as core.String?,
        dataformRepositoryResourceName:
            json_['dataformRepositoryResourceName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (commitSha != null) 'commitSha': commitSha!,
    if (dataformRepositoryResourceName != null)
      'dataformRepositoryResourceName': dataformRepositoryResourceName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookExecutionJobDirectNotebookSource
class $NotebookExecutionJobDirectNotebookSource {
  /// The base64-encoded contents of the input notebook file.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $NotebookExecutionJobDirectNotebookSource({this.content});

  $NotebookExecutionJobDirectNotebookSource.fromJson(core.Map json_)
    : this(content: json_['content'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookExecutionJobGcsNotebookSource
class $NotebookExecutionJobGcsNotebookSource {
  /// The version of the Cloud Storage object to read.
  ///
  /// If unset, the current version of the object is read. See
  /// https://cloud.google.com/storage/docs/metadata#generation-number.
  core.String? generation;

  /// The Cloud Storage uri pointing to the ipynb file.
  ///
  /// Format: `gs://bucket/notebook_file.ipynb`
  core.String? uri;

  $NotebookExecutionJobGcsNotebookSource({this.generation, this.uri});

  $NotebookExecutionJobGcsNotebookSource.fromJson(core.Map json_)
    : this(
        generation: json_['generation'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (generation != null) 'generation': generation!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookIdleShutdownConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig
class $NotebookIdleShutdownConfig {
  /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
  core.bool? idleShutdownDisabled;

  /// Duration is accurate to the second.
  ///
  /// In Notebook, Idle Timeout is accurate to minute so the range of
  /// idle_timeout (second) is: 10 * 60 ~ 1440 * 60.
  ///
  /// Required.
  core.String? idleTimeout;

  $NotebookIdleShutdownConfig({this.idleShutdownDisabled, this.idleTimeout});

  $NotebookIdleShutdownConfig.fromJson(core.Map json_)
    : this(
        idleShutdownDisabled: json_['idleShutdownDisabled'] as core.bool?,
        idleTimeout: json_['idleTimeout'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idleShutdownDisabled != null)
      'idleShutdownDisabled': idleShutdownDisabled!,
    if (idleTimeout != null) 'idleTimeout': idleTimeout!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookReservationAffinity
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookReservationAffinity
class $NotebookReservationAffinity {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: RESERVATION_ANY (default), RESERVATION_SPECIFIC, or
  /// RESERVATION_NONE.
  ///
  /// See Consuming reserved instances for examples.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESERVATION_AFFINITY_TYPE_UNSPECIFIED" : Default type.
  /// - "RESERVATION_NONE" : Do not consume from any allocated capacity.
  /// - "RESERVATION_ANY" : Consume any reservation available.
  /// - "RESERVATION_SPECIFIC" : Must consume from a specific reservation. Must
  /// specify key value fields for specifying the reservations.
  core.String? consumeReservationType;

  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a RESERVATION_SPECIFIC by name, use
  /// compute.googleapis.com/reservation-name as the key and specify the name of
  /// your reservation as its value.
  ///
  /// Optional.
  core.String? key;

  /// Corresponds to the label values of a reservation resource.
  ///
  /// This must be the full path name of Reservation.
  ///
  /// Optional.
  core.List<core.String>? values;

  $NotebookReservationAffinity({
    this.consumeReservationType,
    this.key,
    this.values,
  });

  $NotebookReservationAffinity.fromJson(core.Map json_)
    : this(
        consumeReservationType: json_['consumeReservationType'] as core.String?,
        key: json_['key'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumeReservationType != null)
      'consumeReservationType': consumeReservationType!,
    if (key != null) 'key': key!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1NotebookRuntimeTemplateRef
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1NotebookRuntimeTemplateRef
class $NotebookRuntimeTemplateRef {
  /// A resource name of the NotebookRuntimeTemplate.
  ///
  /// Immutable.
  core.String? notebookRuntimeTemplate;

  $NotebookRuntimeTemplateRef({this.notebookRuntimeTemplate});

  $NotebookRuntimeTemplateRef.fromJson(core.Map json_)
    : this(
        notebookRuntimeTemplate:
            json_['notebookRuntimeTemplate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (notebookRuntimeTemplate != null)
      'notebookRuntimeTemplate': notebookRuntimeTemplate!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2NotificationConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1NotificationConfig
class $NotificationConfig00 {
  /// Format of message.
  /// Possible string values are:
  /// - "MESSAGE_FORMAT_UNSPECIFIED" : If it is unspecified, PROTO will be used.
  /// - "PROTO" : Pub/Sub message will be serialized proto.
  /// - "JSON" : Pub/Sub message will be json.
  core.String? messageFormat;

  /// Name of the Pub/Sub topic to publish conversation events like
  /// CONVERSATION_STARTED as serialized ConversationEvent protos.
  ///
  /// For telephony integration to receive notification, make sure either this
  /// topic is in the same project as the conversation or you grant
  /// `service-@gcp-sa-dialogflow.iam.gserviceaccount.com` the `Dialogflow
  /// Service Agent` role in the topic project. For chat integration to receive
  /// notification, make sure API caller has been granted the `Dialogflow
  /// Service Agent` role for the topic. Format: `projects//locations//topics/`.
  core.String? topic;

  $NotificationConfig00({this.messageFormat, this.topic});

  $NotificationConfig00.fromJson(core.Map json_)
    : this(
        messageFormat: json_['messageFormat'] as core.String?,
        topic: json_['topic'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (messageFormat != null) 'messageFormat': messageFormat!,
    if (topic != null) 'topic': topic!,
  };
}

/// Used by:
///
/// - healthcare:v1 : NotificationConfig
/// - healthcare:v1beta1 : NotificationConfig
class $NotificationConfig01 {
  /// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that
  /// notifications of changes are published on.
  ///
  /// Supplied by the client. PubsubMessage.Data contains the resource name.
  /// PubsubMessage.MessageId is the ID of this message. It is guaranteed to be
  /// unique within the topic. PubsubMessage.PublishTime is the time at which
  /// the message was published. Notifications are only sent if the topic is
  /// non-empty.
  /// [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be
  /// scoped to a project. Cloud Healthcare API service account must have
  /// publisher permissions on the given Pub/Sub topic. Not having adequate
  /// permissions causes the calls that send notifications to fail. If a
  /// notification can't be published to Pub/Sub, errors are logged to Cloud
  /// Logging (see
  /// [Viewing error logs in Cloud Logging](https://cloud.google.com/healthcare/docs/how-tos/logging)).
  /// If the number of errors exceeds a certain rate, some aren't submitted.
  /// Note that not all operations trigger notifications, see
  /// [Configuring Pub/Sub notifications](https://cloud.google.com/healthcare/docs/how-tos/pubsub)
  /// for specific details.
  core.String? pubsubTopic;

  /// Indicates whether or not to send Pub/Sub notifications on bulk import.
  ///
  /// Only supported for DICOM imports.
  core.bool? sendForBulkImport;

  $NotificationConfig01({this.pubsubTopic, this.sendForBulkImport});

  $NotificationConfig01.fromJson(core.Map json_)
    : this(
        pubsubTopic: json_['pubsubTopic'] as core.String?,
        sendForBulkImport: json_['sendForBulkImport'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pubsubTopic != null) 'pubsubTopic': pubsubTopic!,
    if (sendForBulkImport != null) 'sendForBulkImport': sendForBulkImport!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpAppconnectorsV1NotificationConfigCloudPubSubNotificationConfig
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpAppconnectorsV1alphaNotificationConfigCloudPubSubNotificationConfig
class $NotificationConfigCloudPubSubNotificationConfig {
  /// The Pub/Sub subscription the AppConnector uses to receive notifications.
  core.String? pubsubSubscription;

  $NotificationConfigCloudPubSubNotificationConfig({this.pubsubSubscription});

  $NotificationConfigCloudPubSubNotificationConfig.fromJson(core.Map json_)
    : this(pubsubSubscription: json_['pubsubSubscription'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pubsubSubscription != null) 'pubsubSubscription': pubsubSubscription!,
  };
}

/// Used by:
///
/// - jobs:v3 : NumericBucketingOption
/// - jobs:v3p1beta1 : NumericBucketingOption
class $NumericBucketingOption {
  /// Two adjacent values form a histogram bucket.
  ///
  /// Values should be in ascending order. For example, if \[5, 10, 15\] are
  /// provided, four buckets are created: (-inf, 5), 5, 10), \[10, 15), \[15,
  /// inf). At most 20 \[buckets_bound is supported.
  ///
  /// Required.
  core.List<core.double>? bucketBounds;

  /// If set to true, the histogram result includes minimum/maximum value of the
  /// numeric field.
  ///
  /// Optional.
  core.bool? requiresMinMax;

  $NumericBucketingOption({this.bucketBounds, this.requiresMinMax});

  $NumericBucketingOption.fromJson(core.Map json_)
    : this(
        bucketBounds:
            (json_['bucketBounds'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        requiresMinMax: json_['requiresMinMax'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucketBounds != null) 'bucketBounds': bucketBounds!,
    if (requiresMinMax != null) 'requiresMinMax': requiresMinMax!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaNumericValue
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaNumericValue
/// - analyticsdata:v1beta : NumericValue
class $NumericValue {
  /// Double value
  core.double? doubleValue;

  /// Integer value
  core.String? int64Value;

  $NumericValue({this.doubleValue, this.int64Value});

  $NumericValue.fromJson(core.Map json_)
    : this(
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        int64Value: json_['int64Value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (int64Value != null) 'int64Value': int64Value!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : OAuthRequirements
/// - serviceusage:v1 : OAuthRequirements
/// - serviceusage:v1beta1 : OAuthRequirements
class $OAuthRequirements {
  /// The list of publicly documented OAuth scopes that are allowed access.
  ///
  /// An OAuth token containing any of these scopes will be accepted. Example:
  /// canonical_scopes: https://www.googleapis.com/auth/calendar,
  /// https://www.googleapis.com/auth/calendar.read
  core.String? canonicalScopes;

  $OAuthRequirements({this.canonicalScopes});

  $OAuthRequirements.fromJson(core.Map json_)
    : this(canonicalScopes: json_['canonicalScopes'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalScopes != null) 'canonicalScopes': canonicalScopes!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : OAuthToken
/// - cloudtasks:v2beta2 : OAuthToken
/// - cloudtasks:v2beta3 : OAuthToken
class $OAuthToken00 {
  /// OAuth scope to be used for generating OAuth access token.
  ///
  /// If not specified, "https://www.googleapis.com/auth/cloud-platform" will be
  /// used.
  core.String? scope;

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OAuth token.
  ///
  /// The service account must be within the same project as the queue. The
  /// caller must have iam.serviceAccounts.actAs permission for the service
  /// account.
  core.String? serviceAccountEmail;

  $OAuthToken00({this.scope, this.serviceAccountEmail});

  $OAuthToken00.fromJson(core.Map json_)
    : this(
        scope: json_['scope'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - cloudscheduler:v1 : OAuthToken
/// - cloudscheduler:v1beta1 : OAuthToken
class $OAuthToken01 {
  /// OAuth scope to be used for generating OAuth access token.
  ///
  /// If not specified, "https://www.googleapis.com/auth/cloud-platform" will be
  /// used.
  core.String? scope;

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OAuth token.
  ///
  /// The service account must be within the same project as the job. The caller
  /// must have iam.serviceAccounts.actAs permission for the service account.
  core.String? serviceAccountEmail;

  $OAuthToken01({this.scope, this.serviceAccountEmail});

  $OAuthToken01.fromJson(core.Map json_)
    : this(
        scope: json_['scope'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : OSDescription
/// - vmmigration:v1alpha1 : OSDescription
class $OSDescription {
  /// OS offer.
  core.String? offer;

  /// OS plan.
  core.String? plan;

  /// OS publisher.
  core.String? publisher;

  /// OS type.
  core.String? type;

  $OSDescription({this.offer, this.plan, this.publisher, this.type});

  $OSDescription.fromJson(core.Map json_)
    : this(
        offer: json_['offer'] as core.String?,
        plan: json_['plan'] as core.String?,
        publisher: json_['publisher'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (offer != null) 'offer': offer!,
    if (plan != null) 'plan': plan!,
    if (publisher != null) 'publisher': publisher!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : OSDisk
/// - vmmigration:v1alpha1 : OSDisk
class $OSDisk {
  /// The disk's full name.
  core.String? name;

  /// The disk's size in GB.
  core.int? sizeGb;

  /// The disk's type.
  core.String? type;

  $OSDisk({this.name, this.sizeGb, this.type});

  $OSDisk.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        sizeGb: json_['sizeGb'] as core.int?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyAssignmentLabelSet
/// - osconfig:v1alpha : OSPolicyAssignmentLabelSet
/// - osconfig:v2 : OSPolicyAssignmentLabelSet
/// - osconfig:v2beta : OSPolicyAssignmentLabelSet
class $OSPolicyAssignmentLabelSet {
  /// Labels are identified by key/value pairs in this map.
  ///
  /// A VM should contain all the key/value pairs specified in this map to be
  /// selected.
  core.Map<core.String, core.String>? labels;

  $OSPolicyAssignmentLabelSet({this.labels});

  $OSPolicyAssignmentLabelSet.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput
/// - osconfig:v1alpha : OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput
class $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput {
  /// Output from enforcement phase output file (if run).
  ///
  /// Output size is limited to 100K bytes.
  core.String? enforcementOutput;
  core.List<core.int> get enforcementOutputAsBytes =>
      convert.base64.decode(enforcementOutput!);

  set enforcementOutputAsBytes(core.List<core.int> bytes_) {
    enforcementOutput = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput({
    this.enforcementOutput,
  });

  $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceExecResourceOutput.fromJson(
    core.Map json_,
  ) : this(enforcementOutput: json_['enforcementOutput'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enforcementOutput != null) 'enforcementOutput': enforcementOutput!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep
/// - osconfig:v1alpha : OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep
class $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep {
  /// An error message recorded during the execution of this step.
  ///
  /// Only populated if errors were encountered during this step execution.
  core.String? errorMessage;

  /// Configuration step type.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value. This value is unused.
  /// - "VALIDATION" : Checks for resource conflicts such as schema errors.
  /// - "DESIRED_STATE_CHECK" : Checks the current status of the desired state
  /// for a resource.
  /// - "DESIRED_STATE_ENFORCEMENT" : Enforces the desired state for a resource
  /// that is not in desired state.
  /// - "DESIRED_STATE_CHECK_POST_ENFORCEMENT" : Re-checks the status of the
  /// desired state. This check is done for a resource after the enforcement of
  /// all OS policies. This step is used to determine the final desired state
  /// status for the resource. It accounts for any resources that might have
  /// drifted from their desired state due to side effects from executing other
  /// resources.
  core.String? type;

  $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep({
    this.errorMessage,
    this.type,
  });

  $OSPolicyAssignmentReportOSPolicyComplianceOSPolicyResourceComplianceOSPolicyResourceConfigStep.fromJson(
    core.Map json_,
  ) : this(
        errorMessage: json_['errorMessage'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceFileGcs
/// - osconfig:v1alpha : OSPolicyResourceFileGcs
/// - osconfig:v2 : OSPolicyResourceFileGcs
/// - osconfig:v2beta : OSPolicyResourceFileGcs
class $OSPolicyResourceFileGcs {
  /// Bucket of the Cloud Storage object.
  ///
  /// Required.
  core.String? bucket;

  /// Generation number of the Cloud Storage object.
  core.String? generation;

  /// Name of the Cloud Storage object.
  ///
  /// Required.
  core.String? object;

  $OSPolicyResourceFileGcs({this.bucket, this.generation, this.object});

  $OSPolicyResourceFileGcs.fromJson(core.Map json_)
    : this(
        bucket: json_['bucket'] as core.String?,
        generation: json_['generation'] as core.String?,
        object: json_['object'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
    if (generation != null) 'generation': generation!,
    if (object != null) 'object': object!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceFileRemote
/// - osconfig:v1alpha : OSPolicyResourceFileRemote
/// - osconfig:v2 : OSPolicyResourceFileRemote
/// - osconfig:v2beta : OSPolicyResourceFileRemote
class $OSPolicyResourceFileRemote {
  /// SHA256 checksum of the remote file.
  core.String? sha256Checksum;

  /// URI from which to fetch the object.
  ///
  /// It should contain both the protocol and path following the format
  /// `{protocol}://{location}`.
  ///
  /// Required.
  core.String? uri;

  $OSPolicyResourceFileRemote({this.sha256Checksum, this.uri});

  $OSPolicyResourceFileRemote.fromJson(core.Map json_)
    : this(
        sha256Checksum: json_['sha256Checksum'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sha256Checksum != null) 'sha256Checksum': sha256Checksum!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceRepositoryResourceAptRepository
/// - osconfig:v1alpha : OSPolicyResourceRepositoryResourceAptRepository
/// - osconfig:v2 : OSPolicyResourceRepositoryResourceAptRepository
/// - osconfig:v2beta : OSPolicyResourceRepositoryResourceAptRepository
class $OSPolicyResourceRepositoryResourceAptRepository {
  /// Type of archive files in this repository.
  ///
  /// Required.
  /// Possible string values are:
  /// - "ARCHIVE_TYPE_UNSPECIFIED" : Unspecified is invalid.
  /// - "DEB" : Deb indicates that the archive contains binary files.
  /// - "DEB_SRC" : Deb-src indicates that the archive contains source files.
  core.String? archiveType;

  /// List of components for this repository.
  ///
  /// Must contain at least one item.
  ///
  /// Required.
  core.List<core.String>? components;

  /// Distribution of this repository.
  ///
  /// Required.
  core.String? distribution;

  /// URI of the key file for this repository.
  ///
  /// The agent maintains a keyring at
  /// `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg`.
  core.String? gpgKey;

  /// URI for this repository.
  ///
  /// Required.
  core.String? uri;

  $OSPolicyResourceRepositoryResourceAptRepository({
    this.archiveType,
    this.components,
    this.distribution,
    this.gpgKey,
    this.uri,
  });

  $OSPolicyResourceRepositoryResourceAptRepository.fromJson(core.Map json_)
    : this(
        archiveType: json_['archiveType'] as core.String?,
        components:
            (json_['components'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        distribution: json_['distribution'] as core.String?,
        gpgKey: json_['gpgKey'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (archiveType != null) 'archiveType': archiveType!,
    if (components != null) 'components': components!,
    if (distribution != null) 'distribution': distribution!,
    if (gpgKey != null) 'gpgKey': gpgKey!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceRepositoryResourceYumRepository
/// - osconfig:v1alpha : OSPolicyResourceRepositoryResourceYumRepository
/// - osconfig:v2 : OSPolicyResourceRepositoryResourceYumRepository
/// - osconfig:v2beta : OSPolicyResourceRepositoryResourceYumRepository
class $OSPolicyResourceRepositoryResourceYumRepository {
  /// The location of the repository directory.
  ///
  /// Required.
  core.String? baseUrl;

  /// The display name of the repository.
  core.String? displayName;

  /// URIs of GPG keys.
  core.List<core.String>? gpgKeys;

  /// A one word, unique name for this repository.
  ///
  /// This is the `repo id` in the yum config file and also the `display_name`
  /// if `display_name` is omitted. This id is also used as the unique
  /// identifier when checking for resource conflicts.
  ///
  /// Required.
  core.String? id;

  $OSPolicyResourceRepositoryResourceYumRepository({
    this.baseUrl,
    this.displayName,
    this.gpgKeys,
    this.id,
  });

  $OSPolicyResourceRepositoryResourceYumRepository.fromJson(core.Map json_)
    : this(
        baseUrl: json_['baseUrl'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        gpgKeys:
            (json_['gpgKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseUrl != null) 'baseUrl': baseUrl!,
    if (displayName != null) 'displayName': displayName!,
    if (gpgKeys != null) 'gpgKeys': gpgKeys!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourceRepositoryResourceZypperRepository
/// - osconfig:v1alpha : OSPolicyResourceRepositoryResourceZypperRepository
/// - osconfig:v2 : OSPolicyResourceRepositoryResourceZypperRepository
/// - osconfig:v2beta : OSPolicyResourceRepositoryResourceZypperRepository
class $OSPolicyResourceRepositoryResourceZypperRepository {
  /// The location of the repository directory.
  ///
  /// Required.
  core.String? baseUrl;

  /// The display name of the repository.
  core.String? displayName;

  /// URIs of GPG keys.
  core.List<core.String>? gpgKeys;

  /// A one word, unique name for this repository.
  ///
  /// This is the `repo id` in the zypper config file and also the
  /// `display_name` if `display_name` is omitted. This id is also used as the
  /// unique identifier when checking for GuestPolicy conflicts.
  ///
  /// Required.
  core.String? id;

  $OSPolicyResourceRepositoryResourceZypperRepository({
    this.baseUrl,
    this.displayName,
    this.gpgKeys,
    this.id,
  });

  $OSPolicyResourceRepositoryResourceZypperRepository.fromJson(core.Map json_)
    : this(
        baseUrl: json_['baseUrl'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        gpgKeys:
            (json_['gpgKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseUrl != null) 'baseUrl': baseUrl!,
    if (displayName != null) 'displayName': displayName!,
    if (gpgKeys != null) 'gpgKeys': gpgKeys!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - connectors:v1 : Oauth2AuthCodeFlowGoogleManaged
/// - integrations:v1 : GoogleCloudConnectorsV1AuthConfigOauth2AuthCodeFlowGoogleManaged
class $Oauth2AuthCodeFlowGoogleManaged {
  /// Authorization code to be exchanged for access and refresh tokens.
  ///
  /// Optional.
  core.String? authCode;

  /// Redirect URI to be provided during the auth code exchange.
  ///
  /// Optional.
  core.String? redirectUri;

  /// Scopes the connection will request when the user performs the auth code
  /// flow.
  ///
  /// Required.
  core.List<core.String>? scopes;

  $Oauth2AuthCodeFlowGoogleManaged({
    this.authCode,
    this.redirectUri,
    this.scopes,
  });

  $Oauth2AuthCodeFlowGoogleManaged.fromJson(core.Map json_)
    : this(
        authCode: json_['authCode'] as core.String?,
        redirectUri: json_['redirectUri'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authCode != null) 'authCode': authCode!,
    if (redirectUri != null) 'redirectUri': redirectUri!,
    if (scopes != null) 'scopes': scopes!,
  };
}

/// Used by:
///
/// - vision:v1 : ObjectAnnotation
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1ProductSearchResultsObjectAnnotation
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1ProductSearchResultsObjectAnnotation
class $ObjectAnnotation {
  /// The BCP-47 language code, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  core.String? languageCode;

  /// Object ID that should align with EntityAnnotation mid.
  core.String? mid;

  /// Object name, expressed in its `language_code` language.
  core.String? name;

  /// Score of the result.
  ///
  /// Range \[0, 1\].
  core.double? score;

  $ObjectAnnotation({this.languageCode, this.mid, this.name, this.score});

  $ObjectAnnotation.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        mid: json_['mid'] as core.String?,
        name: json_['name'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (mid != null) 'mid': mid!,
    if (name != null) 'name': name!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GdataObjectId
/// - discoveryengine:v1alpha : GdataObjectId
/// - discoveryengine:v1beta : GdataObjectId
/// - firebaseappdistribution:v1 : GdataObjectId
/// - walletobjects:v1 : ObjectId
class $ObjectId00 {
  /// The name of the bucket to which this object belongs.
  core.String? bucketName;

  /// Generation of the object.
  ///
  /// Generations are monotonically increasing across writes, allowing them to
  /// be be compared to determine which generation is newer. If this is omitted
  /// in a request, then you are requesting the live object. See
  /// http://go/bigstore-versions
  core.String? generation;

  /// The name of the object.
  core.String? objectName;

  $ObjectId00({this.bucketName, this.generation, this.objectName});

  $ObjectId00.fromJson(core.Map json_)
    : this(
        bucketName: json_['bucketName'] as core.String?,
        generation: json_['generation'] as core.String?,
        objectName: json_['objectName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucketName != null) 'bucketName': bucketName!,
    if (generation != null) 'generation': generation!,
    if (objectName != null) 'objectName': objectName!,
  };
}

/// Used by:
///
/// - cloudsupport:v2 : ObjectId
/// - cloudsupport:v2beta : ObjectId
class $ObjectId01 {
  /// # gdata.* are outside protos with mising documentation
  core.String? bucketName;

  /// # gdata.* are outside protos with mising documentation
  core.String? generation;

  /// # gdata.* are outside protos with mising documentation
  core.String? objectName;

  $ObjectId01({this.bucketName, this.generation, this.objectName});

  $ObjectId01.fromJson(core.Map json_)
    : this(
        bucketName: json_['bucketName'] as core.String?,
        generation: json_['generation'] as core.String?,
        objectName: json_['objectName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucketName != null) 'bucketName': bucketName!,
    if (generation != null) 'generation': generation!,
    if (objectName != null) 'objectName': objectName!,
  };
}

/// Used by:
///
/// - datastream:v1 : OracleObjectIdentifier
/// - datastream:v1 : PostgresqlObjectIdentifier
/// - datastream:v1 : SqlServerObjectIdentifier
/// - datastream:v1alpha1 : OracleObjectIdentifier
class $ObjectIdentifier {
  /// The schema name.
  ///
  /// Required.
  core.String? schema;

  /// The table name.
  ///
  /// Required.
  core.String? table;

  $ObjectIdentifier({this.schema, this.table});

  $ObjectIdentifier.fromJson(core.Map json_)
    : this(
        schema: json_['schema'] as core.String?,
        table: json_['table'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (schema != null) 'schema': schema!,
    if (table != null) 'table': table!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_ObjectTrackingConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_ObjectTrackingConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_ObjectTrackingConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_ObjectTrackingConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_ObjectTrackingConfig
class $ObjectTrackingConfig {
  /// Model to use for object tracking.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest".
  core.String? model;

  $ObjectTrackingConfig({this.model});

  $ObjectTrackingConfig.fromJson(core.Map json_)
    : this(model: json_['model'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : ObservabilityInstanceConfig
/// - alloydb:v1beta : ObservabilityInstanceConfig
class $ObservabilityInstanceConfig {
  /// Whether assistive experiences are enabled for this AlloyDB instance.
  core.bool? assistiveExperiencesEnabled;

  /// Observability feature status for an instance.
  ///
  /// This flag is turned "off" by default.
  core.bool? enabled;

  /// Query string length.
  ///
  /// The default value is 10k.
  core.int? maxQueryStringLength;

  /// Preserve comments in query string for an instance.
  ///
  /// This flag is turned "off" by default.
  core.bool? preserveComments;

  /// Number of query execution plans captured by Insights per minute for all
  /// queries combined.
  ///
  /// The default value is 200. Any integer between 0 to 200 is considered
  /// valid.
  core.int? queryPlansPerMinute;

  /// Record application tags for an instance.
  ///
  /// This flag is turned "off" by default.
  core.bool? recordApplicationTags;

  /// Track actively running queries on the instance.
  ///
  /// If not set, this flag is "off" by default.
  core.bool? trackActiveQueries;

  /// Track client address for an instance.
  ///
  /// If not set, default value is "off".
  core.bool? trackClientAddress;

  /// Track wait event types during query execution for an instance.
  ///
  /// This flag is turned "on" by default but tracking is enabled only after
  /// observability enabled flag is also turned on. This is read-only flag and
  /// only modifiable by internal API.
  ///
  /// Output only.
  core.bool? trackWaitEventTypes;

  /// Track wait events during query execution for an instance.
  ///
  /// This flag is turned "on" by default but tracking is enabled only after
  /// observability enabled flag is also turned on.
  core.bool? trackWaitEvents;

  $ObservabilityInstanceConfig({
    this.assistiveExperiencesEnabled,
    this.enabled,
    this.maxQueryStringLength,
    this.preserveComments,
    this.queryPlansPerMinute,
    this.recordApplicationTags,
    this.trackActiveQueries,
    this.trackClientAddress,
    this.trackWaitEventTypes,
    this.trackWaitEvents,
  });

  $ObservabilityInstanceConfig.fromJson(core.Map json_)
    : this(
        assistiveExperiencesEnabled:
            json_['assistiveExperiencesEnabled'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
        maxQueryStringLength: json_['maxQueryStringLength'] as core.int?,
        preserveComments: json_['preserveComments'] as core.bool?,
        queryPlansPerMinute: json_['queryPlansPerMinute'] as core.int?,
        recordApplicationTags: json_['recordApplicationTags'] as core.bool?,
        trackActiveQueries: json_['trackActiveQueries'] as core.bool?,
        trackClientAddress: json_['trackClientAddress'] as core.bool?,
        trackWaitEventTypes: json_['trackWaitEventTypes'] as core.bool?,
        trackWaitEvents: json_['trackWaitEvents'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assistiveExperiencesEnabled != null)
      'assistiveExperiencesEnabled': assistiveExperiencesEnabled!,
    if (enabled != null) 'enabled': enabled!,
    if (maxQueryStringLength != null)
      'maxQueryStringLength': maxQueryStringLength!,
    if (preserveComments != null) 'preserveComments': preserveComments!,
    if (queryPlansPerMinute != null)
      'queryPlansPerMinute': queryPlansPerMinute!,
    if (recordApplicationTags != null)
      'recordApplicationTags': recordApplicationTags!,
    if (trackActiveQueries != null) 'trackActiveQueries': trackActiveQueries!,
    if (trackClientAddress != null) 'trackClientAddress': trackClientAddress!,
    if (trackWaitEventTypes != null)
      'trackWaitEventTypes': trackWaitEventTypes!,
    if (trackWaitEvents != null) 'trackWaitEvents': trackWaitEvents!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaObtainCrawlRateRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaObtainCrawlRateRequest
class $ObtainCrawlRateRequest {
  /// The scope of the crawl rate that the user wants to monitor.
  ///
  /// Currently, only domain and host name are supported. A domain name example:
  /// `example.com`. A host name example: `www.example.com`. Please do not
  /// include `/` in the domain or host name.
  ///
  /// Required.
  core.String? crawlRateScope;

  $ObtainCrawlRateRequest({this.crawlRateScope});

  $ObtainCrawlRateRequest.fromJson(core.Map json_)
    : this(crawlRateScope: json_['crawlRateScope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (crawlRateScope != null) 'crawlRateScope': crawlRateScope!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1OcrConfigHints
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3OcrConfigHints
class $OcrConfigHints {
  /// List of BCP-47 language codes to use for OCR.
  ///
  /// In most cases, not specifying it yields the best results since it enables
  /// automatic language detection. For languages based on the Latin alphabet,
  /// setting hints is not needed. In rare cases, when the language of the text
  /// in the image is known, setting a hint will help get better results
  /// (although it will be a significant hindrance if the hint is wrong).
  core.List<core.String>? languageHints;

  $OcrConfigHints({this.languageHints});

  $OcrConfigHints.fromJson(core.Map json_)
    : this(
        languageHints:
            (json_['languageHints'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageHints != null) 'languageHints': languageHints!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1OcrConfigPremiumFeatures
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3OcrConfigPremiumFeatures
class $OcrConfigPremiumFeatures {
  /// Turn on font identification model and return font style information.
  core.bool? computeStyleInfo;

  /// Turn on the model that can extract LaTeX math formulas.
  core.bool? enableMathOcr;

  /// Turn on selection mark detector in OCR engine.
  ///
  /// Only available in OCR 2.0 (and later) processors.
  core.bool? enableSelectionMarkDetection;

  $OcrConfigPremiumFeatures({
    this.computeStyleInfo,
    this.enableMathOcr,
    this.enableSelectionMarkDetection,
  });

  $OcrConfigPremiumFeatures.fromJson(core.Map json_)
    : this(
        computeStyleInfo: json_['computeStyleInfo'] as core.bool?,
        enableMathOcr: json_['enableMathOcr'] as core.bool?,
        enableSelectionMarkDetection:
            json_['enableSelectionMarkDetection'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (computeStyleInfo != null) 'computeStyleInfo': computeStyleInfo!,
    if (enableMathOcr != null) 'enableMathOcr': enableMathOcr!,
    if (enableSelectionMarkDetection != null)
      'enableSelectionMarkDetection': enableSelectionMarkDetection!,
  };
}

/// Used by:
///
/// - dfareporting:v3.5 : OffsetPosition
/// - dfareporting:v4 : OffsetPosition
class $OffsetPosition {
  /// Offset distance from left side of an asset or a window.
  core.int? left;

  /// Offset distance from top side of an asset or a window.
  core.int? top;

  $OffsetPosition({this.left, this.top});

  $OffsetPosition.fromJson(core.Map json_)
    : this(left: json_['left'] as core.int?, top: json_['top'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (left != null) 'left': left!,
    if (top != null) 'top': top!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : OidcToken
/// - cloudtasks:v2beta2 : OidcToken
/// - cloudtasks:v2beta3 : OidcToken
class $OidcToken00 {
  /// Audience to be used when generating OIDC token.
  ///
  /// If not specified, the URI specified in target will be used.
  core.String? audience;

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OIDC token.
  ///
  /// The service account must be within the same project as the queue. The
  /// caller must have iam.serviceAccounts.actAs permission for the service
  /// account.
  core.String? serviceAccountEmail;

  $OidcToken00({this.audience, this.serviceAccountEmail});

  $OidcToken00.fromJson(core.Map json_)
    : this(
        audience: json_['audience'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audience != null) 'audience': audience!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : OidcToken
/// - pubsub:v1 : OidcToken
class $OidcToken01 {
  /// Audience to be used when generating OIDC token.
  ///
  /// The audience claim identifies the recipients that the JWT is intended for.
  /// The audience value is a single case-sensitive string. Having multiple
  /// values (array) for the audience field is not supported. More info about
  /// the OIDC JWT token audience here:
  /// https://tools.ietf.org/html/rfc7519#section-4.1.3 Note: if not specified,
  /// the Push endpoint URL will be used.
  ///
  /// Optional.
  core.String? audience;

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// used for generating the OIDC token.
  ///
  /// For more information on setting up authentication, see
  /// [Push subscriptions](https://cloud.google.com/pubsub/docs/push).
  ///
  /// Optional.
  core.String? serviceAccountEmail;

  $OidcToken01({this.audience, this.serviceAccountEmail});

  $OidcToken01.fromJson(core.Map json_)
    : this(
        audience: json_['audience'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audience != null) 'audience': audience!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - cloudscheduler:v1 : OidcToken
/// - cloudscheduler:v1beta1 : OidcToken
class $OidcToken02 {
  /// Audience to be used when generating OIDC token.
  ///
  /// If not specified, the URI specified in target will be used.
  core.String? audience;

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OIDC token.
  ///
  /// The service account must be within the same project as the job. The caller
  /// must have iam.serviceAccounts.actAs permission for the service account.
  core.String? serviceAccountEmail;

  $OidcToken02({this.audience, this.serviceAccountEmail});

  $OidcToken02.fromJson(core.Map json_)
    : this(
        audience: json_['audience'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audience != null) 'audience': audience!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OmidAssignedTargetingOptionDetails
/// - displayvideo:v3 : OmidAssignedTargetingOptionDetails
/// - displayvideo:v4 : OmidAssignedTargetingOptionDetails
class $OmidAssignedTargetingOptionDetails {
  /// The type of Open Measurement enabled inventory.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OMID_UNSPECIFIED" : Default value when omid targeting is not specified
  /// in this version.
  /// - "OMID_FOR_MOBILE_DISPLAY_ADS" : Open Measurement enabled mobile display
  /// inventory.
  core.String? omid;

  $OmidAssignedTargetingOptionDetails({this.omid});

  $OmidAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(omid: json_['omid'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (omid != null) 'omid': omid!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OmidTargetingOptionDetails
/// - displayvideo:v3 : OmidTargetingOptionDetails
/// - displayvideo:v4 : OmidTargetingOptionDetails
class $OmidTargetingOptionDetails {
  /// The type of Open Measurement enabled inventory.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OMID_UNSPECIFIED" : Default value when omid targeting is not specified
  /// in this version.
  /// - "OMID_FOR_MOBILE_DISPLAY_ADS" : Open Measurement enabled mobile display
  /// inventory.
  core.String? omid;

  $OmidTargetingOptionDetails({this.omid});

  $OmidTargetingOptionDetails.fromJson(core.Map json_)
    : this(omid: json_['omid'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (omid != null) 'omid': omid!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : OnDeployUpdatePolicy
/// - cloudfunctions:v2alpha : OnDeployUpdatePolicy
/// - cloudfunctions:v2beta : OnDeployUpdatePolicy
class $OnDeployUpdatePolicy {
  /// contains the runtime version which was used during latest function
  /// deployment.
  ///
  /// Output only.
  core.String? runtimeVersion;

  $OnDeployUpdatePolicy({this.runtimeVersion});

  $OnDeployUpdatePolicy.fromJson(core.Map json_)
    : this(runtimeVersion: json_['runtimeVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (runtimeVersion != null) 'runtimeVersion': runtimeVersion!,
  };
}

/// Used by:
///
/// - gkehub:v1 : OnPremCluster
/// - gkehub:v1alpha : OnPremCluster
/// - gkehub:v1beta : OnPremCluster
class $OnPremCluster {
  /// Whether the cluster is an admin cluster.
  ///
  /// Immutable.
  core.bool? adminCluster;

  /// If cluster_missing is set then it denotes that
  /// API(gkeonprem.googleapis.com) resource for this GKE On-Prem cluster no
  /// longer exists.
  ///
  /// Output only.
  core.bool? clusterMissing;

  /// The on prem cluster's type.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "CLUSTERTYPE_UNSPECIFIED" : The ClusterType is not set.
  /// - "BOOTSTRAP" : The ClusterType is bootstrap cluster.
  /// - "HYBRID" : The ClusterType is baremetal hybrid cluster.
  /// - "STANDALONE" : The ClusterType is baremetal standalone cluster.
  /// - "USER" : The ClusterType is user cluster.
  core.String? clusterType;

  /// Self-link of the Google Cloud resource for the GKE On-Prem cluster.
  ///
  /// For example:
  /// //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/vmwareClusters/my-cluster
  /// //gkeonprem.googleapis.com/projects/my-project/locations/us-west1-a/bareMetalClusters/my-cluster
  ///
  /// Immutable.
  core.String? resourceLink;

  $OnPremCluster({
    this.adminCluster,
    this.clusterMissing,
    this.clusterType,
    this.resourceLink,
  });

  $OnPremCluster.fromJson(core.Map json_)
    : this(
        adminCluster: json_['adminCluster'] as core.bool?,
        clusterMissing: json_['clusterMissing'] as core.bool?,
        clusterType: json_['clusterType'] as core.String?,
        resourceLink: json_['resourceLink'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adminCluster != null) 'adminCluster': adminCluster!,
    if (clusterMissing != null) 'clusterMissing': clusterMissing!,
    if (clusterType != null) 'clusterType': clusterType!,
    if (resourceLink != null) 'resourceLink': resourceLink!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : OnPremDomainDetails
/// - managedidentities:v1alpha1 : OnPremDomainDetails
/// - managedidentities:v1beta1 : OnPremDomainDetails
class $OnPremDomainDetails {
  /// Option to disable SID filtering.
  ///
  /// Optional.
  core.bool? disableSidFiltering;

  /// FQDN of the on-prem domain being migrated.
  ///
  /// Required.
  core.String? domainName;

  $OnPremDomainDetails({this.disableSidFiltering, this.domainName});

  $OnPremDomainDetails.fromJson(core.Map json_)
    : this(
        disableSidFiltering: json_['disableSidFiltering'] as core.bool?,
        domainName: json_['domainName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableSidFiltering != null)
      'disableSidFiltering': disableSidFiltering!,
    if (domainName != null) 'domainName': domainName!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : OnPremDomainSIDDetails
/// - managedidentities:v1alpha1 : OnPremDomainSIDDetails
/// - managedidentities:v1beta1 : OnPremDomainSIDDetails
class $OnPremDomainSIDDetails {
  /// FQDN of the on-prem domain being migrated.
  core.String? name;

  /// Current SID filtering state.
  /// Possible string values are:
  /// - "SID_FILTERING_STATE_UNSPECIFIED" : SID Filtering is in unspecified
  /// state.
  /// - "ENABLED" : SID Filtering is Enabled.
  /// - "DISABLED" : SID Filtering is Disabled.
  core.String? sidFilteringState;

  $OnPremDomainSIDDetails({this.name, this.sidFilteringState});

  $OnPremDomainSIDDetails.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        sidFilteringState: json_['sidFilteringState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (sidFilteringState != null) 'sidFilteringState': sidFilteringState!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OnScreenPositionAssignedTargetingOptionDetails
/// - displayvideo:v3 : OnScreenPositionAssignedTargetingOptionDetails
/// - displayvideo:v4 : OnScreenPositionAssignedTargetingOptionDetails
class $OnScreenPositionAssignedTargetingOptionDetails {
  /// The ad type to target.
  ///
  /// Only applicable to insertion order targeting and new line items supporting
  /// the specified ad type will inherit this targeting option by default.
  /// Possible values are: * `AD_TYPE_DISPLAY`, the setting will be inherited by
  /// new line item when line_item_type is `LINE_ITEM_TYPE_DISPLAY_DEFAULT`. *
  /// `AD_TYPE_VIDEO`, the setting will be inherited by new line item when
  /// line_item_type is `LINE_ITEM_TYPE_VIDEO_DEFAULT`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AD_TYPE_UNSPECIFIED" : Ad type is not specified or is unknown in this
  /// version.
  /// - "AD_TYPE_DISPLAY" : Display creatives, e.g. image and HTML5.
  /// - "AD_TYPE_VIDEO" : Video creatives, e.g. video ads that play during
  /// streaming content in video players.
  /// - "AD_TYPE_AUDIO" : Audio creatives, e.g. audio ads that play during audio
  /// content.
  core.String? adType;

  /// The on screen position.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ON_SCREEN_POSITION_UNSPECIFIED" : On screen position is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real on screen position.
  /// - "ON_SCREEN_POSITION_UNKNOWN" : The ad position is unknown on the screen.
  /// - "ON_SCREEN_POSITION_ABOVE_THE_FOLD" : The ad is located above the fold.
  /// - "ON_SCREEN_POSITION_BELOW_THE_FOLD" : The ad is located below the fold.
  core.String? onScreenPosition;

  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_ON_SCREEN_POSITION`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $OnScreenPositionAssignedTargetingOptionDetails({
    this.adType,
    this.onScreenPosition,
    this.targetingOptionId,
  });

  $OnScreenPositionAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        adType: json_['adType'] as core.String?,
        onScreenPosition: json_['onScreenPosition'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adType != null) 'adType': adType!,
    if (onScreenPosition != null) 'onScreenPosition': onScreenPosition!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OnScreenPositionTargetingOptionDetails
/// - displayvideo:v3 : OnScreenPositionTargetingOptionDetails
/// - displayvideo:v4 : OnScreenPositionTargetingOptionDetails
class $OnScreenPositionTargetingOptionDetails {
  /// The on screen position.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ON_SCREEN_POSITION_UNSPECIFIED" : On screen position is not specified
  /// in this version. This enum is a place holder for a default value and does
  /// not represent a real on screen position.
  /// - "ON_SCREEN_POSITION_UNKNOWN" : The ad position is unknown on the screen.
  /// - "ON_SCREEN_POSITION_ABOVE_THE_FOLD" : The ad is located above the fold.
  /// - "ON_SCREEN_POSITION_BELOW_THE_FOLD" : The ad is located below the fold.
  core.String? onScreenPosition;

  $OnScreenPositionTargetingOptionDetails({this.onScreenPosition});

  $OnScreenPositionTargetingOptionDetails.fromJson(core.Map json_)
    : this(onScreenPosition: json_['onScreenPosition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (onScreenPosition != null) 'onScreenPosition': onScreenPosition!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OneTimeSchedule
/// - osconfig:v1beta : OneTimeSchedule
class $OneTimeSchedule {
  /// The desired patch job execution time.
  ///
  /// Required.
  core.String? executeTime;

  $OneTimeSchedule({this.executeTime});

  $OneTimeSchedule.fromJson(core.Map json_)
    : this(executeTime: json_['executeTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (executeTime != null) 'executeTime': executeTime!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : OpenFileDetails
/// - migrationcenter:v1alpha1 : OpenFileDetails
class $OpenFileDetails {
  /// Opened file command.
  core.String? command;

  /// Opened file file path.
  core.String? filePath;

  /// Opened file file type.
  core.String? fileType;

  /// Opened file user.
  core.String? user;

  $OpenFileDetails({this.command, this.filePath, this.fileType, this.user});

  $OpenFileDetails.fromJson(core.Map json_)
    : this(
        command: json_['command'] as core.String?,
        filePath: json_['filePath'] as core.String?,
        fileType: json_['fileType'] as core.String?,
        user: json_['user'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (command != null) 'command': command!,
    if (filePath != null) 'filePath': filePath!,
    if (fileType != null) 'fileType': fileType!,
    if (user != null) 'user': user!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OperatingSystemAssignedTargetingOptionDetails
/// - displayvideo:v3 : OperatingSystemAssignedTargetingOptionDetails
/// - displayvideo:v4 : OperatingSystemAssignedTargetingOptionDetails
class $OperatingSystemAssignedTargetingOptionDetails {
  /// The display name of the operating system.
  ///
  /// Output only.
  core.String? displayName;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The targeting option ID populated in targeting_option_id field when
  /// targeting_type is `TARGETING_TYPE_OPERATING_SYSTEM`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $OperatingSystemAssignedTargetingOptionDetails({
    this.displayName,
    this.negative,
    this.targetingOptionId,
  });

  $OperatingSystemAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        negative: json_['negative'] as core.bool?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (negative != null) 'negative': negative!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : OperatingSystemTargetingOptionDetails
/// - displayvideo:v3 : OperatingSystemTargetingOptionDetails
/// - displayvideo:v4 : OperatingSystemTargetingOptionDetails
class $OperatingSystemTargetingOptionDetails {
  /// The display name of the operating system.
  ///
  /// Output only.
  core.String? displayName;

  $OperatingSystemTargetingOptionDetails({this.displayName});

  $OperatingSystemTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - container:v1 : OperationError
/// - container:v1beta1 : OperationError
class $OperationError00 {
  /// Description of the error seen during the operation.
  core.String? errorMessage;

  /// CloudKMS key resource that had the error.
  core.String? keyName;

  /// Time when the CloudKMS error was seen.
  core.String? timestamp;

  $OperationError00({this.errorMessage, this.keyName, this.timestamp});

  $OperationError00.fromJson(core.Map json_)
    : this(
        errorMessage: json_['errorMessage'] as core.String?,
        keyName: json_['keyName'] as core.String?,
        timestamp: json_['timestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (keyName != null) 'keyName': keyName!,
    if (timestamp != null) 'timestamp': timestamp!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : OperationError
/// - sqladmin:v1beta4 : OperationError
class $OperationError01 {
  /// Identifies the specific error that occurred.
  core.String? code;

  /// This is always `sql#operationError`.
  core.String? kind;

  /// Additional information about the error encountered.
  core.String? message;

  $OperationError01({this.code, this.kind, this.message});

  $OperationError01.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        kind: json_['kind'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (kind != null) 'kind': kind!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : Option
/// - serviceusage:v1 : Option
/// - serviceusage:v1beta1 : Option
class $Option {
  /// The option's name.
  ///
  /// For protobuf built-in options (options defined in descriptor.proto), this
  /// is the short name. For example, `"map_entry"`. For custom options, it
  /// should be the fully-qualified name. For example, `"google.api.http"`.
  core.String? name;

  /// The option's value packed in an Any message.
  ///
  /// If the value is a primitive, the corresponding wrapper type defined in
  /// google/protobuf/wrappers.proto should be used. If the value is an enum, it
  /// should be stored as an int32 value using the google.protobuf.Int32Value
  /// type.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? value;

  $Option({this.name, this.value});

  $Option.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value:
            json_.containsKey('value')
                ? json_['value'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - osconfig:v2 : GoogleCloudOsconfigV2_OrchestrationScope_LocationSelector
/// - osconfig:v2beta : GoogleCloudOsconfigV2beta_OrchestrationScope_LocationSelector
class $OrchestrationScope_LocationSelector {
  /// Names of the locations in scope.
  ///
  /// Format: `us-central1-a`
  ///
  /// Optional.
  core.List<core.String>? includedLocations;

  $OrchestrationScope_LocationSelector({this.includedLocations});

  $OrchestrationScope_LocationSelector.fromJson(core.Map json_)
    : this(
        includedLocations:
            (json_['includedLocations'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includedLocations != null) 'includedLocations': includedLocations!,
  };
}

/// Used by:
///
/// - osconfig:v2 : GoogleCloudOsconfigV2_OrchestrationScope_ResourceHierarchySelector
/// - osconfig:v2beta : GoogleCloudOsconfigV2beta_OrchestrationScope_ResourceHierarchySelector
class $OrchestrationScope_ResourceHierarchySelector {
  /// Names of the folders in scope.
  ///
  /// Format: `folders/{folder_id}`
  ///
  /// Optional.
  core.List<core.String>? includedFolders;

  /// Names of the projects in scope.
  ///
  /// Format: `projects/{project_number}`
  ///
  /// Optional.
  core.List<core.String>? includedProjects;

  $OrchestrationScope_ResourceHierarchySelector({
    this.includedFolders,
    this.includedProjects,
  });

  $OrchestrationScope_ResourceHierarchySelector.fromJson(core.Map json_)
    : this(
        includedFolders:
            (json_['includedFolders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        includedProjects:
            (json_['includedProjects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includedFolders != null) 'includedFolders': includedFolders!,
    if (includedProjects != null) 'includedProjects': includedProjects!,
  };
}

/// Used by:
///
/// - policysimulator:v1 : GoogleCloudPolicysimulatorV1OrgPolicyViolationsPreviewResourceCounts
/// - policysimulator:v1beta : GoogleCloudPolicysimulatorV1betaOrgPolicyViolationsPreviewResourceCounts
class $OrgPolicyViolationsPreviewResourceCounts {
  /// Number of scanned resources with zero violations.
  ///
  /// Output only.
  core.int? compliant;

  /// Number of resources that returned an error when scanned.
  ///
  /// Output only.
  core.int? errors;

  /// Number of scanned resources with at least one violation.
  ///
  /// Output only.
  core.int? noncompliant;

  /// Number of resources checked for compliance.
  ///
  /// Must equal: unenforced + noncompliant + compliant + error
  ///
  /// Output only.
  core.int? scanned;

  /// Number of resources where the constraint was not enforced, i.e. the Policy
  /// set `enforced: false` for that resource.
  ///
  /// Output only.
  core.int? unenforced;

  $OrgPolicyViolationsPreviewResourceCounts({
    this.compliant,
    this.errors,
    this.noncompliant,
    this.scanned,
    this.unenforced,
  });

  $OrgPolicyViolationsPreviewResourceCounts.fromJson(core.Map json_)
    : this(
        compliant: json_['compliant'] as core.int?,
        errors: json_['errors'] as core.int?,
        noncompliant: json_['noncompliant'] as core.int?,
        scanned: json_['scanned'] as core.int?,
        unenforced: json_['unenforced'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (compliant != null) 'compliant': compliant!,
    if (errors != null) 'errors': errors!,
    if (noncompliant != null) 'noncompliant': noncompliant!,
    if (scanned != null) 'scanned': scanned!,
    if (unenforced != null) 'unenforced': unenforced!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v1 : OrganizationOwner
/// - cloudresourcemanager:v1beta1 : OrganizationOwner
class $OrganizationOwner {
  /// The G Suite customer id used in the Directory API.
  core.String? directoryCustomerId;

  $OrganizationOwner({this.directoryCustomerId});

  $OrganizationOwner.fromJson(core.Map json_)
    : this(directoryCustomerId: json_['directoryCustomerId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (directoryCustomerId != null)
      'directoryCustomerId': directoryCustomerId!,
  };
}

/// Used by:
///
/// - gkehub:v1 : Origin
/// - gkehub:v1alpha : Origin
/// - gkehub:v1beta : Origin
class $Origin00 {
  /// Type specifies which type of origin is set.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Type is unknown or not set.
  /// - "FLEET" : Per-Membership spec was inherited from the fleet-level
  /// default.
  /// - "FLEET_OUT_OF_SYNC" : Per-Membership spec was inherited from the
  /// fleet-level default but is now out of sync with the current default.
  /// - "USER" : Per-Membership spec was inherited from a user specification.
  core.String? type;

  $Origin00({this.type});

  $Origin00.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - gkehub:v2 : Origin
/// - gkehub:v2alpha : Origin
/// - gkehub:v2beta : Origin
class $Origin01 {
  /// Type specifies which type of origin is set.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Type is unknown or not set.
  /// - "FLEET" : Per-Feature spec was inherited from the fleet-level default.
  /// - "FLEET_OUT_OF_SYNC" : Per-Feature spec was inherited from the
  /// fleet-level default but is now out of sync with the current default.
  /// - "USER" : Per-Feature spec was inherited from a user specification.
  core.String? type;

  $Origin01({this.type});

  $Origin01.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : OsConstraint
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1OsConstraint
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1OsConstraint
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1OsConstraint
class $OsConstraint {
  /// The minimum allowed OS version.
  ///
  /// If not set, any version of this OS satisfies the constraint. Format:
  /// `"major.minor.patch"`. Examples: `"10.5.301"`, `"9.2.1"`.
  core.String? minimumVersion;

  /// The allowed OS type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OS_UNSPECIFIED" : The operating system of the device is not specified
  /// or not known.
  /// - "DESKTOP_MAC" : A desktop Mac operating system.
  /// - "DESKTOP_WINDOWS" : A desktop Windows operating system.
  /// - "DESKTOP_LINUX" : A desktop Linux operating system.
  /// - "DESKTOP_CHROME_OS" : A desktop ChromeOS operating system.
  /// - "ANDROID" : An Android operating system.
  /// - "IOS" : An iOS operating system.
  core.String? osType;

  /// Only allows requests from devices with a verified Chrome OS.
  ///
  /// Verifications includes requirements that the device is enterprise-managed,
  /// conformant to domain policies, and the caller has permission to call the
  /// API targeted by the request.
  core.bool? requireVerifiedChromeOs;

  $OsConstraint({
    this.minimumVersion,
    this.osType,
    this.requireVerifiedChromeOs,
  });

  $OsConstraint.fromJson(core.Map json_)
    : this(
        minimumVersion: json_['minimumVersion'] as core.String?,
        osType: json_['osType'] as core.String?,
        requireVerifiedChromeOs: json_['requireVerifiedChromeOs'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (minimumVersion != null) 'minimumVersion': minimumVersion!,
    if (osType != null) 'osType': osType!,
    if (requireVerifiedChromeOs != null)
      'requireVerifiedChromeOs': requireVerifiedChromeOs!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : OsInfo
/// - osconfig:v1 : InventoryOsInfo
/// - osconfig:v1alpha : InventoryOsInfo
class $OsInfo {
  /// The system architecture of the operating system.
  core.String? architecture;

  /// The VM hostname.
  core.String? hostname;

  /// The kernel release of the operating system.
  core.String? kernelRelease;

  /// The kernel version of the operating system.
  core.String? kernelVersion;

  /// The operating system long name.
  ///
  /// For example 'Debian GNU/Linux 9' or 'Microsoft Window Server 2019
  /// Datacenter'.
  core.String? longName;

  /// The current version of the OS Config agent running on the VM.
  core.String? osconfigAgentVersion;

  /// The operating system short name.
  ///
  /// For example, 'windows' or 'debian'.
  core.String? shortName;

  /// The version of the operating system.
  core.String? version;

  $OsInfo({
    this.architecture,
    this.hostname,
    this.kernelRelease,
    this.kernelVersion,
    this.longName,
    this.osconfigAgentVersion,
    this.shortName,
    this.version,
  });

  $OsInfo.fromJson(core.Map json_)
    : this(
        architecture: json_['architecture'] as core.String?,
        hostname: json_['hostname'] as core.String?,
        kernelRelease: json_['kernelRelease'] as core.String?,
        kernelVersion: json_['kernelVersion'] as core.String?,
        longName: json_['longName'] as core.String?,
        osconfigAgentVersion: json_['osconfigAgentVersion'] as core.String?,
        shortName: json_['shortName'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (architecture != null) 'architecture': architecture!,
    if (hostname != null) 'hostname': hostname!,
    if (kernelRelease != null) 'kernelRelease': kernelRelease!,
    if (kernelVersion != null) 'kernelVersion': kernelVersion!,
    if (longName != null) 'longName': longName!,
    if (osconfigAgentVersion != null)
      'osconfigAgentVersion': osconfigAgentVersion!,
    if (shortName != null) 'shortName': shortName!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1OsVersion
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1OsVersion
class $OsVersion {
  /// Numeric version code of the OS - API level
  core.String? apiLevel;

  $OsVersion({this.apiLevel});

  $OsVersion.fromJson(core.Map json_)
    : this(apiLevel: json_['apiLevel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiLevel != null) 'apiLevel': apiLevel!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : OutdatedLibrary
/// - websecurityscanner:v1alpha : OutdatedLibrary
/// - websecurityscanner:v1beta : OutdatedLibrary
class $OutdatedLibrary {
  /// URLs to learn more information about the vulnerabilities in the library.
  core.List<core.String>? learnMoreUrls;

  /// The name of the outdated library.
  core.String? libraryName;

  /// The version number.
  core.String? version;

  $OutdatedLibrary({this.learnMoreUrls, this.libraryName, this.version});

  $OutdatedLibrary.fromJson(core.Map json_)
    : this(
        learnMoreUrls:
            (json_['learnMoreUrls'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        libraryName: json_['libraryName'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (learnMoreUrls != null) 'learnMoreUrls': learnMoreUrls!,
    if (libraryName != null) 'libraryName': libraryName!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2OutputConfigBigQueryDestination
/// - retail:v2alpha : GoogleCloudRetailV2alphaOutputConfigBigQueryDestination
/// - retail:v2beta : GoogleCloudRetailV2betaOutputConfigBigQueryDestination
class $OutputConfigBigQueryDestination {
  /// The ID of a BigQuery Dataset.
  ///
  /// Required.
  core.String? datasetId;

  /// The prefix of exported BigQuery tables.
  ///
  /// Required.
  core.String? tableIdPrefix;

  /// Describes the table type.
  ///
  /// The following values are supported: * `table`: A BigQuery native table. *
  /// `view`: A virtual table defined by a SQL query.
  ///
  /// Required.
  core.String? tableType;

  $OutputConfigBigQueryDestination({
    this.datasetId,
    this.tableIdPrefix,
    this.tableType,
  });

  $OutputConfigBigQueryDestination.fromJson(core.Map json_)
    : this(
        datasetId: json_['datasetId'] as core.String?,
        tableIdPrefix: json_['tableIdPrefix'] as core.String?,
        tableType: json_['tableType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetId != null) 'datasetId': datasetId!,
    if (tableIdPrefix != null) 'tableIdPrefix': tableIdPrefix!,
    if (tableType != null) 'tableType': tableType!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2OutputConfigGcsDestination
/// - retail:v2alpha : GoogleCloudRetailV2alphaOutputConfigGcsDestination
/// - retail:v2beta : GoogleCloudRetailV2betaOutputConfigGcsDestination
class $OutputConfigGcsDestination {
  /// The output uri prefix for saving output data to json files.
  ///
  /// Some mapping examples are as follows: output_uri_prefix sample
  /// output(assuming the object is foo.json) ========================
  /// ============================================= gs://bucket/
  /// gs://bucket/foo.json gs://bucket/folder/ gs://bucket/folder/foo.json
  /// gs://bucket/folder/item_ gs://bucket/folder/item_foo.json
  ///
  /// Required.
  core.String? outputUriPrefix;

  $OutputConfigGcsDestination({this.outputUriPrefix});

  $OutputConfigGcsDestination.fromJson(core.Map json_)
    : this(outputUriPrefix: json_['outputUriPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix!,
  };
}

/// Used by:
///
/// - dataproc:v1 : OutputMetrics
/// - dataproc:v1 : StageOutputMetrics
class $OutputMetrics {
  core.String? bytesWritten;
  core.String? recordsWritten;

  $OutputMetrics({this.bytesWritten, this.recordsWritten});

  $OutputMetrics.fromJson(core.Map json_)
    : this(
        bytesWritten: json_['bytesWritten'] as core.String?,
        recordsWritten: json_['recordsWritten'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bytesWritten != null) 'bytesWritten': bytesWritten!,
    if (recordsWritten != null) 'recordsWritten': recordsWritten!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PSCAutomationConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PSCAutomationConfig
class $PSCAutomationConfig {
  /// Error message if the PSC service automation failed.
  ///
  /// Output only.
  core.String? errorMessage;

  /// Forwarding rule created by the PSC service automation.
  ///
  /// Output only.
  core.String? forwardingRule;

  /// IP address rule created by the PSC service automation.
  ///
  /// Output only.
  core.String? ipAddress;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/get):
  /// `projects/{project}/global/networks/{network}`.
  ///
  /// Required.
  core.String? network;

  /// Project id used to create forwarding rule.
  ///
  /// Required.
  core.String? projectId;

  /// The state of the PSC service automation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PSC_AUTOMATION_STATE_UNSPECIFIED" : Should not be used.
  /// - "PSC_AUTOMATION_STATE_SUCCESSFUL" : The PSC service automation is
  /// successful.
  /// - "PSC_AUTOMATION_STATE_FAILED" : The PSC service automation has failed.
  core.String? state;

  $PSCAutomationConfig({
    this.errorMessage,
    this.forwardingRule,
    this.ipAddress,
    this.network,
    this.projectId,
    this.state,
  });

  $PSCAutomationConfig.fromJson(core.Map json_)
    : this(
        errorMessage: json_['errorMessage'] as core.String?,
        forwardingRule: json_['forwardingRule'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        network: json_['network'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (network != null) 'network': network!,
    if (projectId != null) 'projectId': projectId!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : Pacing
/// - displayvideo:v3 : Pacing
/// - displayvideo:v4 : Pacing
class $Pacing {
  /// Maximum number of impressions to serve every day.
  ///
  /// Applicable when the budget is impression based. Must be greater than 0.
  core.String? dailyMaxImpressions;

  /// Maximum currency amount to spend every day in micros of advertiser's
  /// currency.
  ///
  /// Applicable when the budget is currency based. Must be greater than 0. For
  /// example, for 1.5 standard unit of the currency, set this field to 1500000.
  /// The value assigned will be rounded to whole billable units for the
  /// relevant currency by the following rules: any positive value less than a
  /// single billable unit will be rounded up to one billable unit and any value
  /// larger than a single billable unit will be rounded down to the nearest
  /// billable value. For example, if the currency's billable unit is 0.01, and
  /// this field is set to 10257770, it will round down to 10250000, a value of
  /// 10.25. If set to 505, it will round up to 10000, a value of 0.01.
  core.String? dailyMaxMicros;

  /// The time period in which the pacing budget will be spent.
  ///
  /// When automatic budget allocation is enabled at the insertion order via
  /// automationType, this field is output only and defaults to
  /// `PACING_PERIOD_FLIGHT`.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PACING_PERIOD_UNSPECIFIED" : Period value is not specified or is
  /// unknown in this version.
  /// - "PACING_PERIOD_DAILY" : The pacing setting will be applied on daily
  /// basis.
  /// - "PACING_PERIOD_FLIGHT" : The pacing setting will be applied to the whole
  /// flight duration.
  core.String? pacingPeriod;

  /// The type of pacing that defines how the budget amount will be spent across
  /// the pacing_period.
  ///
  /// `PACING_TYPE_ASAP` is not compatible with pacing_period
  /// `PACING_PERIOD_FLIGHT` for insertion orders.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PACING_TYPE_UNSPECIFIED" : Pacing mode value is not specified or is
  /// unknown in this version.
  /// - "PACING_TYPE_AHEAD" : Only applicable to `PACING_PERIOD_FLIGHT` pacing
  /// period. Ahead pacing attempts to spend faster than evenly, to make sure
  /// the entire budget is spent by the end of the flight.
  /// - "PACING_TYPE_ASAP" : Spend all of pacing budget amount as quick as
  /// possible.
  /// - "PACING_TYPE_EVEN" : Spend a consistent budget amount every period of
  /// time.
  core.String? pacingType;

  $Pacing({
    this.dailyMaxImpressions,
    this.dailyMaxMicros,
    this.pacingPeriod,
    this.pacingType,
  });

  $Pacing.fromJson(core.Map json_)
    : this(
        dailyMaxImpressions: json_['dailyMaxImpressions'] as core.String?,
        dailyMaxMicros: json_['dailyMaxMicros'] as core.String?,
        pacingPeriod: json_['pacingPeriod'] as core.String?,
        pacingType: json_['pacingType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dailyMaxImpressions != null)
      'dailyMaxImpressions': dailyMaxImpressions!,
    if (dailyMaxMicros != null) 'dailyMaxMicros': dailyMaxMicros!,
    if (pacingPeriod != null) 'pacingPeriod': pacingPeriod!,
    if (pacingType != null) 'pacingType': pacingType!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : Package
/// - artifactregistry:v1beta2 : Package
class $Package {
  /// Client specified annotations.
  ///
  /// Optional.
  core.Map<core.String, core.String>? annotations;

  /// The time when the package was created.
  core.String? createTime;

  /// The display name of the package.
  core.String? displayName;

  /// The name of the package, for example:
  /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1`.
  ///
  /// If the package ID part contains slashes, the slashes are escaped.
  core.String? name;

  /// The time when the package was last updated.
  ///
  /// This includes publishing a new version of the package.
  core.String? updateTime;

  $Package({
    this.annotations,
    this.createTime,
    this.displayName,
    this.name,
    this.updateTime,
  });

  $Package.fromJson(core.Map json_)
    : this(
        annotations: (json_['annotations']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - ondemandscanning:v1 : PackageVersion
/// - ondemandscanning:v1beta1 : PackageVersion
class $PackageVersion {
  /// The licenses associated with this package.
  ///
  /// Note that this has to go on the PackageVersion level, because we can have
  /// cases with images with the same source having different licences. E.g. in
  /// Alpine, musl and musl-utils both have the same origin musl, but have
  /// different sets of licenses.
  core.List<core.String>? licenses;
  core.String? name;
  core.String? version;

  $PackageVersion({this.licenses, this.name, this.version});

  $PackageVersion.fromJson(core.Map json_)
    : this(
        licenses:
            (json_['licenses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (licenses != null) 'licenses': licenses!,
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketIntervals
/// - compute:beta : PacketIntervals
/// - compute:v1 : PacketIntervals
class $PacketIntervals {
  /// Average observed inter-packet interval in milliseconds.
  core.String? avgMs;

  /// From how long ago in the past these intervals were observed.
  /// Possible string values are:
  /// - "DURATION_UNSPECIFIED"
  /// - "HOUR"
  /// - "MAX" : From BfdSession object creation time.
  /// - "MINUTE"
  core.String? duration;

  /// Maximum observed inter-packet interval in milliseconds.
  core.String? maxMs;

  /// Minimum observed inter-packet interval in milliseconds.
  core.String? minMs;

  /// Number of inter-packet intervals from which these statistics were derived.
  core.String? numIntervals;

  /// The type of packets for which inter-packet intervals were computed.
  /// Possible string values are:
  /// - "LOOPBACK" : Only applies to Echo packets. This shows the intervals
  /// between sending and receiving the same packet.
  /// - "RECEIVE" : Intervals between received packets.
  /// - "TRANSMIT" : Intervals between transmitted packets.
  /// - "TYPE_UNSPECIFIED"
  core.String? type;

  $PacketIntervals({
    this.avgMs,
    this.duration,
    this.maxMs,
    this.minMs,
    this.numIntervals,
    this.type,
  });

  $PacketIntervals.fromJson(core.Map json_)
    : this(
        avgMs: json_['avgMs'] as core.String?,
        duration: json_['duration'] as core.String?,
        maxMs: json_['maxMs'] as core.String?,
        minMs: json_['minMs'] as core.String?,
        numIntervals: json_['numIntervals'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avgMs != null) 'avgMs': avgMs!,
    if (duration != null) 'duration': duration!,
    if (maxMs != null) 'maxMs': maxMs!,
    if (minMs != null) 'minMs': minMs!,
    if (numIntervals != null) 'numIntervals': numIntervals!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketMirroringFilter
/// - compute:beta : PacketMirroringFilter
/// - compute:v1 : PacketMirroringFilter
class $PacketMirroringFilter {
  /// Protocols that apply as filter on mirrored traffic.
  ///
  /// If no protocols are specified, all traffic that matches the specified CIDR
  /// ranges is mirrored. If neither cidrRanges nor IPProtocols is specified,
  /// all IPv4 traffic is mirrored.
  core.List<core.String>? IPProtocols;

  /// One or more IPv4 or IPv6 CIDR ranges that apply as filters on the source
  /// (ingress) or destination (egress) IP in the IP header.
  ///
  /// If no ranges are specified, all IPv4 traffic that matches the specified
  /// IPProtocols is mirrored. If neither cidrRanges nor IPProtocols is
  /// specified, all IPv4 traffic is mirrored. To mirror all IPv4 and IPv6
  /// traffic, use "0.0.0.0/0,::/0".
  core.List<core.String>? cidrRanges;

  /// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH.
  ///
  /// The default is BOTH.
  /// Possible string values are:
  /// - "BOTH" : Default, both directions are mirrored.
  /// - "EGRESS" : Only egress traffic is mirrored.
  /// - "INGRESS" : Only ingress traffic is mirrored.
  core.String? direction;

  $PacketMirroringFilter({this.IPProtocols, this.cidrRanges, this.direction});

  $PacketMirroringFilter.fromJson(core.Map json_)
    : this(
        IPProtocols:
            (json_['IPProtocols'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        cidrRanges:
            (json_['cidrRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        direction: json_['direction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (IPProtocols != null) 'IPProtocols': IPProtocols!,
    if (cidrRanges != null) 'cidrRanges': cidrRanges!,
    if (direction != null) 'direction': direction!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketMirroringForwardingRuleInfo
/// - compute:beta : PacketMirroringForwardingRuleInfo
/// - compute:v1 : PacketMirroringForwardingRuleInfo
class $PacketMirroringForwardingRuleInfo {
  /// Unique identifier for the forwarding rule; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the forwarding rule representing the ILB configured as
  /// destination of the mirrored traffic.
  core.String? url;

  $PacketMirroringForwardingRuleInfo({this.canonicalUrl, this.url});

  $PacketMirroringForwardingRuleInfo.fromJson(core.Map json_)
    : this(
        canonicalUrl: json_['canonicalUrl'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketMirroringMirroredResourceInfoInstanceInfo
/// - compute:beta : PacketMirroringMirroredResourceInfoInstanceInfo
/// - compute:v1 : PacketMirroringMirroredResourceInfoInstanceInfo
class $PacketMirroringMirroredResourceInfoInstanceInfo {
  /// Unique identifier for the instance; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the virtual machine instance which is being mirrored.
  core.String? url;

  $PacketMirroringMirroredResourceInfoInstanceInfo({
    this.canonicalUrl,
    this.url,
  });

  $PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(core.Map json_)
    : this(
        canonicalUrl: json_['canonicalUrl'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketMirroringMirroredResourceInfoSubnetInfo
/// - compute:beta : PacketMirroringMirroredResourceInfoSubnetInfo
/// - compute:v1 : PacketMirroringMirroredResourceInfoSubnetInfo
class $PacketMirroringMirroredResourceInfoSubnetInfo {
  /// Unique identifier for the subnetwork; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the subnetwork for which traffic from/to all VM instances
  /// will be mirrored.
  core.String? url;

  $PacketMirroringMirroredResourceInfoSubnetInfo({this.canonicalUrl, this.url});

  $PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(core.Map json_)
    : this(
        canonicalUrl: json_['canonicalUrl'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - compute:alpha : PacketMirroringNetworkInfo
/// - compute:beta : PacketMirroringNetworkInfo
/// - compute:v1 : PacketMirroringNetworkInfo
class $PacketMirroringNetworkInfo {
  /// Unique identifier for the network; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// URL of the network resource.
  core.String? url;

  $PacketMirroringNetworkInfo({this.canonicalUrl, this.url});

  $PacketMirroringNetworkInfo.fromJson(core.Map json_)
    : this(
        canonicalUrl: json_['canonicalUrl'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - blogger:v2 : Page
/// - blogger:v3 : Page
class $Page {
  /// The author of this Page.
  PageAuthor? author;

  /// Data about the blog containing this Page.
  PageBlog? blog;

  /// The body content of this Page, in HTML.
  core.String? content;

  /// Etag of the resource.
  core.String? etag;

  /// The identifier for this resource.
  core.String? id;

  /// The kind of this entity.
  ///
  /// Always blogger#page.
  core.String? kind;

  /// RFC 3339 date-time when this Page was published.
  core.String? published;

  /// The API REST URL to fetch this resource from.
  core.String? selfLink;

  /// The status of the page for admin resources (either LIVE or DRAFT).
  /// Possible string values are:
  /// - "LIVE"
  /// - "DRAFT"
  /// - "SOFT_TRASHED"
  core.String? status;

  /// The title of this entity.
  ///
  /// This is the name displayed in the Admin user interface.
  core.String? title;

  /// RFC 3339 date-time when this Page was trashed.
  core.String? trashed;

  /// RFC 3339 date-time when this Page was last updated.
  core.String? updated;

  /// The URL that this Page is displayed at.
  core.String? url;

  $Page({
    this.author,
    this.blog,
    this.content,
    this.etag,
    this.id,
    this.kind,
    this.published,
    this.selfLink,
    this.status,
    this.title,
    this.trashed,
    this.updated,
    this.url,
  });

  $Page.fromJson(core.Map json_)
    : this(
        author:
            json_.containsKey('author')
                ? PageAuthor.fromJson(
                  json_['author'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        blog:
            json_.containsKey('blog')
                ? PageBlog.fromJson(
                  json_['blog'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        content: json_['content'] as core.String?,
        etag: json_['etag'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        published: json_['published'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        title: json_['title'] as core.String?,
        trashed: json_['trashed'] as core.String?,
        updated: json_['updated'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (author != null) 'author': author!,
    if (blog != null) 'blog': blog!,
    if (content != null) 'content': content!,
    if (etag != null) 'etag': etag!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (published != null) 'published': published!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (title != null) 'title': title!,
    if (trashed != null) 'trashed': trashed!,
    if (updated != null) 'updated': updated!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PageInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPageInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPageInfo
class $PageInfo00 {
  /// The most specific category associated with a category page.
  ///
  /// To represent full path of category, use '\>' sign to separate different
  /// hierarchies. If '\>' is part of the category name, replace it with other
  /// character(s). Category pages include special pages such as sales or
  /// promotions. For instance, a special sale page may have the category
  /// hierarchy: `"pageCategory" : "Sales > 2017 Black Friday Deals"`. Required
  /// for `view-category-page` events. Other event types should not set this
  /// field. Otherwise, an `INVALID_ARGUMENT` error is returned.
  core.String? pageCategory;

  /// A unique ID of a web page view.
  ///
  /// This should be kept the same for all user events triggered from the same
  /// pageview. For example, an item detail page view could trigger multiple
  /// events as the user is browsing the page. The `pageview_id` property should
  /// be kept the same for all these events so that they can be grouped together
  /// properly. When using the client side event reporting with JavaScript pixel
  /// and Google Tag Manager, this value is filled in automatically.
  core.String? pageviewId;

  /// The referrer URL of the current page.
  ///
  /// When using the client side event reporting with JavaScript pixel and
  /// Google Tag Manager, this value is filled in automatically. However, some
  /// browser privacy restrictions may cause this field to be empty.
  core.String? referrerUri;

  /// Complete URL (window.location.href) of the user's current page.
  ///
  /// When using the client side event reporting with JavaScript pixel and
  /// Google Tag Manager, this value is filled in automatically. Maximum length
  /// 5,000 characters.
  core.String? uri;

  $PageInfo00({this.pageCategory, this.pageviewId, this.referrerUri, this.uri});

  $PageInfo00.fromJson(core.Map json_)
    : this(
        pageCategory: json_['pageCategory'] as core.String?,
        pageviewId: json_['pageviewId'] as core.String?,
        referrerUri: json_['referrerUri'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageCategory != null) 'pageCategory': pageCategory!,
    if (pageviewId != null) 'pageviewId': pageviewId!,
    if (referrerUri != null) 'referrerUri': referrerUri!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - androidenterprise:v1 : PageInfo
/// - androidpublisher:v3 : PageInfo
class $PageInfo01 {
  /// Maximum number of results returned in one page.
  ///
  /// ! The number of results included in the API response.
  core.int? resultPerPage;

  /// Index of the first result returned in the current page.
  core.int? startIndex;

  /// Total number of results available on the backend ! The total number of
  /// results in the result set.
  core.int? totalResults;

  $PageInfo01({this.resultPerPage, this.startIndex, this.totalResults});

  $PageInfo01.fromJson(core.Map json_)
    : this(
        resultPerPage: json_['resultPerPage'] as core.int?,
        startIndex: json_['startIndex'] as core.int?,
        totalResults: json_['totalResults'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resultPerPage != null) 'resultPerPage': resultPerPage!,
    if (startIndex != null) 'startIndex': startIndex!,
    if (totalResults != null) 'totalResults': totalResults!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInstance
class $PairwiseQuestionAnsweringQualityInstance {
  /// Output of the baseline model.
  ///
  /// Required.
  core.String? baselinePrediction;

  /// Text to answer the question.
  ///
  /// Required.
  core.String? context;

  /// Question Answering prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the candidate model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $PairwiseQuestionAnsweringQualityInstance({
    this.baselinePrediction,
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $PairwiseQuestionAnsweringQualityInstance.fromJson(core.Map json_)
    : this(
        baselinePrediction: json_['baselinePrediction'] as core.String?,
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselinePrediction != null) 'baselinePrediction': baselinePrediction!,
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityResult
class $PairwiseQuestionAnsweringQualityResult {
  /// Confidence for question answering quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise question answering prediction choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  $PairwiseQuestionAnsweringQualityResult({
    this.confidence,
    this.explanation,
    this.pairwiseChoice,
  });

  $PairwiseQuestionAnsweringQualityResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        pairwiseChoice: json_['pairwiseChoice'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInstance
class $PairwiseSummarizationQualityInstance {
  /// Output of the baseline model.
  ///
  /// Required.
  core.String? baselinePrediction;

  /// Text to be summarized.
  ///
  /// Required.
  core.String? context;

  /// Summarization prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the candidate model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $PairwiseSummarizationQualityInstance({
    this.baselinePrediction,
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $PairwiseSummarizationQualityInstance.fromJson(core.Map json_)
    : this(
        baselinePrediction: json_['baselinePrediction'] as core.String?,
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselinePrediction != null) 'baselinePrediction': baselinePrediction!,
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseSummarizationQualityResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityResult
class $PairwiseSummarizationQualityResult {
  /// Confidence for summarization quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise summarization prediction choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  $PairwiseSummarizationQualityResult({
    this.confidence,
    this.explanation,
    this.pairwiseChoice,
  });

  $PairwiseSummarizationQualityResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        pairwiseChoice: json_['pairwiseChoice'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseSummarizationQualitySpec
class $PairwiseSummarizationQualitySpec {
  /// Whether to use instance.reference to compute pairwise summarization
  /// quality.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $PairwiseSummarizationQualitySpec({this.useReference, this.version});

  $PairwiseSummarizationQualitySpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - parallelstore:v1 : DestinationParallelstore
/// - parallelstore:v1 : SourceParallelstore
/// - parallelstore:v1beta : DestinationParallelstore
/// - parallelstore:v1beta : SourceParallelstore
class $Parallelstore {
  /// Root directory path to the Paralellstore filesystem, starting with `/`.
  ///
  /// Defaults to `/` if unset.
  ///
  /// Optional.
  core.String? path;

  $Parallelstore({this.path});

  $Parallelstore.fromJson(core.Map json_)
    : this(path: json_['path'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - container:v1 : ParallelstoreCsiDriverConfig
/// - container:v1beta1 : ParallelstoreCsiDriverConfig
class $ParallelstoreCsiDriverConfig {
  /// Whether the Cloud Storage Parallelstore CSI driver is enabled for this
  /// cluster.
  core.bool? enabled;

  $ParallelstoreCsiDriverConfig({this.enabled});

  $ParallelstoreCsiDriverConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - compute:alpha : BackendBucketParams
/// - compute:alpha : BackendServiceParams
/// - compute:alpha : FirewallParams
/// - compute:alpha : NetworkParams
/// - compute:alpha : RouteParams
/// - compute:alpha : SubnetworkParams
/// - compute:beta : BackendBucketParams
/// - compute:beta : BackendServiceParams
/// - compute:beta : FirewallParams
/// - compute:beta : NetworkParams
/// - compute:beta : RouteParams
/// - compute:beta : SubnetworkParams
/// - compute:v1 : FirewallParams
/// - compute:v1 : NetworkParams
/// - compute:v1 : RouteParams
/// - compute:v1 : SubnetworkParams
class $Params {
  /// Tag keys/values directly bound to this resource.
  ///
  /// Tag keys and values have the same definition as resource manager tags. The
  /// field is allowed for INSERT only. The keys/values to set on the resource
  /// should be specified in either ID { : } or Namespaced format { : }. For
  /// example the following are valid inputs: * {"tagKeys/333" :
  /// "tagValues/444", "tagKeys/123" : "tagValues/456"} * {"123/environment" :
  /// "production", "345/abc" : "xyz"} Note: * Invalid combinations of ID &
  /// namespaced format is not supported. For instance: {"123/environment" :
  /// "tagValues/444"} is invalid.
  core.Map<core.String, core.String>? resourceManagerTags;

  $Params({this.resourceManagerTags});

  $Params.fromJson(core.Map json_)
    : this(
        resourceManagerTags: (json_['resourceManagerTags']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceManagerTags != null)
      'resourceManagerTags': resourceManagerTags!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : ParentEntityFilter
/// - displayvideo:v4 : ParentEntityFilter
class $ParentEntityFilter {
  /// File types that will be returned.
  ///
  /// Required.
  core.List<core.String>? fileType;

  /// The IDs of the specified filter type.
  ///
  /// This is used to filter entities to fetch. If filter type is not
  /// `FILTER_TYPE_NONE`, at least one ID must be specified.
  core.List<core.String>? filterIds;

  /// Filter type used to filter fetched entities.
  ///
  /// Required.
  /// Possible string values are:
  /// - "FILTER_TYPE_UNSPECIFIED" : Default value when type is unspecified or is
  /// unknown in this version.
  /// - "FILTER_TYPE_NONE" : If selected, no filter will be applied to the
  /// download. Can only be used if an Advertiser is specified in
  /// CreateSdfDownloadTaskRequest.
  /// - "FILTER_TYPE_ADVERTISER_ID" : Advertiser ID. If selected, all filter IDs
  /// must be Advertiser IDs that belong to the Partner specified in
  /// CreateSdfDownloadTaskRequest.
  /// - "FILTER_TYPE_CAMPAIGN_ID" : Campaign ID. If selected, all filter IDs
  /// must be Campaign IDs that belong to the Advertiser or Partner specified in
  /// CreateSdfDownloadTaskRequest.
  /// - "FILTER_TYPE_MEDIA_PRODUCT_ID" : Media Product ID. If selected, all
  /// filter IDs must be Media Product IDs that belong to the Advertiser or
  /// Partner specified in CreateSdfDownloadTaskRequest. Can only be used for
  /// downloading `FILE_TYPE_MEDIA_PRODUCT`.
  /// - "FILTER_TYPE_INSERTION_ORDER_ID" : Insertion Order ID. If selected, all
  /// filter IDs must be Insertion Order IDs that belong to the Advertiser or
  /// Partner specified in CreateSdfDownloadTaskRequest. Can only be used for
  /// downloading `FILE_TYPE_INSERTION_ORDER`, `FILE_TYPE_LINE_ITEM`,
  /// `FILE_TYPE_LINE_ITEM_QA`, `FILE_TYPE_AD_GROUP`, `FILE_TYPE_AD_GROUP_QA`,
  /// and `FILE_TYPE_AD`.
  /// - "FILTER_TYPE_LINE_ITEM_ID" : Line Item ID. If selected, all filter IDs
  /// must be Line Item IDs that belong to the Advertiser or Partner specified
  /// in CreateSdfDownloadTaskRequest. Can only be used for downloading
  /// `FILE_TYPE_LINE_ITEM`, `FILE_TYPE_LINE_ITEM_QA`,`FILE_TYPE_AD_GROUP`,
  /// `FILE_TYPE_AD_GROUP_QA`, and `FILE_TYPE_AD`.
  core.String? filterType;

  $ParentEntityFilter({this.fileType, this.filterIds, this.filterType});

  $ParentEntityFilter.fromJson(core.Map json_)
    : this(
        fileType:
            (json_['fileType'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        filterIds:
            (json_['filterIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        filterType: json_['filterType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fileType != null) 'fileType': fileType!,
    if (filterIds != null) 'filterIds': filterIds!,
    if (filterType != null) 'filterType': filterType!,
  };
}

/// Used by:
///
/// - container:v1 : ParentProductConfig
/// - container:v1beta1 : ParentProductConfig
class $ParentProductConfig {
  /// Labels contain the configuration of the parent product.
  core.Map<core.String, core.String>? labels;

  /// Name of the parent product associated with the cluster.
  core.String? productName;

  $ParentProductConfig({this.labels, this.productName});

  $ParentProductConfig.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        productName: json_['productName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (productName != null) 'productName': productName!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ParentalStatusAssignedTargetingOptionDetails
/// - displayvideo:v3 : ParentalStatusAssignedTargetingOptionDetails
/// - displayvideo:v4 : ParentalStatusAssignedTargetingOptionDetails
class $ParentalStatusAssignedTargetingOptionDetails {
  /// The parental status of the audience.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PARENTAL_STATUS_UNSPECIFIED" : Default value when parental status is
  /// not specified in this version. This enum is a place holder for default
  /// value and does not represent a real parental status option.
  /// - "PARENTAL_STATUS_PARENT" : The audience is a parent.
  /// - "PARENTAL_STATUS_NOT_A_PARENT" : The audience is not a parent.
  /// - "PARENTAL_STATUS_UNKNOWN" : The parental status of the audience is
  /// unknown.
  core.String? parentalStatus;

  $ParentalStatusAssignedTargetingOptionDetails({this.parentalStatus});

  $ParentalStatusAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(parentalStatus: json_['parentalStatus'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (parentalStatus != null) 'parentalStatus': parentalStatus!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ParentalStatusTargetingOptionDetails
/// - displayvideo:v3 : ParentalStatusTargetingOptionDetails
/// - displayvideo:v4 : ParentalStatusTargetingOptionDetails
class $ParentalStatusTargetingOptionDetails {
  /// The parental status of an audience.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PARENTAL_STATUS_UNSPECIFIED" : Default value when parental status is
  /// not specified in this version. This enum is a place holder for default
  /// value and does not represent a real parental status option.
  /// - "PARENTAL_STATUS_PARENT" : The audience is a parent.
  /// - "PARENTAL_STATUS_NOT_A_PARENT" : The audience is not a parent.
  /// - "PARENTAL_STATUS_UNKNOWN" : The parental status of the audience is
  /// unknown.
  core.String? parentalStatus;

  $ParentalStatusTargetingOptionDetails({this.parentalStatus});

  $ParentalStatusTargetingOptionDetails.fromJson(core.Map json_)
    : this(parentalStatus: json_['parentalStatus'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (parentalStatus != null) 'parentalStatus': parentalStatus!,
  };
}

/// Used by:
///
/// - language:v1 : PartOfSpeech
/// - language:v1beta2 : PartOfSpeech
class $PartOfSpeech {
  /// The grammatical aspect.
  /// Possible string values are:
  /// - "ASPECT_UNKNOWN" : Aspect is not applicable in the analyzed language or
  /// is not predicted.
  /// - "PERFECTIVE" : Perfective
  /// - "IMPERFECTIVE" : Imperfective
  /// - "PROGRESSIVE" : Progressive
  core.String? aspect;

  /// The grammatical case.
  /// Possible string values are:
  /// - "CASE_UNKNOWN" : Case is not applicable in the analyzed language or is
  /// not predicted.
  /// - "ACCUSATIVE" : Accusative
  /// - "ADVERBIAL" : Adverbial
  /// - "COMPLEMENTIVE" : Complementive
  /// - "DATIVE" : Dative
  /// - "GENITIVE" : Genitive
  /// - "INSTRUMENTAL" : Instrumental
  /// - "LOCATIVE" : Locative
  /// - "NOMINATIVE" : Nominative
  /// - "OBLIQUE" : Oblique
  /// - "PARTITIVE" : Partitive
  /// - "PREPOSITIONAL" : Prepositional
  /// - "REFLEXIVE_CASE" : Reflexive
  /// - "RELATIVE_CASE" : Relative
  /// - "VOCATIVE" : Vocative
  core.String? case_;

  /// The grammatical form.
  /// Possible string values are:
  /// - "FORM_UNKNOWN" : Form is not applicable in the analyzed language or is
  /// not predicted.
  /// - "ADNOMIAL" : Adnomial
  /// - "AUXILIARY" : Auxiliary
  /// - "COMPLEMENTIZER" : Complementizer
  /// - "FINAL_ENDING" : Final ending
  /// - "GERUND" : Gerund
  /// - "REALIS" : Realis
  /// - "IRREALIS" : Irrealis
  /// - "SHORT" : Short form
  /// - "LONG" : Long form
  /// - "ORDER" : Order form
  /// - "SPECIFIC" : Specific form
  core.String? form;

  /// The grammatical gender.
  /// Possible string values are:
  /// - "GENDER_UNKNOWN" : Gender is not applicable in the analyzed language or
  /// is not predicted.
  /// - "FEMININE" : Feminine
  /// - "MASCULINE" : Masculine
  /// - "NEUTER" : Neuter
  core.String? gender;

  /// The grammatical mood.
  /// Possible string values are:
  /// - "MOOD_UNKNOWN" : Mood is not applicable in the analyzed language or is
  /// not predicted.
  /// - "CONDITIONAL_MOOD" : Conditional
  /// - "IMPERATIVE" : Imperative
  /// - "INDICATIVE" : Indicative
  /// - "INTERROGATIVE" : Interrogative
  /// - "JUSSIVE" : Jussive
  /// - "SUBJUNCTIVE" : Subjunctive
  core.String? mood;

  /// The grammatical number.
  /// Possible string values are:
  /// - "NUMBER_UNKNOWN" : Number is not applicable in the analyzed language or
  /// is not predicted.
  /// - "SINGULAR" : Singular
  /// - "PLURAL" : Plural
  /// - "DUAL" : Dual
  core.String? number;

  /// The grammatical person.
  /// Possible string values are:
  /// - "PERSON_UNKNOWN" : Person is not applicable in the analyzed language or
  /// is not predicted.
  /// - "FIRST" : First
  /// - "SECOND" : Second
  /// - "THIRD" : Third
  /// - "REFLEXIVE_PERSON" : Reflexive
  core.String? person;

  /// The grammatical properness.
  /// Possible string values are:
  /// - "PROPER_UNKNOWN" : Proper is not applicable in the analyzed language or
  /// is not predicted.
  /// - "PROPER" : Proper
  /// - "NOT_PROPER" : Not proper
  core.String? proper;

  /// The grammatical reciprocity.
  /// Possible string values are:
  /// - "RECIPROCITY_UNKNOWN" : Reciprocity is not applicable in the analyzed
  /// language or is not predicted.
  /// - "RECIPROCAL" : Reciprocal
  /// - "NON_RECIPROCAL" : Non-reciprocal
  core.String? reciprocity;

  /// The part of speech tag.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown
  /// - "ADJ" : Adjective
  /// - "ADP" : Adposition (preposition and postposition)
  /// - "ADV" : Adverb
  /// - "CONJ" : Conjunction
  /// - "DET" : Determiner
  /// - "NOUN" : Noun (common and proper)
  /// - "NUM" : Cardinal number
  /// - "PRON" : Pronoun
  /// - "PRT" : Particle or other function word
  /// - "PUNCT" : Punctuation
  /// - "VERB" : Verb (all tenses and modes)
  /// - "X" : Other: foreign words, typos, abbreviations
  /// - "AFFIX" : Affix
  core.String? tag;

  /// The grammatical tense.
  /// Possible string values are:
  /// - "TENSE_UNKNOWN" : Tense is not applicable in the analyzed language or is
  /// not predicted.
  /// - "CONDITIONAL_TENSE" : Conditional
  /// - "FUTURE" : Future
  /// - "PAST" : Past
  /// - "PRESENT" : Present
  /// - "IMPERFECT" : Imperfect
  /// - "PLUPERFECT" : Pluperfect
  core.String? tense;

  /// The grammatical voice.
  /// Possible string values are:
  /// - "VOICE_UNKNOWN" : Voice is not applicable in the analyzed language or is
  /// not predicted.
  /// - "ACTIVE" : Active
  /// - "CAUSATIVE" : Causative
  /// - "PASSIVE" : Passive
  core.String? voice;

  $PartOfSpeech({
    this.aspect,
    this.case_,
    this.form,
    this.gender,
    this.mood,
    this.number,
    this.person,
    this.proper,
    this.reciprocity,
    this.tag,
    this.tense,
    this.voice,
  });

  $PartOfSpeech.fromJson(core.Map json_)
    : this(
        aspect: json_['aspect'] as core.String?,
        case_: json_['case'] as core.String?,
        form: json_['form'] as core.String?,
        gender: json_['gender'] as core.String?,
        mood: json_['mood'] as core.String?,
        number: json_['number'] as core.String?,
        person: json_['person'] as core.String?,
        proper: json_['proper'] as core.String?,
        reciprocity: json_['reciprocity'] as core.String?,
        tag: json_['tag'] as core.String?,
        tense: json_['tense'] as core.String?,
        voice: json_['voice'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aspect != null) 'aspect': aspect!,
    if (case_ != null) 'case': case_!,
    if (form != null) 'form': form!,
    if (gender != null) 'gender': gender!,
    if (mood != null) 'mood': mood!,
    if (number != null) 'number': number!,
    if (person != null) 'person': person!,
    if (proper != null) 'proper': proper!,
    if (reciprocity != null) 'reciprocity': reciprocity!,
    if (tag != null) 'tag': tag!,
    if (tense != null) 'tense': tense!,
    if (voice != null) 'voice': voice!,
  };
}

/// Used by:
///
/// - datastore:v1beta3 : PartitionId
/// - dlp:v2 : GooglePrivacyDlpV2PartitionId
class $PartitionId {
  /// If not empty, the ID of the namespace to which the entities belong.
  core.String? namespaceId;

  /// The ID of the project to which the entities belong.
  core.String? projectId;

  $PartitionId({this.namespaceId, this.projectId});

  $PartitionId.fromJson(core.Map json_)
    : this(
        namespaceId: json_['namespaceId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (namespaceId != null) 'namespaceId': namespaceId!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : PartitionSpec
/// - cloudasset:v1p7beta1 : GoogleCloudAssetV1p7beta1PartitionSpec
class $PartitionSpec {
  /// The partition key for BigQuery partitioned table.
  /// Possible string values are:
  /// - "PARTITION_KEY_UNSPECIFIED" : Unspecified partition key. If used, it
  /// means using non-partitioned table.
  /// - "READ_TIME" : The time when the snapshot is taken. If specified as
  /// partition key, the result table(s) is partitioned by the additional
  /// timestamp column, readTime. If \[read_time\] in ExportAssetsRequest is
  /// specified, the readTime column's value will be the same as it. Otherwise,
  /// its value will be the current time that is used to take the snapshot.
  /// - "REQUEST_TIME" : The time when the request is received and started to be
  /// processed. If specified as partition key, the result table(s) is
  /// partitioned by the requestTime column, an additional timestamp column
  /// representing when the request was received.
  core.String? partitionKey;

  $PartitionSpec({this.partitionKey});

  $PartitionSpec.fromJson(core.Map json_)
    : this(partitionKey: json_['partitionKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (partitionKey != null) 'partitionKey': partitionKey!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : PartnerBillingConfig
/// - displayvideo:v4 : PartnerBillingConfig
class $PartnerBillingConfig {
  /// The ID of a partner default billing profile.
  core.String? billingProfileId;

  $PartnerBillingConfig({this.billingProfileId});

  $PartnerBillingConfig.fromJson(core.Map json_)
    : this(billingProfileId: json_['billingProfileId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (billingProfileId != null) 'billingProfileId': billingProfileId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PartnerCost
/// - displayvideo:v4 : PartnerCost
class $PartnerCost {
  /// The type of the partner cost.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PARTNER_COST_TYPE_UNSPECIFIED" : Type value is not specified or is
  /// unknown in this version.
  /// - "PARTNER_COST_TYPE_ADLOOX" : The cost is charged for using Scope3
  /// (previously known as Adloox). Billed by the partner.
  /// - "PARTNER_COST_TYPE_ADLOOX_PREBID" : The cost is charged for using Scope3
  /// (previously known as Adloox) Pre-Bid. Billed through DV360.
  /// - "PARTNER_COST_TYPE_ADSAFE" : The cost is charged for using AdSafe.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_ADXPOSE" : The cost is charged for using AdExpose.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_AGGREGATE_KNOWLEDGE" : The cost is charged for using
  /// Aggregate Knowledge. Billed by the partner.
  /// - "PARTNER_COST_TYPE_AGENCY_TRADING_DESK" : The cost is charged for using
  /// an Agency Trading Desk. Billed by the partner.
  /// - "PARTNER_COST_TYPE_DV360_FEE" : The cost is charged for using DV360.
  /// Billed through DV360.
  /// - "PARTNER_COST_TYPE_COMSCORE_VCE" : The cost is charged for using
  /// comScore vCE. Billed through DV360.
  /// - "PARTNER_COST_TYPE_DATA_MANAGEMENT_PLATFORM" : The cost is charged for
  /// using a Data Management Platform. Billed by the partner.
  /// - "PARTNER_COST_TYPE_DEFAULT" : The default cost type. Billed by the
  /// partner.
  /// - "PARTNER_COST_TYPE_DOUBLE_VERIFY" : The cost is charged for using
  /// DoubleVerify. Billed by the partner.
  /// - "PARTNER_COST_TYPE_DOUBLE_VERIFY_PREBID" : The cost is charged for using
  /// DoubleVerify Pre-Bid. Billed through DV360.
  /// - "PARTNER_COST_TYPE_EVIDON" : The cost is charged for using Evidon.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_INTEGRAL_AD_SCIENCE_VIDEO" : The cost is charged for
  /// using Integral Ad Science Video. Billed by the partner.
  /// - "PARTNER_COST_TYPE_INTEGRAL_AD_SCIENCE_PREBID" : The cost is charged for
  /// using Integral Ad Science Pre-Bid. Billed through DV360.
  /// - "PARTNER_COST_TYPE_MEDIA_COST_DATA" : The cost is charged for using
  /// media cost data. Billed by the partner.
  /// - "PARTNER_COST_TYPE_MOAT_VIDEO" : The cost is charged for using MOAT
  /// Video. Billed by the partner.
  /// - "PARTNER_COST_TYPE_NIELSEN_DAR" : The cost is charged for using Nielsen
  /// Digital Ad Ratings. Billed through DV360.
  /// - "PARTNER_COST_TYPE_SHOP_LOCAL" : The cost is charged for using
  /// ShopLocal. Billed by the partner.
  /// - "PARTNER_COST_TYPE_TERACENT" : The cost is charged for using Teracent.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_THIRD_PARTY_AD_SERVER" : The cost is charged for
  /// using a third-party ad server. Billed by the partner.
  /// - "PARTNER_COST_TYPE_TRUST_METRICS" : The cost is charged for using
  /// TrustMetrics. Billed by the partner.
  /// - "PARTNER_COST_TYPE_VIZU" : The cost is charged for using Vizu. Billed by
  /// the partner.
  /// - "PARTNER_COST_TYPE_CUSTOM_FEE_1" : The cost is charged as custom fee 1.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_CUSTOM_FEE_2" : The cost is charged as custom fee 2.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_CUSTOM_FEE_3" : The cost is charged as custom fee 3.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_CUSTOM_FEE_4" : The cost is charged as custom fee 4.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_CUSTOM_FEE_5" : The cost is charged as custom fee 5.
  /// Billed by the partner.
  /// - "PARTNER_COST_TYPE_SCIBIDS_FEE" : The cost is charged for using Scibids.
  /// Billed through DV360. This type is currently only available to certain
  /// customers. Other customers attempting to use this type will receive an
  /// error.
  core.String? costType;

  /// The CPM fee amount in micros of advertiser's currency.
  ///
  /// Applicable when the fee_type is `PARTNER_FEE_TYPE_CPM_FEE`. Must be
  /// greater than or equal to 0. For example, for 1.5 standard unit of the
  /// advertiser's currency, set this field to 1500000.
  core.String? feeAmount;

  /// The media fee percentage in millis (1/1000 of a percent).
  ///
  /// Applicable when the fee_type is `PARTNER_FEE_TYPE_MEDIA_FEE`. Must be
  /// greater than or equal to 0. For example: 100 represents 0.1%.
  core.String? feePercentageMillis;

  /// The fee type for this partner cost.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PARTNER_COST_FEE_TYPE_UNSPECIFIED" : Value is not specified or is
  /// unknown in this version.
  /// - "PARTNER_COST_FEE_TYPE_CPM_FEE" : The partner cost is a fixed CPM fee.
  /// Not applicable when the partner cost cost_type is one of: *
  /// `PARTNER_COST_TYPE_MEDIA_COST_DATA` * `PARTNER_COST_TYPE_DV360_FEE`.
  /// - "PARTNER_COST_FEE_TYPE_MEDIA_FEE" : The partner cost is a percentage
  /// surcharge based on the media cost. Not applicable when the partner
  /// cost_type is one of: * `PARTNER_COST_TYPE_SHOP_LOCAL` *
  /// `PARTNER_COST_TYPE_TRUST_METRICS` *
  /// `PARTNER_COST_TYPE_INTEGRAL_AD_SCIENCE_VIDEO` *
  /// `PARTNER_COST_TYPE_MOAT_VIDEO`.
  core.String? feeType;

  /// The invoice type for this partner cost.
  ///
  /// * Required when cost_type is one of: - `PARTNER_COST_TYPE_ADLOOX` -
  /// `PARTNER_COST_TYPE_DOUBLE_VERIFY` -
  /// `PARTNER_COST_TYPE_INTEGRAL_AD_SCIENCE`. * Output only for other types.
  /// Possible string values are:
  /// - "PARTNER_COST_INVOICE_TYPE_UNSPECIFIED" : Type value is not specified or
  /// is unknown in this version.
  /// - "PARTNER_COST_INVOICE_TYPE_DV360" : Partner cost is billed through
  /// DV360.
  /// - "PARTNER_COST_INVOICE_TYPE_PARTNER" : Partner cost is billed by the
  /// partner.
  core.String? invoiceType;

  $PartnerCost({
    this.costType,
    this.feeAmount,
    this.feePercentageMillis,
    this.feeType,
    this.invoiceType,
  });

  $PartnerCost.fromJson(core.Map json_)
    : this(
        costType: json_['costType'] as core.String?,
        feeAmount: json_['feeAmount'] as core.String?,
        feePercentageMillis: json_['feePercentageMillis'] as core.String?,
        feeType: json_['feeType'] as core.String?,
        invoiceType: json_['invoiceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (costType != null) 'costType': costType!,
    if (feeAmount != null) 'feeAmount': feeAmount!,
    if (feePercentageMillis != null)
      'feePercentageMillis': feePercentageMillis!,
    if (feeType != null) 'feeType': feeType!,
    if (invoiceType != null) 'invoiceType': invoiceType!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PartnerGeneralConfig
/// - displayvideo:v3 : PartnerGeneralConfig
/// - displayvideo:v4 : PartnerGeneralConfig
class $PartnerGeneralConfig {
  /// Partner's currency in ISO 4217 format.
  ///
  /// Immutable.
  core.String? currencyCode;

  /// The standard TZ database name of the partner's time zone.
  ///
  /// For example, `America/New_York`. See more at:
  /// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
  ///
  /// Immutable.
  core.String? timeZone;

  $PartnerGeneralConfig({this.currencyCode, this.timeZone});

  $PartnerGeneralConfig.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : PartnerPermissions
/// - cloudcontrolspartner:v1beta : PartnerPermissions
class $PartnerPermissions {
  /// Identifier.
  ///
  /// Format:
  /// `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/partnerPermissions`
  core.String? name;

  /// The partner permissions granted for the workload
  core.List<core.String>? partnerPermissions;

  $PartnerPermissions({this.name, this.partnerPermissions});

  $PartnerPermissions.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        partnerPermissions:
            (json_['partnerPermissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (partnerPermissions != null) 'partnerPermissions': partnerPermissions!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PartnerRevenueModel
/// - displayvideo:v3 : PartnerRevenueModel
/// - displayvideo:v4 : PartnerRevenueModel
class $PartnerRevenueModel {
  /// The markup amount of the partner revenue model.
  ///
  /// Must be greater than or equal to 0. * When the markup_type is set to be
  /// `PARTNER_REVENUE_MODEL_MARKUP_TYPE_CPM`, this field represents the CPM
  /// markup in micros of advertiser's currency. For example, 1500000 represents
  /// 1.5 standard units of the currency. * When the markup_type is set to be
  /// `PARTNER_REVENUE_MODEL_MARKUP_TYPE_MEDIA_COST_MARKUP`, this field
  /// represents the media cost percent markup in millis. For example, 100
  /// represents 0.1% (decimal 0.001). * When the markup_type is set to be
  /// `PARTNER_REVENUE_MODEL_MARKUP_TYPE_TOTAL_MEDIA_COST_MARKUP`, this field
  /// represents the total media cost percent markup in millis. For example, 100
  /// represents 0.1% (decimal 0.001).
  ///
  /// Required.
  core.String? markupAmount;

  /// The markup type of the partner revenue model.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PARTNER_REVENUE_MODEL_MARKUP_TYPE_UNSPECIFIED" : Type value is not
  /// specified or is unknown in this version.
  /// - "PARTNER_REVENUE_MODEL_MARKUP_TYPE_CPM" : Calculate the partner revenue
  /// based on a fixed CPM.
  /// - "PARTNER_REVENUE_MODEL_MARKUP_TYPE_MEDIA_COST_MARKUP" : Calculate the
  /// partner revenue based on a percentage surcharge of its media cost.
  /// - "PARTNER_REVENUE_MODEL_MARKUP_TYPE_TOTAL_MEDIA_COST_MARKUP" : Calculate
  /// the partner revenue based on a percentage surcharge of its total media
  /// cost, which includes all partner costs and data costs.
  core.String? markupType;

  $PartnerRevenueModel({this.markupAmount, this.markupType});

  $PartnerRevenueModel.fromJson(core.Map json_)
    : this(
        markupAmount: json_['markupAmount'] as core.String?,
        markupType: json_['markupType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (markupAmount != null) 'markupAmount': markupAmount!,
    if (markupType != null) 'markupType': markupType!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : PasswordStatus
/// - sqladmin:v1beta4 : PasswordStatus
class $PasswordStatus {
  /// If true, user does not have login privileges.
  core.bool? locked;

  /// The expiration time of the current password.
  core.String? passwordExpirationTime;

  $PasswordStatus({this.locked, this.passwordExpirationTime});

  $PasswordStatus.fromJson(core.Map json_)
    : this(
        locked: json_['locked'] as core.bool?,
        passwordExpirationTime: json_['passwordExpirationTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (locked != null) 'locked': locked!,
    if (passwordExpirationTime != null)
      'passwordExpirationTime': passwordExpirationTime!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : PasswordValidationPolicy
/// - sqladmin:v1beta4 : PasswordValidationPolicy
class $PasswordValidationPolicy {
  /// The complexity of the password.
  /// Possible string values are:
  /// - "COMPLEXITY_UNSPECIFIED" : Complexity check is not specified.
  /// - "COMPLEXITY_DEFAULT" : A combination of lowercase, uppercase, numeric,
  /// and non-alphanumeric characters.
  core.String? complexity;

  /// This field is deprecated and will be removed in a future version of the
  /// API.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? disallowCompromisedCredentials;

  /// Disallow username as a part of the password.
  core.bool? disallowUsernameSubstring;

  /// Whether the password policy is enabled or not.
  core.bool? enablePasswordPolicy;

  /// Minimum number of characters allowed.
  core.int? minLength;

  /// Minimum interval after which the password can be changed.
  ///
  /// This flag is only supported for PostgreSQL.
  core.String? passwordChangeInterval;

  /// Number of previous passwords that cannot be reused.
  core.int? reuseInterval;

  $PasswordValidationPolicy({
    this.complexity,
    this.disallowCompromisedCredentials,
    this.disallowUsernameSubstring,
    this.enablePasswordPolicy,
    this.minLength,
    this.passwordChangeInterval,
    this.reuseInterval,
  });

  $PasswordValidationPolicy.fromJson(core.Map json_)
    : this(
        complexity: json_['complexity'] as core.String?,
        disallowCompromisedCredentials:
            json_['disallowCompromisedCredentials'] as core.bool?,
        disallowUsernameSubstring:
            json_['disallowUsernameSubstring'] as core.bool?,
        enablePasswordPolicy: json_['enablePasswordPolicy'] as core.bool?,
        minLength: json_['minLength'] as core.int?,
        passwordChangeInterval: json_['passwordChangeInterval'] as core.String?,
        reuseInterval: json_['reuseInterval'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (complexity != null) 'complexity': complexity!,
    if (disallowCompromisedCredentials != null)
      'disallowCompromisedCredentials': disallowCompromisedCredentials!,
    if (disallowUsernameSubstring != null)
      'disallowUsernameSubstring': disallowUsernameSubstring!,
    if (enablePasswordPolicy != null)
      'enablePasswordPolicy': enablePasswordPolicy!,
    if (minLength != null) 'minLength': minLength!,
    if (passwordChangeInterval != null)
      'passwordChangeInterval': passwordChangeInterval!,
    if (reuseInterval != null) 'reuseInterval': reuseInterval!,
  };
}

/// Used by:
///
/// - osconfig:v1 : PatchInstanceFilterGroupLabel
/// - osconfig:v1beta : PatchInstanceFilterGroupLabel
class $PatchInstanceFilterGroupLabel {
  /// Compute Engine instance labels that must be present for a VM instance to
  /// be targeted by this filter.
  core.Map<core.String, core.String>? labels;

  $PatchInstanceFilterGroupLabel({this.labels});

  $PatchInstanceFilterGroupLabel.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - osconfig:v1 : PatchJobInstanceDetails
/// - osconfig:v1beta : PatchJobInstanceDetails
class $PatchJobInstanceDetails {
  /// The number of times the agent that the agent attempts to apply the patch.
  core.String? attemptCount;

  /// If the patch fails, this field provides the reason.
  core.String? failureReason;

  /// The unique identifier for the instance.
  ///
  /// This identifier is defined by the server.
  core.String? instanceSystemId;

  /// The instance name in the form `projects / * /zones / * /instances / * `
  core.String? name;

  /// Current state of instance patch.
  /// Possible string values are:
  /// - "PATCH_STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : The instance is not yet notified.
  /// - "INACTIVE" : Instance is inactive and cannot be patched.
  /// - "NOTIFIED" : The instance is notified that it should be patched.
  /// - "STARTED" : The instance has started the patching process.
  /// - "DOWNLOADING_PATCHES" : The instance is downloading patches.
  /// - "APPLYING_PATCHES" : The instance is applying patches.
  /// - "REBOOTING" : The instance is rebooting.
  /// - "SUCCEEDED" : The instance has completed applying patches.
  /// - "SUCCEEDED_REBOOT_REQUIRED" : The instance has completed applying
  /// patches but a reboot is required.
  /// - "FAILED" : The instance has failed to apply the patch.
  /// - "ACKED" : The instance acked the notification and will start shortly.
  /// - "TIMED_OUT" : The instance exceeded the time out while applying the
  /// patch.
  /// - "RUNNING_PRE_PATCH_STEP" : The instance is running the pre-patch step.
  /// - "RUNNING_POST_PATCH_STEP" : The instance is running the post-patch step.
  /// - "NO_AGENT_DETECTED" : The service could not detect the presence of the
  /// agent. Check to ensure that the agent is installed, running, and able to
  /// communicate with the service.
  core.String? state;

  $PatchJobInstanceDetails({
    this.attemptCount,
    this.failureReason,
    this.instanceSystemId,
    this.name,
    this.state,
  });

  $PatchJobInstanceDetails.fromJson(core.Map json_)
    : this(
        attemptCount: json_['attemptCount'] as core.String?,
        failureReason: json_['failureReason'] as core.String?,
        instanceSystemId: json_['instanceSystemId'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attemptCount != null) 'attemptCount': attemptCount!,
    if (failureReason != null) 'failureReason': failureReason!,
    if (instanceSystemId != null) 'instanceSystemId': instanceSystemId!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - osconfig:v1 : PatchJobInstanceDetailsSummary
/// - osconfig:v1beta : PatchJobInstanceDetailsSummary
class $PatchJobInstanceDetailsSummary {
  /// Number of instances that have acked and will start shortly.
  core.String? ackedInstanceCount;

  /// Number of instances that are applying patches.
  core.String? applyingPatchesInstanceCount;

  /// Number of instances that are downloading patches.
  core.String? downloadingPatchesInstanceCount;

  /// Number of instances that failed.
  core.String? failedInstanceCount;

  /// Number of instances that are inactive.
  core.String? inactiveInstanceCount;

  /// Number of instances that do not appear to be running the agent.
  ///
  /// Check to ensure that the agent is installed, running, and able to
  /// communicate with the service.
  core.String? noAgentDetectedInstanceCount;

  /// Number of instances notified about patch job.
  core.String? notifiedInstanceCount;

  /// Number of instances pending patch job.
  core.String? pendingInstanceCount;

  /// Number of instances that are running the post-patch step.
  core.String? postPatchStepInstanceCount;

  /// Number of instances that are running the pre-patch step.
  core.String? prePatchStepInstanceCount;

  /// Number of instances rebooting.
  core.String? rebootingInstanceCount;

  /// Number of instances that have started.
  core.String? startedInstanceCount;

  /// Number of instances that have completed successfully.
  core.String? succeededInstanceCount;

  /// Number of instances that require reboot.
  core.String? succeededRebootRequiredInstanceCount;

  /// Number of instances that exceeded the time out while applying the patch.
  core.String? timedOutInstanceCount;

  $PatchJobInstanceDetailsSummary({
    this.ackedInstanceCount,
    this.applyingPatchesInstanceCount,
    this.downloadingPatchesInstanceCount,
    this.failedInstanceCount,
    this.inactiveInstanceCount,
    this.noAgentDetectedInstanceCount,
    this.notifiedInstanceCount,
    this.pendingInstanceCount,
    this.postPatchStepInstanceCount,
    this.prePatchStepInstanceCount,
    this.rebootingInstanceCount,
    this.startedInstanceCount,
    this.succeededInstanceCount,
    this.succeededRebootRequiredInstanceCount,
    this.timedOutInstanceCount,
  });

  $PatchJobInstanceDetailsSummary.fromJson(core.Map json_)
    : this(
        ackedInstanceCount: json_['ackedInstanceCount'] as core.String?,
        applyingPatchesInstanceCount:
            json_['applyingPatchesInstanceCount'] as core.String?,
        downloadingPatchesInstanceCount:
            json_['downloadingPatchesInstanceCount'] as core.String?,
        failedInstanceCount: json_['failedInstanceCount'] as core.String?,
        inactiveInstanceCount: json_['inactiveInstanceCount'] as core.String?,
        noAgentDetectedInstanceCount:
            json_['noAgentDetectedInstanceCount'] as core.String?,
        notifiedInstanceCount: json_['notifiedInstanceCount'] as core.String?,
        pendingInstanceCount: json_['pendingInstanceCount'] as core.String?,
        postPatchStepInstanceCount:
            json_['postPatchStepInstanceCount'] as core.String?,
        prePatchStepInstanceCount:
            json_['prePatchStepInstanceCount'] as core.String?,
        rebootingInstanceCount: json_['rebootingInstanceCount'] as core.String?,
        startedInstanceCount: json_['startedInstanceCount'] as core.String?,
        succeededInstanceCount: json_['succeededInstanceCount'] as core.String?,
        succeededRebootRequiredInstanceCount:
            json_['succeededRebootRequiredInstanceCount'] as core.String?,
        timedOutInstanceCount: json_['timedOutInstanceCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ackedInstanceCount != null) 'ackedInstanceCount': ackedInstanceCount!,
    if (applyingPatchesInstanceCount != null)
      'applyingPatchesInstanceCount': applyingPatchesInstanceCount!,
    if (downloadingPatchesInstanceCount != null)
      'downloadingPatchesInstanceCount': downloadingPatchesInstanceCount!,
    if (failedInstanceCount != null)
      'failedInstanceCount': failedInstanceCount!,
    if (inactiveInstanceCount != null)
      'inactiveInstanceCount': inactiveInstanceCount!,
    if (noAgentDetectedInstanceCount != null)
      'noAgentDetectedInstanceCount': noAgentDetectedInstanceCount!,
    if (notifiedInstanceCount != null)
      'notifiedInstanceCount': notifiedInstanceCount!,
    if (pendingInstanceCount != null)
      'pendingInstanceCount': pendingInstanceCount!,
    if (postPatchStepInstanceCount != null)
      'postPatchStepInstanceCount': postPatchStepInstanceCount!,
    if (prePatchStepInstanceCount != null)
      'prePatchStepInstanceCount': prePatchStepInstanceCount!,
    if (rebootingInstanceCount != null)
      'rebootingInstanceCount': rebootingInstanceCount!,
    if (startedInstanceCount != null)
      'startedInstanceCount': startedInstanceCount!,
    if (succeededInstanceCount != null)
      'succeededInstanceCount': succeededInstanceCount!,
    if (succeededRebootRequiredInstanceCount != null)
      'succeededRebootRequiredInstanceCount':
          succeededRebootRequiredInstanceCount!,
    if (timedOutInstanceCount != null)
      'timedOutInstanceCount': timedOutInstanceCount!,
  };
}

/// Used by:
///
/// - datastore:v1 : PathElement
/// - datastore:v1beta3 : PathElement
class $PathElement {
  /// The auto-allocated ID of the entity.
  ///
  /// Never equal to zero. Values less than zero are discouraged and may not be
  /// supported in the future.
  core.String? id;

  /// The kind of the entity.
  ///
  /// A kind matching regex `__.*__` is reserved/read-only. A kind must not
  /// contain more than 1500 bytes when UTF-8 encoded. Cannot be `""`. Must be
  /// valid UTF-8 bytes. Legacy values that are not valid UTF-8 are encoded as
  /// `__bytes__` where `` is the base-64 encoding of the bytes.
  core.String? kind;

  /// The name of the entity.
  ///
  /// A name matching regex `__.*__` is reserved/read-only. A name must not be
  /// more than 1500 bytes when UTF-8 encoded. Cannot be `""`. Must be valid
  /// UTF-8 bytes. Legacy values that are not valid UTF-8 are encoded as
  /// `__bytes__` where `` is the base-64 encoding of the bytes.
  core.String? name;

  $PathElement({this.id, this.kind, this.name});

  $PathElement.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : PathOverride
/// - cloudtasks:v2beta2 : PathOverride
/// - cloudtasks:v2beta3 : PathOverride
class $PathOverride {
  /// The URI path (e.g., /users/1234).
  ///
  /// Default is an empty string.
  core.String? path;

  $PathOverride({this.path});

  $PathOverride.fromJson(core.Map json_)
    : this(path: json_['path'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : PathSegment
/// - trafficdirector:v3 : PathSegment
class $PathSegment {
  /// If specified, use the key to retrieve the value in a Struct.
  core.String? key;

  $PathSegment({this.key});

  $PathSegment.fromJson(core.Map json_)
    : this(key: json_['key'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
  };
}

/// Used by:
///
/// - healthcare:v1 : PatientId
/// - healthcare:v1beta1 : PatientId
class $PatientId {
  /// ID type.
  ///
  /// For example, MRN or NHS.
  core.String? type;

  /// The patient's unique identifier.
  core.String? value;

  $PatientId({this.type, this.value});

  $PatientId.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - healthcare:v1 : PatientScope
/// - healthcare:v1beta1 : PatientScope
class $PatientScope {
  /// The list of patient IDs whose Consent resources will be enforced.
  ///
  /// At most 10,000 patients can be specified. An empty list is equivalent to
  /// all patients (meaning the entire FHIR store).
  ///
  /// Optional.
  core.List<core.String>? patientIds;

  $PatientScope({this.patientIds});

  $PatientScope.fromJson(core.Map json_)
    : this(
        patientIds:
            (json_['patientIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (patientIds != null) 'patientIds': patientIds!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : PauseFinalizedDealRequest
/// - authorizedbuyersmarketplace:v1alpha : PauseFinalizedDealRequest
class $PauseFinalizedDealRequest {
  /// The reason to pause the finalized deal, will be displayed to the seller.
  ///
  /// Maximum length is 1000 characters.
  core.String? reason;

  $PauseFinalizedDealRequest({this.reason});

  $PauseFinalizedDealRequest.fromJson(core.Map json_)
    : this(reason: json_['reason'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (reason != null) 'reason': reason!,
  };
}

/// Used by:
///
/// - managedidentities:v1alpha1 : Peering
/// - managedidentities:v1beta1 : Peering
class $Peering {
  /// The full names of the Google Compute Engine
  /// \[networks\](/compute/docs/networks-and-firewalls#networks) to which the
  /// instance is connected.
  ///
  /// Caller needs to make sure that CIDR subnets do not overlap between
  /// networks, else peering creation will fail.
  ///
  /// Required.
  core.String? authorizedNetwork;

  /// The time the instance was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Full domain resource path for the Managed AD Domain involved in peering.
  ///
  /// The resource path should be in the form:
  /// `projects/{project_id}/locations/global/domains/{domain_name}`
  ///
  /// Required.
  core.String? domainResource;

  /// Resource labels to represent user provided metadata.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Unique name of the peering in this scope including projects and location
  /// using the form:
  /// `projects/{project_id}/locations/global/peerings/{peering_id}`.
  ///
  /// Output only.
  core.String? name;

  /// The current state of this Peering.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "CREATING" : Peering is being created.
  /// - "CONNECTED" : Peering is connected.
  /// - "DISCONNECTED" : Peering is disconnected.
  /// - "DELETING" : Peering is being deleted.
  core.String? state;

  /// Additional information about the current status of this peering, if
  /// available.
  ///
  /// Output only.
  core.String? statusMessage;

  /// Last update time.
  ///
  /// Output only.
  core.String? updateTime;

  $Peering({
    this.authorizedNetwork,
    this.createTime,
    this.domainResource,
    this.labels,
    this.name,
    this.state,
    this.statusMessage,
    this.updateTime,
  });

  $Peering.fromJson(core.Map json_)
    : this(
        authorizedNetwork: json_['authorizedNetwork'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        domainResource: json_['domainResource'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        statusMessage: json_['statusMessage'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authorizedNetwork != null) 'authorizedNetwork': authorizedNetwork!,
    if (createTime != null) 'createTime': createTime!,
    if (domainResource != null) 'domainResource': domainResource!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (statusMessage != null) 'statusMessage': statusMessage!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : PerformDiskShrinkContext
/// - sqladmin:v1beta4 : PerformDiskShrinkContext
class $PerformDiskShrinkContext {
  /// The target disk shrink size in GigaBytes.
  core.String? targetSizeGb;

  $PerformDiskShrinkContext({this.targetSizeGb});

  $PerformDiskShrinkContext.fromJson(core.Map json_)
    : this(targetSizeGb: json_['targetSizeGb'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetSizeGb != null) 'targetSizeGb': targetSizeGb!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationsBlocksPerformMaintenanceRequest
/// - compute:alpha : ReservationsPerformMaintenanceRequest
/// - compute:beta : ReservationsBlocksPerformMaintenanceRequest
/// - compute:beta : ReservationsPerformMaintenanceRequest
/// - compute:v1 : ReservationsBlocksPerformMaintenanceRequest
/// - compute:v1 : ReservationsPerformMaintenanceRequest
class $PerformMaintenanceRequest {
  /// Specifies if all, running or unused hosts are in scope for this request.
  /// Possible string values are:
  /// - "ALL" : Trigger maintenance for all hosts belonging to this reservation
  /// irrespective of whether VMs are running on them or not.
  /// - "MAINTENANCE_SCOPE_UNSPECIFIED" : Internal only
  /// - "RUNNING_VMS" : Trigger maintenance only on the hosts belonging to this
  /// reservation which have VMs running on them.
  /// - "UNUSED_CAPACITY" : Trigger maintenance only on the hosts belonging to
  /// this reservation which do not have any VMs running on them. This is not
  /// allowed for Standard ExR
  core.String? maintenanceScope;

  $PerformMaintenanceRequest({this.maintenanceScope});

  $PerformMaintenanceRequest.fromJson(core.Map json_)
    : this(maintenanceScope: json_['maintenanceScope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maintenanceScope != null) 'maintenanceScope': maintenanceScope!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PerformanceGoal
/// - displayvideo:v3 : PerformanceGoal
/// - displayvideo:v4 : PerformanceGoal
class $PerformanceGoal {
  /// The goal amount, in micros of the advertiser's currency.
  ///
  /// Applicable when performance_goal_type is one of: *
  /// `PERFORMANCE_GOAL_TYPE_CPM` * `PERFORMANCE_GOAL_TYPE_CPC` *
  /// `PERFORMANCE_GOAL_TYPE_CPA` * `PERFORMANCE_GOAL_TYPE_CPIAVC` *
  /// `PERFORMANCE_GOAL_TYPE_VCPM` For example 1500000 represents 1.5 standard
  /// units of the currency.
  core.String? performanceGoalAmountMicros;

  /// The decimal representation of the goal percentage in micros.
  ///
  /// Applicable when performance_goal_type is one of: *
  /// `PERFORMANCE_GOAL_TYPE_CTR` * `PERFORMANCE_GOAL_TYPE_VIEWABILITY` *
  /// `PERFORMANCE_GOAL_TYPE_CLICK_CVR` * `PERFORMANCE_GOAL_TYPE_IMPRESSION_CVR`
  /// * `PERFORMANCE_GOAL_TYPE_VTR` *
  /// `PERFORMANCE_GOAL_TYPE_AUDIO_COMPLETION_RATE` *
  /// `PERFORMANCE_GOAL_TYPE_VIDEO_COMPLETION_RATE` For example, 70000
  /// represents 7% (decimal 0.07).
  core.String? performanceGoalPercentageMicros;

  /// A key performance indicator (KPI) string, which can be empty.
  ///
  /// Must be UTF-8 encoded with a length of no more than 100 characters.
  /// Applicable when performance_goal_type is set to
  /// `PERFORMANCE_GOAL_TYPE_OTHER`.
  core.String? performanceGoalString;

  /// The type of the performance goal.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PERFORMANCE_GOAL_TYPE_UNSPECIFIED" : Performance goal type is not
  /// specified or is unknown in this version.
  /// - "PERFORMANCE_GOAL_TYPE_CPM" : The performance goal is set in CPM (cost
  /// per mille).
  /// - "PERFORMANCE_GOAL_TYPE_CPC" : The performance goal is set in CPC (cost
  /// per click).
  /// - "PERFORMANCE_GOAL_TYPE_CPA" : The performance goal is set in CPA (cost
  /// per action).
  /// - "PERFORMANCE_GOAL_TYPE_CTR" : The performance goal is set in CTR
  /// (click-through rate) percentage.
  /// - "PERFORMANCE_GOAL_TYPE_VIEWABILITY" : The performance goal is set in
  /// Viewability percentage.
  /// - "PERFORMANCE_GOAL_TYPE_CPIAVC" : The performance goal is set as CPIAVC
  /// (cost per impression audible and visible at completion).
  /// - "PERFORMANCE_GOAL_TYPE_CPE" : The performance goal is set in CPE (cost
  /// per engagement).
  /// - "PERFORMANCE_GOAL_TYPE_CPV" : The performance goal is set in CPV (cost
  /// per view).
  /// - "PERFORMANCE_GOAL_TYPE_CLICK_CVR" : The performance goal is set in click
  /// conversion rate (conversions per click) percentage.
  /// - "PERFORMANCE_GOAL_TYPE_IMPRESSION_CVR" : The performance goal is set in
  /// impression conversion rate (conversions per impression) percentage.
  /// - "PERFORMANCE_GOAL_TYPE_VCPM" : The performance goal is set in VCPM (cost
  /// per thousand viewable impressions).
  /// - "PERFORMANCE_GOAL_TYPE_VTR" : The performance goal is set in YouTube
  /// view rate (YouTube views per impression) percentage.
  /// - "PERFORMANCE_GOAL_TYPE_AUDIO_COMPLETION_RATE" : The performance goal is
  /// set in audio completion rate (complete audio listens per impression)
  /// percentage.
  /// - "PERFORMANCE_GOAL_TYPE_VIDEO_COMPLETION_RATE" : The performance goal is
  /// set in video completion rate (complete video views per impression)
  /// percentage.
  /// - "PERFORMANCE_GOAL_TYPE_OTHER" : The performance goal is set to Other.
  core.String? performanceGoalType;

  $PerformanceGoal({
    this.performanceGoalAmountMicros,
    this.performanceGoalPercentageMicros,
    this.performanceGoalString,
    this.performanceGoalType,
  });

  $PerformanceGoal.fromJson(core.Map json_)
    : this(
        performanceGoalAmountMicros:
            json_['performanceGoalAmountMicros'] as core.String?,
        performanceGoalPercentageMicros:
            json_['performanceGoalPercentageMicros'] as core.String?,
        performanceGoalString: json_['performanceGoalString'] as core.String?,
        performanceGoalType: json_['performanceGoalType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (performanceGoalAmountMicros != null)
      'performanceGoalAmountMicros': performanceGoalAmountMicros!,
    if (performanceGoalPercentageMicros != null)
      'performanceGoalPercentageMicros': performanceGoalPercentageMicros!,
    if (performanceGoalString != null)
      'performanceGoalString': performanceGoalString!,
    if (performanceGoalType != null)
      'performanceGoalType': performanceGoalType!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PerformanceGoalBidStrategy
/// - displayvideo:v3 : PerformanceGoalBidStrategy
/// - displayvideo:v4 : PerformanceGoalBidStrategy
class $PerformanceGoalBidStrategy {
  /// The ID of the Custom Bidding Algorithm used by this strategy.
  ///
  /// Only applicable when performance_goal_type is set to
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO`. Assigning a custom
  /// bidding algorithm that uses floodlight activities not identified in
  /// floodlightActivityConfigs will return an error.
  core.String? customBiddingAlgorithmId;

  /// The maximum average CPM that may be bid, in micros of the advertiser's
  /// currency.
  ///
  /// Must be greater than or equal to a billable unit of the given currency.
  /// Not applicable when performance_goal_type is set to
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM`. For example,
  /// 1500000 represents 1.5 standard units of the currency.
  core.String? maxAverageCpmBidAmountMicros;

  /// The performance goal the bidding strategy will attempt to meet or beat, in
  /// micros of the advertiser's currency or in micro of the ROAS (Return On
  /// Advertising Spend) value which is also based on advertiser's currency.
  ///
  /// Must be greater than or equal to a billable unit of the given currency and
  /// smaller or equal to upper bounds. Each performance_goal_type has its upper
  /// bound: * when performance_goal_type is
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPA`, upper bound is 10000.00 USD.
  /// * when performance_goal_type is
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPC`, upper bound is 1000.00 USD.
  /// * when performance_goal_type is
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM`, upper bound is
  /// 1000.00 USD. * when performance_goal_type is
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO`, upper bound is
  /// 1000.00 and lower bound is 0.01. Example: If set to
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM`, the bid price will
  /// be based on the probability that each available impression will be
  /// viewable. For example, if viewable CPM target is $2 and an impression is
  /// 40% likely to be viewable, the bid price will be $0.80 CPM (40% of $2).
  /// For example, 1500000 represents 1.5 standard units of the currency or ROAS
  /// value.
  ///
  /// Required.
  core.String? performanceGoalAmountMicros;

  /// The type of the performance goal that the bidding strategy will try to
  /// meet or beat.
  ///
  /// For line item level usage, the value must be one of: *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPA` *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPC` *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM` *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO`.
  ///
  /// Required.
  /// Possible string values are:
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_UNSPECIFIED" : Type value is not
  /// specified or is unknown in this version.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPA" : Cost per action.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CPC" : Cost per click.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM" : Viewable CPM.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CUSTOM_ALGO" : Custom bidding
  /// algorithm.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CIVA" : Completed inview and
  /// audible views.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_IVO_TEN" : Inview time over 10
  /// secs views.
  /// - "BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_AV_VIEWED" : Viewable
  /// impressions.
  core.String? performanceGoalType;

  $PerformanceGoalBidStrategy({
    this.customBiddingAlgorithmId,
    this.maxAverageCpmBidAmountMicros,
    this.performanceGoalAmountMicros,
    this.performanceGoalType,
  });

  $PerformanceGoalBidStrategy.fromJson(core.Map json_)
    : this(
        customBiddingAlgorithmId:
            json_['customBiddingAlgorithmId'] as core.String?,
        maxAverageCpmBidAmountMicros:
            json_['maxAverageCpmBidAmountMicros'] as core.String?,
        performanceGoalAmountMicros:
            json_['performanceGoalAmountMicros'] as core.String?,
        performanceGoalType: json_['performanceGoalType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customBiddingAlgorithmId != null)
      'customBiddingAlgorithmId': customBiddingAlgorithmId!,
    if (maxAverageCpmBidAmountMicros != null)
      'maxAverageCpmBidAmountMicros': maxAverageCpmBidAmountMicros!,
    if (performanceGoalAmountMicros != null)
      'performanceGoalAmountMicros': performanceGoalAmountMicros!,
    if (performanceGoalType != null)
      'performanceGoalType': performanceGoalType!,
  };
}

/// Used by:
///
/// - file:v1 : PerformanceLimits
/// - file:v1beta1 : PerformanceLimits
class $PerformanceLimits {
  /// The max IOPS.
  ///
  /// Output only.
  core.String? maxIops;

  /// The max read IOPS.
  ///
  /// Output only.
  core.String? maxReadIops;

  /// The max read throughput in bytes per second.
  ///
  /// Output only.
  core.String? maxReadThroughputBps;

  /// The max write IOPS.
  ///
  /// Output only.
  core.String? maxWriteIops;

  /// The max write throughput in bytes per second.
  ///
  /// Output only.
  core.String? maxWriteThroughputBps;

  $PerformanceLimits({
    this.maxIops,
    this.maxReadIops,
    this.maxReadThroughputBps,
    this.maxWriteIops,
    this.maxWriteThroughputBps,
  });

  $PerformanceLimits.fromJson(core.Map json_)
    : this(
        maxIops: json_['maxIops'] as core.String?,
        maxReadIops: json_['maxReadIops'] as core.String?,
        maxReadThroughputBps: json_['maxReadThroughputBps'] as core.String?,
        maxWriteIops: json_['maxWriteIops'] as core.String?,
        maxWriteThroughputBps: json_['maxWriteThroughputBps'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxIops != null) 'maxIops': maxIops!,
    if (maxReadIops != null) 'maxReadIops': maxReadIops!,
    if (maxReadThroughputBps != null)
      'maxReadThroughputBps': maxReadThroughputBps!,
    if (maxWriteIops != null) 'maxWriteIops': maxWriteIops!,
    if (maxWriteThroughputBps != null)
      'maxWriteThroughputBps': maxWriteThroughputBps!,
  };
}

/// Used by:
///
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitAdminV2ClientPermissions
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitAdminV2Permissions
class $Permissions {
  /// When true, end users cannot delete their account on the associated project
  /// through any of our API methods
  core.bool? disabledUserDeletion;

  /// When true, end users cannot sign up for a new account on the associated
  /// project through any of our API methods
  core.bool? disabledUserSignup;

  $Permissions({this.disabledUserDeletion, this.disabledUserSignup});

  $Permissions.fromJson(core.Map json_)
    : this(
        disabledUserDeletion: json_['disabledUserDeletion'] as core.bool?,
        disabledUserSignup: json_['disabledUserSignup'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabledUserDeletion != null)
      'disabledUserDeletion': disabledUserDeletion!,
    if (disabledUserSignup != null) 'disabledUserSignup': disabledUserSignup!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : TestIamPermissionsResponse
/// - aiplatform:v1 : GoogleIamV1TestIamPermissionsResponse
/// - aiplatform:v1beta1 : GoogleIamV1TestIamPermissionsResponse
/// - analyticshub:v1 : TestIamPermissionsResponse
/// - analyticshub:v1beta1 : TestIamPermissionsResponse
/// - apigateway:v1 : ApigatewayTestIamPermissionsResponse
/// - apigateway:v1beta : ApigatewayTestIamPermissionsResponse
/// - apigee:v1 : GoogleIamV1TestIamPermissionsResponse
/// - apigeeregistry:v1 : TestIamPermissionsResponse
/// - apphub:v1 : TestIamPermissionsResponse
/// - apphub:v1alpha : TestIamPermissionsResponse
/// - artifactregistry:v1 : TestIamPermissionsResponse
/// - artifactregistry:v1beta1 : TestIamPermissionsResponse
/// - artifactregistry:v1beta2 : TestIamPermissionsResponse
/// - backupdr:v1 : TestIamPermissionsResponse
/// - beyondcorp:v1 : GoogleIamV1TestIamPermissionsResponse
/// - beyondcorp:v1alpha : GoogleIamV1TestIamPermissionsResponse
/// - bigquery:v2 : TestIamPermissionsResponse
/// - bigqueryconnection:v1 : TestIamPermissionsResponse
/// - bigqueryconnection:v1beta1 : TestIamPermissionsResponse
/// - bigquerydatapolicy:v1 : TestIamPermissionsResponse
/// - bigqueryreservation:v1 : TestIamPermissionsResponse
/// - bigtableadmin:v2 : TestIamPermissionsResponse
/// - binaryauthorization:v1 : TestIamPermissionsResponse
/// - binaryauthorization:v1beta1 : TestIamPermissionsResponse
/// - cloudbilling:v1 : TestIamPermissionsResponse
/// - cloudbuild:v2 : TestIamPermissionsResponse
/// - clouddeploy:v1 : TestIamPermissionsResponse
/// - cloudfunctions:v1 : TestIamPermissionsResponse
/// - cloudfunctions:v2 : TestIamPermissionsResponse
/// - cloudfunctions:v2alpha : TestIamPermissionsResponse
/// - cloudfunctions:v2beta : TestIamPermissionsResponse
/// - cloudkms:v1 : TestIamPermissionsResponse
/// - cloudresourcemanager:v1 : TestIamPermissionsResponse
/// - cloudresourcemanager:v1beta1 : TestIamPermissionsResponse
/// - cloudresourcemanager:v2 : TestIamPermissionsResponse
/// - cloudresourcemanager:v2beta1 : TestIamPermissionsResponse
/// - cloudresourcemanager:v3 : TestIamPermissionsResponse
/// - cloudtasks:v2 : TestIamPermissionsResponse
/// - cloudtasks:v2beta2 : TestIamPermissionsResponse
/// - cloudtasks:v2beta3 : TestIamPermissionsResponse
/// - compute:alpha : TestPermissionsResponse
/// - compute:beta : TestPermissionsResponse
/// - compute:v1 : TestPermissionsResponse
/// - config:v1 : TestIamPermissionsResponse
/// - connectors:v1 : TestIamPermissionsResponse
/// - containeranalysis:v1 : TestIamPermissionsResponse
/// - containeranalysis:v1alpha1 : TestIamPermissionsResponse
/// - containeranalysis:v1beta1 : TestIamPermissionsResponse
/// - datacatalog:v1 : TestIamPermissionsResponse
/// - datacatalog:v1beta1 : TestIamPermissionsResponse
/// - dataform:v1beta1 : TestIamPermissionsResponse
/// - datafusion:v1 : TestIamPermissionsResponse
/// - datafusion:v1beta1 : TestIamPermissionsResponse
/// - datamigration:v1 : TestIamPermissionsResponse
/// - datamigration:v1beta1 : TestIamPermissionsResponse
/// - deploymentmanager:alpha : TestPermissionsResponse
/// - deploymentmanager:v2 : TestPermissionsResponse
/// - deploymentmanager:v2beta : TestPermissionsResponse
/// - dns:v1 : GoogleIamV1TestIamPermissionsResponse
/// - dns:v1beta2 : GoogleIamV1TestIamPermissionsResponse
/// - domains:v1 : TestIamPermissionsResponse
/// - domains:v1alpha2 : TestIamPermissionsResponse
/// - domains:v1beta1 : TestIamPermissionsResponse
/// - eventarc:v1 : TestIamPermissionsResponse
/// - gkebackup:v1 : TestIamPermissionsResponse
/// - gkehub:v1 : TestIamPermissionsResponse
/// - gkehub:v1alpha : TestIamPermissionsResponse
/// - gkehub:v1beta : TestIamPermissionsResponse
/// - gkehub:v1beta1 : TestIamPermissionsResponse
/// - gkeonprem:v1 : TestIamPermissionsResponse
/// - healthcare:v1 : TestIamPermissionsResponse
/// - healthcare:v1beta1 : TestIamPermissionsResponse
/// - iam:v1 : TestIamPermissionsResponse
/// - iap:v1 : TestIamPermissionsResponse
/// - iap:v1beta1 : TestIamPermissionsResponse
/// - identitytoolkit:v2 : GoogleIamV1TestIamPermissionsResponse
/// - managedidentities:v1 : TestIamPermissionsResponse
/// - managedidentities:v1alpha1 : TestIamPermissionsResponse
/// - managedidentities:v1beta1 : TestIamPermissionsResponse
/// - ml:v1 : GoogleIamV1__TestIamPermissionsResponse
/// - networkconnectivity:v1 : TestIamPermissionsResponse
/// - networkconnectivity:v1alpha1 : TestIamPermissionsResponse
/// - networkmanagement:v1 : TestIamPermissionsResponse
/// - networkmanagement:v1beta1 : TestIamPermissionsResponse
/// - networksecurity:v1 : GoogleIamV1TestIamPermissionsResponse
/// - networksecurity:v1beta1 : GoogleIamV1TestIamPermissionsResponse
/// - networkservices:v1 : TestIamPermissionsResponse
/// - notebooks:v1 : TestIamPermissionsResponse
/// - notebooks:v2 : TestIamPermissionsResponse
/// - privateca:v1 : TestIamPermissionsResponse
/// - privateca:v1beta1 : TestIamPermissionsResponse
/// - pubsub:v1 : TestIamPermissionsResponse
/// - pubsub:v1beta2 : TestIamPermissionsResponse
/// - run:v1 : TestIamPermissionsResponse
/// - run:v2 : GoogleIamV1TestIamPermissionsResponse
/// - runtimeconfig:v1beta1 : TestIamPermissionsResponse
/// - secretmanager:v1 : TestIamPermissionsResponse
/// - secretmanager:v1beta1 : TestIamPermissionsResponse
/// - secretmanager:v1beta2 : TestIamPermissionsResponse
/// - securesourcemanager:v1 : TestIamPermissionsResponse
/// - securitycenter:v1 : TestIamPermissionsResponse
/// - securitycenter:v1beta1 : TestIamPermissionsResponse
/// - servicedirectory:v1 : TestIamPermissionsResponse
/// - servicedirectory:v1beta1 : TestIamPermissionsResponse
/// - servicemanagement:v1 : TestIamPermissionsResponse
/// - spanner:v1 : TestIamPermissionsResponse
/// - vmwareengine:v1 : TestIamPermissionsResponse
/// - workstations:v1 : TestIamPermissionsResponse
/// - workstations:v1beta : TestIamPermissionsResponse
class $PermissionsResponse {
  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  core.List<core.String>? permissions;

  $PermissionsResponse({this.permissions});

  $PermissionsResponse.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - redis:v1 : PersistenceConfig
/// - redis:v1beta1 : PersistenceConfig
class $PersistenceConfig {
  /// Controls whether Persistence features are enabled.
  ///
  /// If not provided, the existing value will be used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "PERSISTENCE_MODE_UNSPECIFIED" : Not set.
  /// - "DISABLED" : Persistence is disabled for the instance, and any existing
  /// snapshots are deleted.
  /// - "RDB" : RDB based Persistence is enabled.
  core.String? persistenceMode;

  /// The next time that a snapshot attempt is scheduled to occur.
  ///
  /// Output only.
  core.String? rdbNextSnapshotTime;

  /// Period between RDB snapshots.
  ///
  /// Snapshots will be attempted every period starting from the provided
  /// snapshot start time. For example, a start time of 01/01/2033 06:45 and
  /// SIX_HOURS snapshot period will do nothing until 01/01/2033, and then
  /// trigger snapshots every day at 06:45, 12:45, 18:45, and 00:45 the next
  /// day, and so on. If not provided, TWENTY_FOUR_HOURS will be used as
  /// default.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SNAPSHOT_PERIOD_UNSPECIFIED" : Not set.
  /// - "ONE_HOUR" : Snapshot every 1 hour.
  /// - "SIX_HOURS" : Snapshot every 6 hours.
  /// - "TWELVE_HOURS" : Snapshot every 12 hours.
  /// - "TWENTY_FOUR_HOURS" : Snapshot every 24 hours.
  core.String? rdbSnapshotPeriod;

  /// Date and time that the first snapshot was/will be attempted, and to which
  /// future snapshots will be aligned.
  ///
  /// If not provided, the current time will be used.
  ///
  /// Optional.
  core.String? rdbSnapshotStartTime;

  $PersistenceConfig({
    this.persistenceMode,
    this.rdbNextSnapshotTime,
    this.rdbSnapshotPeriod,
    this.rdbSnapshotStartTime,
  });

  $PersistenceConfig.fromJson(core.Map json_)
    : this(
        persistenceMode: json_['persistenceMode'] as core.String?,
        rdbNextSnapshotTime: json_['rdbNextSnapshotTime'] as core.String?,
        rdbSnapshotPeriod: json_['rdbSnapshotPeriod'] as core.String?,
        rdbSnapshotStartTime: json_['rdbSnapshotStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (persistenceMode != null) 'persistenceMode': persistenceMode!,
    if (rdbNextSnapshotTime != null)
      'rdbNextSnapshotTime': rdbNextSnapshotTime!,
    if (rdbSnapshotPeriod != null) 'rdbSnapshotPeriod': rdbSnapshotPeriod!,
    if (rdbSnapshotStartTime != null)
      'rdbSnapshotStartTime': rdbSnapshotStartTime!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : PersistentDisk
/// - vmmigration:v1alpha1 : PersistentDisk
class $PersistentDisk {
  /// The URI of the Persistent Disk.
  core.String? diskUri;

  /// The ordinal number of the source VM disk.
  core.int? sourceDiskNumber;

  $PersistentDisk({this.diskUri, this.sourceDiskNumber});

  $PersistentDisk.fromJson(core.Map json_)
    : this(
        diskUri: json_['diskUri'] as core.String?,
        sourceDiskNumber: json_['sourceDiskNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskUri != null) 'diskUri': diskUri!,
    if (sourceDiskNumber != null) 'sourceDiskNumber': sourceDiskNumber!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PersistentDiskSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PersistentDiskSpec
class $PersistentDiskSpec {
  /// Size in GB of the disk (default is 100GB).
  core.String? diskSizeGb;

  /// Type of the disk (default is "pd-standard").
  ///
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) "pd-standard"
  /// (Persistent Disk Hard Disk Drive) "pd-balanced" (Balanced Persistent Disk)
  /// "pd-extreme" (Extreme Persistent Disk)
  core.String? diskType;

  $PersistentDiskSpec({this.diskSizeGb, this.diskType});

  $PersistentDiskSpec.fromJson(core.Map json_)
    : this(
        diskSizeGb: json_['diskSizeGb'] as core.String?,
        diskType: json_['diskType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
    if (diskType != null) 'diskType': diskType!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_PersonDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_PersonDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_PersonDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_PersonDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_PersonDetectionConfig
class $PersonDetectionConfig {
  /// Whether to enable person attributes detection, such as cloth color (black,
  /// blue, etc), type (coat, dress, etc), pattern (plain, floral, etc), hair,
  /// etc.
  ///
  /// Ignored if 'include_bounding_boxes' is set to false.
  core.bool? includeAttributes;

  /// Whether bounding boxes are included in the person detection annotation
  /// output.
  core.bool? includeBoundingBoxes;

  /// Whether to enable pose landmarks detection.
  ///
  /// Ignored if 'include_bounding_boxes' is set to false.
  core.bool? includePoseLandmarks;

  $PersonDetectionConfig({
    this.includeAttributes,
    this.includeBoundingBoxes,
    this.includePoseLandmarks,
  });

  $PersonDetectionConfig.fromJson(core.Map json_)
    : this(
        includeAttributes: json_['includeAttributes'] as core.bool?,
        includeBoundingBoxes: json_['includeBoundingBoxes'] as core.bool?,
        includePoseLandmarks: json_['includePoseLandmarks'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeAttributes != null) 'includeAttributes': includeAttributes!,
    if (includeBoundingBoxes != null)
      'includeBoundingBoxes': includeBoundingBoxes!,
    if (includePoseLandmarks != null)
      'includePoseLandmarks': includePoseLandmarks!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3Phrase
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1Phrase
class $Phrase00 {
  /// Text input which can be used for prompt or banned phrases.
  ///
  /// Required.
  core.String? text;

  $Phrase00({this.text});

  $Phrase00.fromJson(core.Map json_)
    : this(text: json_['text'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - speech:v1 : Phrase
/// - speech:v1p1beta1 : Phrase
class $Phrase01 {
  /// Hint Boost.
  ///
  /// Overrides the boost set at the phrase set level. Positive value will
  /// increase the probability that a specific phrase will be recognized over
  /// other similar sounding phrases. The higher the boost, the higher the
  /// chance of false positive recognition as well. Negative boost will simply
  /// be ignored. Though `boost` can accept a wide range of positive values,
  /// most use cases are best served with values between 0 and 20. We recommend
  /// using a binary search approach to finding the optimal value for your use
  /// case as well as adding phrases both with and without boost to your
  /// requests.
  core.double? boost;

  /// The phrase itself.
  core.String? value;

  $Phrase01({this.boost, this.value});

  $Phrase01.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : PhysicalPlatformDetails
/// - migrationcenter:v1alpha1 : PhysicalPlatformDetails
class $PhysicalPlatformDetails {
  /// Whether the machine is hyperthreaded.
  /// Possible string values are:
  /// - "HYPERTHREADING_STATUS_UNSPECIFIED" : Simultaneous Multithreading status
  /// unknown.
  /// - "HYPERTHREADING_STATUS_DISABLED" : Simultaneous Multithreading is
  /// disabled or unavailable.
  /// - "HYPERTHREADING_STATUS_ENABLED" : Simultaneous Multithreading is
  /// enabled.
  core.String? hyperthreading;

  /// Free text representation of the machine location.
  ///
  /// The format of this field should not be relied on. Different machines in
  /// the same location may have different string values for this field.
  core.String? location;

  $PhysicalPlatformDetails({this.hyperthreading, this.location});

  $PhysicalPlatformDetails.fromJson(core.Map json_)
    : this(
        hyperthreading: json_['hyperthreading'] as core.String?,
        location: json_['location'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperthreading != null) 'hyperthreading': hyperthreading!,
    if (location != null) 'location': location!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2PinControlMetadataProductPins
/// - retail:v2alpha : GoogleCloudRetailV2alphaPinControlMetadataProductPins
/// - retail:v2beta : GoogleCloudRetailV2betaPinControlMetadataProductPins
class $PinControlMetadataProductPins {
  /// List of product ids which have associated pins.
  core.List<core.String>? productId;

  $PinControlMetadataProductPins({this.productId});

  $PinControlMetadataProductPins.fromJson(core.Map json_)
    : this(
        productId:
            (json_['productId'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (productId != null) 'productId': productId!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : Pipe
/// - trafficdirector:v3 : Pipe
class $Pipe {
  /// The mode for the Pipe.
  ///
  /// Not applicable for abstract sockets.
  core.int? mode;

  /// Unix Domain Socket path.
  ///
  /// On Linux, paths starting with '@' will use the abstract namespace. The
  /// starting '@' is replaced by a null byte by Envoy. Paths starting with '@'
  /// will result in an error in environments other than Linux.
  core.String? path;

  $Pipe({this.mode, this.path});

  $Pipe.fromJson(core.Map json_)
    : this(
        mode: json_['mode'] as core.int?,
        path: json_['path'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigInputArtifact
class $PipelineJobRuntimeConfigInputArtifact {
  /// Artifact resource id from MLMD.
  ///
  /// Which is the last portion of an artifact resource name:
  /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
  /// The artifact must stay within the same project, location and default
  /// metadatastore as the pipeline.
  core.String? artifactId;

  $PipelineJobRuntimeConfigInputArtifact({this.artifactId});

  $PipelineJobRuntimeConfigInputArtifact.fromJson(core.Map json_)
    : this(artifactId: json_['artifactId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactId != null) 'artifactId': artifactId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailContainerDetail
class $PipelineTaskExecutorDetailContainerDetail {
  /// The names of the previously failed CustomJob for the main container
  /// executions.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedMainJobs;

  /// The names of the previously failed CustomJob for the pre-caching-check
  /// container executions.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events. The list includes the
  /// all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedPreCachingCheckJobs;

  /// The name of the CustomJob for the main container execution.
  ///
  /// Output only.
  core.String? mainJob;

  /// The name of the CustomJob for the pre-caching-check container execution.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events.
  ///
  /// Output only.
  core.String? preCachingCheckJob;

  $PipelineTaskExecutorDetailContainerDetail({
    this.failedMainJobs,
    this.failedPreCachingCheckJobs,
    this.mainJob,
    this.preCachingCheckJob,
  });

  $PipelineTaskExecutorDetailContainerDetail.fromJson(core.Map json_)
    : this(
        failedMainJobs:
            (json_['failedMainJobs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        failedPreCachingCheckJobs:
            (json_['failedPreCachingCheckJobs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        mainJob: json_['mainJob'] as core.String?,
        preCachingCheckJob: json_['preCachingCheckJob'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (failedMainJobs != null) 'failedMainJobs': failedMainJobs!,
    if (failedPreCachingCheckJobs != null)
      'failedPreCachingCheckJobs': failedPreCachingCheckJobs!,
    if (mainJob != null) 'mainJob': mainJob!,
    if (preCachingCheckJob != null) 'preCachingCheckJob': preCachingCheckJob!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailCustomJobDetail
class $PipelineTaskExecutorDetailCustomJobDetail {
  /// The names of the previously failed CustomJob.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedJobs;

  /// The name of the CustomJob.
  ///
  /// Output only.
  core.String? job;

  $PipelineTaskExecutorDetailCustomJobDetail({this.failedJobs, this.job});

  $PipelineTaskExecutorDetailCustomJobDetail.fromJson(core.Map json_)
    : this(
        failedJobs:
            (json_['failedJobs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        job: json_['job'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (failedJobs != null) 'failedJobs': failedJobs!,
    if (job != null) 'job': job!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PipelineTemplateMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PipelineTemplateMetadata
class $PipelineTemplateMetadata {
  /// The version_name in artifact registry.
  ///
  /// Will always be presented in output if the PipelineJob.template_uri is from
  /// supported template registry. Format is "sha256:abcdef123456...".
  core.String? version;

  $PipelineTemplateMetadata({this.version});

  $PipelineTemplateMetadata.fromJson(core.Map json_)
    : this(version: json_['version'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - datastore:v1 : PlanSummary
/// - datastore:v1beta3 : PlanSummary
/// - firestore:v1 : PlanSummary
/// - firestore:v1beta1 : PlanSummary
class $PlanSummary {
  /// The indexes selected for the query.
  ///
  /// For example: \[ {"query_scope": "Collection", "properties": "(foo ASC,
  /// __name__ ASC)"}, {"query_scope": "Collection", "properties": "(bar ASC,
  /// __name__ ASC)"} \]
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? indexesUsed;

  $PlanSummary({this.indexesUsed});

  $PlanSummary.fromJson(core.Map json_)
    : this(
        indexesUsed:
            (json_['indexesUsed'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (indexesUsed != null) 'indexesUsed': indexesUsed!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1PlayIntegrityConfig
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaPlayIntegrityConfig
class $PlayIntegrityConfig {
  /// The relative resource name of the Play Integrity configuration object, in
  /// the format: ```
  /// projects/{project_number}/apps/{app_id}/playIntegrityConfig ```
  ///
  /// Required.
  core.String? name;

  /// Specifies the duration for which App Check tokens exchanged from Play
  /// Integrity tokens will be valid.
  ///
  /// If unset, a default value of 1 hour is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $PlayIntegrityConfig({this.name, this.tokenTtl});

  $PlayIntegrityConfig.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3PlaybookImportStrategy
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1PlaybookImportStrategy
class $PlaybookImportStrategy {
  /// Specifies the import strategy used when resolving conflicts with the main
  /// playbook.
  ///
  /// If not specified, 'CREATE_NEW' is assumed.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IMPORT_STRATEGY_UNSPECIFIED" : Unspecified. Treated as 'CREATE_NEW'.
  /// - "IMPORT_STRATEGY_CREATE_NEW" : Create a new resource with a numeric
  /// suffix appended to the end of the existing display name.
  /// - "IMPORT_STRATEGY_REPLACE" : Replace existing resource with incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_KEEP" : Keep existing resource and discard incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_MERGE" : Combine existing and incoming resources when a
  /// conflict is encountered.
  /// - "IMPORT_STRATEGY_THROW_ERROR" : Throw error if a conflict is
  /// encountered.
  core.String? mainPlaybookImportStrategy;

  /// Specifies the import strategy used when resolving referenced playbook/flow
  /// conflicts.
  ///
  /// If not specified, 'CREATE_NEW' is assumed.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IMPORT_STRATEGY_UNSPECIFIED" : Unspecified. Treated as 'CREATE_NEW'.
  /// - "IMPORT_STRATEGY_CREATE_NEW" : Create a new resource with a numeric
  /// suffix appended to the end of the existing display name.
  /// - "IMPORT_STRATEGY_REPLACE" : Replace existing resource with incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_KEEP" : Keep existing resource and discard incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_MERGE" : Combine existing and incoming resources when a
  /// conflict is encountered.
  /// - "IMPORT_STRATEGY_THROW_ERROR" : Throw error if a conflict is
  /// encountered.
  core.String? nestedResourceImportStrategy;

  /// Specifies the import strategy used when resolving tool conflicts.
  ///
  /// If not specified, 'CREATE_NEW' is assumed. This will be applied after the
  /// main playbook and nested resource import strategies, meaning if the
  /// playbook that references the tool is skipped, the tool will also be
  /// skipped.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IMPORT_STRATEGY_UNSPECIFIED" : Unspecified. Treated as 'CREATE_NEW'.
  /// - "IMPORT_STRATEGY_CREATE_NEW" : Create a new resource with a numeric
  /// suffix appended to the end of the existing display name.
  /// - "IMPORT_STRATEGY_REPLACE" : Replace existing resource with incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_KEEP" : Keep existing resource and discard incoming
  /// resource in the content to be imported.
  /// - "IMPORT_STRATEGY_MERGE" : Combine existing and incoming resources when a
  /// conflict is encountered.
  /// - "IMPORT_STRATEGY_THROW_ERROR" : Throw error if a conflict is
  /// encountered.
  core.String? toolImportStrategy;

  $PlaybookImportStrategy({
    this.mainPlaybookImportStrategy,
    this.nestedResourceImportStrategy,
    this.toolImportStrategy,
  });

  $PlaybookImportStrategy.fromJson(core.Map json_)
    : this(
        mainPlaybookImportStrategy:
            json_['mainPlaybookImportStrategy'] as core.String?,
        nestedResourceImportStrategy:
            json_['nestedResourceImportStrategy'] as core.String?,
        toolImportStrategy: json_['toolImportStrategy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mainPlaybookImportStrategy != null)
      'mainPlaybookImportStrategy': mainPlaybookImportStrategy!,
    if (nestedResourceImportStrategy != null)
      'nestedResourceImportStrategy': nestedResourceImportStrategy!,
    if (toolImportStrategy != null) 'toolImportStrategy': toolImportStrategy!,
  };
}

/// Used by:
///
/// - addressvalidation:v1 : GoogleMapsAddressvalidationV1PlusCode
/// - places:v1 : GoogleMapsPlacesV1PlacePlusCode
class $PlusCode {
  /// Place's compound code, such as "33GV+HQ, Ramberg, Norway", containing the
  /// suffix of the global code and replacing the prefix with a formatted name
  /// of a reference entity.
  core.String? compoundCode;

  /// Place's global (full) code, such as "9FWM33GV+HQ", representing an 1/8000
  /// by 1/8000 degree area (~14 by 14 meters).
  core.String? globalCode;

  $PlusCode({this.compoundCode, this.globalCode});

  $PlusCode.fromJson(core.Map json_)
    : this(
        compoundCode: json_['compoundCode'] as core.String?,
        globalCode: json_['globalCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (compoundCode != null) 'compoundCode': compoundCode!,
    if (globalCode != null) 'globalCode': globalCode!,
  };
}

/// Used by:
///
/// - container:v1 : PodAutoscaling
/// - container:v1beta1 : PodAutoscaling
class $PodAutoscaling {
  /// Selected Horizontal Pod Autoscaling profile.
  /// Possible string values are:
  /// - "HPA_PROFILE_UNSPECIFIED" : HPA_PROFILE_UNSPECIFIED is used when no
  /// custom HPA profile is set.
  /// - "NONE" : Customers explicitly opt-out of HPA profiles.
  /// - "PERFORMANCE" : PERFORMANCE is used when customers opt-in to the
  /// performance HPA profile. In this profile we support a higher number of
  /// HPAs per cluster and faster metrics collection for workload autoscaling.
  core.String? hpaProfile;

  $PodAutoscaling({this.hpaProfile});

  $PodAutoscaling.fromJson(core.Map json_)
    : this(hpaProfile: json_['hpaProfile'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (hpaProfile != null) 'hpaProfile': hpaProfile!,
  };
}

/// Used by:
///
/// - container:v1 : PodCIDROverprovisionConfig
/// - container:v1beta1 : PodCIDROverprovisionConfig
class $PodCIDROverprovisionConfig {
  /// Whether Pod CIDR overprovisioning is disabled.
  ///
  /// Note: Pod CIDR overprovisioning is enabled by default.
  core.bool? disable;

  $PodCIDROverprovisionConfig({this.disable});

  $PodCIDROverprovisionConfig.fromJson(core.Map json_)
    : this(disable: json_['disable'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disable != null) 'disable': disable!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PoiAssignedTargetingOptionDetails
/// - displayvideo:v3 : PoiAssignedTargetingOptionDetails
/// - displayvideo:v4 : PoiAssignedTargetingOptionDetails
class $PoiAssignedTargetingOptionDetails {
  /// The display name of a POI, e.g. "Times Square", "Space Needle", followed
  /// by its full address if available.
  ///
  /// Output only.
  core.String? displayName;

  /// Latitude of the POI rounding to 6th decimal place.
  ///
  /// Output only.
  core.double? latitude;

  /// Longitude of the POI rounding to 6th decimal place.
  ///
  /// Output only.
  core.double? longitude;

  /// The radius of the area around the POI that will be targeted.
  ///
  /// The units of the radius are specified by proximity_radius_unit. Must be 1
  /// to 800 if unit is `DISTANCE_UNIT_KILOMETERS` and 1 to 500 if unit is
  /// `DISTANCE_UNIT_MILES`.
  ///
  /// Required.
  core.double? proximityRadiusAmount;

  /// The unit of distance by which the targeting radius is measured.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DISTANCE_UNIT_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "DISTANCE_UNIT_MILES" : Miles.
  /// - "DISTANCE_UNIT_KILOMETERS" : Kilometers.
  core.String? proximityRadiusUnit;

  /// The targeting_option_id of a TargetingOption of type `TARGETING_TYPE_POI`.
  ///
  /// Accepted POI targeting option IDs can be retrieved using
  /// `targetingTypes.targetingOptions.search`. If targeting a specific
  /// latitude/longitude coordinate removed from an address or POI name, you can
  /// generate the necessary targeting option ID by rounding the desired
  /// coordinate values to the 6th decimal place, removing the decimals, and
  /// concatenating the string values separated by a semicolon. For example, you
  /// can target the latitude/longitude pair of 40.7414691, -74.003387 using the
  /// targeting option ID "40741469;-74003387". **Upon** **creation, this field
  /// value will be updated to append a semicolon and** **alphanumerical hash
  /// value if only latitude/longitude coordinates are** **provided.**
  ///
  /// Required.
  core.String? targetingOptionId;

  $PoiAssignedTargetingOptionDetails({
    this.displayName,
    this.latitude,
    this.longitude,
    this.proximityRadiusAmount,
    this.proximityRadiusUnit,
    this.targetingOptionId,
  });

  $PoiAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
        proximityRadiusAmount:
            (json_['proximityRadiusAmount'] as core.num?)?.toDouble(),
        proximityRadiusUnit: json_['proximityRadiusUnit'] as core.String?,
        targetingOptionId: json_['targetingOptionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
    if (proximityRadiusAmount != null)
      'proximityRadiusAmount': proximityRadiusAmount!,
    if (proximityRadiusUnit != null)
      'proximityRadiusUnit': proximityRadiusUnit!,
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PoiSearchTerms
/// - displayvideo:v3 : PoiSearchTerms
/// - displayvideo:v4 : PoiSearchTerms
class $PoiSearchTerms {
  /// The search query for the desired POI name, street address, or coordinate
  /// of the desired POI.
  ///
  /// The query can be a prefix, e.g. "Times squar", "40.7505045,-73.99562",
  /// "315 W 44th St", etc.
  core.String? poiQuery;

  $PoiSearchTerms({this.poiQuery});

  $PoiSearchTerms.fromJson(core.Map json_)
    : this(poiQuery: json_['poiQuery'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (poiQuery != null) 'poiQuery': poiQuery!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PoiTargetingOptionDetails
/// - displayvideo:v3 : PoiTargetingOptionDetails
/// - displayvideo:v4 : PoiTargetingOptionDetails
class $PoiTargetingOptionDetails {
  /// The display name of a POI(e.g. "Times Square", "Space Needle"), followed
  /// by its full address if available.
  ///
  /// Output only.
  core.String? displayName;

  /// Latitude of the POI rounding to 6th decimal place.
  ///
  /// Output only.
  core.double? latitude;

  /// Longitude of the POI rounding to 6th decimal place.
  ///
  /// Output only.
  core.double? longitude;

  $PoiTargetingOptionDetails({this.displayName, this.latitude, this.longitude});

  $PoiTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : PointInTimeRestoreContext
/// - sqladmin:v1beta4 : PointInTimeRestoreContext
class $PointInTimeRestoreContext {
  /// The name of the allocated IP range for the internal IP Cloud SQL instance.
  ///
  /// For example: "google-managed-services-default". If you set this, then
  /// Cloud SQL creates the IP address for the cloned instance in the allocated
  /// range. This range must comply with
  /// [RFC 1035](https://tools.ietf.org/html/rfc1035) standards. Specifically,
  /// the name must be 1-63 characters long and match the regular expression
  /// \[a-z\](\[-a-z0-9\]*\[a-z0-9\])?. Reserved for future use.
  /// http://go/speckle-subnet-picker-clone
  ///
  /// Optional.
  core.String? allocatedIpRange;

  /// The Google Cloud Backup and Disaster Recovery Datasource URI.
  ///
  /// Format:
  /// projects/{project}/locations/{region}/backupVaults/{backupvault}/dataSources/{datasource}.
  core.String? datasource;

  /// The date and time to which you want to restore the instance.
  ///
  /// Required.
  core.String? pointInTime;

  /// Point-in-time recovery of a regional instance in the specified zones.
  ///
  /// If not specified, clone to the same secondary zone as the source instance.
  /// This value cannot be the same as the preferred_zone field.
  ///
  /// Optional.
  core.String? preferredSecondaryZone;

  /// Point-in-time recovery of an instance to the specified zone.
  ///
  /// If no zone is specified, then clone to the same primary zone as the source
  /// instance.
  ///
  /// Optional.
  core.String? preferredZone;

  /// The resource link for the VPC network from which the Cloud SQL instance is
  /// accessible for private IP.
  ///
  /// For example, `/projects/myProject/global/networks/default`.
  ///
  /// Optional.
  core.String? privateNetwork;

  /// Target instance name.
  core.String? targetInstance;

  $PointInTimeRestoreContext({
    this.allocatedIpRange,
    this.datasource,
    this.pointInTime,
    this.preferredSecondaryZone,
    this.preferredZone,
    this.privateNetwork,
    this.targetInstance,
  });

  $PointInTimeRestoreContext.fromJson(core.Map json_)
    : this(
        allocatedIpRange: json_['allocatedIpRange'] as core.String?,
        datasource: json_['datasource'] as core.String?,
        pointInTime: json_['pointInTime'] as core.String?,
        preferredSecondaryZone: json_['preferredSecondaryZone'] as core.String?,
        preferredZone: json_['preferredZone'] as core.String?,
        privateNetwork: json_['privateNetwork'] as core.String?,
        targetInstance: json_['targetInstance'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allocatedIpRange != null) 'allocatedIpRange': allocatedIpRange!,
    if (datasource != null) 'datasource': datasource!,
    if (pointInTime != null) 'pointInTime': pointInTime!,
    if (preferredSecondaryZone != null)
      'preferredSecondaryZone': preferredSecondaryZone!,
    if (preferredZone != null) 'preferredZone': preferredZone!,
    if (privateNetwork != null) 'privateNetwork': privateNetwork!,
    if (targetInstance != null) 'targetInstance': targetInstance!,
  };
}

/// Used by:
///
/// - dns:v1 : PolicyAlternativeNameServerConfigTargetNameServer
/// - dns:v1beta2 : PolicyAlternativeNameServerConfigTargetNameServer
class $PolicyAlternativeNameServerConfigTargetNameServer {
  /// Forwarding path for this TargetNameServer.
  ///
  /// If unset or set to DEFAULT, Cloud DNS makes forwarding decisions based on
  /// address ranges; that is, RFC1918 addresses go to the VPC network,
  /// non-RFC1918 addresses go to the internet. When set to PRIVATE, Cloud DNS
  /// always sends queries through the VPC network for this target.
  /// Possible string values are:
  /// - "default" : Cloud DNS makes forwarding decision based on IP address
  /// ranges; that is, RFC1918 addresses forward to the target through the VPC
  /// and non-RFC1918 addresses forward to the target through the internet
  /// - "private" : Cloud DNS always forwards to this target through the VPC.
  core.String? forwardingPath;

  /// IPv4 address to forward queries to.
  core.String? ipv4Address;

  /// IPv6 address to forward to.
  ///
  /// Does not accept both fields (ipv4 & ipv6) being populated. Public preview
  /// as of November 2022.
  core.String? ipv6Address;
  core.String? kind;

  $PolicyAlternativeNameServerConfigTargetNameServer({
    this.forwardingPath,
    this.ipv4Address,
    this.ipv6Address,
    this.kind,
  });

  $PolicyAlternativeNameServerConfigTargetNameServer.fromJson(core.Map json_)
    : this(
        forwardingPath: json_['forwardingPath'] as core.String?,
        ipv4Address: json_['ipv4Address'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (forwardingPath != null) 'forwardingPath': forwardingPath!,
    if (ipv4Address != null) 'ipv4Address': ipv4Address!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyBinding
/// - gkehub:v1alpha : PolicyBinding
/// - gkehub:v1beta : PolicyBinding
class $PolicyBinding {
  /// The relative resource name of the binauthz platform policy to audit.
  ///
  /// GKE platform policies have the following format:
  /// `projects/{project_number}/platforms/gke/policies/{policy_id}`.
  core.String? name;

  $PolicyBinding({this.name});

  $PolicyBinding.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyControllerBundleInstallSpec
/// - gkehub:v1alpha : PolicyControllerBundleInstallSpec
/// - gkehub:v1beta : PolicyControllerBundleInstallSpec
class $PolicyControllerBundleInstallSpec00 {
  /// The set of namespaces to be exempted from the bundle.
  core.List<core.String>? exemptedNamespaces;

  $PolicyControllerBundleInstallSpec00({this.exemptedNamespaces});

  $PolicyControllerBundleInstallSpec00.fromJson(core.Map json_)
    : this(
        exemptedNamespaces:
            (json_['exemptedNamespaces'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exemptedNamespaces != null) 'exemptedNamespaces': exemptedNamespaces!,
  };
}

/// Used by:
///
/// - gkehub:v2 : PolicyControllerBundleInstallSpec
/// - gkehub:v2alpha : PolicyControllerBundleInstallSpec
/// - gkehub:v2beta : PolicyControllerBundleInstallSpec
class $PolicyControllerBundleInstallSpec01 {
  /// the set of namespaces to be exempted from the bundle
  core.List<core.String>? exemptedNamespaces;

  $PolicyControllerBundleInstallSpec01({this.exemptedNamespaces});

  $PolicyControllerBundleInstallSpec01.fromJson(core.Map json_)
    : this(
        exemptedNamespaces:
            (json_['exemptedNamespaces'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exemptedNamespaces != null) 'exemptedNamespaces': exemptedNamespaces!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyControllerOnClusterState
/// - gkehub:v1alpha : PolicyControllerOnClusterState
/// - gkehub:v1beta : PolicyControllerOnClusterState
class $PolicyControllerOnClusterState00 {
  /// Surface potential errors or information logs.
  core.String? details;

  /// The lifecycle state of this component.
  /// Possible string values are:
  /// - "LIFECYCLE_STATE_UNSPECIFIED" : The lifecycle state is unspecified.
  /// - "NOT_INSTALLED" : The PC does not exist on the given cluster, and no k8s
  /// resources of any type that are associated with the PC should exist there.
  /// The cluster does not possess a membership with the PCH.
  /// - "INSTALLING" : The PCH possesses a Membership, however the PC is not
  /// fully installed on the cluster. In this state the hub can be expected to
  /// be taking actions to install the PC on the cluster.
  /// - "ACTIVE" : The PC is fully installed on the cluster and in an
  /// operational mode. In this state PCH will be reconciling state with the PC,
  /// and the PC will be performing it's operational tasks per that software.
  /// Entering a READY state requires that the hub has confirmed the PC is
  /// installed and its pods are operational with the version of the PC the PCH
  /// expects.
  /// - "UPDATING" : The PC is fully installed, but in the process of changing
  /// the configuration (including changing the version of PC either up and
  /// down, or modifying the manifests of PC) of the resources running on the
  /// cluster. The PCH has a Membership, is aware of the version the cluster
  /// should be running in, but has not confirmed for itself that the PC is
  /// running with that version.
  /// - "DECOMMISSIONING" : The PC may have resources on the cluster, but the
  /// PCH wishes to remove the Membership. The Membership still exists.
  /// - "CLUSTER_ERROR" : The PC is not operational, and the PCH is unable to
  /// act to make it operational. Entering a CLUSTER_ERROR state happens
  /// automatically when the PCH determines that a PC installed on the cluster
  /// is non-operative or that the cluster does not meet requirements set for
  /// the PCH to administer the cluster but has nevertheless been given an
  /// instruction to do so (such as 'install').
  /// - "HUB_ERROR" : In this state, the PC may still be operational, and only
  /// the PCH is unable to act. The hub should not issue instructions to change
  /// the PC state, or otherwise interfere with the on-cluster resources.
  /// Entering a HUB_ERROR state happens automatically when the PCH determines
  /// the hub is in an unhealthy state and it wishes to 'take hands off' to
  /// avoid corrupting the PC or other data.
  /// - "SUSPENDED" : Policy Controller (PC) is installed but suspended. This
  /// means that the policies are not enforced, but violations are still
  /// recorded (through audit).
  /// - "DETACHED" : PoCo Hub is not taking any action to reconcile cluster
  /// objects. Changes to those objects will not be overwritten by PoCo Hub.
  core.String? state;

  $PolicyControllerOnClusterState00({this.details, this.state});

  $PolicyControllerOnClusterState00.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - gkehub:v2 : PolicyControllerOnClusterState
/// - gkehub:v2alpha : PolicyControllerOnClusterState
/// - gkehub:v2beta : PolicyControllerOnClusterState
class $PolicyControllerOnClusterState01 {
  /// Surface potential errors or information logs.
  core.String? details;

  /// The lifecycle state of this component.
  /// Possible string values are:
  /// - "LIFECYCLE_STATE_UNSPECIFIED" : The lifecycle state is unspecified.
  /// - "NOT_INSTALLED" : The PC does not exist on the given cluster, and no k8s
  /// resources of any type that are associated with the PC should exist there.
  /// The cluster does not possess a membership with the PCH.
  /// - "INSTALLING" : The PCH possesses a Membership, however the PC is not
  /// fully installed on the cluster. In this state the hub can be expected to
  /// be taking actions to install the PC on the cluster.
  /// - "ACTIVE" : The PC is fully installed on the cluster and in an
  /// operational mode. In this state PCH will be reconciling state with the PC,
  /// and the PC will be performing it's operational tasks per that software.
  /// Entering a READY state requires that the hub has confirmed the PC is
  /// installed and its pods are operational with the version of the PC the PCH
  /// expects.
  /// - "UPDATING" : The PC is fully installed, but in the process of changing
  /// the configuration (including changing the version of PC either up and
  /// down, or modifying the manifests of PC) of the resources running on the
  /// cluster. The PCH has a Membership, is aware of the version the cluster
  /// should be running in, but has not confirmed for itself that the PC is
  /// running with that version.
  /// - "DECOMMISSIONING" : The PC may have resources on the cluster, but the
  /// PCH wishes to remove the Membership. The Membership still exists.
  /// - "CLUSTER_ERROR" : The PC is not operational, and the PCH is unable to
  /// act to make it operational. Entering a CLUSTER_ERROR state happens
  /// automatically when the PCH determines that a PC installed on the cluster
  /// is non-operative or that the cluster does not meet requirements set for
  /// the PCH to administer the cluster but has nevertheless been given an
  /// instruction to do so (such as install').
  /// - "HUB_ERROR" : In this state, the PC may still be operational, and only
  /// the PCH is unable to act. The hub should not issue instructions to change
  /// the PC state, or otherwise interfere with the on-cluster resources.
  /// Entering a HUB_ERROR state happens automatically when the PCH determines
  /// the hub is in an unhealthy state and it wishes to take hands off' to
  /// avoid corrupting the PC or other data.
  /// - "SUSPENDED" : Policy Controller (PC) is installed but suspended. This
  /// means that the policies are not enforced, but violations are still
  /// recorded (through audit).
  /// - "DETACHED" : PoCo Hub is not taking any action to reconcile cluster
  /// objects. Changes to those objects will not be overwritten by PoCo Hub.
  core.String? state;

  $PolicyControllerOnClusterState01({this.details, this.state});

  $PolicyControllerOnClusterState01.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyControllerResourceList
/// - gkehub:v1alpha : PolicyControllerResourceList
/// - gkehub:v1beta : PolicyControllerResourceList
/// - gkehub:v2 : PolicyControllerResourceList
/// - gkehub:v2alpha : PolicyControllerResourceList
/// - gkehub:v2beta : PolicyControllerResourceList
class $PolicyControllerResourceList {
  /// CPU requirement expressed in Kubernetes resource units.
  core.String? cpu;

  /// Memory requirement expressed in Kubernetes resource units.
  core.String? memory;

  $PolicyControllerResourceList({this.cpu, this.memory});

  $PolicyControllerResourceList.fromJson(core.Map json_)
    : this(
        cpu: json_['cpu'] as core.String?,
        memory: json_['memory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpu != null) 'cpu': cpu!,
    if (memory != null) 'memory': memory!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyControllerTemplateLibraryConfig
/// - gkehub:v1alpha : PolicyControllerTemplateLibraryConfig
/// - gkehub:v1beta : PolicyControllerTemplateLibraryConfig
/// - gkehub:v2 : PolicyControllerTemplateLibraryConfig
/// - gkehub:v2alpha : PolicyControllerTemplateLibraryConfig
/// - gkehub:v2beta : PolicyControllerTemplateLibraryConfig
class $PolicyControllerTemplateLibraryConfig {
  /// Configures the manner in which the template library is installed on the
  /// cluster.
  /// Possible string values are:
  /// - "INSTALLATION_UNSPECIFIED" : No installation strategy has been
  /// specified.
  /// - "NOT_INSTALLED" : Do not install the template library.
  /// - "ALL" : Install the entire template library.
  core.String? installation;

  $PolicyControllerTemplateLibraryConfig({this.installation});

  $PolicyControllerTemplateLibraryConfig.fromJson(core.Map json_)
    : this(installation: json_['installation'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (installation != null) 'installation': installation!,
  };
}

/// Used by:
///
/// - gkehub:v1 : PolicyControllerToleration
/// - gkehub:v1alpha : PolicyControllerToleration
/// - gkehub:v1beta : PolicyControllerToleration
/// - gkehub:v2 : PolicyControllerToleration
/// - gkehub:v2alpha : PolicyControllerToleration
/// - gkehub:v2beta : PolicyControllerToleration
class $PolicyControllerToleration {
  /// Matches a taint effect.
  core.String? effect;

  /// Matches a taint key (not necessarily unique).
  core.String? key;

  /// Matches a taint operator.
  core.String? operator;

  /// Matches a taint value.
  core.String? value;

  $PolicyControllerToleration({
    this.effect,
    this.key,
    this.operator,
    this.value,
  });

  $PolicyControllerToleration.fromJson(core.Map json_)
    : this(
        effect: json_['effect'] as core.String?,
        key: json_['key'] as core.String?,
        operator: json_['operator'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (effect != null) 'effect': effect!,
    if (key != null) 'key': key!,
    if (operator != null) 'operator': operator!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dns:v1 : PolicyDns64ConfigScope
/// - dns:v1beta2 : PolicyDns64ConfigScope
class $PolicyDns64ConfigScope {
  /// Controls whether DNS64 is enabled globally at the network level.
  core.bool? allQueries;
  core.String? kind;

  $PolicyDns64ConfigScope({this.allQueries, this.kind});

  $PolicyDns64ConfigScope.fromJson(core.Map json_)
    : this(
        allQueries: json_['allQueries'] as core.bool?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allQueries != null) 'allQueries': allQueries!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : PolicyNetwork
/// - dns:v1beta2 : PolicyNetwork
class $PolicyNetwork {
  core.String? kind;

  /// The fully qualified URL of the VPC network to bind to.
  ///
  /// This should be formatted like
  /// https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}
  core.String? networkUrl;

  $PolicyNetwork({this.kind, this.networkUrl});

  $PolicyNetwork.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : PolicyQuery
/// - cloudidentity:v1beta1 : PolicyQuery
class $PolicyQuery {
  /// The group that the query applies to.
  ///
  /// This field is only set if there is a single value for group that satisfies
  /// all clauses of the query. If no group applies, this will be the empty
  /// string.
  ///
  /// Immutable.
  core.String? group;

  /// Non-empty default.
  ///
  /// The OrgUnit the query applies to. This field is only set if there is a
  /// single value for org_unit that satisfies all clauses of the query.
  ///
  /// Required. Immutable.
  core.String? orgUnit;

  /// The CEL query that defines which entities the Policy applies to (ex.
  ///
  /// a User entity). For details about CEL see
  /// https://opensource.google.com/projects/cel. The OrgUnits the Policy
  /// applies to are represented by a clause like so:
  /// entity.org_units.exists(org_unit, org_unit.org_unit_id ==
  /// orgUnitId('{orgUnitId}')) The Group the Policy applies to are represented
  /// by a clause like so: entity.groups.exists(group, group.group_id ==
  /// groupId('{groupId}')) The Licenses the Policy applies to are represented
  /// by a clause like so: entity.licenses.exists(license, license in
  /// \['/product/{productId}/sku/{skuId}'\]) The above clauses can be present
  /// in any combination, and used in conjunction with the &&, || and !
  /// operators. The org_unit and group fields below are helper fields that
  /// contain the corresponding value(s) as the query to make the query easier
  /// to use.
  ///
  /// Immutable.
  core.String? query;

  /// The decimal sort order of this PolicyQuery.
  ///
  /// The value is relative to all other policies with the same setting type for
  /// the customer. (There are no duplicates within this set).
  ///
  /// Output only.
  core.double? sortOrder;

  $PolicyQuery({this.group, this.orgUnit, this.query, this.sortOrder});

  $PolicyQuery.fromJson(core.Map json_)
    : this(
        group: json_['group'] as core.String?,
        orgUnit: json_['orgUnit'] as core.String?,
        query: json_['query'] as core.String?,
        sortOrder: (json_['sortOrder'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (group != null) 'group': group!,
    if (orgUnit != null) 'orgUnit': orgUnit!,
    if (query != null) 'query': query!,
    if (sortOrder != null) 'sortOrder': sortOrder!,
  };
}

/// Used by:
///
/// - composer:v1 : PollAirflowCommandRequest
/// - composer:v1beta1 : PollAirflowCommandRequest
class $PollAirflowCommandRequest {
  /// The unique ID of the command execution.
  core.String? executionId;

  /// Line number from which new logs should be fetched.
  core.int? nextLineNumber;

  /// The name of the pod where the command is executed.
  core.String? pod;

  /// The namespace of the pod where the command is executed.
  core.String? podNamespace;

  $PollAirflowCommandRequest({
    this.executionId,
    this.nextLineNumber,
    this.pod,
    this.podNamespace,
  });

  $PollAirflowCommandRequest.fromJson(core.Map json_)
    : this(
        executionId: json_['executionId'] as core.String?,
        nextLineNumber: json_['nextLineNumber'] as core.int?,
        pod: json_['pod'] as core.String?,
        podNamespace: json_['podNamespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (executionId != null) 'executionId': executionId!,
    if (nextLineNumber != null) 'nextLineNumber': nextLineNumber!,
    if (pod != null) 'pod': pod!,
    if (podNamespace != null) 'podNamespace': podNamespace!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Port
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Port
class $Port {
  /// The number of the port to expose on the pod's IP address.
  ///
  /// Must be a valid port number, between 1 and 65535 inclusive.
  core.int? containerPort;

  $Port({this.containerPort});

  $Port.fromJson(core.Map json_)
    : this(containerPort: json_['containerPort'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (containerPort != null) 'containerPort': containerPort!,
  };
}

/// Used by:
///
/// - gkeonprem:v1 : BareMetalAdminPortConfig
/// - gkeonprem:v1 : BareMetalPortConfig
class $PortConfig {
  /// The port that control plane hosted load balancers will listen on.
  core.int? controlPlaneLoadBalancerPort;

  $PortConfig({this.controlPlaneLoadBalancerPort});

  $PortConfig.fromJson(core.Map json_)
    : this(
        controlPlaneLoadBalancerPort:
            json_['controlPlaneLoadBalancerPort'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (controlPlaneLoadBalancerPort != null)
      'controlPlaneLoadBalancerPort': controlPlaneLoadBalancerPort!,
  };
}

/// Used by:
///
/// - workstations:v1 : PortRange
/// - workstations:v1beta : PortRange
class $PortRange {
  /// Starting port number for the current range of ports.
  ///
  /// Valid ports are 22, 80, and ports within the range 1024-65535.
  ///
  /// Required.
  core.int? first;

  /// Ending port number for the current range of ports.
  ///
  /// Valid ports are 22, 80, and ports within the range 1024-65535.
  ///
  /// Required.
  core.int? last;

  $PortRange({this.first, this.last});

  $PortRange.fromJson(core.Map json_)
    : this(
        first: json_['first'] as core.int?,
        last: json_['last'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (first != null) 'first': first!,
    if (last != null) 'last': last!,
  };
}

/// Used by:
///
/// - dataportability:v1 : PortabilityArchiveState
/// - dataportability:v1beta : PortabilityArchiveState
class $PortabilityArchiveState {
  /// The timestamp that represents the end point for the data you are
  /// exporting.
  ///
  /// If the end_time value is set in the InitiatePortabilityArchiveRequest,
  /// this field is set to that value. If end_time is not set, this value is set
  /// to the time the export was requested.
  core.String? exportTime;

  /// The resource name of ArchiveJob's PortabilityArchiveState singleton.
  ///
  /// The format is: archiveJobs/{archive_job}/portabilityArchiveState.
  /// archive_job is the job ID provided in the request.
  core.String? name;

  /// The timestamp that represents the starting point for the data you are
  /// exporting.
  ///
  /// This field is set only if the start_time field is specified in the
  /// InitiatePortabilityArchiveRequest.
  core.String? startTime;

  /// Resource that represents the state of the Archive job.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "IN_PROGRESS" : The job is in progress.
  /// - "COMPLETE" : The job is complete.
  /// - "FAILED" : The job failed.
  /// - "CANCELLED" : The job is cancelled.
  core.String? state;

  /// If the state is complete, this method returns the signed URLs of the
  /// objects in the Cloud Storage bucket.
  core.List<core.String>? urls;

  $PortabilityArchiveState({
    this.exportTime,
    this.name,
    this.startTime,
    this.state,
    this.urls,
  });

  $PortabilityArchiveState.fromJson(core.Map json_)
    : this(
        exportTime: json_['exportTime'] as core.String?,
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        urls:
            (json_['urls'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportTime != null) 'exportTime': exportTime!,
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (urls != null) 'urls': urls!,
  };
}

/// Used by:
///
/// - vision:v1 : Position
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1Position
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1Position
class $Position00 {
  /// X coordinate.
  core.double? x;

  /// Y coordinate.
  core.double? y;

  /// Z coordinate (or depth).
  core.double? z;

  $Position00({this.x, this.y, this.z});

  $Position00.fromJson(core.Map json_)
    : this(
        x: (json_['x'] as core.num?)?.toDouble(),
        y: (json_['y'] as core.num?)?.toDouble(),
        z: (json_['z'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
    if (z != null) 'z': z!,
  };
}

/// Used by:
///
/// - workflowexecutions:v1 : Position
/// - workflowexecutions:v1beta : Position
class $Position01 {
  /// The source code column position (of the line) the current instruction was
  /// generated from.
  core.String? column;

  /// The number of bytes of source code making up this stack trace element.
  core.String? length;

  /// The source code line number the current instruction was generated from.
  core.String? line;

  $Position01({this.column, this.length, this.line});

  $Position01.fromJson(core.Map json_)
    : this(
        column: json_['column'] as core.String?,
        length: json_['length'] as core.String?,
        line: json_['line'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (column != null) 'column': column!,
    if (length != null) 'length': length!,
    if (line != null) 'line': line!,
  };
}

/// Used by:
///
/// - oslogin:v1 : PosixAccount
/// - oslogin:v1alpha : PosixAccount
/// - oslogin:v1beta : PosixAccount
class $PosixAccount {
  /// A POSIX account identifier.
  ///
  /// Output only.
  core.String? accountId;

  /// The GECOS (user information) entry for this account.
  core.String? gecos;

  /// The default group ID.
  core.String? gid;

  /// The path to the home directory for this account.
  core.String? homeDirectory;

  /// The canonical resource name.
  ///
  /// Output only.
  core.String? name;

  /// The operating system type where this account applies.
  /// Possible string values are:
  /// - "OPERATING_SYSTEM_TYPE_UNSPECIFIED" : The operating system type
  /// associated with the user account information is unspecified.
  /// - "LINUX" : Linux user account information.
  /// - "WINDOWS" : Windows user account information.
  core.String? operatingSystemType;

  /// Only one POSIX account can be marked as primary.
  core.bool? primary;

  /// The path to the logic shell for this account.
  core.String? shell;

  /// System identifier for which account the username or uid applies to.
  ///
  /// By default, the empty value is used.
  core.String? systemId;

  /// The user ID.
  core.String? uid;

  /// The username of the POSIX account.
  core.String? username;

  $PosixAccount({
    this.accountId,
    this.gecos,
    this.gid,
    this.homeDirectory,
    this.name,
    this.operatingSystemType,
    this.primary,
    this.shell,
    this.systemId,
    this.uid,
    this.username,
  });

  $PosixAccount.fromJson(core.Map json_)
    : this(
        accountId: json_['accountId'] as core.String?,
        gecos: json_['gecos'] as core.String?,
        gid: json_['gid'] as core.String?,
        homeDirectory: json_['homeDirectory'] as core.String?,
        name: json_['name'] as core.String?,
        operatingSystemType: json_['operatingSystemType'] as core.String?,
        primary: json_['primary'] as core.bool?,
        shell: json_['shell'] as core.String?,
        systemId: json_['systemId'] as core.String?,
        uid: json_['uid'] as core.String?,
        username: json_['username'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accountId != null) 'accountId': accountId!,
    if (gecos != null) 'gecos': gecos!,
    if (gid != null) 'gid': gid!,
    if (homeDirectory != null) 'homeDirectory': homeDirectory!,
    if (name != null) 'name': name!,
    if (operatingSystemType != null)
      'operatingSystemType': operatingSystemType!,
    if (primary != null) 'primary': primary!,
    if (shell != null) 'shell': shell!,
    if (systemId != null) 'systemId': systemId!,
    if (uid != null) 'uid': uid!,
    if (username != null) 'username': username!,
  };
}

/// Used by:
///
/// - blogger:v2 : Post
/// - blogger:v3 : Post
class $Post {
  /// The author of this Post.
  PostAuthor? author;

  /// Data about the blog containing this Post.
  PostBlog? blog;

  /// The content of the Post.
  ///
  /// May contain HTML markup.
  core.String? content;

  /// The JSON meta-data for the Post.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? customMetaData;

  /// Etag of the resource.
  core.String? etag;

  /// The identifier of this Post.
  core.String? id;

  /// Display image for the Post.
  core.List<PostImages>? images;

  /// The kind of this entity.
  ///
  /// Always blogger#post.
  core.String? kind;

  /// The list of labels this Post was tagged with.
  core.List<core.String>? labels;

  /// The location for geotagged posts.
  PostLocation? location;

  /// RFC 3339 date-time when this Post was published.
  core.String? published;

  /// Comment control and display setting for readers of this post.
  /// Possible string values are:
  /// - "ALLOW"
  /// - "DONT_ALLOW_SHOW_EXISTING"
  /// - "DONT_ALLOW_HIDE_EXISTING"
  core.String? readerComments;

  /// The container of comments on this Post.
  PostReplies? replies;

  /// The API REST URL to fetch this resource from.
  core.String? selfLink;

  /// Status of the post.
  ///
  /// Only set for admin-level requests.
  /// Possible string values are:
  /// - "LIVE"
  /// - "DRAFT"
  /// - "SCHEDULED"
  /// - "SOFT_TRASHED"
  core.String? status;

  /// The title of the Post.
  core.String? title;

  /// The title link URL, similar to atom's related link.
  core.String? titleLink;

  /// RFC 3339 date-time when this Post was last trashed.
  core.String? trashed;

  /// RFC 3339 date-time when this Post was last updated.
  core.String? updated;

  /// The URL where this Post is displayed.
  core.String? url;

  $Post({
    this.author,
    this.blog,
    this.content,
    this.customMetaData,
    this.etag,
    this.id,
    this.images,
    this.kind,
    this.labels,
    this.location,
    this.published,
    this.readerComments,
    this.replies,
    this.selfLink,
    this.status,
    this.title,
    this.titleLink,
    this.trashed,
    this.updated,
    this.url,
  });

  $Post.fromJson(core.Map json_)
    : this(
        author:
            json_.containsKey('author')
                ? PostAuthor.fromJson(
                  json_['author'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        blog:
            json_.containsKey('blog')
                ? PostBlog.fromJson(
                  json_['blog'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        content: json_['content'] as core.String?,
        customMetaData: json_['customMetaData'] as core.String?,
        etag: json_['etag'] as core.String?,
        id: json_['id'] as core.String?,
        images:
            (json_['images'] as core.List?)
                ?.map(
                  (value) => PostImages.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        kind: json_['kind'] as core.String?,
        labels:
            (json_['labels'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        location:
            json_.containsKey('location')
                ? PostLocation.fromJson(
                  json_['location'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        published: json_['published'] as core.String?,
        readerComments: json_['readerComments'] as core.String?,
        replies:
            json_.containsKey('replies')
                ? PostReplies.fromJson(
                  json_['replies'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        title: json_['title'] as core.String?,
        titleLink: json_['titleLink'] as core.String?,
        trashed: json_['trashed'] as core.String?,
        updated: json_['updated'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (author != null) 'author': author!,
    if (blog != null) 'blog': blog!,
    if (content != null) 'content': content!,
    if (customMetaData != null) 'customMetaData': customMetaData!,
    if (etag != null) 'etag': etag!,
    if (id != null) 'id': id!,
    if (images != null) 'images': images!,
    if (kind != null) 'kind': kind!,
    if (labels != null) 'labels': labels!,
    if (location != null) 'location': location!,
    if (published != null) 'published': published!,
    if (readerComments != null) 'readerComments': readerComments!,
    if (replies != null) 'replies': replies!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (title != null) 'title': title!,
    if (titleLink != null) 'titleLink': titleLink!,
    if (trashed != null) 'trashed': trashed!,
    if (updated != null) 'updated': updated!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PostStartupScriptConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PostStartupScriptConfig
class $PostStartupScriptConfig {
  /// Post startup script to run after runtime is started.
  ///
  /// Optional.
  core.String? postStartupScript;

  /// Post startup script behavior that defines download and execution behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED" : Unspecified post startup
  /// script behavior.
  /// - "RUN_ONCE" : Run post startup script after runtime is started.
  /// - "RUN_EVERY_START" : Run post startup script after runtime is stopped.
  /// - "DOWNLOAD_AND_RUN_EVERY_START" : Download and run post startup script
  /// every time runtime is started.
  core.String? postStartupScriptBehavior;

  /// Post startup script url to download.
  ///
  /// Example: `gs://bucket/script.sh`
  ///
  /// Optional.
  core.String? postStartupScriptUrl;

  $PostStartupScriptConfig({
    this.postStartupScript,
    this.postStartupScriptBehavior,
    this.postStartupScriptUrl,
  });

  $PostStartupScriptConfig.fromJson(core.Map json_)
    : this(
        postStartupScript: json_['postStartupScript'] as core.String?,
        postStartupScriptBehavior:
            json_['postStartupScriptBehavior'] as core.String?,
        postStartupScriptUrl: json_['postStartupScriptUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (postStartupScript != null) 'postStartupScript': postStartupScript!,
    if (postStartupScriptBehavior != null)
      'postStartupScriptBehavior': postStartupScriptBehavior!,
    if (postStartupScriptUrl != null)
      'postStartupScriptUrl': postStartupScriptUrl!,
  };
}

/// Used by:
///
/// - addressvalidation:v1 : GoogleTypePostalAddress
/// - cloudchannel:v1 : GoogleTypePostalAddress
/// - documentai:v1 : GoogleTypePostalAddress
/// - documentai:v1beta3 : GoogleTypePostalAddress
/// - jobs:v3 : PostalAddress
/// - jobs:v3p1beta1 : PostalAddress
/// - jobs:v4 : PostalAddress
/// - merchantapi:accounts_v1beta : PostalAddress
/// - mybusinessaccountmanagement:v1 : PostalAddress
/// - mybusinessbusinessinformation:v1 : PostalAddress
/// - mybusinessverifications:v1 : PostalAddress
/// - places:v1 : GoogleTypePostalAddress
class $PostalAddress00 {
  /// Unstructured address lines describing the lower levels of an address.
  ///
  /// Because values in `address_lines` do not have type information and may
  /// sometimes contain multiple values in a single field (for example, "Austin,
  /// TX"), it is important that the line order is clear. The order of address
  /// lines should be "envelope order" for the country or region of the address.
  /// In places where this can vary (for example, Japan), `address_language` is
  /// used to make it explicit (for example, "ja" for large-to-small ordering
  /// and "ja-Latn" or "en" for small-to-large). In this way, the most specific
  /// line of an address can be selected based on the language. The minimum
  /// permitted structural representation of an address consists of a
  /// `region_code` with all remaining information placed in the
  /// `address_lines`. It would be possible to format such an address very
  /// approximately without geocoding, but no semantic reasoning could be made
  /// about any of the address components until it was at least partially
  /// resolved. Creating an address only containing a `region_code` and
  /// `address_lines` and then geocoding is the recommended way to handle
  /// completely unstructured addresses (as opposed to guessing which parts of
  /// the address should be localities or administrative areas).
  core.List<core.String>? addressLines;

  /// Highest administrative subdivision which is used for postal addresses of a
  /// country or region.
  ///
  /// For example, this can be a state, a province, an oblast, or a prefecture.
  /// For Spain, this is the province and not the autonomous community (for
  /// example, "Barcelona" and not "Catalonia"). Many countries don't use an
  /// administrative area in postal addresses. For example, in Switzerland, this
  /// should be left unpopulated.
  ///
  /// Optional.
  core.String? administrativeArea;

  /// BCP-47 language code of the contents of this address (if known).
  ///
  /// This is often the UI language of the input form or is expected to match
  /// one of the languages used in the address' country/region, or their
  /// transliterated equivalents. This can affect formatting in certain
  /// countries, but is not critical to the correctness of the data and will
  /// never affect any validation or other non-formatting related operations. If
  /// this value is not known, it should be omitted (rather than specifying a
  /// possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
  ///
  /// Optional.
  core.String? languageCode;

  /// Generally refers to the city or town portion of the address.
  ///
  /// Examples: US city, IT comune, UK post town. In regions of the world where
  /// localities are not well defined or do not fit into this structure well,
  /// leave `locality` empty and use `address_lines`.
  ///
  /// Optional.
  core.String? locality;

  /// The name of the organization at the address.
  ///
  /// Optional.
  core.String? organization;

  /// Postal code of the address.
  ///
  /// Not all countries use or require postal codes to be present, but where
  /// they are used, they may trigger additional validation with other parts of
  /// the address (for example, state or zip code validation in the United
  /// States).
  ///
  /// Optional.
  core.String? postalCode;

  /// The recipient at the address.
  ///
  /// This field may, under certain circumstances, contain multiline
  /// information. For example, it might contain "care of" information.
  ///
  /// Optional.
  core.List<core.String>? recipients;

  /// CLDR region code of the country/region of the address.
  ///
  /// This is never inferred and it is up to the user to ensure the value is
  /// correct. See https://cldr.unicode.org/ and
  /// https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  /// for details. Example: "CH" for Switzerland.
  ///
  /// Required.
  core.String? regionCode;

  /// The schema revision of the `PostalAddress`.
  ///
  /// This must be set to 0, which is the latest revision. All new revisions
  /// **must** be backward compatible with old revisions.
  core.int? revision;

  /// Additional, country-specific, sorting code.
  ///
  /// This is not used in most regions. Where it is used, the value is either a
  /// string like "CEDEX", optionally followed by a number (for example, "CEDEX
  /// 7"), or just a number alone, representing the "sector code" (Jamaica),
  /// "delivery area indicator" (Malawi) or "post office indicator" (Cte
  /// d'Ivoire).
  ///
  /// Optional.
  core.String? sortingCode;

  /// Sublocality of the address.
  ///
  /// For example, this can be a neighborhood, borough, or district.
  ///
  /// Optional.
  core.String? sublocality;

  $PostalAddress00({
    this.addressLines,
    this.administrativeArea,
    this.languageCode,
    this.locality,
    this.organization,
    this.postalCode,
    this.recipients,
    this.regionCode,
    this.revision,
    this.sortingCode,
    this.sublocality,
  });

  $PostalAddress00.fromJson(core.Map json_)
    : this(
        addressLines:
            (json_['addressLines'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        administrativeArea: json_['administrativeArea'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        locality: json_['locality'] as core.String?,
        organization: json_['organization'] as core.String?,
        postalCode: json_['postalCode'] as core.String?,
        recipients:
            (json_['recipients'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        regionCode: json_['regionCode'] as core.String?,
        revision: json_['revision'] as core.int?,
        sortingCode: json_['sortingCode'] as core.String?,
        sublocality: json_['sublocality'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addressLines != null) 'addressLines': addressLines!,
    if (administrativeArea != null) 'administrativeArea': administrativeArea!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (locality != null) 'locality': locality!,
    if (organization != null) 'organization': organization!,
    if (postalCode != null) 'postalCode': postalCode!,
    if (recipients != null) 'recipients': recipients!,
    if (regionCode != null) 'regionCode': regionCode!,
    if (revision != null) 'revision': revision!,
    if (sortingCode != null) 'sortingCode': sortingCode!,
    if (sublocality != null) 'sublocality': sublocality!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleTypePostalAddress
/// - domains:v1 : PostalAddress
/// - domains:v1alpha2 : PostalAddress
/// - domains:v1beta1 : PostalAddress
class $PostalAddress01 {
  /// Unstructured address lines describing the lower levels of an address.
  ///
  /// Because values in address_lines do not have type information and may
  /// sometimes contain multiple values in a single field (For example "Austin,
  /// TX"), it is important that the line order is clear. The order of address
  /// lines should be "envelope order" for the country/region of the address. In
  /// places where this can vary (For example Japan), address_language is used
  /// to make it explicit (For example "ja" for large-to-small ordering and
  /// "ja-Latn" or "en" for small-to-large). This way, the most specific line of
  /// an address can be selected based on the language. The minimum permitted
  /// structural representation of an address consists of a region_code with all
  /// remaining information placed in the address_lines. It would be possible to
  /// format such an address very approximately without geocoding, but no
  /// semantic reasoning could be made about any of the address components until
  /// it was at least partially resolved. Creating an address only containing a
  /// region_code and address_lines, and then geocoding is the recommended way
  /// to handle completely unstructured addresses (as opposed to guessing which
  /// parts of the address should be localities or administrative areas).
  core.List<core.String>? addressLines;

  /// Highest administrative subdivision which is used for postal addresses of a
  /// country or region.
  ///
  /// For example, this can be a state, a province, an oblast, or a prefecture.
  /// Specifically, for Spain this is the province and not the autonomous
  /// community (For example "Barcelona" and not "Catalonia"). Many countries
  /// don't use an administrative area in postal addresses. For example in
  /// Switzerland this should be left unpopulated.
  ///
  /// Optional.
  core.String? administrativeArea;

  /// BCP-47 language code of the contents of this address (if known).
  ///
  /// This is often the UI language of the input form or is expected to match
  /// one of the languages used in the address' country/region, or their
  /// transliterated equivalents. This can affect formatting in certain
  /// countries, but is not critical to the correctness of the data and will
  /// never affect any validation or other non-formatting related operations. If
  /// this value is not known, it should be omitted (rather than specifying a
  /// possibly incorrect default). Examples: "zh-Hant", "ja", "ja-Latn", "en".
  ///
  /// Optional.
  core.String? languageCode;

  /// Generally refers to the city/town portion of the address.
  ///
  /// Examples: US city, IT comune, UK post town. In regions of the world where
  /// localities are not well defined or do not fit into this structure well,
  /// leave locality empty and use address_lines.
  ///
  /// Optional.
  core.String? locality;

  /// The name of the organization at the address.
  ///
  /// Optional.
  core.String? organization;

  /// Postal code of the address.
  ///
  /// Not all countries use or require postal codes to be present, but where
  /// they are used, they may trigger additional validation with other parts of
  /// the address (For example state/zip validation in the U.S.A.).
  ///
  /// Optional.
  core.String? postalCode;

  /// The recipient at the address.
  ///
  /// This field may, under certain circumstances, contain multiline
  /// information. For example, it might contain "care of" information.
  ///
  /// Optional.
  core.List<core.String>? recipients;

  /// CLDR region code of the country/region of the address.
  ///
  /// This is never inferred and it is up to the user to ensure the value is
  /// correct. See https://cldr.unicode.org/ and
  /// https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  /// for details. Example: "CH" for Switzerland.
  ///
  /// Required.
  core.String? regionCode;

  /// The schema revision of the `PostalAddress`.
  ///
  /// This must be set to 0, which is the latest revision. All new revisions
  /// **must** be backward compatible with old revisions.
  core.int? revision;

  /// Additional, country-specific, sorting code.
  ///
  /// This is not used in most regions. Where it is used, the value is either a
  /// string like "CEDEX", optionally followed by a number (For example "CEDEX
  /// 7"), or just a number alone, representing the "sector code" (Jamaica),
  /// "delivery area indicator" (Malawi) or "post office indicator" (For example
  /// Cte d'Ivoire).
  ///
  /// Optional.
  core.String? sortingCode;

  /// Sublocality of the address.
  ///
  /// For example, this can be neighborhoods, boroughs, districts.
  ///
  /// Optional.
  core.String? sublocality;

  $PostalAddress01({
    this.addressLines,
    this.administrativeArea,
    this.languageCode,
    this.locality,
    this.organization,
    this.postalCode,
    this.recipients,
    this.regionCode,
    this.revision,
    this.sortingCode,
    this.sublocality,
  });

  $PostalAddress01.fromJson(core.Map json_)
    : this(
        addressLines:
            (json_['addressLines'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        administrativeArea: json_['administrativeArea'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        locality: json_['locality'] as core.String?,
        organization: json_['organization'] as core.String?,
        postalCode: json_['postalCode'] as core.String?,
        recipients:
            (json_['recipients'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        regionCode: json_['regionCode'] as core.String?,
        revision: json_['revision'] as core.int?,
        sortingCode: json_['sortingCode'] as core.String?,
        sublocality: json_['sublocality'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (addressLines != null) 'addressLines': addressLines!,
    if (administrativeArea != null) 'administrativeArea': administrativeArea!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (locality != null) 'locality': locality!,
    if (organization != null) 'organization': organization!,
    if (postalCode != null) 'postalCode': postalCode!,
    if (recipients != null) 'recipients': recipients!,
    if (regionCode != null) 'regionCode': regionCode!,
    if (revision != null) 'revision': revision!,
    if (sortingCode != null) 'sortingCode': sortingCode!,
    if (sublocality != null) 'sublocality': sublocality!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : PostgreSqlExtension
/// - migrationcenter:v1alpha1 : PostgreSqlExtension
class $PostgreSqlExtension {
  /// The extension name.
  ///
  /// Required.
  core.String? extension;

  /// The extension version.
  ///
  /// Required.
  core.String? version;

  $PostgreSqlExtension({this.extension, this.version});

  $PostgreSqlExtension.fromJson(core.Map json_)
    : this(
        extension: json_['extension'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : PostgreSqlSetting
/// - migrationcenter:v1alpha1 : PostgreSqlSetting
class $PostgreSqlSetting {
  /// The setting boolean value.
  ///
  /// Required.
  core.bool? boolValue;

  /// The setting int value.
  ///
  /// Required.
  core.String? intValue;

  /// The setting real value.
  ///
  /// Required.
  core.double? realValue;

  /// The setting name.
  ///
  /// Required.
  core.String? setting;

  /// The setting source.
  ///
  /// Required.
  core.String? source;

  /// The setting string value.
  ///
  /// Notice that enum values are stored as strings.
  ///
  /// Required.
  core.String? stringValue;

  /// The setting unit.
  ///
  /// Optional.
  core.String? unit;

  $PostgreSqlSetting({
    this.boolValue,
    this.intValue,
    this.realValue,
    this.setting,
    this.source,
    this.stringValue,
    this.unit,
  });

  $PostgreSqlSetting.fromJson(core.Map json_)
    : this(
        boolValue: json_['boolValue'] as core.bool?,
        intValue: json_['intValue'] as core.String?,
        realValue: (json_['realValue'] as core.num?)?.toDouble(),
        setting: json_['setting'] as core.String?,
        source: json_['source'] as core.String?,
        stringValue: json_['stringValue'] as core.String?,
        unit: json_['unit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boolValue != null) 'boolValue': boolValue!,
    if (intValue != null) 'intValue': intValue!,
    if (realValue != null) 'realValue': realValue!,
    if (setting != null) 'setting': setting!,
    if (source != null) 'source': source!,
    if (stringValue != null) 'stringValue': stringValue!,
    if (unit != null) 'unit': unit!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PrebuiltVoiceConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PrebuiltVoiceConfig
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1PrebuiltVoiceConfig
class $PrebuiltVoiceConfig {
  /// The name of the preset voice to use.
  core.String? voiceName;

  $PrebuiltVoiceConfig({this.voiceName});

  $PrebuiltVoiceConfig.fromJson(core.Map json_)
    : this(voiceName: json_['voiceName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (voiceName != null) 'voiceName': voiceName!,
  };
}

/// Used by:
///
/// - firestore:v1 : Precondition
/// - firestore:v1beta1 : Precondition
class $Precondition {
  /// When set to `true`, the target document must exist.
  ///
  /// When set to `false`, the target document must not exist.
  core.bool? exists;

  /// When set, the target document must exist and have been last updated at
  /// that time.
  ///
  /// Timestamp must be microsecond aligned.
  core.String? updateTime;

  $Precondition({this.exists, this.updateTime});

  $Precondition.fromJson(core.Map json_)
    : this(
        exists: json_['exists'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exists != null) 'exists': exists!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PredefinedSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PredefinedSplit
class $PredefinedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The value of the key (either the label's value or value in the column)
  /// must be one of {`training`, `validation`, `test`}, and it defines to which
  /// set the given piece of data is assigned. If for a piece of data the key is
  /// not present or has an invalid value, that piece is ignored by the
  /// pipeline.
  ///
  /// Required.
  core.String? key;

  $PredefinedSplit({this.key});

  $PredefinedSplit.fromJson(core.Map json_)
    : this(key: json_['key'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PredictLongRunningRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PredictLongRunningRequest
class $PredictLongRunningRequest {
  /// The instances that are the input to the prediction call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  $PredictLongRunningRequest({this.instances, this.parameters});

  $PredictLongRunningRequest.fromJson(core.Map json_)
    : this(
        instances:
            json_.containsKey('instances')
                ? json_['instances'] as core.List
                : null,
        parameters: json_['parameters'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PredictRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PredictRequest
class $PredictRequest {
  /// The instances that are the input to the prediction call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  $PredictRequest({this.instances, this.parameters});

  $PredictRequest.fromJson(core.Map json_)
    : this(
        instances:
            json_.containsKey('instances')
                ? json_['instances'] as core.List
                : null,
        parameters: json_['parameters'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PredictResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PredictResponse
class $PredictResponse {
  /// ID of the Endpoint's DeployedModel that served this prediction.
  core.String? deployedModelId;

  /// Request-level metadata returned by the model.
  ///
  /// The metadata type will be dependent upon the model implementation.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? model;

  /// The display name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelDisplayName;

  /// The version ID of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// The predictions that are the output of the predictions call.
  ///
  /// The schema of any single prediction may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's prediction_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  $PredictResponse({
    this.deployedModelId,
    this.metadata,
    this.model,
    this.modelDisplayName,
    this.modelVersionId,
    this.predictions,
  });

  $PredictResponse.fromJson(core.Map json_)
    : this(
        deployedModelId: json_['deployedModelId'] as core.String?,
        metadata: json_['metadata'],
        model: json_['model'] as core.String?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
        modelVersionId: json_['modelVersionId'] as core.String?,
        predictions:
            json_.containsKey('predictions')
                ? json_['predictions'] as core.List
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (metadata != null) 'metadata': metadata!,
    if (model != null) 'model': model!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
    if (modelVersionId != null) 'modelVersionId': modelVersionId!,
    if (predictions != null) 'predictions': predictions!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2PredictResponsePredictionResult
/// - retail:v2alpha : GoogleCloudRetailV2alphaPredictResponsePredictionResult
/// - retail:v2beta : GoogleCloudRetailV2betaPredictResponsePredictionResult
class $PredictResponsePredictionResult {
  /// ID of the recommended product
  core.String? id;

  /// Additional product metadata / annotations.
  ///
  /// Possible values: * `product`: JSON representation of the product. Is set
  /// if `returnProduct` is set to true in `PredictRequest.params`. * `score`:
  /// Prediction score in double value. Is set if `returnScore` is set to true
  /// in `PredictRequest.params`.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  $PredictResponsePredictionResult({this.id, this.metadata});

  $PredictResponsePredictionResult.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PredictSchemata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PredictSchemata
class $PredictSchemata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single instance, which are used in PredictRequest.instances,
  /// ExplainRequest.instances and BatchPredictionJob.input_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? instanceSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// parameters of prediction and explanation via PredictRequest.parameters,
  /// ExplainRequest.parameters and BatchPredictionJob.model_parameters.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? parametersSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single prediction produced by this Model, which are returned via
  /// PredictResponse.predictions, ExplainResponse.explanations, and
  /// BatchPredictionJob.output_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? predictionSchemaUri;

  $PredictSchemata({
    this.instanceSchemaUri,
    this.parametersSchemaUri,
    this.predictionSchemaUri,
  });

  $PredictSchemata.fromJson(core.Map json_)
    : this(
        instanceSchemaUri: json_['instanceSchemaUri'] as core.String?,
        parametersSchemaUri: json_['parametersSchemaUri'] as core.String?,
        predictionSchemaUri: json_['predictionSchemaUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceSchemaUri != null) 'instanceSchemaUri': instanceSchemaUri!,
    if (parametersSchemaUri != null)
      'parametersSchemaUri': parametersSchemaUri!,
    if (predictionSchemaUri != null)
      'predictionSchemaUri': predictionSchemaUri!,
  };
}

/// Used by:
///
/// - compute:alpha : PreservedStatePreservedDisk
/// - compute:beta : PreservedStatePreservedDisk
/// - compute:v1 : PreservedStatePreservedDisk
class $PreservedStatePreservedDisk {
  /// These stateful disks will never be deleted during autohealing, update,
  /// instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole MIG
  /// is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
  ///
  /// If not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY" : Attaches this disk in read-only mode. Multiple VM
  /// instances can use a disk in READ_ONLY mode at a time.
  /// - "READ_WRITE" : *\[Default\]* Attaches this disk in READ_WRITE mode. Only
  /// one VM instance at a time can be attached to a disk in READ_WRITE mode.
  core.String? mode;

  /// The URL of the disk resource that is stateful and should be attached to
  /// the VM instance.
  core.String? source;

  $PreservedStatePreservedDisk({this.autoDelete, this.mode, this.source});

  $PreservedStatePreservedDisk.fromJson(core.Map json_)
    : this(
        autoDelete: json_['autoDelete'] as core.String?,
        mode: json_['mode'] as core.String?,
        source: json_['source'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoDelete != null) 'autoDelete': autoDelete!,
    if (mode != null) 'mode': mode!,
    if (source != null) 'source': source!,
  };
}

/// Used by:
///
/// - compute:alpha : PreservedStatePreservedNetworkIpIpAddress
/// - compute:beta : PreservedStatePreservedNetworkIpIpAddress
/// - compute:v1 : PreservedStatePreservedNetworkIpIpAddress
class $PreservedStatePreservedNetworkIpIpAddress {
  /// The URL of the reservation for this IP address.
  core.String? address;

  /// An IPv4 internal network address to assign to the instance for this
  /// network interface.
  core.String? literal;

  $PreservedStatePreservedNetworkIpIpAddress({this.address, this.literal});

  $PreservedStatePreservedNetworkIpIpAddress.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        literal: json_['literal'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (literal != null) 'literal': literal!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Presets
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Presets
class $Presets {
  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries.
  ///
  /// If your model does not precisely fit one of these types, it is okay to
  /// choose the closest type.
  /// Possible string values are:
  /// - "MODALITY_UNSPECIFIED" : Should not be set. Added as a recommended best
  /// practice for enums
  /// - "IMAGE" : IMAGE modality
  /// - "TEXT" : TEXT modality
  /// - "TABULAR" : TABULAR modality
  core.String? modality;

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples.
  ///
  /// If omitted, defaults to `PRECISE`.
  /// Possible string values are:
  /// - "PRECISE" : More precise neighbors as a trade-off against slower
  /// response.
  /// - "FAST" : Faster response as a trade-off against less precise neighbors.
  core.String? query;

  $Presets({this.modality, this.query});

  $Presets.fromJson(core.Map json_)
    : this(
        modality: json_['modality'] as core.String?,
        query: json_['query'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modality != null) 'modality': modality!,
    if (query != null) 'query': query!,
  };
}

/// Used by:
///
/// - compute:alpha : PreviewFeatureRolloutOperationRolloutInput
/// - compute:beta : PreviewFeatureRolloutOperationRolloutInput
class $PreviewFeatureRolloutOperationRolloutInput {
  /// The name of the rollout plan Ex.
  ///
  /// organizations//locations/global/rolloutPlans/ Ex.
  /// folders//locations/global/rolloutPlans/ Ex.
  /// projects//locations/global/rolloutPlans/.
  core.String? name;

  /// Predefined rollout plan.
  /// Possible string values are:
  /// - "ROLLOUT_PLAN_FAST_ROLLOUT"
  /// - "ROLLOUT_PLAN_TWO_DAY_ROLLOUT"
  /// - "ROLLOUT_PLAN_UNSPECIFIED"
  core.String? predefinedRolloutPlan;

  $PreviewFeatureRolloutOperationRolloutInput({
    this.name,
    this.predefinedRolloutPlan,
  });

  $PreviewFeatureRolloutOperationRolloutInput.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        predefinedRolloutPlan: json_['predefinedRolloutPlan'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (predefinedRolloutPlan != null)
      'predefinedRolloutPlan': predefinedRolloutPlan!,
  };
}

/// Used by:
///
/// - css:v1 : Price
/// - merchantapi:accounts_v1beta : Price
/// - merchantapi:inventories_v1beta : Price
/// - merchantapi:lfp_v1beta : Price
/// - merchantapi:ordertracking_v1beta : Price
/// - merchantapi:products_v1beta : Price
/// - merchantapi:promotions_v1beta : Price
/// - merchantapi:reports_v1beta : Price
class $Price {
  /// The price represented as a number in micros (1 million micros is an
  /// equivalent to one's currency standard unit, for example, 1 USD = 1000000
  /// micros).
  core.String? amountMicros;

  /// The currency of the price using three-letter acronyms according to
  /// [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217).
  core.String? currencyCode;

  $Price({this.amountMicros, this.currencyCode});

  $Price.fromJson(core.Map json_)
    : this(
        amountMicros: json_['amountMicros'] as core.String?,
        currencyCode: json_['currencyCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (amountMicros != null) 'amountMicros': amountMicros!,
    if (currencyCode != null) 'currencyCode': currencyCode!,
  };
}

/// Used by:
///
/// - alloydb:v1 : PrimaryConfig
/// - alloydb:v1alpha : PrimaryConfig
/// - alloydb:v1beta : PrimaryConfig
class $PrimaryConfig {
  /// Names of the clusters that are replicating from this cluster.
  ///
  /// Output only.
  core.List<core.String>? secondaryClusterNames;

  $PrimaryConfig({this.secondaryClusterNames});

  $PrimaryConfig.fromJson(core.Map json_)
    : this(
        secondaryClusterNames:
            (json_['secondaryClusterNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (secondaryClusterNames != null)
      'secondaryClusterNames': secondaryClusterNames!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Principal
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPrincipal
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPrincipal
class $Principal {
  /// For 3P application identities which are not present in the customer
  /// identity provider.
  core.String? externalEntityId;

  /// Group identifier.
  ///
  /// For Google Workspace user account, group_id should be the google workspace
  /// group email. For non-google identity provider user account, group_id is
  /// the mapped group identifier configured during the workforcepool config.
  core.String? groupId;

  /// User identifier.
  ///
  /// For Google Workspace user account, user_id should be the google workspace
  /// user email. For non-google identity provider user account, user_id is the
  /// mapped user identifier configured during the workforcepool config.
  core.String? userId;

  $Principal({this.externalEntityId, this.groupId, this.userId});

  $Principal.fromJson(core.Map json_)
    : this(
        externalEntityId: json_['externalEntityId'] as core.String?,
        groupId: json_['groupId'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalEntityId != null) 'externalEntityId': externalEntityId!,
    if (groupId != null) 'groupId': groupId!,
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PrismaCpeCode
/// - displayvideo:v3 : PrismaCpeCode
/// - displayvideo:v4 : PrismaCpeCode
class $PrismaCpeCode {
  /// The Prisma client code.
  core.String? prismaClientCode;

  /// The Prisma estimate code.
  core.String? prismaEstimateCode;

  /// The Prisma product code.
  core.String? prismaProductCode;

  $PrismaCpeCode({
    this.prismaClientCode,
    this.prismaEstimateCode,
    this.prismaProductCode,
  });

  $PrismaCpeCode.fromJson(core.Map json_)
    : this(
        prismaClientCode: json_['prismaClientCode'] as core.String?,
        prismaEstimateCode: json_['prismaEstimateCode'] as core.String?,
        prismaProductCode: json_['prismaProductCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (prismaClientCode != null) 'prismaClientCode': prismaClientCode!,
    if (prismaEstimateCode != null) 'prismaEstimateCode': prismaEstimateCode!,
    if (prismaProductCode != null) 'prismaProductCode': prismaProductCode!,
  };
}

/// Used by:
///
/// - workstations:v1 : PrivateClusterConfig
/// - workstations:v1beta : PrivateClusterConfig
class $PrivateClusterConfig {
  /// Additional projects that are allowed to attach to the workstation
  /// cluster's service attachment.
  ///
  /// By default, the workstation cluster's project and the VPC host project (if
  /// different) are allowed.
  ///
  /// Optional.
  core.List<core.String>? allowedProjects;

  /// Hostname for the workstation cluster.
  ///
  /// This field will be populated only when private endpoint is enabled. To
  /// access workstations in the workstation cluster, create a new DNS zone
  /// mapping this domain name to an internal IP address and a forwarding rule
  /// mapping that address to the service attachment.
  ///
  /// Output only.
  core.String? clusterHostname;

  /// Whether Workstations endpoint is private.
  ///
  /// Immutable.
  core.bool? enablePrivateEndpoint;

  /// Service attachment URI for the workstation cluster.
  ///
  /// The service attachment is created when private endpoint is enabled. To
  /// access workstations in the workstation cluster, configure access to the
  /// managed service using
  /// [Private Service Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
  ///
  /// Output only.
  core.String? serviceAttachmentUri;

  $PrivateClusterConfig({
    this.allowedProjects,
    this.clusterHostname,
    this.enablePrivateEndpoint,
    this.serviceAttachmentUri,
  });

  $PrivateClusterConfig.fromJson(core.Map json_)
    : this(
        allowedProjects:
            (json_['allowedProjects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        clusterHostname: json_['clusterHostname'] as core.String?,
        enablePrivateEndpoint: json_['enablePrivateEndpoint'] as core.bool?,
        serviceAttachmentUri: json_['serviceAttachmentUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedProjects != null) 'allowedProjects': allowedProjects!,
    if (clusterHostname != null) 'clusterHostname': clusterHostname!,
    if (enablePrivateEndpoint != null)
      'enablePrivateEndpoint': enablePrivateEndpoint!,
    if (serviceAttachmentUri != null)
      'serviceAttachmentUri': serviceAttachmentUri!,
  };
}

/// Used by:
///
/// - container:v1 : PrivateClusterMasterGlobalAccessConfig
/// - container:v1beta1 : PrivateClusterMasterGlobalAccessConfig
class $PrivateClusterMasterGlobalAccessConfig {
  /// Whenever master is accessible globally or not.
  core.bool? enabled;

  $PrivateClusterMasterGlobalAccessConfig({this.enabled});

  $PrivateClusterMasterGlobalAccessConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : PrivateData
/// - authorizedbuyersmarketplace:v1alpha : PrivateData
class $PrivateData {
  /// A buyer specified reference ID.
  ///
  /// This can be queried in the list operations (max-length: 1024 unicode code
  /// units).
  core.String? referenceId;

  $PrivateData({this.referenceId});

  $PrivateData.fromJson(core.Map json_)
    : this(referenceId: json_['referenceId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (referenceId != null) 'referenceId': referenceId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PrivateEndpoints
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PrivateEndpoints
class $PrivateEndpoints {
  /// Http(s) path to send explain requests.
  ///
  /// Output only.
  core.String? explainHttpUri;

  /// Http(s) path to send health check requests.
  ///
  /// Output only.
  core.String? healthHttpUri;

  /// Http(s) path to send prediction requests.
  ///
  /// Output only.
  core.String? predictHttpUri;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  $PrivateEndpoints({
    this.explainHttpUri,
    this.healthHttpUri,
    this.predictHttpUri,
    this.serviceAttachment,
  });

  $PrivateEndpoints.fromJson(core.Map json_)
    : this(
        explainHttpUri: json_['explainHttpUri'] as core.String?,
        healthHttpUri: json_['healthHttpUri'] as core.String?,
        predictHttpUri: json_['predictHttpUri'] as core.String?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explainHttpUri != null) 'explainHttpUri': explainHttpUri!,
    if (healthHttpUri != null) 'healthHttpUri': healthHttpUri!,
    if (predictHttpUri != null) 'predictHttpUri': predictHttpUri!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Used by:
///
/// - datafusion:v1 : PrivateServiceConnectConfig
/// - datafusion:v1beta1 : PrivateServiceConnectConfig
class $PrivateServiceConnectConfig {
  /// The CIDR block to which the CDF instance can't route traffic to in the
  /// consumer project VPC.
  ///
  /// The size of this block is /25. The format of this field is governed by RFC
  /// 4632. Example: 240.0.0.0/25
  ///
  /// Output only.
  core.String? effectiveUnreachableCidrBlock;

  /// The reference to the network attachment used to establish private
  /// connectivity.
  ///
  /// It will be of the form
  /// projects/{project-id}/regions/{region}/networkAttachments/{network-attachment-id}.
  ///
  /// Required.
  core.String? networkAttachment;

  /// Input only.
  ///
  /// The CIDR block to which the CDF instance can't route traffic to in the
  /// consumer project VPC. The size of this block should be at least /25. This
  /// range should not overlap with the primary address range of any subnetwork
  /// used by the network attachment. This range can be used for other purposes
  /// in the consumer VPC as long as there is no requirement for CDF to reach
  /// destinations using these addresses. If this value is not provided, the
  /// server chooses a non RFC 1918 address range. The format of this field is
  /// governed by RFC 4632. Example: 192.168.0.0/25
  ///
  /// Optional.
  core.String? unreachableCidrBlock;

  $PrivateServiceConnectConfig({
    this.effectiveUnreachableCidrBlock,
    this.networkAttachment,
    this.unreachableCidrBlock,
  });

  $PrivateServiceConnectConfig.fromJson(core.Map json_)
    : this(
        effectiveUnreachableCidrBlock:
            json_['effectiveUnreachableCidrBlock'] as core.String?,
        networkAttachment: json_['networkAttachment'] as core.String?,
        unreachableCidrBlock: json_['unreachableCidrBlock'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (effectiveUnreachableCidrBlock != null)
      'effectiveUnreachableCidrBlock': effectiveUnreachableCidrBlock!,
    if (networkAttachment != null) 'networkAttachment': networkAttachment!,
    if (unreachableCidrBlock != null)
      'unreachableCidrBlock': unreachableCidrBlock!,
  };
}

/// Used by:
///
/// - container:v1 : PrivilegedAdmissionConfig
/// - container:v1beta1 : PrivilegedAdmissionConfig
class $PrivilegedAdmissionConfig {
  /// The customer allowlist Cloud Storage paths for the cluster.
  ///
  /// These paths are used with the `--autopilot-privileged-admission` flag to
  /// authorize privileged workloads in Autopilot clusters. Paths can be
  /// GKE-owned, in the format `gke:////`, or customer-owned, in the format
  /// `gs:///`. Wildcards (`*`) are supported to authorize all allowlists under
  /// specific paths or directories. Example: `gs://my-bucket / * ` will
  /// authorize all allowlists under the `my-bucket` bucket.
  core.List<core.String>? allowlistPaths;

  $PrivilegedAdmissionConfig({this.allowlistPaths});

  $PrivilegedAdmissionConfig.fromJson(core.Map json_)
    : this(
        allowlistPaths:
            (json_['allowlistPaths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowlistPaths != null) 'allowlistPaths': allowlistPaths!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ProbeGrpcAction
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ProbeGrpcAction
class $ProbeGrpcAction {
  /// Port number of the gRPC service.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  /// Service is the name of the service to place in the gRPC
  /// HealthCheckRequest.
  ///
  /// See https://github.com/grpc/grpc/blob/master/doc/health-checking.md. If
  /// this is not specified, the default behavior is defined by gRPC.
  core.String? service;

  $ProbeGrpcAction({this.port, this.service});

  $ProbeGrpcAction.fromJson(core.Map json_)
    : this(
        port: json_['port'] as core.int?,
        service: json_['service'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (port != null) 'port': port!,
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ProbeHttpHeader
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ProbeHttpHeader
class $ProbeHttpHeader {
  /// The header field name.
  ///
  /// This will be canonicalized upon output, so case-variant names will be
  /// understood as the same header.
  core.String? name;

  /// The header field value
  core.String? value;

  $ProbeHttpHeader({this.name, this.value});

  $ProbeHttpHeader.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ProbeTcpSocketAction
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ProbeTcpSocketAction
class $ProbeTcpSocketAction {
  /// Optional: Host name to connect to, defaults to the model serving
  /// container's IP.
  core.String? host;

  /// Number of the port to access on the container.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  $ProbeTcpSocketAction({this.host, this.port});

  $ProbeTcpSocketAction.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessOptionsIndividualPageSelector
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessOptionsIndividualPageSelector
class $ProcessOptionsIndividualPageSelector {
  /// Indices of the pages (starting from 1).
  ///
  /// Optional.
  core.List<core.int>? pages;

  $ProcessOptionsIndividualPageSelector({this.pages});

  $ProcessOptionsIndividualPageSelector.fromJson(core.Map json_)
    : this(
        pages:
            (json_['pages'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pages != null) 'pages': pages!,
  };
}

/// Used by:
///
/// - jobs:v3 : ProcessingOptions
/// - jobs:v3p1beta1 : ProcessingOptions
class $ProcessingOptions {
  /// If set to `true`, the service does not attempt to resolve a more precise
  /// address for the job.
  ///
  /// Optional.
  core.bool? disableStreetAddressResolution;

  /// Option for job HTML content sanitization.
  ///
  /// Applied fields are: * description * applicationInfo.instruction *
  /// incentives * qualifications * responsibilities HTML tags in these fields
  /// may be stripped if sanitiazation is not disabled. Defaults to
  /// HtmlSanitization.SIMPLE_FORMATTING_ONLY.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HTML_SANITIZATION_UNSPECIFIED" : Default value.
  /// - "HTML_SANITIZATION_DISABLED" : Disables sanitization on HTML input.
  /// - "SIMPLE_FORMATTING_ONLY" : Sanitizes HTML input, only accepts bold,
  /// italic, ordered list, and unordered list markup tags.
  core.String? htmlSanitization;

  $ProcessingOptions({
    this.disableStreetAddressResolution,
    this.htmlSanitization,
  });

  $ProcessingOptions.fromJson(core.Map json_)
    : this(
        disableStreetAddressResolution:
            json_['disableStreetAddressResolution'] as core.bool?,
        htmlSanitization: json_['htmlSanitization'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableStreetAddressResolution != null)
      'disableStreetAddressResolution': disableStreetAddressResolution!,
    if (htmlSanitization != null) 'htmlSanitization': htmlSanitization!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessorTypeLocationInfo
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessorTypeLocationInfo
class $ProcessorTypeLocationInfo {
  /// The location ID.
  ///
  /// For supported locations, refer to \[regional and multi-regional
  /// support\](/document-ai/docs/regions).
  core.String? locationId;

  $ProcessorTypeLocationInfo({this.locationId});

  $ProcessorTypeLocationInfo.fromJson(core.Map json_)
    : this(locationId: json_['locationId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (locationId != null) 'locationId': locationId!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessorVersionAlias
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessorVersionAlias
class $ProcessorVersionAlias {
  /// The alias in the form of `processor_version` resource name.
  core.String? alias;

  /// The resource name of aliased processor version.
  core.String? processorVersion;

  $ProcessorVersionAlias({this.alias, this.processorVersion});

  $ProcessorVersionAlias.fromJson(core.Map json_)
    : this(
        alias: json_['alias'] as core.String?,
        processorVersion: json_['processorVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alias != null) 'alias': alias!,
    if (processorVersion != null) 'processorVersion': processorVersion!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessorVersionDeprecationInfo
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessorVersionDeprecationInfo
class $ProcessorVersionDeprecationInfo {
  /// The time at which this processor version will be deprecated.
  core.String? deprecationTime;

  /// If set, the processor version that will be used as a replacement.
  core.String? replacementProcessorVersion;

  $ProcessorVersionDeprecationInfo({
    this.deprecationTime,
    this.replacementProcessorVersion,
  });

  $ProcessorVersionDeprecationInfo.fromJson(core.Map json_)
    : this(
        deprecationTime: json_['deprecationTime'] as core.String?,
        replacementProcessorVersion:
            json_['replacementProcessorVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deprecationTime != null) 'deprecationTime': deprecationTime!,
    if (replacementProcessorVersion != null)
      'replacementProcessorVersion': replacementProcessorVersion!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessorVersionGenAiModelInfoCustomGenAiModelInfo
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessorVersionGenAiModelInfoCustomGenAiModelInfo
class $ProcessorVersionGenAiModelInfoCustomGenAiModelInfo {
  /// The base processor version ID for the custom model.
  core.String? baseProcessorVersionId;

  /// The type of custom model created by the user.
  /// Possible string values are:
  /// - "CUSTOM_MODEL_TYPE_UNSPECIFIED" : The model type is unspecified.
  /// - "VERSIONED_FOUNDATION" : The model is a versioned foundation model.
  /// - "FINE_TUNED" : The model is a finetuned foundation model.
  core.String? customModelType;

  $ProcessorVersionGenAiModelInfoCustomGenAiModelInfo({
    this.baseProcessorVersionId,
    this.customModelType,
  });

  $ProcessorVersionGenAiModelInfoCustomGenAiModelInfo.fromJson(core.Map json_)
    : this(
        baseProcessorVersionId: json_['baseProcessorVersionId'] as core.String?,
        customModelType: json_['customModelType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseProcessorVersionId != null)
      'baseProcessorVersionId': baseProcessorVersionId!,
    if (customModelType != null) 'customModelType': customModelType!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1ProcessorVersionGenAiModelInfoFoundationGenAiModelInfo
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3ProcessorVersionGenAiModelInfoFoundationGenAiModelInfo
class $ProcessorVersionGenAiModelInfoFoundationGenAiModelInfo {
  /// Whether finetuning is allowed for this base processor version.
  core.bool? finetuningAllowed;

  /// The minimum number of labeled documents in the training dataset required
  /// for finetuning.
  core.int? minTrainLabeledDocuments;

  $ProcessorVersionGenAiModelInfoFoundationGenAiModelInfo({
    this.finetuningAllowed,
    this.minTrainLabeledDocuments,
  });

  $ProcessorVersionGenAiModelInfoFoundationGenAiModelInfo.fromJson(
    core.Map json_,
  ) : this(
        finetuningAllowed: json_['finetuningAllowed'] as core.bool?,
        minTrainLabeledDocuments:
            json_['minTrainLabeledDocuments'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (finetuningAllowed != null) 'finetuningAllowed': finetuningAllowed!,
    if (minTrainLabeledDocuments != null)
      'minTrainLabeledDocuments': minTrainLabeledDocuments!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Product
/// - containeranalysis:v1beta1 : Product
class $Product {
  /// Contains a URI which is vendor-specific.
  ///
  /// Example: The artifact repository URL of an image.
  core.String? genericUri;

  /// Token that identifies a product so that it can be referred to from other
  /// parts in the document.
  ///
  /// There is no predefined format as long as it uniquely identifies a group in
  /// the context of the current document.
  core.String? id;

  /// Name of the product.
  core.String? name;

  $Product({this.genericUri, this.id, this.name});

  $Product.fromJson(core.Map json_)
    : this(
        genericUri: json_['genericUri'] as core.String?,
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (genericUri != null) 'genericUri': genericUri!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ProductAttributeValue
/// - retail:v2alpha : GoogleCloudRetailV2alphaProductAttributeValue
/// - retail:v2beta : GoogleCloudRetailV2betaProductAttributeValue
class $ProductAttributeValue {
  /// The attribute name.
  core.String? name;

  /// The attribute value.
  core.String? value;

  $ProductAttributeValue({this.name, this.value});

  $ProductAttributeValue.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - content:v2.1 : ProductProductDetail
/// - css:v1 : ProductDetail
/// - merchantapi:products_v1beta : ProductDetail
class $ProductDetail {
  /// The name of the product detail.
  core.String? attributeName;

  /// The value of the product detail.
  core.String? attributeValue;

  /// The section header used to group a set of product details.
  core.String? sectionName;

  $ProductDetail({this.attributeName, this.attributeValue, this.sectionName});

  $ProductDetail.fromJson(core.Map json_)
    : this(
        attributeName: json_['attributeName'] as core.String?,
        attributeValue: json_['attributeValue'] as core.String?,
        sectionName: json_['sectionName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeName != null) 'attributeName': attributeName!,
    if (attributeValue != null) 'attributeValue': attributeValue!,
    if (sectionName != null) 'sectionName': sectionName!,
  };
}

/// Used by:
///
/// - css:v1 : ProductDimension
/// - merchantapi:products_v1beta : ProductDimension
class $ProductDimension {
  /// The dimension units.
  ///
  /// Acceptable values are: * "`in`" * "`cm`"
  ///
  /// Required.
  core.String? unit;

  /// The dimension value represented as a number.
  ///
  /// The value can have a maximum precision of four decimal places.
  ///
  /// Required.
  core.double? value;

  $ProductDimension({this.unit, this.value});

  $ProductDimension.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2ProductLevelConfig
/// - retail:v2alpha : GoogleCloudRetailV2alphaProductLevelConfig
/// - retail:v2beta : GoogleCloudRetailV2betaProductLevelConfig
class $ProductLevelConfig {
  /// The type of Products allowed to be ingested into the catalog.
  ///
  /// Acceptable values are: * `primary` (default): You can ingest Products of
  /// all types. When ingesting a Product, its type will default to
  /// Product.Type.PRIMARY if unset. * `variant` (incompatible with Retail
  /// Search): You can only ingest Product.Type.VARIANT Products. This means
  /// Product.primary_product_id cannot be empty. If this field is set to an
  /// invalid value other than these, an INVALID_ARGUMENT error is returned. If
  /// this field is `variant` and merchant_center_product_id_field is
  /// `itemGroupId`, an INVALID_ARGUMENT error is returned. See
  /// [Product levels](https://cloud.google.com/retail/docs/catalog#product-levels)
  /// for more details.
  core.String? ingestionProductType;

  /// Which field of \[Merchant Center
  /// Product\](/bigquery-transfer/docs/merchant-center-products-schema) should
  /// be imported as Product.id.
  ///
  /// Acceptable values are: * `offerId` (default): Import `offerId` as the
  /// product ID. * `itemGroupId`: Import `itemGroupId` as the product ID.
  /// Notice that Retail API will choose one item from the ones with the same
  /// `itemGroupId`, and use it to represent the item group. If this field is
  /// set to an invalid value other than these, an INVALID_ARGUMENT error is
  /// returned. If this field is `itemGroupId` and ingestion_product_type is
  /// `variant`, an INVALID_ARGUMENT error is returned. See
  /// [Product levels](https://cloud.google.com/retail/docs/catalog#product-levels)
  /// for more details.
  core.String? merchantCenterProductIdField;

  $ProductLevelConfig({
    this.ingestionProductType,
    this.merchantCenterProductIdField,
  });

  $ProductLevelConfig.fromJson(core.Map json_)
    : this(
        ingestionProductType: json_['ingestionProductType'] as core.String?,
        merchantCenterProductIdField:
            json_['merchantCenterProductIdField'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ingestionProductType != null)
      'ingestionProductType': ingestionProductType!,
    if (merchantCenterProductIdField != null)
      'merchantCenterProductIdField': merchantCenterProductIdField!,
  };
}

/// Used by:
///
/// - css:v1 : ProductWeight
/// - merchantapi:products_v1beta : ProductWeight
class $ProductWeight {
  /// The weight unit.
  ///
  /// Acceptable values are: * "`g`" * "`kg`" * "`oz`" * "`lb`"
  ///
  /// Required.
  core.String? unit;

  /// The weight represented as a number.
  ///
  /// The weight can have a maximum precision of four decimal places.
  ///
  /// Required.
  core.double? value;

  $ProductWeight({this.unit, this.value});

  $ProductWeight.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - content:v2.1 : FreeListingsProgramStatusReviewIneligibilityReasonDetails
/// - content:v2.1 : ShoppingAdsProgramStatusReviewIneligibilityReasonDetails
class $ProgramStatusReviewIneligibilityReasonDetails {
  /// This timestamp represents end of cooldown period for review ineligbility
  /// reason `IN_COOLDOWN_PERIOD`.
  core.String? cooldownTime;

  $ProgramStatusReviewIneligibilityReasonDetails({this.cooldownTime});

  $ProgramStatusReviewIneligibilityReasonDetails.fromJson(core.Map json_)
    : this(cooldownTime: json_['cooldownTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cooldownTime != null) 'cooldownTime': cooldownTime!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : ProjectRepoId
/// - containeranalysis:v1alpha1 : GoogleDevtoolsContaineranalysisV1alpha1ProjectRepoId
/// - containeranalysis:v1beta1 : ProjectRepoId
/// - ondemandscanning:v1 : ProjectRepoId
/// - ondemandscanning:v1beta1 : ProjectRepoId
class $ProjectRepoId {
  /// The ID of the project.
  core.String? projectId;

  /// The name of the repo.
  ///
  /// Leave empty for the default repo.
  core.String? repoName;

  $ProjectRepoId({this.projectId, this.repoName});

  $ProjectRepoId.fromJson(core.Map json_)
    : this(
        projectId: json_['projectId'] as core.String?,
        repoName: json_['repoName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (projectId != null) 'projectId': projectId!,
    if (repoName != null) 'repoName': repoName!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : ProjectSettings
/// - artifactregistry:v1beta2 : ProjectSettings
class $ProjectSettings {
  /// The redirection state of the legacy repositories in this project.
  /// Possible string values are:
  /// - "REDIRECTION_STATE_UNSPECIFIED" : No redirection status has been set.
  /// - "REDIRECTION_FROM_GCR_IO_DISABLED" : Redirection is disabled.
  /// - "REDIRECTION_FROM_GCR_IO_ENABLED" : Redirection is enabled.
  /// - "REDIRECTION_FROM_GCR_IO_FINALIZED" : Redirection is enabled, and has
  /// been finalized so cannot be reverted.
  /// - "REDIRECTION_FROM_GCR_IO_ENABLED_AND_COPYING" : Redirection is enabled
  /// and missing images are copied from GCR
  /// - "REDIRECTION_FROM_GCR_IO_PARTIAL_AND_COPYING" : Redirection is partially
  /// enabled and missing images are copied from GCR
  core.String? legacyRedirectionState;

  /// The name of the project's settings.
  ///
  /// Always of the form: projects/{project-id}/projectSettings In update
  /// request: never set In response: always set
  core.String? name;

  /// The percentage of pull traffic to redirect from GCR to AR when using
  /// partial redirection.
  core.int? pullPercent;

  $ProjectSettings({this.legacyRedirectionState, this.name, this.pullPercent});

  $ProjectSettings.fromJson(core.Map json_)
    : this(
        legacyRedirectionState: json_['legacyRedirectionState'] as core.String?,
        name: json_['name'] as core.String?,
        pullPercent: json_['pullPercent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (legacyRedirectionState != null)
      'legacyRedirectionState': legacyRedirectionState!,
    if (name != null) 'name': name!,
    if (pullPercent != null) 'pullPercent': pullPercent!,
  };
}

/// Used by:
///
/// - compute:beta : ProjectsListXpnHostsRequest
/// - compute:v1 : ProjectsListXpnHostsRequest
class $ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects.
  ///
  /// If not specified, the organization will be inferred from the project.
  core.String? organization;

  $ProjectsListXpnHostsRequest({this.organization});

  $ProjectsListXpnHostsRequest.fromJson(core.Map json_)
    : this(organization: json_['organization'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (organization != null) 'organization': organization!,
  };
}

/// Used by:
///
/// - compute:alpha : ProjectsSetCloudArmorTierRequest
/// - compute:beta : ProjectsSetCloudArmorTierRequest
/// - compute:v1 : ProjectsSetCloudArmorTierRequest
class $ProjectsSetCloudArmorTierRequest {
  /// Managed protection tier to be set.
  /// Possible string values are:
  /// - "CA_ENTERPRISE_ANNUAL" : Enterprise tier protection billed annually.
  /// - "CA_ENTERPRISE_PAYGO" : Enterprise tier protection billed monthly.
  /// - "CA_STANDARD" : Standard protection.
  core.String? cloudArmorTier;

  $ProjectsSetCloudArmorTierRequest({this.cloudArmorTier});

  $ProjectsSetCloudArmorTierRequest.fromJson(core.Map json_)
    : this(cloudArmorTier: json_['cloudArmorTier'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cloudArmorTier != null) 'cloudArmorTier': cloudArmorTier!,
  };
}

/// Used by:
///
/// - compute:beta : ProjectsSetDefaultNetworkTierRequest
/// - compute:v1 : ProjectsSetDefaultNetworkTierRequest
class $ProjectsSetDefaultNetworkTierRequest {
  /// Default network tier to be set.
  /// Possible string values are:
  /// - "FIXED_STANDARD" : Public internet quality with fixed bandwidth.
  /// - "PREMIUM" : High quality, Google-grade network tier, support for all
  /// networking products.
  /// - "STANDARD" : Public internet quality, only limited support for other
  /// networking products.
  /// - "STANDARD_OVERRIDES_FIXED_STANDARD" : (Output only) Temporary tier for
  /// FIXED_STANDARD when fixed standard tier is expired or not configured.
  core.String? networkTier;

  $ProjectsSetDefaultNetworkTierRequest({this.networkTier});

  $ProjectsSetDefaultNetworkTierRequest.fromJson(core.Map json_)
    : this(networkTier: json_['networkTier'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (networkTier != null) 'networkTier': networkTier!,
  };
}

/// Used by:
///
/// - compute:alpha : ProjectsSetManagedProtectionTierRequest
/// - compute:beta : ProjectsSetManagedProtectionTierRequest
class $ProjectsSetManagedProtectionTierRequest {
  /// Managed protection tier to be set.
  /// Possible string values are:
  /// - "CAMP_PLUS_ANNUAL" : Plus tier protection annual.
  /// - "CAMP_PLUS_PAYGO" : Plus tier protection monthly.
  /// - "CA_STANDARD" : Standard protection.
  core.String? managedProtectionTier;

  $ProjectsSetManagedProtectionTierRequest({this.managedProtectionTier});

  $ProjectsSetManagedProtectionTierRequest.fromJson(core.Map json_)
    : this(
        managedProtectionTier: json_['managedProtectionTier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (managedProtectionTier != null)
      'managedProtectionTier': managedProtectionTier!,
  };
}

/// Used by:
///
/// - alloydb:v1 : PromoteClusterRequest
/// - alloydb:v1alpha : PromoteClusterRequest
/// - alloydb:v1beta : PromoteClusterRequest
class $PromoteClusterRequest {
  /// The current etag of the Cluster.
  ///
  /// If an etag is provided and does not match the current etag of the Cluster,
  /// deletion will be blocked and an ABORTED error will be returned.
  ///
  /// Optional.
  core.String? etag;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server ignores the request if it has already been completed. The server
  /// guarantees that for at least 60 minutes since the first request. For
  /// example, consider a situation where you make an initial request and the
  /// request times out. If you make the request again with the same request ID,
  /// the server can check if original operation with the same request ID was
  /// received, and if so, will ignore the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported
  /// (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// If set, performs request validation, for example, permission checks and
  /// any other type of validation, but does not actually execute the create
  /// request.
  ///
  /// Optional.
  core.bool? validateOnly;

  $PromoteClusterRequest({this.etag, this.requestId, this.validateOnly});

  $PromoteClusterRequest.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        requestId: json_['requestId'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (requestId != null) 'requestId': requestId!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - file:v1 : PromoteReplicaRequest
/// - file:v1beta1 : PromoteReplicaRequest
class $PromoteReplicaRequest {
  /// The resource name of the peer instance to promote, in the format
  /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
  ///
  /// The peer instance is required if the operation is called on an active
  /// instance.
  ///
  /// Optional.
  core.String? peerInstance;

  $PromoteReplicaRequest({this.peerInstance});

  $PromoteReplicaRequest.fromJson(core.Map json_)
    : this(peerInstance: json_['peerInstance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (peerInstance != null) 'peerInstance': peerInstance!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2Promotion
/// - retail:v2alpha : GoogleCloudRetailV2alphaPromotion
/// - retail:v2beta : GoogleCloudRetailV2betaPromotion
class $Promotion {
  /// Promotion identifier, which is the final component of name.
  ///
  /// For example, this field is "free_gift", if name is `projects / *
  /// /locations/global/catalogs/default_catalog/promotions/free_gift`. The
  /// value must be a UTF-8 encoded string with a length limit of 128
  /// characters, and match the pattern: `a-zA-Z*`. For example, id0LikeThis or
  /// ID_1_LIKE_THIS. Otherwise, an INVALID_ARGUMENT error is returned.
  /// Corresponds to Google Merchant Center property
  /// [promotion_id](https://support.google.com/merchants/answer/7050148).
  core.String? promotionId;

  $Promotion({this.promotionId});

  $Promotion.fromJson(core.Map json_)
    : this(promotionId: json_['promotionId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (promotionId != null) 'promotionId': promotionId!,
  };
}

/// Used by:
///
/// - backupdr:v1 : CloudSqlInstanceDataSourceProperties
/// - backupdr:v1 : CloudSqlInstanceDataSourceReferenceProperties
class $Properties {
  /// The installed database version of the Cloud SQL instance.
  ///
  /// Output only.
  core.String? databaseInstalledVersion;

  /// The instance creation timestamp.
  ///
  /// Output only.
  core.String? instanceCreateTime;

  /// The tier (or machine type) for this instance.
  ///
  /// Example: `db-custom-1-3840`
  ///
  /// Output only.
  core.String? instanceTier;

  /// Name of the Cloud SQL instance backed up by the datasource.
  ///
  /// Format: projects/{project}/instances/{instance}
  ///
  /// Output only.
  core.String? name;

  $Properties({
    this.databaseInstalledVersion,
    this.instanceCreateTime,
    this.instanceTier,
    this.name,
  });

  $Properties.fromJson(core.Map json_)
    : this(
        databaseInstalledVersion:
            json_['databaseInstalledVersion'] as core.String?,
        instanceCreateTime: json_['instanceCreateTime'] as core.String?,
        instanceTier: json_['instanceTier'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseInstalledVersion != null)
      'databaseInstalledVersion': databaseInstalledVersion!,
    if (instanceCreateTime != null) 'instanceCreateTime': instanceCreateTime!,
    if (instanceTier != null) 'instanceTier': instanceTier!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - vision:v1 : Property
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1Property
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1Property
class $Property00 {
  /// Name of the property.
  core.String? name;

  /// Value of numeric properties.
  core.String? uint64Value;

  /// Value of the property.
  core.String? value;

  $Property00({this.name, this.uint64Value, this.value});

  $Property00.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        uint64Value: json_['uint64Value'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (uint64Value != null) 'uint64Value': uint64Value!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaProperty
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaProperty
class $Property01 {
  /// The resource name of the parent account Format: accounts/{account_id}
  /// Example: "accounts/123"
  ///
  /// Immutable.
  core.String? account;

  /// Time when the entity was originally created.
  ///
  /// Output only.
  core.String? createTime;

  /// The currency type used in reports involving monetary values.
  ///
  /// Format: https://en.wikipedia.org/wiki/ISO_4217 Examples: "USD", "EUR",
  /// "JPY"
  core.String? currencyCode;

  /// If set, the time at which this property was trashed.
  ///
  /// If not set, then this property is not currently in the trash can.
  ///
  /// Output only.
  core.String? deleteTime;

  /// Human-readable display name for this property.
  ///
  /// The max allowed display name length is 100 UTF-16 code units.
  ///
  /// Required.
  core.String? displayName;

  /// If set, the time at which this trashed property will be permanently
  /// deleted.
  ///
  /// If not set, then this property is not currently in the trash can and is
  /// not slated to be deleted.
  ///
  /// Output only.
  core.String? expireTime;

  /// Industry associated with this property Example: AUTOMOTIVE, FOOD_AND_DRINK
  /// Possible string values are:
  /// - "INDUSTRY_CATEGORY_UNSPECIFIED" : Industry category unspecified
  /// - "AUTOMOTIVE" : Automotive
  /// - "BUSINESS_AND_INDUSTRIAL_MARKETS" : Business and industrial markets
  /// - "FINANCE" : Finance
  /// - "HEALTHCARE" : Healthcare
  /// - "TECHNOLOGY" : Technology
  /// - "TRAVEL" : Travel
  /// - "OTHER" : Other
  /// - "ARTS_AND_ENTERTAINMENT" : Arts and entertainment
  /// - "BEAUTY_AND_FITNESS" : Beauty and fitness
  /// - "BOOKS_AND_LITERATURE" : Books and literature
  /// - "FOOD_AND_DRINK" : Food and drink
  /// - "GAMES" : Games
  /// - "HOBBIES_AND_LEISURE" : Hobbies and leisure
  /// - "HOME_AND_GARDEN" : Home and garden
  /// - "INTERNET_AND_TELECOM" : Internet and telecom
  /// - "LAW_AND_GOVERNMENT" : Law and government
  /// - "NEWS" : News
  /// - "ONLINE_COMMUNITIES" : Online communities
  /// - "PEOPLE_AND_SOCIETY" : People and society
  /// - "PETS_AND_ANIMALS" : Pets and animals
  /// - "REAL_ESTATE" : Real estate
  /// - "REFERENCE" : Reference
  /// - "SCIENCE" : Science
  /// - "SPORTS" : Sports
  /// - "JOBS_AND_EDUCATION" : Jobs and education
  /// - "SHOPPING" : Shopping
  core.String? industryCategory;

  /// Resource name of this property.
  ///
  /// Format: properties/{property_id} Example: "properties/1000"
  ///
  /// Output only.
  core.String? name;

  /// Resource name of this property's logical parent.
  ///
  /// Note: The Property-Moving UI can be used to change the parent. Format:
  /// accounts/{account}, properties/{property} Example: "accounts/100",
  /// "properties/101"
  ///
  /// Immutable.
  core.String? parent;

  /// The property type for this Property resource.
  ///
  /// When creating a property, if the type is "PROPERTY_TYPE_UNSPECIFIED", then
  /// "ORDINARY_PROPERTY" will be implied.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "PROPERTY_TYPE_UNSPECIFIED" : Unknown or unspecified property type
  /// - "PROPERTY_TYPE_ORDINARY" : Ordinary Google Analytics property
  /// - "PROPERTY_TYPE_SUBPROPERTY" : Google Analytics subproperty
  /// - "PROPERTY_TYPE_ROLLUP" : Google Analytics rollup property
  core.String? propertyType;

  /// The Google Analytics service level that applies to this property.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SERVICE_LEVEL_UNSPECIFIED" : Service level not specified or invalid.
  /// - "GOOGLE_ANALYTICS_STANDARD" : The standard version of Google Analytics.
  /// - "GOOGLE_ANALYTICS_360" : The paid, premium version of Google Analytics.
  core.String? serviceLevel;

  /// Reporting Time Zone, used as the day boundary for reports, regardless of
  /// where the data originates.
  ///
  /// If the time zone honors DST, Analytics will automatically adjust for the
  /// changes. NOTE: Changing the time zone only affects data going forward, and
  /// is not applied retroactively. Format: https://www.iana.org/time-zones
  /// Example: "America/Los_Angeles"
  ///
  /// Required.
  core.String? timeZone;

  /// Time when entity payload fields were last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $Property01({
    this.account,
    this.createTime,
    this.currencyCode,
    this.deleteTime,
    this.displayName,
    this.expireTime,
    this.industryCategory,
    this.name,
    this.parent,
    this.propertyType,
    this.serviceLevel,
    this.timeZone,
    this.updateTime,
  });

  $Property01.fromJson(core.Map json_)
    : this(
        account: json_['account'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        currencyCode: json_['currencyCode'] as core.String?,
        deleteTime: json_['deleteTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        expireTime: json_['expireTime'] as core.String?,
        industryCategory: json_['industryCategory'] as core.String?,
        name: json_['name'] as core.String?,
        parent: json_['parent'] as core.String?,
        propertyType: json_['propertyType'] as core.String?,
        serviceLevel: json_['serviceLevel'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (account != null) 'account': account!,
    if (createTime != null) 'createTime': createTime!,
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (deleteTime != null) 'deleteTime': deleteTime!,
    if (displayName != null) 'displayName': displayName!,
    if (expireTime != null) 'expireTime': expireTime!,
    if (industryCategory != null) 'industryCategory': industryCategory!,
    if (name != null) 'name': name!,
    if (parent != null) 'parent': parent!,
    if (propertyType != null) 'propertyType': propertyType!,
    if (serviceLevel != null) 'serviceLevel': serviceLevel!,
    if (timeZone != null) 'timeZone': timeZone!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - datastore:v1 : PropertyMask
/// - datastore:v1beta3 : PropertyMask
class $PropertyMask {
  /// The paths to the properties covered by this mask.
  ///
  /// A path is a list of property names separated by dots (`.`), for example
  /// `foo.bar` means the property `bar` inside the entity property `foo` inside
  /// the entity associated with this path. If a property name contains a dot
  /// `.` or a backslash `\`, then that name must be escaped. A path must not be
  /// empty, and may not reference a value inside an array value.
  core.List<core.String>? paths;

  $PropertyMask({this.paths});

  $PropertyMask.fromJson(core.Map json_)
    : this(
        paths:
            (json_['paths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (paths != null) 'paths': paths!,
  };
}

/// Used by:
///
/// - datastore:v1 : PropertyReference
/// - datastore:v1beta3 : PropertyReference
class $PropertyReference {
  /// A reference to a property.
  ///
  /// Requires: * MUST be a dot-delimited (`.`) string of segments, where each
  /// segment conforms to entity property name limitations.
  core.String? name;

  $PropertyReference({this.name});

  $PropertyReference.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaPropertySummary
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaPropertySummary
class $PropertySummary {
  /// Display name for the property referred to in this property summary.
  core.String? displayName;

  /// Resource name of this property's logical parent.
  ///
  /// Note: The Property-Moving UI can be used to change the parent. Format:
  /// accounts/{account}, properties/{property} Example: "accounts/100",
  /// "properties/200"
  core.String? parent;

  /// Resource name of property referred to by this property summary Format:
  /// properties/{property_id} Example: "properties/1000"
  core.String? property;

  /// The property's property type.
  /// Possible string values are:
  /// - "PROPERTY_TYPE_UNSPECIFIED" : Unknown or unspecified property type
  /// - "PROPERTY_TYPE_ORDINARY" : Ordinary Google Analytics property
  /// - "PROPERTY_TYPE_SUBPROPERTY" : Google Analytics subproperty
  /// - "PROPERTY_TYPE_ROLLUP" : Google Analytics rollup property
  core.String? propertyType;

  $PropertySummary({
    this.displayName,
    this.parent,
    this.property,
    this.propertyType,
  });

  $PropertySummary.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        parent: json_['parent'] as core.String?,
        property: json_['property'] as core.String?,
        propertyType: json_['propertyType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (parent != null) 'parent': parent!,
    if (property != null) 'property': property!,
    if (propertyType != null) 'propertyType': propertyType!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaProvisionAccountTicketResponse
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaProvisionAccountTicketResponse
class $ProvisionAccountTicketResponse {
  /// The param to be passed in the ToS link.
  core.String? accountTicketId;

  $ProvisionAccountTicketResponse({this.accountTicketId});

  $ProvisionAccountTicketResponse.fromJson(core.Map json_)
    : this(accountTicketId: json_['accountTicketId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (accountTicketId != null) 'accountTicketId': accountTicketId!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : ProvisionPosixAccountRequest
/// - oslogin:v1beta : ProvisionPosixAccountRequest
class $ProvisionPosixAccountRequest {
  /// The regions to wait for a POSIX account to be written to before returning
  /// a response.
  ///
  /// If unspecified, defaults to all regions. Regions are listed at
  /// https://cloud.google.com/about/locations#region.
  ///
  /// Optional.
  core.List<core.String>? regions;

  $ProvisionPosixAccountRequest({this.regions});

  $ProvisionPosixAccountRequest.fromJson(core.Map json_)
    : this(
        regions:
            (json_['regions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (regions != null) 'regions': regions!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ProvisionProjectRequestSaasParams
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaProvisionProjectRequestSaasParams
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaProvisionProjectRequestSaasParams
class $ProvisionProjectRequestSaasParams {
  /// Set to `true` to specify that caller has read and would like to give
  /// consent to the \[Terms for Agent Space quality of service\].
  ///
  /// Optional.
  core.bool? acceptBizQos;

  $ProvisionProjectRequestSaasParams({this.acceptBizQos});

  $ProvisionProjectRequestSaasParams.fromJson(core.Map json_)
    : this(acceptBizQos: json_['acceptBizQos'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptBizQos != null) 'acceptBizQos': acceptBizQos!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetSslProxiesSetProxyHeaderRequest
/// - compute:alpha : TargetTcpProxiesSetProxyHeaderRequest
/// - compute:beta : TargetSslProxiesSetProxyHeaderRequest
/// - compute:beta : TargetTcpProxiesSetProxyHeaderRequest
/// - compute:v1 : TargetSslProxiesSetProxyHeaderRequest
/// - compute:v1 : TargetTcpProxiesSetProxyHeaderRequest
class $ProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  ///
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  $ProxiesSetProxyHeaderRequest({this.proxyHeader});

  $ProxiesSetProxyHeaderRequest.fromJson(core.Map json_)
    : this(proxyHeader: json_['proxyHeader'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ProximityLocationListAssignedTargetingOptionDetails
/// - displayvideo:v3 : ProximityLocationListAssignedTargetingOptionDetails
/// - displayvideo:v4 : ProximityLocationListAssignedTargetingOptionDetails
class $ProximityLocationListAssignedTargetingOptionDetails {
  /// ID of the proximity location list.
  ///
  /// Should refer to the location_list_id field of a LocationList resource
  /// whose type is `TARGETING_LOCATION_TYPE_PROXIMITY`.
  ///
  /// Required.
  core.String? proximityLocationListId;

  /// Radius expressed in the distance units set in proximity_radius_unit.
  ///
  /// This represents the size of the area around a chosen location that will be
  /// targeted. Radius should be between 1 and 500 miles or 800 kilometers.
  ///
  /// Required.
  core.double? proximityRadius;

  /// Radius distance units.
  ///
  /// Required.
  /// Possible string values are:
  /// - "PROXIMITY_RADIUS_UNIT_UNSPECIFIED" : Default value when distance units
  /// is not specified in this version. This enum is a place holder for default
  /// value and does not represent a real distance unit.
  /// - "PROXIMITY_RADIUS_UNIT_MILES" : Radius distance unit in miles.
  /// - "PROXIMITY_RADIUS_UNIT_KILOMETERS" : Radius distance unit in kilometeres
  core.String? proximityRadiusUnit;

  $ProximityLocationListAssignedTargetingOptionDetails({
    this.proximityLocationListId,
    this.proximityRadius,
    this.proximityRadiusUnit,
  });

  $ProximityLocationListAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        proximityLocationListId:
            json_['proximityLocationListId'] as core.String?,
        proximityRadius: (json_['proximityRadius'] as core.num?)?.toDouble(),
        proximityRadiusUnit: json_['proximityRadiusUnit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (proximityLocationListId != null)
      'proximityLocationListId': proximityLocationListId!,
    if (proximityRadius != null) 'proximityRadius': proximityRadius!,
    if (proximityRadiusUnit != null)
      'proximityRadiusUnit': proximityRadiusUnit!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : ProxyConnectionInfo
/// - networkmanagement:v1beta1 : ProxyConnectionInfo
class $ProxyConnectionInfo {
  /// URI of the network where connection is proxied.
  core.String? networkUri;

  /// Destination IP address of a new connection.
  core.String? newDestinationIp;

  /// Destination port of a new connection.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? newDestinationPort;

  /// Source IP address of a new connection.
  core.String? newSourceIp;

  /// Source port of a new connection.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? newSourcePort;

  /// Destination IP address of an original connection
  core.String? oldDestinationIp;

  /// Destination port of an original connection.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? oldDestinationPort;

  /// Source IP address of an original connection.
  core.String? oldSourceIp;

  /// Source port of an original connection.
  ///
  /// Only valid when protocol is TCP or UDP.
  core.int? oldSourcePort;

  /// IP protocol in string format, for example: "TCP", "UDP", "ICMP".
  core.String? protocol;

  /// Uri of proxy subnet.
  core.String? subnetUri;

  $ProxyConnectionInfo({
    this.networkUri,
    this.newDestinationIp,
    this.newDestinationPort,
    this.newSourceIp,
    this.newSourcePort,
    this.oldDestinationIp,
    this.oldDestinationPort,
    this.oldSourceIp,
    this.oldSourcePort,
    this.protocol,
    this.subnetUri,
  });

  $ProxyConnectionInfo.fromJson(core.Map json_)
    : this(
        networkUri: json_['networkUri'] as core.String?,
        newDestinationIp: json_['newDestinationIp'] as core.String?,
        newDestinationPort: json_['newDestinationPort'] as core.int?,
        newSourceIp: json_['newSourceIp'] as core.String?,
        newSourcePort: json_['newSourcePort'] as core.int?,
        oldDestinationIp: json_['oldDestinationIp'] as core.String?,
        oldDestinationPort: json_['oldDestinationPort'] as core.int?,
        oldSourceIp: json_['oldSourceIp'] as core.String?,
        oldSourcePort: json_['oldSourcePort'] as core.int?,
        protocol: json_['protocol'] as core.String?,
        subnetUri: json_['subnetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (networkUri != null) 'networkUri': networkUri!,
    if (newDestinationIp != null) 'newDestinationIp': newDestinationIp!,
    if (newDestinationPort != null) 'newDestinationPort': newDestinationPort!,
    if (newSourceIp != null) 'newSourceIp': newSourceIp!,
    if (newSourcePort != null) 'newSourcePort': newSourcePort!,
    if (oldDestinationIp != null) 'oldDestinationIp': oldDestinationIp!,
    if (oldDestinationPort != null) 'oldDestinationPort': oldDestinationPort!,
    if (oldSourceIp != null) 'oldSourceIp': oldSourceIp!,
    if (oldSourcePort != null) 'oldSourcePort': oldSourcePort!,
    if (protocol != null) 'protocol': protocol!,
    if (subnetUri != null) 'subnetUri': subnetUri!,
  };
}

/// Used by:
///
/// - redis:v1 : PscAutoConnection
/// - redis:v1beta1 : PscAutoConnection
class $PscAutoConnection {
  /// The IP allocated on the consumer network for the PSC forwarding rule.
  ///
  /// Output only.
  core.String? address;

  /// Type of the PSC connection.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONNECTION_TYPE_UNSPECIFIED" : Cluster endpoint Type is not set
  /// - "CONNECTION_TYPE_DISCOVERY" : Cluster endpoint that will be used as for
  /// cluster topology discovery.
  /// - "CONNECTION_TYPE_PRIMARY" : Cluster endpoint that will be used as
  /// primary endpoint to access primary.
  /// - "CONNECTION_TYPE_READER" : Cluster endpoint that will be used as reader
  /// endpoint to access replicas.
  core.String? connectionType;

  /// The URI of the consumer side forwarding rule.
  ///
  /// Example:
  /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
  ///
  /// Output only.
  core.String? forwardingRule;

  /// The consumer network where the IP address resides, in the form of
  /// projects/{project_id}/global/networks/{network_id}.
  ///
  /// Required.
  core.String? network;

  /// The consumer project_id where the forwarding rule is created from.
  ///
  /// Required.
  core.String? projectId;

  /// The PSC connection id of the forwarding rule connected to the service
  /// attachment.
  ///
  /// Output only.
  core.String? pscConnectionId;

  /// The status of the PSC connection.
  ///
  /// Please note that this value is updated periodically. Please use Private
  /// Service Connect APIs for the latest status.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PSC_CONNECTION_STATUS_UNSPECIFIED" : PSC connection status is not
  /// specified.
  /// - "PSC_CONNECTION_STATUS_ACTIVE" : The connection is active
  /// - "PSC_CONNECTION_STATUS_NOT_FOUND" : Connection not found
  core.String? pscConnectionStatus;

  /// The service attachment which is the target of the PSC connection, in the
  /// form of
  /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
  ///
  /// Output only.
  core.String? serviceAttachment;

  $PscAutoConnection({
    this.address,
    this.connectionType,
    this.forwardingRule,
    this.network,
    this.projectId,
    this.pscConnectionId,
    this.pscConnectionStatus,
    this.serviceAttachment,
  });

  $PscAutoConnection.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        connectionType: json_['connectionType'] as core.String?,
        forwardingRule: json_['forwardingRule'] as core.String?,
        network: json_['network'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        pscConnectionId: json_['pscConnectionId'] as core.String?,
        pscConnectionStatus: json_['pscConnectionStatus'] as core.String?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (connectionType != null) 'connectionType': connectionType!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (network != null) 'network': network!,
    if (projectId != null) 'projectId': projectId!,
    if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
    if (pscConnectionStatus != null)
      'pscConnectionStatus': pscConnectionStatus!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Used by:
///
/// - alloydb:v1 : PscAutoConnectionConfig
/// - alloydb:v1alpha : PscAutoConnectionConfig
/// - alloydb:v1beta : PscAutoConnectionConfig
class $PscAutoConnectionConfig00 {
  /// The consumer network for the PSC service automation, example:
  /// "projects/vpc-host-project/global/networks/default".
  ///
  /// The consumer network might be hosted a different project than the consumer
  /// project.
  core.String? consumerNetwork;

  /// The status of the service connection policy.
  ///
  /// Possible values: "STATE_UNSPECIFIED" - Default state, when Connection Map
  /// is created initially. "VALID" - Set when policy and map configuration is
  /// valid, and their matching can lead to allowing creation of PSC Connections
  /// subject to other constraints like connections limit.
  /// "CONNECTION_POLICY_MISSING" - No Service Connection Policy found for this
  /// network and Service Class "POLICY_LIMIT_REACHED" - Service Connection
  /// Policy limit reached for this network and Service Class
  /// "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED" - The consumer instance
  /// project is not in AllowedGoogleProducersResourceHierarchyLevels of the
  /// matching ServiceConnectionPolicy.
  ///
  /// Output only.
  core.String? consumerNetworkStatus;

  /// The consumer project to which the PSC service automation endpoint will be
  /// created.
  core.String? consumerProject;

  /// The IP address of the PSC service automation endpoint.
  ///
  /// Output only.
  core.String? ipAddress;

  /// The status of the PSC service automation connection.
  ///
  /// Possible values: "STATE_UNSPECIFIED" - An invalid state as the default
  /// case. "ACTIVE" - The connection has been created successfully. "FAILED" -
  /// The connection is not functional since some resources on the connection
  /// fail to be created. "CREATING" - The connection is being created.
  /// "DELETING" - The connection is being deleted. "CREATE_REPAIRING" - The
  /// connection is being repaired to complete creation. "DELETE_REPAIRING" -
  /// The connection is being repaired to complete deletion.
  ///
  /// Output only.
  core.String? status;

  $PscAutoConnectionConfig00({
    this.consumerNetwork,
    this.consumerNetworkStatus,
    this.consumerProject,
    this.ipAddress,
    this.status,
  });

  $PscAutoConnectionConfig00.fromJson(core.Map json_)
    : this(
        consumerNetwork: json_['consumerNetwork'] as core.String?,
        consumerNetworkStatus: json_['consumerNetworkStatus'] as core.String?,
        consumerProject: json_['consumerProject'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumerNetwork != null) 'consumerNetwork': consumerNetwork!,
    if (consumerNetworkStatus != null)
      'consumerNetworkStatus': consumerNetworkStatus!,
    if (consumerProject != null) 'consumerProject': consumerProject!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : PscAutoConnectionConfig
/// - sqladmin:v1beta4 : PscAutoConnectionConfig
class $PscAutoConnectionConfig01 {
  /// The consumer network of this consumer endpoint.
  ///
  /// This must be a resource path that includes both the host project and the
  /// network name. For example, `projects/project1/global/networks/network1`.
  /// The consumer host project of this network might be different from the
  /// consumer service project.
  ///
  /// Optional.
  core.String? consumerNetwork;

  /// The connection policy status of the consumer network.
  core.String? consumerNetworkStatus;

  /// This is the project ID of consumer service project of this consumer
  /// endpoint.
  ///
  /// Optional. This is only applicable if consumer_network is a shared vpc
  /// network.
  ///
  /// Optional.
  core.String? consumerProject;

  /// The IP address of the consumer endpoint.
  core.String? ipAddress;

  /// The connection status of the consumer endpoint.
  core.String? status;

  $PscAutoConnectionConfig01({
    this.consumerNetwork,
    this.consumerNetworkStatus,
    this.consumerProject,
    this.ipAddress,
    this.status,
  });

  $PscAutoConnectionConfig01.fromJson(core.Map json_)
    : this(
        consumerNetwork: json_['consumerNetwork'] as core.String?,
        consumerNetworkStatus: json_['consumerNetworkStatus'] as core.String?,
        consumerProject: json_['consumerProject'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumerNetwork != null) 'consumerNetwork': consumerNetwork!,
    if (consumerNetworkStatus != null)
      'consumerNetworkStatus': consumerNetworkStatus!,
    if (consumerProject != null) 'consumerProject': consumerProject!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PscAutomatedEndpoints
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PscAutomatedEndpoints
class $PscAutomatedEndpoints {
  /// Ip Address created by the automated forwarding rule.
  core.String? matchAddress;

  /// Corresponding network in pscAutomationConfigs.
  core.String? network;

  /// Corresponding project_id in pscAutomationConfigs
  core.String? projectId;

  $PscAutomatedEndpoints({this.matchAddress, this.network, this.projectId});

  $PscAutomatedEndpoints.fromJson(core.Map json_)
    : this(
        matchAddress: json_['matchAddress'] as core.String?,
        network: json_['network'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (matchAddress != null) 'matchAddress': matchAddress!,
    if (network != null) 'network': network!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - alloydb:v1 : PscConfig
/// - alloydb:v1alpha : PscConfig
/// - alloydb:v1beta : PscConfig
class $PscConfig00 {
  /// Create an instance that allows connections from Private Service Connect
  /// endpoints to the instance.
  ///
  /// Optional.
  core.bool? pscEnabled;

  /// The project number that needs to be allowlisted on the network attachment
  /// to enable outbound connectivity.
  ///
  /// Output only.
  core.String? serviceOwnedProjectNumber;

  $PscConfig00({this.pscEnabled, this.serviceOwnedProjectNumber});

  $PscConfig00.fromJson(core.Map json_)
    : this(
        pscEnabled: json_['pscEnabled'] as core.bool?,
        serviceOwnedProjectNumber:
            json_['serviceOwnedProjectNumber'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pscEnabled != null) 'pscEnabled': pscEnabled!,
    if (serviceOwnedProjectNumber != null)
      'serviceOwnedProjectNumber': serviceOwnedProjectNumber!,
  };
}

/// Used by:
///
/// - redis:v1 : PscConfig
/// - redis:v1beta1 : PscConfig
class $PscConfig01 {
  /// The network where the IP address of the discovery endpoint will be
  /// reserved, in the form of
  /// projects/{network_project}/global/networks/{network_id}.
  ///
  /// Required.
  core.String? network;

  $PscConfig01({this.network});

  $PscConfig01.fromJson(core.Map json_)
    : this(network: json_['network'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (network != null) 'network': network!,
  };
}

/// Used by:
///
/// - redis:v1 : PscConnection
/// - redis:v1beta1 : PscConnection
class $PscConnection {
  /// The IP allocated on the consumer network for the PSC forwarding rule.
  ///
  /// Required.
  core.String? address;

  /// Type of the PSC connection.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONNECTION_TYPE_UNSPECIFIED" : Cluster endpoint Type is not set
  /// - "CONNECTION_TYPE_DISCOVERY" : Cluster endpoint that will be used as for
  /// cluster topology discovery.
  /// - "CONNECTION_TYPE_PRIMARY" : Cluster endpoint that will be used as
  /// primary endpoint to access primary.
  /// - "CONNECTION_TYPE_READER" : Cluster endpoint that will be used as reader
  /// endpoint to access replicas.
  core.String? connectionType;

  /// The URI of the consumer side forwarding rule.
  ///
  /// Example:
  /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
  ///
  /// Required.
  core.String? forwardingRule;

  /// The consumer network where the IP address resides, in the form of
  /// projects/{project_id}/global/networks/{network_id}.
  ///
  /// Required.
  core.String? network;

  /// port will only be set for Primary/Reader or Discovery endpoint.
  ///
  /// Output only.
  core.int? port;

  /// Project ID of the consumer project where the forwarding rule is created
  /// in.
  ///
  /// Optional.
  core.String? projectId;

  /// The PSC connection id of the forwarding rule connected to the service
  /// attachment.
  ///
  /// Required.
  core.String? pscConnectionId;

  /// The status of the PSC connection.
  ///
  /// Please note that this value is updated periodically. To get the latest
  /// status of a PSC connection, follow
  /// https://cloud.google.com/vpc/docs/configure-private-service-connect-services#endpoint-details.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PSC_CONNECTION_STATUS_UNSPECIFIED" : PSC connection status is not
  /// specified.
  /// - "PSC_CONNECTION_STATUS_ACTIVE" : The connection is active
  /// - "PSC_CONNECTION_STATUS_NOT_FOUND" : Connection not found
  core.String? pscConnectionStatus;

  /// The service attachment which is the target of the PSC connection, in the
  /// form of
  /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
  ///
  /// Required.
  core.String? serviceAttachment;

  $PscConnection({
    this.address,
    this.connectionType,
    this.forwardingRule,
    this.network,
    this.port,
    this.projectId,
    this.pscConnectionId,
    this.pscConnectionStatus,
    this.serviceAttachment,
  });

  $PscConnection.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        connectionType: json_['connectionType'] as core.String?,
        forwardingRule: json_['forwardingRule'] as core.String?,
        network: json_['network'] as core.String?,
        port: json_['port'] as core.int?,
        projectId: json_['projectId'] as core.String?,
        pscConnectionId: json_['pscConnectionId'] as core.String?,
        pscConnectionStatus: json_['pscConnectionStatus'] as core.String?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (connectionType != null) 'connectionType': connectionType!,
    if (forwardingRule != null) 'forwardingRule': forwardingRule!,
    if (network != null) 'network': network!,
    if (port != null) 'port': port!,
    if (projectId != null) 'projectId': projectId!,
    if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
    if (pscConnectionStatus != null)
      'pscConnectionStatus': pscConnectionStatus!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Used by:
///
/// - alloydb:v1 : PscInterfaceConfig
/// - alloydb:v1alpha : PscInterfaceConfig
/// - alloydb:v1beta : PscInterfaceConfig
class $PscInterfaceConfig {
  /// The network attachment resource created in the consumer network to which
  /// the PSC interface will be linked.
  ///
  /// This is of the format:
  /// "projects/${CONSUMER_PROJECT}/regions/${REGION}/networkAttachments/${NETWORK_ATTACHMENT_NAME}".
  /// The network attachment must be in the same region as the instance.
  core.String? networkAttachmentResource;

  $PscInterfaceConfig({this.networkAttachmentResource});

  $PscInterfaceConfig.fromJson(core.Map json_)
    : this(
        networkAttachmentResource:
            json_['networkAttachmentResource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (networkAttachmentResource != null)
      'networkAttachmentResource': networkAttachmentResource!,
  };
}

/// Used by:
///
/// - redis:v1 : PscServiceAttachment
/// - redis:v1beta1 : PscServiceAttachment
class $PscServiceAttachment {
  /// Type of a PSC connection targeting this service attachment.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONNECTION_TYPE_UNSPECIFIED" : Cluster endpoint Type is not set
  /// - "CONNECTION_TYPE_DISCOVERY" : Cluster endpoint that will be used as for
  /// cluster topology discovery.
  /// - "CONNECTION_TYPE_PRIMARY" : Cluster endpoint that will be used as
  /// primary endpoint to access primary.
  /// - "CONNECTION_TYPE_READER" : Cluster endpoint that will be used as reader
  /// endpoint to access replicas.
  core.String? connectionType;

  /// Service attachment URI which your self-created PscConnection should use as
  /// target
  ///
  /// Output only.
  core.String? serviceAttachment;

  $PscServiceAttachment({this.connectionType, this.serviceAttachment});

  $PscServiceAttachment.fromJson(core.Map json_)
    : this(
        connectionType: json_['connectionType'] as core.String?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectionType != null) 'connectionType': connectionType!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Used by:
///
/// - compute:alpha : PublicAdvertisedPrefixPublicDelegatedPrefix
/// - compute:beta : PublicAdvertisedPrefixPublicDelegatedPrefix
/// - compute:v1 : PublicAdvertisedPrefixPublicDelegatedPrefix
class $PublicAdvertisedPrefixPublicDelegatedPrefix {
  /// The IP address range of the public delegated prefix
  core.String? ipRange;

  /// The name of the public delegated prefix
  core.String? name;

  /// The project number of the public delegated prefix
  core.String? project;

  /// The region of the public delegated prefix if it is regional.
  ///
  /// If absent, the prefix is global.
  core.String? region;

  /// The status of the public delegated prefix.
  ///
  /// Possible values are: INITIALIZING: The public delegated prefix is being
  /// initialized and addresses cannot be created yet. ANNOUNCED: The public
  /// delegated prefix is active.
  core.String? status;

  $PublicAdvertisedPrefixPublicDelegatedPrefix({
    this.ipRange,
    this.name,
    this.project,
    this.region,
    this.status,
  });

  $PublicAdvertisedPrefixPublicDelegatedPrefix.fromJson(core.Map json_)
    : this(
        ipRange: json_['ipRange'] as core.String?,
        name: json_['name'] as core.String?,
        project: json_['project'] as core.String?,
        region: json_['region'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipRange != null) 'ipRange': ipRange!,
    if (name != null) 'name': name!,
    if (project != null) 'project': project!,
    if (region != null) 'region': region!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:beta : PublicDelegatedPrefixPublicDelegatedSubPrefix
/// - compute:v1 : PublicDelegatedPrefixPublicDelegatedSubPrefix
class $PublicDelegatedPrefixPublicDelegatedSubPrefix {
  /// The allocatable prefix length supported by this PublicDelegatedSubPrefix.
  core.int? allocatablePrefixLength;

  /// Name of the project scoping this PublicDelegatedSubPrefix.
  core.String? delegateeProject;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The IP address range, in CIDR format, represented by this sub public
  /// delegated prefix.
  core.String? ipCidrRange;

  /// Whether the sub prefix is delegated to create Address resources in the
  /// delegatee project.
  core.bool? isAddress;

  /// The PublicDelegatedSubPrefix mode for IPv6 only.
  /// Possible string values are:
  /// - "DELEGATION" : The public delegated prefix is used for further
  /// sub-delegation only. Such prefixes cannot set allocatablePrefixLength.
  /// - "EXTERNAL_IPV6_FORWARDING_RULE_CREATION" : The public delegated prefix
  /// is used for creating forwarding rules only. Such prefixes cannot set
  /// publicDelegatedSubPrefixes.
  /// - "EXTERNAL_IPV6_SUBNETWORK_CREATION" : The public delegated prefix is
  /// used for creating dual-mode subnetworks only. Such prefixes cannot set
  /// publicDelegatedSubPrefixes.
  core.String? mode;

  /// The name of the sub public delegated prefix.
  core.String? name;

  /// The region of the sub public delegated prefix if it is regional.
  ///
  /// If absent, the sub prefix is global.
  ///
  /// Output only.
  core.String? region;

  /// The status of the sub public delegated prefix.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String? status;

  $PublicDelegatedPrefixPublicDelegatedSubPrefix({
    this.allocatablePrefixLength,
    this.delegateeProject,
    this.description,
    this.ipCidrRange,
    this.isAddress,
    this.mode,
    this.name,
    this.region,
    this.status,
  });

  $PublicDelegatedPrefixPublicDelegatedSubPrefix.fromJson(core.Map json_)
    : this(
        allocatablePrefixLength: json_['allocatablePrefixLength'] as core.int?,
        delegateeProject: json_['delegateeProject'] as core.String?,
        description: json_['description'] as core.String?,
        ipCidrRange: json_['ipCidrRange'] as core.String?,
        isAddress: json_['isAddress'] as core.bool?,
        mode: json_['mode'] as core.String?,
        name: json_['name'] as core.String?,
        region: json_['region'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allocatablePrefixLength != null)
      'allocatablePrefixLength': allocatablePrefixLength!,
    if (delegateeProject != null) 'delegateeProject': delegateeProject!,
    if (description != null) 'description': description!,
    if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
    if (isAddress != null) 'isAddress': isAddress!,
    if (mode != null) 'mode': mode!,
    if (name != null) 'name': name!,
    if (region != null) 'region': region!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1PublicJwk
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaPublicJwk
class $PublicJwk {
  /// See
  /// [section 4.4 of RFC 7517](https://tools.ietf.org/html/rfc7517#section-4.4).
  core.String? alg;

  /// See
  /// [section 6.3.1.2 of RFC 7518](https://tools.ietf.org/html/rfc7518#section-6.3.1.2).
  core.String? e;

  /// See
  /// [section 4.5 of RFC 7517](https://tools.ietf.org/html/rfc7517#section-4.5).
  core.String? kid;

  /// See
  /// [section 4.1 of RFC 7517](https://tools.ietf.org/html/rfc7517#section-4.1).
  core.String? kty;

  /// See
  /// [section 6.3.1.1 of RFC 7518](https://tools.ietf.org/html/rfc7518#section-6.3.1.1).
  core.String? n;

  /// See
  /// [section 4.2 of RFC 7517](https://tools.ietf.org/html/rfc7517#section-4.2).
  core.String? use;

  $PublicJwk({this.alg, this.e, this.kid, this.kty, this.n, this.use});

  $PublicJwk.fromJson(core.Map json_)
    : this(
        alg: json_['alg'] as core.String?,
        e: json_['e'] as core.String?,
        kid: json_['kid'] as core.String?,
        kty: json_['kty'] as core.String?,
        n: json_['n'] as core.String?,
        use: json_['use'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alg != null) 'alg': alg!,
    if (e != null) 'e': e!,
    if (kid != null) 'kid': kid!,
    if (kty != null) 'kty': kty!,
    if (n != null) 'n': n!,
    if (use != null) 'use': use!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Publisher
/// - containeranalysis:v1alpha1 : Publisher
/// - containeranalysis:v1beta1 : Publisher
class $Publisher00 {
  /// Provides information about the authority of the issuing party to release
  /// the document, in particular, the party's constituency and responsibilities
  /// or other obligations.
  core.String? issuingAuthority;

  /// Name of the publisher.
  ///
  /// Examples: 'Google', 'Google Cloud Platform'.
  core.String? name;

  /// The context or namespace.
  ///
  /// Contains a URL which is under control of the issuing party and can be used
  /// as a globally unique identifier for that issuing party. Example:
  /// https://csaf.io
  core.String? publisherNamespace;

  $Publisher00({this.issuingAuthority, this.name, this.publisherNamespace});

  $Publisher00.fromJson(core.Map json_)
    : this(
        issuingAuthority: json_['issuingAuthority'] as core.String?,
        name: json_['name'] as core.String?,
        publisherNamespace: json_['publisherNamespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (issuingAuthority != null) 'issuingAuthority': issuingAuthority!,
    if (name != null) 'name': name!,
    if (publisherNamespace != null) 'publisherNamespace': publisherNamespace!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : Publisher
/// - analyticshub:v1beta1 : Publisher
class $Publisher01 {
  /// Name of the listing publisher.
  ///
  /// Optional.
  core.String? name;

  /// Email or URL of the listing publisher.
  ///
  /// Max Length: 1000 bytes.
  ///
  /// Optional.
  core.String? primaryContact;

  $Publisher01({this.name, this.primaryContact});

  $Publisher01.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        primaryContact: json_['primaryContact'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (primaryContact != null) 'primaryContact': primaryContact!,
  };
}

/// Used by:
///
/// - admob:v1 : PublisherAccount
/// - admob:v1beta : PublisherAccount
class $PublisherAccount {
  /// Currency code of the earning-related metrics, which is the 3-letter code
  /// defined in ISO 4217.
  ///
  /// The daily average rate is used for the currency conversion.
  core.String? currencyCode;

  /// Resource name of this account.
  ///
  /// Format is accounts/{publisher_id}.
  core.String? name;

  /// The unique ID by which this publisher account can be identified in the API
  /// requests (for example, pub-1234567890).
  core.String? publisherId;

  /// The time zone that is used in reports that are generated for this account.
  ///
  /// The value is a time-zone ID as specified by the CLDR project, for example,
  /// "America/Los_Angeles".
  core.String? reportingTimeZone;

  $PublisherAccount({
    this.currencyCode,
    this.name,
    this.publisherId,
    this.reportingTimeZone,
  });

  $PublisherAccount.fromJson(core.Map json_)
    : this(
        currencyCode: json_['currencyCode'] as core.String?,
        name: json_['name'] as core.String?,
        publisherId: json_['publisherId'] as core.String?,
        reportingTimeZone: json_['reportingTimeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (name != null) 'name': name!,
    if (publisherId != null) 'publisherId': publisherId!,
    if (reportingTimeZone != null) 'reportingTimeZone': reportingTimeZone!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployDeployMetadata
class $PublisherModelCallToActionDeployDeployMetadata {
  /// Labels for the deployment config.
  ///
  /// For managing deployment config like verifying, source of deployment
  /// config, etc.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Sample request for deployed endpoint.
  ///
  /// Optional.
  core.String? sampleRequest;

  $PublisherModelCallToActionDeployDeployMetadata({
    this.labels,
    this.sampleRequest,
  });

  $PublisherModelCallToActionDeployDeployMetadata.fromJson(core.Map json_)
    : this(
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        sampleRequest: json_['sampleRequest'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labels != null) 'labels': labels!,
    if (sampleRequest != null) 'sampleRequest': sampleRequest!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployGke
class $PublisherModelCallToActionDeployGke {
  /// GKE deployment configuration in yaml format.
  ///
  /// Optional.
  core.List<core.String>? gkeYamlConfigs;

  $PublisherModelCallToActionDeployGke({this.gkeYamlConfigs});

  $PublisherModelCallToActionDeployGke.fromJson(core.Map json_)
    : this(
        gkeYamlConfigs:
            (json_['gkeYamlConfigs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gkeYamlConfigs != null) 'gkeYamlConfigs': gkeYamlConfigs!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PublisherModelDocumentation
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PublisherModelDocumentation
class $PublisherModelDocumentation {
  /// Content of this piece of document (in Markdown format).
  ///
  /// Required.
  core.String? content;

  /// E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA, NODE.JS,
  /// etc..
  ///
  /// Required.
  core.String? title;

  $PublisherModelDocumentation({this.content, this.title});

  $PublisherModelDocumentation.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PublisherModelResourceReference
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PublisherModelResourceReference
class $PublisherModelResourceReference {
  /// Description of the resource.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? description;

  /// The resource name of the Google Cloud resource.
  core.String? resourceName;

  /// The URI of the resource.
  core.String? uri;

  /// Use case (CUJ) of the resource.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? useCase;

  $PublisherModelResourceReference({
    this.description,
    this.resourceName,
    this.uri,
    this.useCase,
  });

  $PublisherModelResourceReference.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        resourceName: json_['resourceName'] as core.String?,
        uri: json_['uri'] as core.String?,
        useCase: json_['useCase'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (resourceName != null) 'resourceName': resourceName!,
    if (uri != null) 'uri': uri!,
    if (useCase != null) 'useCase': useCase!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : PublisherProfileMobileApplication
/// - authorizedbuyersmarketplace:v1alpha : PublisherProfileMobileApplication
class $PublisherProfileMobileApplication {
  /// The app store the app belongs to.
  ///
  /// Can be used to filter the response of the publisherProfiles.list method.
  /// Possible string values are:
  /// - "APP_STORE_TYPE_UNSPECIFIED" : A placeholder for an unknown app store.
  /// - "APPLE_ITUNES" : Apple iTunes
  /// - "GOOGLE_PLAY" : Google Play
  /// - "ROKU" : Roku
  /// - "AMAZON_FIRE_TV" : Amazon Fire TV
  /// - "PLAYSTATION" : PlayStation
  /// - "XBOX" : Xbox
  /// - "SAMSUNG_TV" : Samsung TV
  /// - "AMAZON" : Amazon Appstore
  /// - "OPPO" : OPPO App Market
  /// - "SAMSUNG" : Samsung Galaxy Store
  /// - "VIVO" : VIVO App Store
  /// - "XIAOMI" : Xiaomi GetApps
  /// - "LG_TV" : LG TV
  core.String? appStore;

  /// The external ID for the app from its app store.
  ///
  /// Can be used to filter the response of the publisherProfiles.list method.
  core.String? externalAppId;

  /// The name of the app.
  core.String? name;

  $PublisherProfileMobileApplication({
    this.appStore,
    this.externalAppId,
    this.name,
  });

  $PublisherProfileMobileApplication.fromJson(core.Map json_)
    : this(
        appStore: json_['appStore'] as core.String?,
        externalAppId: json_['externalAppId'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appStore != null) 'appStore': appStore!,
    if (externalAppId != null) 'externalAppId': externalAppId!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : PublisherReviewStatus
/// - displayvideo:v3 : PublisherReviewStatus
class $PublisherReviewStatus {
  /// The publisher reviewing the creative.
  core.String? publisherName;

  /// Status of the publisher review.
  /// Possible string values are:
  /// - "REVIEW_STATUS_UNSPECIFIED" : Type value is not specified or is unknown
  /// in this version.
  /// - "REVIEW_STATUS_APPROVED" : The creative is approved.
  /// - "REVIEW_STATUS_REJECTED" : The creative is rejected.
  /// - "REVIEW_STATUS_PENDING" : The creative is pending review.
  core.String? status;

  $PublisherReviewStatus({this.publisherName, this.status});

  $PublisherReviewStatus.fromJson(core.Map json_)
    : this(
        publisherName: json_['publisherName'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (publisherName != null) 'publisherName': publisherName!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - healthcare:v1 : PubsubDestination
/// - healthcare:v1beta1 : PubsubDestination
class $PubsubDestination {
  /// The [Pub/Sub](https://cloud.google.com/pubsub/docs/) topic that Pub/Sub
  /// messages are published on.
  ///
  /// Supplied by the client. The `PubsubMessage` contains the following fields:
  /// * `PubsubMessage.Data` contains the resource name. *
  /// `PubsubMessage.MessageId` is the ID of this notification. It is guaranteed
  /// to be unique within the topic. * `PubsubMessage.PublishTime` is the time
  /// when the message was published.
  /// [Topic names](https://cloud.google.com/pubsub/docs/overview#names) must be
  /// scoped to a project. The Cloud Healthcare API service account,
  /// service-PROJECT_NUMBER@gcp-sa-healthcare.iam.gserviceaccount.com, must
  /// have publisher permissions on the given Pub/Sub topic. Not having adequate
  /// permissions causes the calls that send notifications to fail.
  core.String? pubsubTopic;

  $PubsubDestination({this.pubsubTopic});

  $PubsubDestination.fromJson(core.Map json_)
    : this(pubsubTopic: json_['pubsubTopic'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pubsubTopic != null) 'pubsubTopic': pubsubTopic!,
  };
}

/// Used by:
///
/// - pubsub:v1 : PubsubMessage
/// - workflowexecutions:v1 : PubsubMessage
class $PubsubMessage {
  /// Attributes for this message.
  ///
  /// If this field is empty, the message must contain non-empty data. This can
  /// be used to filter messages on the subscription.
  ///
  /// Optional.
  core.Map<core.String, core.String>? attributes;

  /// The message data field.
  ///
  /// If this field is empty, the message must contain at least one attribute.
  ///
  /// Optional.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// ID of this message, assigned by the server when the message is published.
  ///
  /// Guaranteed to be unique within the topic. This value may be read by a
  /// subscriber that receives a `PubsubMessage` via a `Pull` call or a push
  /// delivery. It must not be populated by the publisher in a `Publish` call.
  core.String? messageId;

  /// If non-empty, identifies related messages for which publish order should
  /// be respected.
  ///
  /// If a `Subscription` has `enable_message_ordering` set to `true`, messages
  /// published with the same non-empty `ordering_key` value will be delivered
  /// to subscribers in the order in which they are received by the Pub/Sub
  /// system. All `PubsubMessage`s published in a given `PublishRequest` must
  /// specify the same `ordering_key` value. For more information, see
  /// [ordering messages](https://cloud.google.com/pubsub/docs/ordering).
  ///
  /// Optional.
  core.String? orderingKey;

  /// The time at which the message was published, populated by the server when
  /// it receives the `Publish` call.
  ///
  /// It must not be populated by the publisher in a `Publish` call.
  core.String? publishTime;

  $PubsubMessage({
    this.attributes,
    this.data,
    this.messageId,
    this.orderingKey,
    this.publishTime,
  });

  $PubsubMessage.fromJson(core.Map json_)
    : this(
        attributes: (json_['attributes']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        data: json_['data'] as core.String?,
        messageId: json_['messageId'] as core.String?,
        orderingKey: json_['orderingKey'] as core.String?,
        publishTime: json_['publishTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributes != null) 'attributes': attributes!,
    if (data != null) 'data': data!,
    if (messageId != null) 'messageId': messageId!,
    if (orderingKey != null) 'orderingKey': orderingKey!,
    if (publishTime != null) 'publishTime': publishTime!,
  };
}

/// Used by:
///
/// - cloudscheduler:v1 : PubsubTarget
/// - cloudscheduler:v1beta1 : PubsubTarget
class $PubsubTarget {
  /// Attributes for PubsubMessage.
  ///
  /// Pubsub message must contain either non-empty data, or at least one
  /// attribute.
  core.Map<core.String, core.String>? attributes;

  /// The message payload for PubsubMessage.
  ///
  /// Pubsub message must contain either non-empty data, or at least one
  /// attribute.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The name of the Cloud Pub/Sub topic to which messages will be published
  /// when a job is delivered.
  ///
  /// The topic name must be in the same format as required by Pub/Sub's
  /// [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest),
  /// for example `projects/PROJECT_ID/topics/TOPIC_ID`. The topic must be in
  /// the same project as the Cloud Scheduler job.
  ///
  /// Required.
  core.String? topicName;

  $PubsubTarget({this.attributes, this.data, this.topicName});

  $PubsubTarget.fromJson(core.Map json_)
    : this(
        attributes: (json_['attributes']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        data: json_['data'] as core.String?,
        topicName: json_['topicName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributes != null) 'attributes': attributes!,
    if (data != null) 'data': data!,
    if (topicName != null) 'topicName': topicName!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2PurchaseTransaction
/// - retail:v2alpha : GoogleCloudRetailV2alphaPurchaseTransaction
/// - retail:v2beta : GoogleCloudRetailV2betaPurchaseTransaction
class $PurchaseTransaction {
  /// All the costs associated with the products.
  ///
  /// These can be manufacturing costs, shipping expenses not borne by the end
  /// user, or any other costs, such that: * Profit = revenue - tax - cost
  core.double? cost;

  /// Currency code.
  ///
  /// Use three-character ISO-4217 code.
  ///
  /// Required.
  core.String? currencyCode;

  /// The transaction ID with a length limit of 128 characters.
  core.String? id;

  /// Total non-zero revenue or grand total associated with the transaction.
  ///
  /// This value include shipping, tax, or other adjustments to total revenue
  /// that you want to include as part of your revenue calculations.
  ///
  /// Required.
  core.double? revenue;

  /// All the taxes associated with the transaction.
  core.double? tax;

  $PurchaseTransaction({
    this.cost,
    this.currencyCode,
    this.id,
    this.revenue,
    this.tax,
  });

  $PurchaseTransaction.fromJson(core.Map json_)
    : this(
        cost: (json_['cost'] as core.num?)?.toDouble(),
        currencyCode: json_['currencyCode'] as core.String?,
        id: json_['id'] as core.String?,
        revenue: (json_['revenue'] as core.num?)?.toDouble(),
        tax: (json_['tax'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cost != null) 'cost': cost!,
    if (currencyCode != null) 'currencyCode': currencyCode!,
    if (id != null) 'id': id!,
    if (revenue != null) 'revenue': revenue!,
    if (tax != null) 'tax': tax!,
  };
}

/// Used by:
///
/// - androidpublisher:v3 : ProductPurchasesAcknowledgeRequest
/// - androidpublisher:v3 : SubscriptionPurchasesAcknowledgeRequest
class $PurchasesAcknowledgeRequest {
  /// Payload to attach to the purchase.
  core.String? developerPayload;

  $PurchasesAcknowledgeRequest({this.developerPayload});

  $PurchasesAcknowledgeRequest.fromJson(core.Map json_)
    : this(developerPayload: json_['developerPayload'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (developerPayload != null) 'developerPayload': developerPayload!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PurgeArtifactsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PurgeArtifactsRequest
class $PurgeArtifactsRequest {
  /// A required filter matching the Artifacts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Artifact
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  $PurgeArtifactsRequest({this.filter, this.force});

  $PurgeArtifactsRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PurgeContextsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PurgeContextsRequest
class $PurgeContextsRequest {
  /// A required filter matching the Contexts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Context
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  $PurgeContextsRequest({this.filter, this.force});

  $PurgeContextsRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PurgeDocumentsRequestInlineSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequestInlineSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPurgeDocumentsRequestInlineSource
class $PurgeDocumentsRequestInlineSource {
  /// A list of full resource name of documents to purge.
  ///
  /// In the format `projects / * /locations / * /collections / * /dataStores /
  /// * /branches / * /documents / * `. Recommended max of 100 items.
  ///
  /// Required.
  core.List<core.String>? documents;

  $PurgeDocumentsRequestInlineSource({this.documents});

  $PurgeDocumentsRequestInlineSource.fromJson(core.Map json_)
    : this(
        documents:
            (json_['documents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documents != null) 'documents': documents!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PurgeErrorConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPurgeErrorConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPurgeErrorConfig
class $PurgeErrorConfig {
  /// Cloud Storage prefix for purge errors.
  ///
  /// This must be an empty, existing Cloud Storage directory. Purge errors are
  /// written to sharded files in this directory, one per line, as a
  /// JSON-encoded `google.rpc.Status` message.
  core.String? gcsPrefix;

  $PurgeErrorConfig({this.gcsPrefix});

  $PurgeErrorConfig.fromJson(core.Map json_)
    : this(gcsPrefix: json_['gcsPrefix'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsPrefix != null) 'gcsPrefix': gcsPrefix!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PurgeExecutionsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PurgeExecutionsRequest
class $PurgeExecutionsRequest {
  /// A required filter matching the Executions to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Execution
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  $PurgeExecutionsRequest({this.filter, this.force});

  $PurgeExecutionsRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2PurgeProductsRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaPurgeProductsRequest
/// - retail:v2beta : GoogleCloudRetailV2betaPurgeProductsRequest
class $PurgeProductsRequest {
  /// The filter string to specify the products to be deleted with a length
  /// limit of 5,000 characters.
  ///
  /// Empty string filter is not allowed. "*" implies delete all items in a
  /// branch. The eligible fields for filtering are: * `availability`: Double
  /// quoted Product.availability string. * `create_time` : in ISO 8601 "zulu"
  /// format. Supported syntax: * Comparators ("\>", "\<", "\>=", "\<=", "=").
  /// Examples: * create_time \<= "2015-02-13T17:05:46Z" * availability =
  /// "IN_STOCK" * Conjunctions ("AND") Examples: * create_time \<=
  /// "2015-02-13T17:05:46Z" AND availability = "PREORDER" * Disjunctions ("OR")
  /// Examples: * create_time \<= "2015-02-13T17:05:46Z" OR availability =
  /// "IN_STOCK" * Can support nested queries. Examples: * (create_time \<=
  /// "2015-02-13T17:05:46Z" AND availability = "PREORDER") OR (create_time \>=
  /// "2015-02-14T13:03:32Z" AND availability = "IN_STOCK") * Filter Limits: *
  /// Filter should not contain more than 6 conditions. * Max nesting depth
  /// should not exceed 2 levels. Examples queries: * Delete back order products
  /// created before a timestamp. create_time \<= "2015-02-13T17:05:46Z" OR
  /// availability = "BACKORDER"
  ///
  /// Required.
  core.String? filter;

  /// Actually perform the purge.
  ///
  /// If `force` is set to false, the method will return the expected purge
  /// count without deleting any products.
  core.bool? force;

  $PurgeProductsRequest({this.filter, this.force});

  $PurgeProductsRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1PurgeUserEventsRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaPurgeUserEventsRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaPurgeUserEventsRequest
class $PurgeUserEventsRequest00 {
  /// The filter string to specify the events to be deleted with a length limit
  /// of 5,000 characters.
  ///
  /// The eligible fields for filtering are: * `eventType`: Double quoted
  /// UserEvent.event_type string. * `eventTime`: in ISO 8601 "zulu" format. *
  /// `userPseudoId`: Double quoted string. Specifying this will delete all
  /// events associated with a visitor. * `userId`: Double quoted string.
  /// Specifying this will delete all events associated with a user. Note: This
  /// API only supports purging a max range of 30 days. Examples: * Deleting all
  /// events in a time range: `eventTime > "2012-04-23T18:25:43.511Z" eventTime
  /// < "2012-04-23T18:30:43.511Z"` * Deleting specific eventType in a time
  /// range: `eventTime > "2012-04-23T18:25:43.511Z" eventTime <
  /// "2012-04-23T18:30:43.511Z" eventType = "search"` * Deleting all events for
  /// a specific visitor in a time range: `eventTime >
  /// "2012-04-23T18:25:43.511Z" eventTime < "2012-04-23T18:30:43.511Z"
  /// userPseudoId = "visitor1024"` * Deleting the past 30 days of events inside
  /// a DataStore: `*` The filtering fields are assumed to have an implicit AND.
  ///
  /// Required.
  core.String? filter;

  /// The `force` field is currently not supported.
  ///
  /// Purge user event requests will permanently delete all purgeable events.
  /// Once the development is complete: If `force` is set to false, the method
  /// will return the expected purge count without deleting any user events.
  /// This field will default to false if not included in the request.
  core.bool? force;

  $PurgeUserEventsRequest00({this.filter, this.force});

  $PurgeUserEventsRequest00.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2PurgeUserEventsRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaPurgeUserEventsRequest
/// - retail:v2beta : GoogleCloudRetailV2betaPurgeUserEventsRequest
class $PurgeUserEventsRequest01 {
  /// The filter string to specify the events to be deleted with a length limit
  /// of 5,000 characters.
  ///
  /// Empty string filter is not allowed. The eligible fields for filtering are:
  /// * `eventType`: Double quoted UserEvent.event_type string. * `eventTime`:
  /// in ISO 8601 "zulu" format. * `visitorId`: Double quoted string. Specifying
  /// this will delete all events associated with a visitor. * `userId`: Double
  /// quoted string. Specifying this will delete all events associated with a
  /// user. Examples: * Deleting all events in a time range: `eventTime >
  /// "2012-04-23T18:25:43.511Z" eventTime < "2012-04-23T18:30:43.511Z"` *
  /// Deleting specific eventType in time range: `eventTime >
  /// "2012-04-23T18:25:43.511Z" eventType = "detail-page-view"` * Deleting all
  /// events for a specific visitor: `visitorId = "visitor1024"` The filtering
  /// fields are assumed to have an implicit AND.
  ///
  /// Required.
  core.String? filter;

  /// Actually perform the purge.
  ///
  /// If `force` is set to false, the method will return the expected purge
  /// count without deleting any user events.
  core.bool? force;

  $PurgeUserEventsRequest01({this.filter, this.force});

  $PurgeUserEventsRequest01.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaQualityMetricsTopkMetrics
class $QualityMetricsTopkMetrics {
  /// The top-1 value.
  core.double? top1;

  /// The top-10 value.
  core.double? top10;

  /// The top-3 value.
  core.double? top3;

  /// The top-5 value.
  core.double? top5;

  $QualityMetricsTopkMetrics({this.top1, this.top10, this.top3, this.top5});

  $QualityMetricsTopkMetrics.fromJson(core.Map json_)
    : this(
        top1: (json_['top1'] as core.num?)?.toDouble(),
        top10: (json_['top10'] as core.num?)?.toDouble(),
        top3: (json_['top3'] as core.num?)?.toDouble(),
        top5: (json_['top5'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (top1 != null) 'top1': top1!,
    if (top10 != null) 'top10': top10!,
    if (top3 != null) 'top3': top3!,
    if (top5 != null) 'top5': top5!,
  };
}

/// Used by:
///
/// - alloydb:v1 : QuantityBasedExpiry
/// - alloydb:v1alpha : QuantityBasedExpiry
/// - alloydb:v1beta : QuantityBasedExpiry
class $QuantityBasedExpiry {
  /// The backup's position among its backups with the same source cluster and
  /// type, by descending chronological order create time(i.e. newest first).
  ///
  /// Output only.
  core.int? retentionCount;

  /// The length of the quantity-based queue, specified by the backup's
  /// retention policy.
  ///
  /// Output only.
  core.int? totalRetentionCount;

  $QuantityBasedExpiry({this.retentionCount, this.totalRetentionCount});

  $QuantityBasedExpiry.fromJson(core.Map json_)
    : this(
        retentionCount: json_['retentionCount'] as core.int?,
        totalRetentionCount: json_['totalRetentionCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (retentionCount != null) 'retentionCount': retentionCount!,
    if (totalRetentionCount != null)
      'totalRetentionCount': totalRetentionCount!,
  };
}

/// Used by:
///
/// - alloydb:v1 : QuantityBasedRetention
/// - alloydb:v1alpha : QuantityBasedRetention
/// - alloydb:v1beta : QuantityBasedRetention
class $QuantityBasedRetention {
  /// The number of backups to retain.
  core.int? count;

  $QuantityBasedRetention({this.count});

  $QuantityBasedRetention.fromJson(core.Map json_)
    : this(count: json_['count'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Query
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaQuery
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaQuery
class $Query00 {
  /// Unique Id for the query.
  ///
  /// Output only.
  core.String? queryId;

  /// Plain text.
  core.String? text;

  $Query00({this.queryId, this.text});

  $Query00.fromJson(core.Map json_)
    : this(
        queryId: json_['queryId'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryId != null) 'queryId': queryId!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - vault:v1 : HeldGroupsQuery
/// - vault:v1 : HeldMailQuery
class $Query01 {
  /// The end time for the query.
  ///
  /// Specify in GMT. The value is rounded to 12 AM on the specified date.
  core.String? endTime;

  /// The start time for the query.
  ///
  /// Specify in GMT. The value is rounded to 12 AM on the specified date.
  core.String? startTime;

  /// The [search operators](https://support.google.com/vault/answer/2474474)
  /// used to refine the messages covered by the hold.
  core.String? terms;

  $Query01({this.endTime, this.startTime, this.terms});

  $Query01.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        terms: json_['terms'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
    if (terms != null) 'terms': terms!,
  };
}

/// Used by:
///
/// - alloydb:v1 : QueryInsightsInstanceConfig
/// - alloydb:v1alpha : QueryInsightsInstanceConfig
/// - alloydb:v1beta : QueryInsightsInstanceConfig
class $QueryInsightsInstanceConfig {
  /// Number of query execution plans captured by Insights per minute for all
  /// queries combined.
  ///
  /// The default value is 5. Any integer between 0 and 20 is considered valid.
  core.int? queryPlansPerMinute;

  /// Query string length.
  ///
  /// The default value is 1024. Any integer between 256 and 4500 is considered
  /// valid.
  core.int? queryStringLength;

  /// Record application tags for an instance.
  ///
  /// This flag is turned "on" by default.
  core.bool? recordApplicationTags;

  /// Record client address for an instance.
  ///
  /// Client address is PII information. This flag is turned "on" by default.
  core.bool? recordClientAddress;

  $QueryInsightsInstanceConfig({
    this.queryPlansPerMinute,
    this.queryStringLength,
    this.recordApplicationTags,
    this.recordClientAddress,
  });

  $QueryInsightsInstanceConfig.fromJson(core.Map json_)
    : this(
        queryPlansPerMinute: json_['queryPlansPerMinute'] as core.int?,
        queryStringLength: json_['queryStringLength'] as core.int?,
        recordApplicationTags: json_['recordApplicationTags'] as core.bool?,
        recordClientAddress: json_['recordClientAddress'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryPlansPerMinute != null)
      'queryPlansPerMinute': queryPlansPerMinute!,
    if (queryStringLength != null) 'queryStringLength': queryStringLength!,
    if (recordApplicationTags != null)
      'recordApplicationTags': recordApplicationTags!,
    if (recordClientAddress != null)
      'recordClientAddress': recordClientAddress!,
  };
}

/// Used by:
///
/// - metastore:v1 : QueryMetadataRequest
/// - metastore:v1alpha : QueryMetadataRequest
/// - metastore:v1beta : QueryMetadataRequest
class $QueryMetadataRequest {
  /// A read-only SQL query to execute against the metadata database.
  ///
  /// The query cannot change or mutate the data.
  ///
  /// Required.
  core.String? query;

  $QueryMetadataRequest({this.query});

  $QueryMetadataRequest.fromJson(core.Map json_)
    : this(query: json_['query'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : QueryOverride
/// - cloudtasks:v2beta2 : QueryOverride
/// - cloudtasks:v2beta3 : QueryOverride
class $QueryOverride {
  /// The query parameters (e.g., qparam1=123&qparam2=456).
  ///
  /// Default is an empty string.
  core.String? queryParams;

  $QueryOverride({this.queryParams});

  $QueryOverride.fromJson(core.Map json_)
    : this(queryParams: json_['queryParams'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryParams != null) 'queryParams': queryParams!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QueryReasoningEngineRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QueryReasoningEngineRequest
class $QueryReasoningEngineRequest {
  /// Class method to be used for the query.
  ///
  /// It is optional and defaults to "query" if unspecified.
  ///
  /// Optional.
  core.String? classMethod;

  /// Input content provided by users in JSON object format.
  ///
  /// Examples include text query, function calling parameters, media bytes,
  /// etc.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? input;

  $QueryReasoningEngineRequest({this.classMethod, this.input});

  $QueryReasoningEngineRequest.fromJson(core.Map json_)
    : this(
        classMethod: json_['classMethod'] as core.String?,
        input:
            json_.containsKey('input')
                ? json_['input'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classMethod != null) 'classMethod': classMethod!,
    if (input != null) 'input': input!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QueryReasoningEngineResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse
class $QueryReasoningEngineResponse {
  /// Response provided by users in JSON object format.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? output;

  $QueryReasoningEngineResponse({this.output});

  $QueryReasoningEngineResponse.fromJson(core.Map json_)
    : this(output: json_['output']);

  core.Map<core.String, core.dynamic> toJson() => {
    if (output != null) 'output': output!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessResult
class $QuestionAnsweringCorrectnessResult {
  /// Confidence for question answering correctness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering correctness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Correctness score.
  ///
  /// Output only.
  core.double? score;

  $QuestionAnsweringCorrectnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $QuestionAnsweringCorrectnessResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessSpec
class $QuestionAnsweringCorrectnessSpec {
  /// Whether to use instance.reference to compute question answering
  /// correctness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $QuestionAnsweringCorrectnessSpec({this.useReference, this.version});

  $QuestionAnsweringCorrectnessSpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessResult
class $QuestionAnsweringHelpfulnessResult {
  /// Confidence for question answering helpfulness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering helpfulness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Helpfulness score.
  ///
  /// Output only.
  core.double? score;

  $QuestionAnsweringHelpfulnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $QuestionAnsweringHelpfulnessResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessSpec
class $QuestionAnsweringHelpfulnessSpec {
  /// Whether to use instance.reference to compute question answering
  /// helpfulness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $QuestionAnsweringHelpfulnessSpec({this.useReference, this.version});

  $QuestionAnsweringHelpfulnessSpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringQualityInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInstance
class $QuestionAnsweringQualityInstance {
  /// Text to answer the question.
  ///
  /// Required.
  core.String? context;

  /// Question Answering prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $QuestionAnsweringQualityInstance({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $QuestionAnsweringQualityInstance.fromJson(core.Map json_)
    : this(
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringQualityResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringQualityResult
class $QuestionAnsweringQualityResult {
  /// Confidence for question answering quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Quality score.
  ///
  /// Output only.
  core.double? score;

  $QuestionAnsweringQualityResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $QuestionAnsweringQualityResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualitySpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringQualitySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualitySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringQualitySpec
class $QuestionAnsweringQualitySpec {
  /// Whether to use instance.reference to compute question answering quality.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $QuestionAnsweringQualitySpec({this.useReference, this.version});

  $QuestionAnsweringQualitySpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceResult
class $QuestionAnsweringRelevanceResult {
  /// Confidence for question answering relevance score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering relevance score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Relevance score.
  ///
  /// Output only.
  core.double? score;

  $QuestionAnsweringRelevanceResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $QuestionAnsweringRelevanceResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceSpec
class $QuestionAnsweringRelevanceSpec {
  /// Whether to use instance.reference to compute question answering relevance.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $QuestionAnsweringRelevanceSpec({this.useReference, this.version});

  $QuestionAnsweringRelevanceSpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - cloudtasks:v2beta2 : QueueStats
/// - cloudtasks:v2beta3 : QueueStats
class $QueueStats {
  /// The number of requests that the queue has dispatched but has not received
  /// a reply for yet.
  ///
  /// Output only.
  core.String? concurrentDispatchesCount;

  /// The current maximum number of tasks per second executed by the queue.
  ///
  /// The maximum value of this variable is controlled by the RateLimits of the
  /// Queue. However, this value could be less to avoid overloading the
  /// endpoints tasks in the queue are targeting.
  ///
  /// Output only.
  core.double? effectiveExecutionRate;

  /// The number of tasks that the queue has dispatched and received a reply for
  /// during the last minute.
  ///
  /// This variable counts both successful and non-successful executions.
  ///
  /// Output only.
  core.String? executedLastMinuteCount;

  /// An estimation of the nearest time in the future where a task in the queue
  /// is scheduled to be executed.
  ///
  /// Output only.
  core.String? oldestEstimatedArrivalTime;

  /// An estimation of the number of tasks in the queue, that is, the tasks in
  /// the queue that haven't been executed, the tasks in the queue which the
  /// queue has dispatched but has not yet received a reply for, and the failed
  /// tasks that the queue is retrying.
  ///
  /// Output only.
  core.String? tasksCount;

  $QueueStats({
    this.concurrentDispatchesCount,
    this.effectiveExecutionRate,
    this.executedLastMinuteCount,
    this.oldestEstimatedArrivalTime,
    this.tasksCount,
  });

  $QueueStats.fromJson(core.Map json_)
    : this(
        concurrentDispatchesCount:
            json_['concurrentDispatchesCount'] as core.String?,
        effectiveExecutionRate:
            (json_['effectiveExecutionRate'] as core.num?)?.toDouble(),
        executedLastMinuteCount:
            json_['executedLastMinuteCount'] as core.String?,
        oldestEstimatedArrivalTime:
            json_['oldestEstimatedArrivalTime'] as core.String?,
        tasksCount: json_['tasksCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (concurrentDispatchesCount != null)
      'concurrentDispatchesCount': concurrentDispatchesCount!,
    if (effectiveExecutionRate != null)
      'effectiveExecutionRate': effectiveExecutionRate!,
    if (executedLastMinuteCount != null)
      'executedLastMinuteCount': executedLastMinuteCount!,
    if (oldestEstimatedArrivalTime != null)
      'oldestEstimatedArrivalTime': oldestEstimatedArrivalTime!,
    if (tasksCount != null) 'tasksCount': tasksCount!,
  };
}

/// Used by:
///
/// - container:v1 : QueuedProvisioning
/// - container:v1beta1 : QueuedProvisioning
class $QueuedProvisioning {
  /// Denotes that this nodepool is QRM specific, meaning nodes can be only
  /// obtained through queuing via the Cluster Autoscaler ProvisioningRequest
  /// API.
  core.bool? enabled;

  $QueuedProvisioning({this.enabled});

  $QueuedProvisioning.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - compute:alpha : QuotaExceededInfo
/// - compute:beta : QuotaExceededInfo
/// - compute:v1 : QuotaExceededInfo
class $QuotaExceededInfo00 {
  /// The map holding related quota dimensions.
  core.Map<core.String, core.String>? dimensions;

  /// Future quota limit being rolled out.
  ///
  /// The limit's unit depends on the quota type or metric.
  core.double? futureLimit;

  /// Current effective quota limit.
  ///
  /// The limit's unit depends on the quota type or metric.
  core.double? limit;

  /// The name of the quota limit.
  core.String? limitName;

  /// The Compute Engine quota metric name.
  core.String? metricName;

  /// Rollout status of the future quota limit.
  /// Possible string values are:
  /// - "IN_PROGRESS" : IN_PROGRESS - A rollout is in process which will change
  /// the limit value to future limit.
  /// - "ROLLOUT_STATUS_UNSPECIFIED" : ROLLOUT_STATUS_UNSPECIFIED - Rollout
  /// status is not specified. The default value.
  core.String? rolloutStatus;

  $QuotaExceededInfo00({
    this.dimensions,
    this.futureLimit,
    this.limit,
    this.limitName,
    this.metricName,
    this.rolloutStatus,
  });

  $QuotaExceededInfo00.fromJson(core.Map json_)
    : this(
        dimensions: (json_['dimensions']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        futureLimit: (json_['futureLimit'] as core.num?)?.toDouble(),
        limit: (json_['limit'] as core.num?)?.toDouble(),
        limitName: json_['limitName'] as core.String?,
        metricName: json_['metricName'] as core.String?,
        rolloutStatus: json_['rolloutStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensions != null) 'dimensions': dimensions!,
    if (futureLimit != null) 'futureLimit': futureLimit!,
    if (limit != null) 'limit': limit!,
    if (limitName != null) 'limitName': limitName!,
    if (metricName != null) 'metricName': metricName!,
    if (rolloutStatus != null) 'rolloutStatus': rolloutStatus!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : QuotaExceededInfo
/// - deploymentmanager:v2 : QuotaExceededInfo
/// - deploymentmanager:v2beta : QuotaExceededInfo
class $QuotaExceededInfo01 {
  /// The map holding related quota dimensions.
  core.Map<core.String, core.String>? dimensions;

  /// Future quota limit being rolled out.
  ///
  /// The limit's unit depends on the quota type or metric.
  core.double? futureLimit;

  /// Current effective quota limit.
  ///
  /// The limit's unit depends on the quota type or metric.
  core.double? limit;

  /// The name of the quota limit.
  core.String? limitName;

  /// The Compute Engine quota metric name.
  core.String? metricName;

  /// Rollout status of the future quota limit.
  /// Possible string values are:
  /// - "ROLLOUT_STATUS_UNSPECIFIED" : ROLLOUT_STATUS_UNSPECIFIED - Rollout
  /// status is not specified. The default value.
  /// - "IN_PROGRESS" : IN_PROGRESS - A rollout is in process which will change
  /// the limit value to future limit.
  core.String? rolloutStatus;

  $QuotaExceededInfo01({
    this.dimensions,
    this.futureLimit,
    this.limit,
    this.limitName,
    this.metricName,
    this.rolloutStatus,
  });

  $QuotaExceededInfo01.fromJson(core.Map json_)
    : this(
        dimensions: (json_['dimensions']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        futureLimit: (json_['futureLimit'] as core.num?)?.toDouble(),
        limit: (json_['limit'] as core.num?)?.toDouble(),
        limitName: json_['limitName'] as core.String?,
        metricName: json_['metricName'] as core.String?,
        rolloutStatus: json_['rolloutStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimensions != null) 'dimensions': dimensions!,
    if (futureLimit != null) 'futureLimit': futureLimit!,
    if (limit != null) 'limit': limit!,
    if (limitName != null) 'limitName': limitName!,
    if (metricName != null) 'metricName': metricName!,
    if (rolloutStatus != null) 'rolloutStatus': rolloutStatus!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : QuotaLimit
/// - serviceusage:v1 : QuotaLimit
/// - serviceusage:v1beta1 : QuotaLimit
class $QuotaLimit {
  /// Default number of tokens that can be consumed during the specified
  /// duration.
  ///
  /// This is the number of tokens assigned when a client application developer
  /// activates the service for his/her project. Specifying a value of 0 will
  /// block all requests. This can be used if you are provisioning quota to
  /// selected consumers and blocking others. Similarly, a value of -1 will
  /// indicate an unlimited quota. No other negative values are allowed. Used by
  /// group-based quotas only.
  core.String? defaultLimit;

  /// User-visible, extended description for this quota limit.
  ///
  /// Should be used only when more context is needed to understand this limit
  /// than provided by the limit's display name (see: `display_name`).
  ///
  /// Optional.
  core.String? description;

  /// User-visible display name for this limit.
  ///
  /// Optional. If not set, the UI will provide a default display name based on
  /// the quota configuration. This field can be used to override the default
  /// display name generated from the configuration.
  core.String? displayName;

  /// Duration of this limit in textual notation.
  ///
  /// Must be "100s" or "1d". Used by group-based quotas only.
  core.String? duration;

  /// Free tier value displayed in the Developers Console for this limit.
  ///
  /// The free tier is the number of tokens that will be subtracted from the
  /// billed amount when billing is enabled. This field can only be set on a
  /// limit with duration "1d", in a billable group; it is invalid on any other
  /// limit. If this field is not set, it defaults to 0, indicating that there
  /// is no free tier for this service. Used by group-based quotas only.
  core.String? freeTier;

  /// Maximum number of tokens that can be consumed during the specified
  /// duration.
  ///
  /// Client application developers can override the default limit up to this
  /// maximum. If specified, this value cannot be set to a value less than the
  /// default limit. If not specified, it is set to the default limit. To allow
  /// clients to apply overrides with no upper bound, set this to -1, indicating
  /// unlimited maximum quota. Used by group-based quotas only.
  core.String? maxLimit;

  /// The name of the metric this quota limit applies to.
  ///
  /// The quota limits with the same metric will be checked together during
  /// runtime. The metric must be defined within the service config.
  core.String? metric;

  /// Name of the quota limit.
  ///
  /// The name must be provided, and it must be unique within the service. The
  /// name can only include alphanumeric characters as well as '-'. The maximum
  /// length of the limit name is 64 characters.
  core.String? name;

  /// Specify the unit of the quota limit.
  ///
  /// It uses the same syntax as MetricDescriptor.unit. The supported unit kinds
  /// are determined by the quota backend system. Here are some examples: *
  /// "1/min/{project}" for quota per minute per project. Note: the order of
  /// unit components is insignificant. The "1" at the beginning is required to
  /// follow the metric unit syntax.
  core.String? unit;

  /// Tiered limit values.
  ///
  /// You must specify this as a key:value pair, with an integer value that is
  /// the maximum number of requests allowed for the specified unit. Currently
  /// only STANDARD is supported.
  core.Map<core.String, core.String>? values;

  $QuotaLimit({
    this.defaultLimit,
    this.description,
    this.displayName,
    this.duration,
    this.freeTier,
    this.maxLimit,
    this.metric,
    this.name,
    this.unit,
    this.values,
  });

  $QuotaLimit.fromJson(core.Map json_)
    : this(
        defaultLimit: json_['defaultLimit'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        duration: json_['duration'] as core.String?,
        freeTier: json_['freeTier'] as core.String?,
        maxLimit: json_['maxLimit'] as core.String?,
        metric: json_['metric'] as core.String?,
        name: json_['name'] as core.String?,
        unit: json_['unit'] as core.String?,
        values: (json_['values'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultLimit != null) 'defaultLimit': defaultLimit!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (duration != null) 'duration': duration!,
    if (freeTier != null) 'freeTier': freeTier!,
    if (maxLimit != null) 'maxLimit': maxLimit!,
    if (metric != null) 'metric': metric!,
    if (name != null) 'name': name!,
    if (unit != null) 'unit': unit!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - netapp:v1 : QuotaRule
/// - netapp:v1beta1 : QuotaRule
class $QuotaRule {
  /// Create time of the quota rule
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the quota rule
  ///
  /// Optional.
  core.String? description;

  /// The maximum allowed disk space in MiB.
  ///
  /// Required.
  core.int? diskLimitMib;

  /// Labels of the quota rule
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The resource name of the quota rule. Format:
  /// `projects/{project_number}/locations/{location_id}/volumes/volumes/{volume_id}/quotaRules/{quota_rule_id}`.
  core.String? name;

  /// State of the quota rule
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state for quota rule
  /// - "CREATING" : Quota rule is creating
  /// - "UPDATING" : Quota rule is updating
  /// - "DELETING" : Quota rule is deleting
  /// - "READY" : Quota rule is ready
  /// - "ERROR" : Quota rule is in error state.
  core.String? state;

  /// State details of the quota rule
  ///
  /// Output only.
  core.String? stateDetails;

  /// The quota rule applies to the specified user or group, identified by a
  /// Unix UID/GID, Windows SID, or null for default.
  ///
  /// Optional.
  core.String? target;

  /// The type of quota rule.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified type for quota rule
  /// - "INDIVIDUAL_USER_QUOTA" : Individual user quota rule
  /// - "INDIVIDUAL_GROUP_QUOTA" : Individual group quota rule
  /// - "DEFAULT_USER_QUOTA" : Default user quota rule
  /// - "DEFAULT_GROUP_QUOTA" : Default group quota rule
  core.String? type;

  $QuotaRule({
    this.createTime,
    this.description,
    this.diskLimitMib,
    this.labels,
    this.name,
    this.state,
    this.stateDetails,
    this.target,
    this.type,
  });

  $QuotaRule.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        diskLimitMib: json_['diskLimitMib'] as core.int?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        stateDetails: json_['stateDetails'] as core.String?,
        target: json_['target'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (diskLimitMib != null) 'diskLimitMib': diskLimitMib!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (stateDetails != null) 'stateDetails': stateDetails!,
    if (target != null) 'target': target!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessQuotaStatus
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessQuotaStatus
/// - analyticsdata:v1beta : QuotaStatus
class $QuotaStatus {
  /// Quota consumed by this request.
  core.int? consumed;

  /// Quota remaining after this request.
  core.int? remaining;

  $QuotaStatus({this.consumed, this.remaining});

  $QuotaStatus.fromJson(core.Map json_)
    : this(
        consumed: json_['consumed'] as core.int?,
        remaining: json_['remaining'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumed != null) 'consumed': consumed!,
    if (remaining != null) 'remaining': remaining!,
  };
}

/// Used by:
///
/// - container:v1 : RBACBindingConfig
/// - container:v1beta1 : RBACBindingConfig
class $RBACBindingConfig {
  /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
  /// with subjects system:authenticated.
  core.bool? enableInsecureBindingSystemAuthenticated;

  /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
  /// with subjets system:anonymous or system:unauthenticated.
  core.bool? enableInsecureBindingSystemUnauthenticated;

  $RBACBindingConfig({
    this.enableInsecureBindingSystemAuthenticated,
    this.enableInsecureBindingSystemUnauthenticated,
  });

  $RBACBindingConfig.fromJson(core.Map json_)
    : this(
        enableInsecureBindingSystemAuthenticated:
            json_['enableInsecureBindingSystemAuthenticated'] as core.bool?,
        enableInsecureBindingSystemUnauthenticated:
            json_['enableInsecureBindingSystemUnauthenticated'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableInsecureBindingSystemAuthenticated != null)
      'enableInsecureBindingSystemAuthenticated':
          enableInsecureBindingSystemAuthenticated!,
    if (enableInsecureBindingSystemUnauthenticated != null)
      'enableInsecureBindingSystemUnauthenticated':
          enableInsecureBindingSystemUnauthenticated!,
  };
}

/// Used by:
///
/// - gkehub:v1 : RBACRoleBindingActuationFeatureSpec
/// - gkehub:v1alpha : RBACRoleBindingActuationFeatureSpec
/// - gkehub:v1beta : RBACRoleBindingActuationFeatureSpec
class $RBACRoleBindingActuationFeatureSpec {
  /// The list of allowed custom roles (ClusterRoles).
  ///
  /// If a ClusterRole is not part of this list, it cannot be used in a Scope
  /// RBACRoleBinding. If a ClusterRole in this list is in use, it cannot be
  /// removed from the list.
  core.List<core.String>? allowedCustomRoles;

  $RBACRoleBindingActuationFeatureSpec({this.allowedCustomRoles});

  $RBACRoleBindingActuationFeatureSpec.fromJson(core.Map json_)
    : this(
        allowedCustomRoles:
            (json_['allowedCustomRoles'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedCustomRoles != null) 'allowedCustomRoles': allowedCustomRoles!,
  };
}

/// Used by:
///
/// - gkehub:v2 : RBACRoleBindingActuationRBACRoleBindingState
/// - gkehub:v2alpha : RBACRoleBindingActuationRBACRoleBindingState
/// - gkehub:v2beta : RBACRoleBindingActuationRBACRoleBindingState
class $RBACRoleBindingActuationRBACRoleBindingState {
  /// The reason for the failure.
  core.String? description;

  /// The state of the RBACRoleBinding.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ROLE_BINDING_STATE_UNSPECIFIED" : Unspecified state.
  /// - "OK" : RBACRoleBinding is created properly on the cluster.
  /// - "CUSTOM_ROLE_MISSING_FROM_CLUSTER" : The RBACRoleBinding was created on
  /// the cluster but the specified custom role does not exist on the cluster,
  /// hence the RBACRoleBinding has no effect.
  core.String? state;

  /// The time the RBACRoleBinding status was last updated.
  core.String? updateTime;

  $RBACRoleBindingActuationRBACRoleBindingState({
    this.description,
    this.state,
    this.updateTime,
  });

  $RBACRoleBindingActuationRBACRoleBindingState.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - gkehub:v1 : RBACRoleBindingLifecycleState
/// - gkehub:v1alpha : RBACRoleBindingLifecycleState
/// - gkehub:v1beta : RBACRoleBindingLifecycleState
class $RBACRoleBindingLifecycleState {
  /// The current state of the rbacrolebinding resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The rbacrolebinding is being created.
  /// - "READY" : The rbacrolebinding active.
  /// - "DELETING" : The rbacrolebinding is being deleted.
  /// - "UPDATING" : The rbacrolebinding is being updated.
  core.String? code;

  $RBACRoleBindingLifecycleState({this.code});

  $RBACRoleBindingLifecycleState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - redis:v1 : RDBConfig
/// - redis:v1beta1 : RDBConfig
class $RDBConfig {
  /// Period between RDB snapshots.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SNAPSHOT_PERIOD_UNSPECIFIED" : Not set.
  /// - "ONE_HOUR" : One hour.
  /// - "SIX_HOURS" : Six hours.
  /// - "TWELVE_HOURS" : Twelve hours.
  /// - "TWENTY_FOUR_HOURS" : Twenty four hours.
  core.String? rdbSnapshotPeriod;

  /// The time that the first snapshot was/will be attempted, and to which
  /// future snapshots will be aligned.
  ///
  /// If not provided, the current time will be used.
  ///
  /// Optional.
  core.String? rdbSnapshotStartTime;

  $RDBConfig({this.rdbSnapshotPeriod, this.rdbSnapshotStartTime});

  $RDBConfig.fromJson(core.Map json_)
    : this(
        rdbSnapshotPeriod: json_['rdbSnapshotPeriod'] as core.String?,
        rdbSnapshotStartTime: json_['rdbSnapshotStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rdbSnapshotPeriod != null) 'rdbSnapshotPeriod': rdbSnapshotPeriod!,
    if (rdbSnapshotStartTime != null)
      'rdbSnapshotStartTime': rdbSnapshotStartTime!,
  };
}

/// Used by:
///
/// - dns:v1 : RRSetRoutingPolicyLoadBalancerTarget
/// - dns:v1beta2 : RRSetRoutingPolicyLoadBalancerTarget
class $RRSetRoutingPolicyLoadBalancerTarget {
  /// The frontend IP address of the load balancer to health check.
  core.String? ipAddress;

  /// The protocol of the load balancer to health check.
  /// Possible string values are:
  /// - "undefined"
  /// - "tcp" : Indicates the load balancer is accessible via TCP.
  /// - "udp" : Indicates the load balancer is accessible via UDP.
  core.String? ipProtocol;
  core.String? kind;

  /// The type of load balancer specified by this target.
  ///
  /// This value must match the configuration of the load balancer located at
  /// the LoadBalancerTarget's IP address, port, and region. Use the following:
  /// - *regionalL4ilb*: for a regional internal passthrough Network Load
  /// Balancer. - *regionalL7ilb*: for a regional internal Application Load
  /// Balancer. - *globalL7ilb*: for a global internal Application Load
  /// Balancer.
  /// Possible string values are:
  /// - "none"
  /// - "globalL7ilb" : Indicates the load balancer is a Cross-Region
  /// Application Load Balancer.
  /// - "regionalL4ilb" : Indicates the load balancer is a Regional Network
  /// Passthrough Load Balancer.
  /// - "regionalL7ilb" : Indicates the load balancer is a Regional Application
  /// Load Balancer.
  core.String? loadBalancerType;

  /// The fully qualified URL of the network that the load balancer is attached
  /// to.
  ///
  /// This should be formatted like
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`.
  core.String? networkUrl;

  /// The configured port of the load balancer.
  core.String? port;

  /// The project ID in which the load balancer is located.
  core.String? project;

  /// The region in which the load balancer is located.
  core.String? region;

  $RRSetRoutingPolicyLoadBalancerTarget({
    this.ipAddress,
    this.ipProtocol,
    this.kind,
    this.loadBalancerType,
    this.networkUrl,
    this.port,
    this.project,
    this.region,
  });

  $RRSetRoutingPolicyLoadBalancerTarget.fromJson(core.Map json_)
    : this(
        ipAddress: json_['ipAddress'] as core.String?,
        ipProtocol: json_['ipProtocol'] as core.String?,
        kind: json_['kind'] as core.String?,
        loadBalancerType: json_['loadBalancerType'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
        port: json_['port'] as core.String?,
        project: json_['project'] as core.String?,
        region: json_['region'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipProtocol != null) 'ipProtocol': ipProtocol!,
    if (kind != null) 'kind': kind!,
    if (loadBalancerType != null) 'loadBalancerType': loadBalancerType!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
    if (port != null) 'port': port!,
    if (project != null) 'project': project!,
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagChunkPageSpan
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagChunkPageSpan
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RagChunkPageSpan
class $RagChunkPageSpan {
  /// Page where chunk starts in the document.
  ///
  /// Inclusive. 1-indexed.
  core.int? firstPage;

  /// Page where chunk ends in the document.
  ///
  /// Inclusive. 1-indexed.
  core.int? lastPage;

  $RagChunkPageSpan({this.firstPage, this.lastPage});

  $RagChunkPageSpan.fromJson(core.Map json_)
    : this(
        firstPage: json_['firstPage'] as core.int?,
        lastPage: json_['lastPage'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (firstPage != null) 'firstPage': firstPage!,
    if (lastPage != null) 'lastPage': lastPage!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint
class $RagEmbeddingModelConfigVertexPredictionEndpoint {
  /// The endpoint resource name.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// or `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Required.
  core.String? endpoint;

  /// The resource name of the model that is deployed on the endpoint.
  ///
  /// Present only when the endpoint is not a publisher model. Pattern:
  /// `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Output only.
  core.String? model;

  /// Version ID of the model that is deployed on the endpoint.
  ///
  /// Present only when the endpoint is not a publisher model.
  ///
  /// Output only.
  core.String? modelVersionId;

  $RagEmbeddingModelConfigVertexPredictionEndpoint({
    this.endpoint,
    this.model,
    this.modelVersionId,
  });

  $RagEmbeddingModelConfigVertexPredictionEndpoint.fromJson(core.Map json_)
    : this(
        endpoint: json_['endpoint'] as core.String?,
        model: json_['model'] as core.String?,
        modelVersionId: json_['modelVersionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoint != null) 'endpoint': endpoint!,
    if (model != null) 'model': model!,
    if (modelVersionId != null) 'modelVersionId': modelVersionId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagFileChunkingConfigFixedLengthChunking
class $RagFileChunkingConfigFixedLengthChunking {
  /// The overlap between chunks.
  core.int? chunkOverlap;

  /// The size of the chunks.
  core.int? chunkSize;

  $RagFileChunkingConfigFixedLengthChunking({
    this.chunkOverlap,
    this.chunkSize,
  });

  $RagFileChunkingConfigFixedLengthChunking.fromJson(core.Map json_)
    : this(
        chunkOverlap: json_['chunkOverlap'] as core.int?,
        chunkSize: json_['chunkSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkOverlap != null) 'chunkOverlap': chunkOverlap!,
    if (chunkSize != null) 'chunkSize': chunkSize!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagRetrievalConfigFilter
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagRetrievalConfigFilter
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RagRetrievalConfigFilter
class $RagRetrievalConfigFilter {
  /// String for metadata filtering.
  ///
  /// Optional.
  core.String? metadataFilter;

  /// Only returns contexts with vector distance smaller than the threshold.
  ///
  /// Optional.
  core.double? vectorDistanceThreshold;

  /// Only returns contexts with vector similarity larger than the threshold.
  ///
  /// Optional.
  core.double? vectorSimilarityThreshold;

  $RagRetrievalConfigFilter({
    this.metadataFilter,
    this.vectorDistanceThreshold,
    this.vectorSimilarityThreshold,
  });

  $RagRetrievalConfigFilter.fromJson(core.Map json_)
    : this(
        metadataFilter: json_['metadataFilter'] as core.String?,
        vectorDistanceThreshold:
            (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
        vectorSimilarityThreshold:
            (json_['vectorSimilarityThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadataFilter != null) 'metadataFilter': metadataFilter!,
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': vectorDistanceThreshold!,
    if (vectorSimilarityThreshold != null)
      'vectorSimilarityThreshold': vectorSimilarityThreshold!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagRetrievalConfigRankingLlmRanker
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingLlmRanker
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingLlmRanker
class $RagRetrievalConfigRankingLlmRanker {
  /// The model name used for ranking.
  ///
  /// See
  /// [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/inference#supported-models).
  ///
  /// Optional.
  core.String? modelName;

  $RagRetrievalConfigRankingLlmRanker({this.modelName});

  $RagRetrievalConfigRankingLlmRanker.fromJson(core.Map json_)
    : this(modelName: json_['modelName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagRetrievalConfigRankingRankService
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingRankService
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingRankService
class $RagRetrievalConfigRankingRankService {
  /// The model name of the rank service.
  ///
  /// Format: `semantic-ranker-512@latest`
  ///
  /// Optional.
  core.String? modelName;

  $RagRetrievalConfigRankingRankService({this.modelName});

  $RagRetrievalConfigRankingRankService.fromJson(core.Map json_)
    : this(modelName: json_['modelName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagVectorDbConfigPinecone
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagVectorDbConfigPinecone
class $RagVectorDbConfigPinecone {
  /// Pinecone index name.
  ///
  /// This value cannot be changed after it's set.
  core.String? indexName;

  $RagVectorDbConfigPinecone({this.indexName});

  $RagVectorDbConfigPinecone.fromJson(core.Map json_)
    : this(indexName: json_['indexName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (indexName != null) 'indexName': indexName!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagVectorDbConfigRagManagedDbANN
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbANN
class $RagVectorDbConfigRagManagedDbANN {
  /// Number of leaf nodes in the tree-based structure.
  ///
  /// Each leaf node contains groups of closely related vectors along with their
  /// corresponding centroid. Recommended value is 10 * sqrt(num of RagFiles in
  /// your RagCorpus). Default value is 500.
  core.int? leafCount;

  /// The depth of the tree-based structure.
  ///
  /// Only depth values of 2 and 3 are supported. Recommended value is 2 if you
  /// have if you have O(10K) files in the RagCorpus and set this to 3 if more
  /// than that. Default value is 2.
  core.int? treeDepth;

  $RagVectorDbConfigRagManagedDbANN({this.leafCount, this.treeDepth});

  $RagVectorDbConfigRagManagedDbANN.fromJson(core.Map json_)
    : this(
        leafCount: json_['leafCount'] as core.int?,
        treeDepth: json_['treeDepth'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (leafCount != null) 'leafCount': leafCount!,
    if (treeDepth != null) 'treeDepth': treeDepth!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexVectorSearch
class $RagVectorDbConfigVertexVectorSearch {
  /// The resource name of the Index.
  ///
  /// Format: `projects/{project}/locations/{location}/indexes/{index}`
  core.String? index;

  /// The resource name of the Index Endpoint.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  core.String? indexEndpoint;

  $RagVectorDbConfigVertexVectorSearch({this.index, this.indexEndpoint});

  $RagVectorDbConfigVertexVectorSearch.fromJson(core.Map json_)
    : this(
        index: json_['index'] as core.String?,
        indexEndpoint: json_['indexEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (index != null) 'index': index!,
    if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleApiDistributionRange
/// - discoveryengine:v1beta : GoogleApiDistributionRange
/// - monitoring:v3 : Range
class $Range {
  /// The maximum of the population values.
  core.double? max;

  /// The minimum of the population values.
  core.double? min;

  $Range({this.max, this.min});

  $Range.fromJson(core.Map json_)
    : this(
        max: (json_['max'] as core.num?)?.toDouble(),
        min: (json_['min'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (max != null) 'max': max!,
    if (min != null) 'min': min!,
  };
}

/// Used by:
///
/// - container:v1 : RangeInfo
/// - container:v1beta1 : RangeInfo
class $RangeInfo {
  /// Name of a range.
  ///
  /// Output only.
  core.String? rangeName;

  /// The utilization of the range.
  ///
  /// Output only.
  core.double? utilization;

  $RangeInfo({this.rangeName, this.utilization});

  $RangeInfo.fromJson(core.Map json_)
    : this(
        rangeName: json_['rangeName'] as core.String?,
        utilization: (json_['utilization'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rangeName != null) 'rangeName': rangeName!,
    if (utilization != null) 'utilization': utilization!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1RankingRecord
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaRankingRecord
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaRankingRecord
class $RankingRecord {
  /// The content of the record.
  ///
  /// Empty by default. At least one of title or content should be set otherwise
  /// an INVALID_ARGUMENT error is thrown.
  core.String? content;

  /// The unique ID to represent the record.
  core.String? id;

  /// The score of this record based on the given query and selected model.
  ///
  /// The score will be rounded to 2 decimal places. If the score is close to 0,
  /// it will be rounded to 0.0001 to avoid returning unset.
  core.double? score;

  /// The title of the record.
  ///
  /// Empty by default. At least one of title or content should be set otherwise
  /// an INVALID_ARGUMENT error is thrown.
  core.String? title;

  $RankingRecord({this.content, this.id, this.score, this.title});

  $RankingRecord.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        id: json_['id'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (id != null) 'id': id!,
    if (score != null) 'score': score!,
    if (title != null) 'title': title!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2Rating
/// - retail:v2alpha : GoogleCloudRetailV2alphaRating
/// - retail:v2beta : GoogleCloudRetailV2betaRating
class $Rating {
  /// The average rating of the Product.
  ///
  /// The rating is scaled at 1-5. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  core.double? averageRating;

  /// The total number of ratings.
  ///
  /// This value is independent of the value of rating_histogram. This value
  /// must be nonnegative. Otherwise, an INVALID_ARGUMENT error is returned.
  core.int? ratingCount;

  /// List of rating counts per rating value (index = rating - 1).
  ///
  /// The list is empty if there is no rating. If the list is non-empty, its
  /// size is always 5. Otherwise, an INVALID_ARGUMENT error is returned. For
  /// example, \[41, 14, 13, 47, 303\]. It means that the Product got 41 ratings
  /// with 1 star, 14 ratings with 2 star, and so on.
  core.List<core.int>? ratingHistogram;

  $Rating({this.averageRating, this.ratingCount, this.ratingHistogram});

  $Rating.fromJson(core.Map json_)
    : this(
        averageRating: (json_['averageRating'] as core.num?)?.toDouble(),
        ratingCount: json_['ratingCount'] as core.int?,
        ratingHistogram:
            (json_['ratingHistogram'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (averageRating != null) 'averageRating': averageRating!,
    if (ratingCount != null) 'ratingCount': ratingCount!,
    if (ratingHistogram != null) 'ratingHistogram': ratingHistogram!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1RawDocument
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3RawDocument
class $RawDocument {
  /// Inline document content.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The display name of the document, it supports all Unicode characters
  /// except the following: `*`, `?`, `[`, `]`, `%`, `{`, `}`,`'`, `\"`, `,`
  /// `~`, `=` and `:` are reserved.
  ///
  /// If not specified, a default ID is generated.
  core.String? displayName;

  /// An IANA MIME type (RFC6838) indicating the nature and format of the
  /// content.
  core.String? mimeType;

  $RawDocument({this.content, this.displayName, this.mimeType});

  $RawDocument.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (displayName != null) 'displayName': displayName!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - safebrowsing:v4 : GoogleSecuritySafebrowsingV4RawIndices
/// - webrisk:v1 : GoogleCloudWebriskV1RawIndices
class $RawIndices {
  /// The indices to remove from a lexicographically-sorted local list.
  core.List<core.int>? indices;

  $RawIndices({this.indices});

  $RawIndices.fromJson(core.Map json_)
    : this(
        indices:
            (json_['indices'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (indices != null) 'indices': indices!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RawOutput
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RawOutput
class $RawOutput {
  /// Raw output string.
  ///
  /// Output only.
  core.List<core.String>? rawOutput;

  $RawOutput({this.rawOutput});

  $RawOutput.fromJson(core.Map json_)
    : this(
        rawOutput:
            (json_['rawOutput'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rawOutput != null) 'rawOutput': rawOutput!,
  };
}

/// Used by:
///
/// - container:v1 : RayClusterLoggingConfig
/// - container:v1beta1 : RayClusterLoggingConfig
class $RayClusterLoggingConfig {
  /// Enable log collection for Ray clusters.
  core.bool? enabled;

  $RayClusterLoggingConfig({this.enabled});

  $RayClusterLoggingConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - container:v1 : RayClusterMonitoringConfig
/// - container:v1beta1 : RayClusterMonitoringConfig
class $RayClusterMonitoringConfig {
  /// Enable metrics collection for Ray clusters.
  core.bool? enabled;

  $RayClusterMonitoringConfig({this.enabled});

  $RayClusterMonitoringConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RayLogsSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RayLogsSpec
class $RayLogsSpec {
  /// Flag to disable the export of Ray OSS logs to Cloud Logging.
  ///
  /// Optional.
  core.bool? disabled;

  $RayLogsSpec({this.disabled});

  $RayLogsSpec.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RayMetricSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RayMetricSpec
class $RayMetricSpec {
  /// Flag to disable the Ray metrics collection.
  ///
  /// Optional.
  core.bool? disabled;

  $RayMetricSpec({this.disabled});

  $RayMetricSpec.fromJson(core.Map json_)
    : this(disabled: json_['disabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseFeatureDescriptor
class $ReadFeatureValuesResponseFeatureDescriptor {
  /// Feature ID.
  core.String? id;

  $ReadFeatureValuesResponseFeatureDescriptor({this.id});

  $ReadFeatureValuesResponseFeatureDescriptor.fromJson(core.Map json_)
    : this(id: json_['id'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {if (id != null) 'id': id!};
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReadIndexDatapointsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReadIndexDatapointsRequest
class $ReadIndexDatapointsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  core.String? deployedIndexId;

  /// IDs of the datapoints to be searched for.
  core.List<core.String>? ids;

  $ReadIndexDatapointsRequest({this.deployedIndexId, this.ids});

  $ReadIndexDatapointsRequest.fromJson(core.Map json_)
    : this(
        deployedIndexId: json_['deployedIndexId'] as core.String?,
        ids:
            (json_['ids'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
    if (ids != null) 'ids': ids!,
  };
}

/// Used by:
///
/// - datastore:v1 : ReadOnly
/// - datastore:v1beta3 : ReadOnly
class $ReadOnly00 {
  /// Reads entities at the given time.
  ///
  /// This must be a microsecond precision timestamp within the past one hour,
  /// or if Point-in-Time Recovery is enabled, can additionally be a whole
  /// minute timestamp within the past 7 days.
  core.String? readTime;

  $ReadOnly00({this.readTime});

  $ReadOnly00.fromJson(core.Map json_)
    : this(readTime: json_['readTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (readTime != null) 'readTime': readTime!,
  };
}

/// Used by:
///
/// - firestore:v1 : ReadOnly
/// - firestore:v1beta1 : ReadOnly
class $ReadOnly01 {
  /// Reads documents at the given time.
  ///
  /// This must be a microsecond precision timestamp within the past one hour,
  /// or if Point-in-Time Recovery is enabled, can additionally be a whole
  /// minute timestamp within the past 7 days.
  core.String? readTime;

  $ReadOnly01({this.readTime});

  $ReadOnly01.fromJson(core.Map json_)
    : this(readTime: json_['readTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (readTime != null) 'readTime': readTime!,
  };
}

/// Used by:
///
/// - alloydb:v1 : ReadPoolConfig
/// - alloydb:v1alpha : ReadPoolConfig
/// - alloydb:v1beta : ReadPoolConfig
class $ReadPoolConfig {
  /// Read capacity, i.e. number of nodes in a read pool instance.
  core.int? nodeCount;

  $ReadPoolConfig({this.nodeCount});

  $ReadPoolConfig.fromJson(core.Map json_)
    : this(nodeCount: json_['nodeCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeCount != null) 'nodeCount': nodeCount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReadTensorboardSizeResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReadTensorboardSizeResponse
class $ReadTensorboardSizeResponse {
  /// Payload storage size for the TensorBoard
  core.String? storageSizeByte;

  $ReadTensorboardSizeResponse({this.storageSizeByte});

  $ReadTensorboardSizeResponse.fromJson(core.Map json_)
    : this(storageSizeByte: json_['storageSizeByte'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (storageSizeByte != null) 'storageSizeByte': storageSizeByte!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerUserUsageData
class $ReadTensorboardUsageResponsePerUserUsageData {
  /// User's username
  core.String? username;

  /// Number of times the user has read data within the Tensorboard.
  core.String? viewCount;

  $ReadTensorboardUsageResponsePerUserUsageData({
    this.username,
    this.viewCount,
  });

  $ReadTensorboardUsageResponsePerUserUsageData.fromJson(core.Map json_)
    : this(
        username: json_['username'] as core.String?,
        viewCount: json_['viewCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (username != null) 'username': username!,
    if (viewCount != null) 'viewCount': viewCount!,
  };
}

/// Used by:
///
/// - datastore:v1 : ReadWrite
/// - datastore:v1beta3 : ReadWrite
class $ReadWrite00 {
  /// The transaction identifier of the transaction being retried.
  core.String? previousTransaction;
  core.List<core.int> get previousTransactionAsBytes =>
      convert.base64.decode(previousTransaction!);

  set previousTransactionAsBytes(core.List<core.int> bytes_) {
    previousTransaction = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $ReadWrite00({this.previousTransaction});

  $ReadWrite00.fromJson(core.Map json_)
    : this(previousTransaction: json_['previousTransaction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (previousTransaction != null)
      'previousTransaction': previousTransaction!,
  };
}

/// Used by:
///
/// - firestore:v1 : ReadWrite
/// - firestore:v1beta1 : ReadWrite
class $ReadWrite01 {
  /// An optional transaction to retry.
  core.String? retryTransaction;
  core.List<core.int> get retryTransactionAsBytes =>
      convert.base64.decode(retryTransaction!);

  set retryTransactionAsBytes(core.List<core.int> bytes_) {
    retryTransaction = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $ReadWrite01({this.retryTransaction});

  $ReadWrite01.fromJson(core.Map json_)
    : this(retryTransaction: json_['retryTransaction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (retryTransaction != null) 'retryTransaction': retryTransaction!,
  };
}

/// Used by:
///
/// - appengine:v1 : ReadinessCheck
/// - appengine:v1beta : ReadinessCheck
class $ReadinessCheck00 {
  /// A maximum time limit on application initialization, measured from moment
  /// the application successfully replies to a healthcheck until it is ready to
  /// serve traffic.
  core.String? appStartTimeout;

  /// Interval between health checks.
  core.String? checkInterval;

  /// Number of consecutive failed checks required before removing traffic.
  core.int? failureThreshold;

  /// Host header to send when performing a HTTP Readiness check.
  ///
  /// Example: "myapp.appspot.com"
  core.String? host;

  /// The request path.
  core.String? path;

  /// Number of consecutive successful checks required before receiving traffic.
  core.int? successThreshold;

  /// Time before the check is considered failed.
  core.String? timeout;

  $ReadinessCheck00({
    this.appStartTimeout,
    this.checkInterval,
    this.failureThreshold,
    this.host,
    this.path,
    this.successThreshold,
    this.timeout,
  });

  $ReadinessCheck00.fromJson(core.Map json_)
    : this(
        appStartTimeout: json_['appStartTimeout'] as core.String?,
        checkInterval: json_['checkInterval'] as core.String?,
        failureThreshold: json_['failureThreshold'] as core.int?,
        host: json_['host'] as core.String?,
        path: json_['path'] as core.String?,
        successThreshold: json_['successThreshold'] as core.int?,
        timeout: json_['timeout'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appStartTimeout != null) 'appStartTimeout': appStartTimeout!,
    if (checkInterval != null) 'checkInterval': checkInterval!,
    if (failureThreshold != null) 'failureThreshold': failureThreshold!,
    if (host != null) 'host': host!,
    if (path != null) 'path': path!,
    if (successThreshold != null) 'successThreshold': successThreshold!,
    if (timeout != null) 'timeout': timeout!,
  };
}

/// Used by:
///
/// - workstations:v1 : ReadinessCheck
/// - workstations:v1beta : ReadinessCheck
class $ReadinessCheck01 {
  /// Path to which the request should be sent.
  ///
  /// Optional.
  core.String? path;

  /// Port to which the request should be sent.
  ///
  /// Optional.
  core.int? port;

  $ReadinessCheck01({this.path, this.port});

  $ReadinessCheck01.fromJson(core.Map json_)
    : this(
        path: json_['path'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReasoningEngineSpecPackageSpec
class $ReasoningEngineSpecPackageSpec {
  /// The Cloud Storage URI of the dependency files in tar.gz format.
  ///
  /// Optional.
  core.String? dependencyFilesGcsUri;

  /// The Cloud Storage URI of the pickled python object.
  ///
  /// Optional.
  core.String? pickleObjectGcsUri;

  /// The Python version.
  ///
  /// Currently support 3.8, 3.9, 3.10, 3.11. If not specified, default value is
  /// 3.10.
  ///
  /// Optional.
  core.String? pythonVersion;

  /// The Cloud Storage URI of the `requirements.txt` file
  ///
  /// Optional.
  core.String? requirementsGcsUri;

  $ReasoningEngineSpecPackageSpec({
    this.dependencyFilesGcsUri,
    this.pickleObjectGcsUri,
    this.pythonVersion,
    this.requirementsGcsUri,
  });

  $ReasoningEngineSpecPackageSpec.fromJson(core.Map json_)
    : this(
        dependencyFilesGcsUri: json_['dependencyFilesGcsUri'] as core.String?,
        pickleObjectGcsUri: json_['pickleObjectGcsUri'] as core.String?,
        pythonVersion: json_['pythonVersion'] as core.String?,
        requirementsGcsUri: json_['requirementsGcsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dependencyFilesGcsUri != null)
      'dependencyFilesGcsUri': dependencyFilesGcsUri!,
    if (pickleObjectGcsUri != null) 'pickleObjectGcsUri': pickleObjectGcsUri!,
    if (pythonVersion != null) 'pythonVersion': pythonVersion!,
    if (requirementsGcsUri != null) 'requirementsGcsUri': requirementsGcsUri!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1RecaptchaEnterpriseConfig
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaRecaptchaEnterpriseConfig
class $RecaptchaEnterpriseConfig {
  /// The relative resource name of the reCAPTCHA Enterprise configuration
  /// object, in the format: ```
  /// projects/{project_number}/apps/{app_id}/recaptchaEnterpriseConfig ```
  ///
  /// Required.
  core.String? name;

  /// The score-based site key
  /// [created in reCAPTCHA Enterprise](https://cloud.google.com/recaptcha-enterprise/docs/create-key#creating_a_site_key)
  /// used to
  /// [invoke reCAPTCHA and generate the reCAPTCHA tokens](https://cloud.google.com/recaptcha-enterprise/docs/instrument-web-pages)
  /// for your application.
  ///
  /// Important: This is *not* the `site_secret` (as it is in reCAPTCHA v3), but
  /// rather your score-based reCAPTCHA Enterprise site key.
  core.String? siteKey;

  /// Specifies the duration for which App Check tokens exchanged from reCAPTCHA
  /// Enterprise tokens will be valid.
  ///
  /// If unset, a default value of 1 hour is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $RecaptchaEnterpriseConfig({this.name, this.siteKey, this.tokenTtl});

  $RecaptchaEnterpriseConfig.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        siteKey: json_['siteKey'] as core.String?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (siteKey != null) 'siteKey': siteKey!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1RecaptchaV3Config
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaRecaptchaV3Config
class $RecaptchaV3Config {
  /// The relative resource name of the reCAPTCHA v3 configuration object, in
  /// the format: ``` projects/{project_number}/apps/{app_id}/recaptchaV3Config
  /// ```
  ///
  /// Required.
  core.String? name;

  /// Input only.
  ///
  /// The site secret used to identify your service for reCAPTCHA v3
  /// verification. For security reasons, this field will never be populated in
  /// any response.
  ///
  /// Required.
  core.String? siteSecret;

  /// Whether the `site_secret` field was previously set.
  ///
  /// Since we will never return the `site_secret` field, this field is the only
  /// way to find out whether it was previously set.
  ///
  /// Output only.
  core.bool? siteSecretSet;

  /// Specifies the duration for which App Check tokens exchanged from reCAPTCHA
  /// tokens will be valid.
  ///
  /// If unset, a default value of 1 day is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $RecaptchaV3Config({
    this.name,
    this.siteSecret,
    this.siteSecretSet,
    this.tokenTtl,
  });

  $RecaptchaV3Config.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        siteSecret: json_['siteSecret'] as core.String?,
        siteSecretSet: json_['siteSecretSet'] as core.bool?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (siteSecret != null) 'siteSecret': siteSecret!,
    if (siteSecretSet != null) 'siteSecretSet': siteSecretSet!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Recipe
/// - ondemandscanning:v1 : Recipe
/// - ondemandscanning:v1beta1 : Recipe
class $Recipe {
  /// Collection of all external inputs that influenced the build on top of
  /// recipe.definedInMaterial and recipe.entryPoint.
  ///
  /// For example, if the recipe type were "make", then this might be the flags
  /// passed to make aside from the target, which is captured in
  /// recipe.entryPoint. Since the arguments field can greatly vary in
  /// structure, depending on the builder and recipe type, this is of form
  /// "Any".
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? arguments;

  /// Index in materials containing the recipe steps that are not implied by
  /// recipe.type.
  ///
  /// For example, if the recipe type were "make", then this would point to the
  /// source containing the Makefile, not the make program itself. Set to -1 if
  /// the recipe doesn't come from a material, as zero is default unset value
  /// for int64.
  core.String? definedInMaterial;

  /// String identifying the entry point into the build.
  ///
  /// This is often a path to a configuration file and/or a target label within
  /// that file. The syntax and meaning are defined by recipe.type. For example,
  /// if the recipe type were "make", then this would reference the directory in
  /// which to run make as well as which target to use.
  core.String? entryPoint;

  /// Any other builder-controlled inputs necessary for correctly evaluating the
  /// recipe.
  ///
  /// Usually only needed for reproducing the build but not evaluated as part of
  /// policy. Since the environment field can greatly vary in structure,
  /// depending on the builder and recipe type, this is of form "Any".
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? environment;

  /// URI indicating what type of recipe was performed.
  ///
  /// It determines the meaning of recipe.entryPoint, recipe.arguments,
  /// recipe.environment, and materials.
  core.String? type;

  $Recipe({
    this.arguments,
    this.definedInMaterial,
    this.entryPoint,
    this.environment,
    this.type,
  });

  $Recipe.fromJson(core.Map json_)
    : this(
        arguments:
            (json_['arguments'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        definedInMaterial: json_['definedInMaterial'] as core.String?,
        entryPoint: json_['entryPoint'] as core.String?,
        environment:
            (json_['environment'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (arguments != null) 'arguments': arguments!,
    if (definedInMaterial != null) 'definedInMaterial': definedInMaterial!,
    if (entryPoint != null) 'entryPoint': entryPoint!,
    if (environment != null) 'environment': environment!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - speech:v1 : RecognitionAudio
/// - speech:v1p1beta1 : RecognitionAudio
class $RecognitionAudio {
  /// The audio data bytes encoded as specified in `RecognitionConfig`.
  ///
  /// Note: as with all bytes fields, proto buffers use a pure binary
  /// representation, whereas JSON representations use base64.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// URI that points to a file that contains audio data bytes as specified in
  /// `RecognitionConfig`.
  ///
  /// The file must not be compressed (for example, gzip). Currently, only
  /// Google Cloud Storage URIs are supported, which must be specified in the
  /// following format: `gs://bucket_name/object_name` (other URI formats return
  /// google.rpc.Code.INVALID_ARGUMENT). For more information, see
  /// [Request URIs](https://cloud.google.com/storage/docs/reference-uris).
  core.String? uri;

  $RecognitionAudio({this.content, this.uri});

  $RecognitionAudio.fromJson(core.Map json_)
    : this(
        content: json_['content'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1RecommendationInsightReference
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1RecommendationInsightReference
class $RecommendationInsightReference {
  /// Insight resource name, e.g.
  /// projects/\[PROJECT_NUMBER\]/locations/\[LOCATION\]/insightTypes/\[INSIGHT_TYPE_ID\]/insights/\[INSIGHT_ID\]
  core.String? insight;

  $RecommendationInsightReference({this.insight});

  $RecommendationInsightReference.fromJson(core.Map json_)
    : this(insight: json_['insight'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (insight != null) 'insight': insight!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1RecommendationStateInfo
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1RecommendationStateInfo
class $RecommendationStateInfo {
  /// The state of the recommendation, Eg ACTIVE, SUCCEEDED, FAILED.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default state. Don't use directly.
  /// - "ACTIVE" : Recommendation is active and can be applied. Recommendations
  /// content can be updated by Google. ACTIVE recommendations can be marked as
  /// CLAIMED, SUCCEEDED, or FAILED.
  /// - "CLAIMED" : Recommendation is in claimed state. Recommendations content
  /// is immutable and cannot be updated by Google. CLAIMED recommendations can
  /// be marked as CLAIMED, SUCCEEDED, or FAILED.
  /// - "SUCCEEDED" : Recommendation is in succeeded state. Recommendations
  /// content is immutable and cannot be updated by Google. SUCCEEDED
  /// recommendations can be marked as SUCCEEDED, or FAILED.
  /// - "FAILED" : Recommendation is in failed state. Recommendations content is
  /// immutable and cannot be updated by Google. FAILED recommendations can be
  /// marked as SUCCEEDED, or FAILED.
  /// - "DISMISSED" : Recommendation is in dismissed state. Recommendation
  /// content can be updated by Google. DISMISSED recommendations can be marked
  /// as ACTIVE.
  core.String? state;

  /// A map of metadata for the state, provided by user or automations systems.
  core.Map<core.String, core.String>? stateMetadata;

  $RecommendationStateInfo({this.state, this.stateMetadata});

  $RecommendationStateInfo.fromJson(core.Map json_)
    : this(
        state: json_['state'] as core.String?,
        stateMetadata: (json_['stateMetadata']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
    if (stateMetadata != null) 'stateMetadata': stateMetadata!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1RecommenderGenerationConfig
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1RecommenderGenerationConfig
class $RecommenderGenerationConfig {
  /// Parameters for this RecommenderGenerationConfig.
  ///
  /// These configs can be used by or are applied to all subtypes.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  $RecommenderGenerationConfig({this.params});

  $RecommenderGenerationConfig.fromJson(core.Map json_)
    : this(
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (params != null) 'params': params!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : ReconfigureTrustRequest
/// - managedidentities:v1beta1 : ReconfigureTrustRequest
class $ReconfigureTrustRequest {
  /// The target DNS server IP addresses to resolve the remote domain involved
  /// in the trust.
  ///
  /// Required.
  core.List<core.String>? targetDnsIpAddresses;

  /// The fully-qualified target domain name which will be in trust with current
  /// domain.
  ///
  /// Required.
  core.String? targetDomainName;

  $ReconfigureTrustRequest({this.targetDnsIpAddresses, this.targetDomainName});

  $ReconfigureTrustRequest.fromJson(core.Map json_)
    : this(
        targetDnsIpAddresses:
            (json_['targetDnsIpAddresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetDomainName: json_['targetDomainName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetDnsIpAddresses != null)
      'targetDnsIpAddresses': targetDnsIpAddresses!,
    if (targetDomainName != null) 'targetDomainName': targetDomainName!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1RecrawlUrisRequest
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaRecrawlUrisRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaRecrawlUrisRequest
class $RecrawlUrisRequest {
  /// Credential id to use for crawling.
  ///
  /// Optional.
  core.String? siteCredential;

  /// List of URIs to crawl.
  ///
  /// At most 10K URIs are supported, otherwise an INVALID_ARGUMENT error is
  /// thrown. Each URI should match at least one TargetSite in
  /// `site_search_engine`.
  ///
  /// Required.
  core.List<core.String>? uris;

  $RecrawlUrisRequest({this.siteCredential, this.uris});

  $RecrawlUrisRequest.fromJson(core.Map json_)
    : this(
        siteCredential: json_['siteCredential'] as core.String?,
        uris:
            (json_['uris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (siteCredential != null) 'siteCredential': siteCredential!,
    if (uris != null) 'uris': uris!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : Redirect
/// - firebaseapphosting:v1beta : Redirect
class $Redirect {
  /// The status code to use in a redirect response.
  ///
  /// Must be a valid HTTP 3XX status code. Defaults to 302 if not present.
  ///
  /// Optional.
  core.String? status;

  /// The URI of the redirect's intended destination.
  ///
  /// This URI will be prepended to the original request path. URI without a
  /// scheme are assumed to be HTTPS.
  ///
  /// Required.
  core.String? uri;

  $Redirect({this.status, this.uri});

  $Redirect.fromJson(core.Map json_)
    : this(
        status: json_['status'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (status != null) 'status': status!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : RedisClusterInfo
/// - networkmanagement:v1beta1 : RedisClusterInfo
class $RedisClusterInfo {
  /// Discovery endpoint IP address of a Redis Cluster.
  core.String? discoveryEndpointIpAddress;

  /// Name of a Redis Cluster.
  core.String? displayName;

  /// Name of the region in which the Redis Cluster is defined.
  ///
  /// For example, "us-central1".
  core.String? location;

  /// URI of the network containing the Redis Cluster endpoints in format
  /// "projects/{project_id}/global/networks/{network_id}".
  core.String? networkUri;

  /// Secondary endpoint IP address of a Redis Cluster.
  core.String? secondaryEndpointIpAddress;

  /// URI of a Redis Cluster in format
  /// "projects/{project_id}/locations/{location}/clusters/{cluster_id}"
  core.String? uri;

  $RedisClusterInfo({
    this.discoveryEndpointIpAddress,
    this.displayName,
    this.location,
    this.networkUri,
    this.secondaryEndpointIpAddress,
    this.uri,
  });

  $RedisClusterInfo.fromJson(core.Map json_)
    : this(
        discoveryEndpointIpAddress:
            json_['discoveryEndpointIpAddress'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        location: json_['location'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        secondaryEndpointIpAddress:
            json_['secondaryEndpointIpAddress'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (discoveryEndpointIpAddress != null)
      'discoveryEndpointIpAddress': discoveryEndpointIpAddress!,
    if (displayName != null) 'displayName': displayName!,
    if (location != null) 'location': location!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (secondaryEndpointIpAddress != null)
      'secondaryEndpointIpAddress': secondaryEndpointIpAddress!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : RedisInstanceInfo
/// - networkmanagement:v1beta1 : RedisInstanceInfo
class $RedisInstanceInfo {
  /// Name of a Cloud Redis Instance.
  core.String? displayName;

  /// URI of a Cloud Redis Instance network.
  core.String? networkUri;

  /// Primary endpoint IP address of a Cloud Redis Instance.
  core.String? primaryEndpointIp;

  /// Read endpoint IP address of a Cloud Redis Instance (if applicable).
  core.String? readEndpointIp;

  /// Region in which the Cloud Redis Instance is defined.
  core.String? region;

  /// URI of a Cloud Redis Instance.
  core.String? uri;

  $RedisInstanceInfo({
    this.displayName,
    this.networkUri,
    this.primaryEndpointIp,
    this.readEndpointIp,
    this.region,
    this.uri,
  });

  $RedisInstanceInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        primaryEndpointIp: json_['primaryEndpointIp'] as core.String?,
        readEndpointIp: json_['readEndpointIp'] as core.String?,
        region: json_['region'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (primaryEndpointIp != null) 'primaryEndpointIp': primaryEndpointIp!,
    if (readEndpointIp != null) 'readEndpointIp': readEndpointIp!,
    if (region != null) 'region': region!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - compute:alpha : Reference
/// - compute:beta : Reference
/// - compute:v1 : Reference
class $Reference {
  /// Type of the resource.
  ///
  /// Always compute#reference for references.
  ///
  /// Output only.
  core.String? kind;

  /// A description of the reference type with no implied semantics.
  ///
  /// Possible values include: 1. MEMBER_OF
  core.String? referenceType;

  /// URL of the resource which refers to the target.
  core.String? referrer;

  /// URL of the resource to which this reference points.
  core.String? target;

  $Reference({this.kind, this.referenceType, this.referrer, this.target});

  $Reference.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        referenceType: json_['referenceType'] as core.String?,
        referrer: json_['referrer'] as core.String?,
        target: json_['target'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (referenceType != null) 'referenceType': referenceType!,
    if (referrer != null) 'referrer': referrer!,
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - content:v2.1 : BreakdownRegion
/// - merchantapi:issueresolution_v1beta : Region
class $Region {
  /// The
  /// [CLDR territory code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml)
  core.String? code;

  /// The localized name of the region.
  ///
  /// For region with code='001' the value is 'All countries' or the equivalent
  /// in other languages.
  core.String? name;

  $Region({this.code, this.name});

  $Region.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionAddressesMoveRequest
/// - compute:beta : RegionAddressesMoveRequest
/// - compute:v1 : RegionAddressesMoveRequest
class $RegionAddressesMoveRequest {
  /// An optional destination address description if intended to be different
  /// from the source.
  core.String? description;

  /// The URL of the destination address to move to.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a address: -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region
  /// /addresses/address - projects/project/regions/region/addresses/address
  /// Note that destination project must be different from the source project.
  /// So /regions/region/addresses/address is not valid partial url.
  core.String? destinationAddress;

  $RegionAddressesMoveRequest({this.description, this.destinationAddress});

  $RegionAddressesMoveRequest.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        destinationAddress: json_['destinationAddress'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (destinationAddress != null) 'destinationAddress': destinationAddress!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionDisksAddResourcePoliciesRequest
/// - compute:beta : RegionDisksAddResourcePoliciesRequest
/// - compute:v1 : RegionDisksAddResourcePoliciesRequest
class $RegionDisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  core.List<core.String>? resourcePolicies;

  $RegionDisksAddResourcePoliciesRequest({this.resourcePolicies});

  $RegionDisksAddResourcePoliciesRequest.fromJson(core.Map json_)
    : this(
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionDisksResizeRequest
/// - compute:beta : RegionDisksResizeRequest
/// - compute:v1 : RegionDisksResizeRequest
class $RegionDisksResizeRequest {
  /// The new size of the regional persistent disk, which is specified in GB.
  core.String? sizeGb;

  $RegionDisksResizeRequest({this.sizeGb});

  $RegionDisksResizeRequest.fromJson(core.Map json_)
    : this(sizeGb: json_['sizeGb'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionInstanceGroupManagersDeleteInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersDeleteInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersDeleteInstancesRequest
class $RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// Specifies whether the request should proceed despite the inclusion of
  /// instances that are not members of the group or that are already in the
  /// process of being deleted or abandoned.
  ///
  /// If this field is set to `false` and such an instance is specified in the
  /// request, the operation fails. The operation always fails if the request
  /// contains a malformed instance URL or a reference to an instance that
  /// exists in a zone or region other than the group's zone or region.
  core.bool? skipInstancesOnValidationError;

  $RegionInstanceGroupManagersDeleteInstancesRequest({
    this.instances,
    this.skipInstancesOnValidationError,
  });

  $RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        skipInstancesOnValidationError:
            json_['skipInstancesOnValidationError'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (skipInstancesOnValidationError != null)
      'skipInstancesOnValidationError': skipInstancesOnValidationError!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionInstanceGroupManagersResizeAdvancedRequest
/// - compute:beta : RegionInstanceGroupManagersResizeAdvancedRequest
class $RegionInstanceGroupManagersResizeAdvancedRequest {
  /// If this flag is true, the managed instance group attempts to create all
  /// instances initiated by this resize request only once.
  ///
  /// If there is an error during creation, the managed instance group does not
  /// retry create this instance, and we will decrease the targetSize of the
  /// request instead. If the flag is false, the group attempts to recreate each
  /// instance continuously until it succeeds. This flag matters only in the
  /// first attempt of creation of an instance. After an instance is
  /// successfully created while this flag is enabled, the instance behaves the
  /// same way as all the other instances created with a regular resize request.
  /// In particular, if a running instance dies unexpectedly at a later time and
  /// needs to be recreated, this mode does not affect the recreation behavior
  /// in that scenario. This flag is applicable only to the current resize
  /// request. It does not influence other resize requests in any way. You can
  /// see which instances ar being created in which mode by calling the get or
  /// listManagedInstances API.
  core.bool? noCreationRetries;

  /// The number of running instances that the managed instance group should
  /// maintain at any given time.
  ///
  /// The group automatically adds or removes instances to maintain the number
  /// of instances specified by this parameter.
  core.int? targetSize;

  $RegionInstanceGroupManagersResizeAdvancedRequest({
    this.noCreationRetries,
    this.targetSize,
  });

  $RegionInstanceGroupManagersResizeAdvancedRequest.fromJson(core.Map json_)
    : this(
        noCreationRetries: json_['noCreationRetries'] as core.bool?,
        targetSize: json_['targetSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (noCreationRetries != null) 'noCreationRetries': noCreationRetries!,
    if (targetSize != null) 'targetSize': targetSize!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionInstanceGroupManagersSetTargetPoolsRequest
/// - compute:beta : RegionInstanceGroupManagersSetTargetPoolsRequest
/// - compute:v1 : RegionInstanceGroupManagersSetTargetPoolsRequest
class $RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents.
  ///
  /// This field is used for optimistic locking when you update the target pool
  /// entries. This field is optional.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group.
  core.List<core.String>? targetPools;

  $RegionInstanceGroupManagersSetTargetPoolsRequest({
    this.fingerprint,
    this.targetPools,
  });

  $RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map json_)
    : this(
        fingerprint: json_['fingerprint'] as core.String?,
        targetPools:
            (json_['targetPools'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (targetPools != null) 'targetPools': targetPools!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionInstanceGroupManagersSetTemplateRequest
/// - compute:beta : RegionInstanceGroupManagersSetTemplateRequest
/// - compute:v1 : RegionInstanceGroupManagersSetTemplateRequest
class $RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String? instanceTemplate;

  $RegionInstanceGroupManagersSetTemplateRequest({this.instanceTemplate});

  $RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map json_)
    : this(instanceTemplate: json_['instanceTemplate'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionInstanceGroupsListInstancesRequest
/// - compute:beta : RegionInstanceGroupsListInstancesRequest
/// - compute:v1 : RegionInstanceGroupsListInstancesRequest
class $RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned.
  ///
  /// Valid options are: 'ALL', 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL" : Matches any status of the instances, running, non-running and
  /// others.
  /// - "RUNNING" : Instance is in RUNNING state if it is running.
  core.String? instanceState;

  /// Name of port user is interested in.
  ///
  /// It is optional. If it is set, only information about this ports will be
  /// returned. If it is not set, all the named ports will be returned. Always
  /// lists all instances.
  core.String? portName;

  $RegionInstanceGroupsListInstancesRequest({
    this.instanceState,
    this.portName,
  });

  $RegionInstanceGroupsListInstancesRequest.fromJson(core.Map json_)
    : this(
        instanceState: json_['instanceState'] as core.String?,
        portName: json_['portName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceState != null) 'instanceState': instanceState!,
    if (portName != null) 'portName': portName!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : RegionPreferences
/// - migrationcenter:v1alpha1 : RegionPreferences
class $RegionPreferences {
  /// A list of preferred regions, ordered by the most preferred region first.
  ///
  /// Set only valid Google Cloud region names. See
  /// https://cloud.google.com/compute/docs/regions-zones for available regions.
  core.List<core.String>? preferredRegions;

  $RegionPreferences({this.preferredRegions});

  $RegionPreferences.fromJson(core.Map json_)
    : this(
        preferredRegions:
            (json_['preferredRegions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (preferredRegions != null) 'preferredRegions': preferredRegions!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionTargetHttpsProxiesSetSslCertificatesRequest
/// - compute:beta : RegionTargetHttpsProxiesSetSslCertificatesRequest
/// - compute:v1 : RegionTargetHttpsProxiesSetSslCertificatesRequest
class $RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  core.List<core.String>? sslCertificates;

  $RegionTargetHttpsProxiesSetSslCertificatesRequest({this.sslCertificates});

  $RegionTargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map json_)
    : this(
        sslCertificates:
            (json_['sslCertificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sslCertificates != null) 'sslCertificates': sslCertificates!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : RegionalLocationListAssignedTargetingOptionDetails
/// - displayvideo:v3 : RegionalLocationListAssignedTargetingOptionDetails
/// - displayvideo:v4 : RegionalLocationListAssignedTargetingOptionDetails
class $RegionalLocationListAssignedTargetingOptionDetails {
  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// ID of the regional location list.
  ///
  /// Should refer to the location_list_id field of a LocationList resource
  /// whose type is `TARGETING_LOCATION_TYPE_REGIONAL`.
  ///
  /// Required.
  core.String? regionalLocationListId;

  $RegionalLocationListAssignedTargetingOptionDetails({
    this.negative,
    this.regionalLocationListId,
  });

  $RegionalLocationListAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        negative: json_['negative'] as core.bool?,
        regionalLocationListId: json_['regionalLocationListId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (negative != null) 'negative': negative!,
    if (regionalLocationListId != null)
      'regionalLocationListId': regionalLocationListId!,
  };
}

/// Used by:
///
/// - tpu:v1 : ReimageNodeRequest
/// - tpu:v1alpha1 : ReimageNodeRequest
class $ReimageNodeRequest {
  /// The version for reimage to create.
  core.String? tensorflowVersion;

  $ReimageNodeRequest({this.tensorflowVersion});

  $ReimageNodeRequest.fromJson(core.Map json_)
    : this(tensorflowVersion: json_['tensorflowVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (tensorflowVersion != null) 'tensorflowVersion': tensorflowVersion!,
  };
}

/// Used by:
///
/// - healthcare:v1 : RejectConsentRequest
/// - healthcare:v1beta1 : RejectConsentRequest
class $RejectConsentRequest {
  /// The resource name of the Consent artifact that contains documentation of
  /// the user's rejection of the draft Consent, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
  ///
  /// If the draft Consent had a Consent artifact, this Consent artifact
  /// overwrites it.
  ///
  /// Optional.
  core.String? consentArtifact;

  $RejectConsentRequest({this.consentArtifact});

  $RejectConsentRequest.fromJson(core.Map json_)
    : this(consentArtifact: json_['consentArtifact'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (consentArtifact != null) 'consentArtifact': consentArtifact!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RejoinUserEventsRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaRejoinUserEventsRequest
/// - retail:v2beta : GoogleCloudRetailV2betaRejoinUserEventsRequest
class $RejoinUserEventsRequest {
  /// The type of the user event rejoin to define the scope and range of the
  /// user events to be rejoined with the latest product catalog.
  ///
  /// Defaults to `USER_EVENT_REJOIN_SCOPE_UNSPECIFIED` if this field is not
  /// set, or set to an invalid integer value.
  /// Possible string values are:
  /// - "USER_EVENT_REJOIN_SCOPE_UNSPECIFIED" : Rejoin all events with the
  /// latest product catalog, including both joined events and unjoined events.
  /// - "JOINED_EVENTS" : Only rejoin joined events with the latest product
  /// catalog.
  /// - "UNJOINED_EVENTS" : Only rejoin unjoined events with the latest product
  /// catalog.
  core.String? userEventRejoinScope;

  $RejoinUserEventsRequest({this.userEventRejoinScope});

  $RejoinUserEventsRequest.fromJson(core.Map json_)
    : this(userEventRejoinScope: json_['userEventRejoinScope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (userEventRejoinScope != null)
      'userEventRejoinScope': userEventRejoinScope!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : RelatedUrl
/// - containeranalysis:v1beta1 : RelatedUrl
/// - ondemandscanning:v1 : RelatedUrl
/// - ondemandscanning:v1beta1 : RelatedUrl
class $RelatedUrl {
  /// Label to describe usage of the URL.
  core.String? label;

  /// Specific URL associated with the resource.
  core.String? url;

  $RelatedUrl({this.label, this.url});

  $RelatedUrl.fromJson(core.Map json_)
    : this(
        label: json_['label'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (label != null) 'label': label!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : Relation
/// - migrationcenter:v1alpha1 : Relation
class $Relation {
  /// The timestamp when the relation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The destination asset name in the relation.
  ///
  /// Output only.
  core.String? dstAsset;

  /// Identifier.
  ///
  /// The identifier of the relation.
  ///
  /// Output only.
  core.String? name;

  /// The source asset name in the relation.
  ///
  /// Output only.
  core.String? srcAsset;

  /// The type of the relation.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value.
  /// - "LOGICAL_DATABASE" : DBDeployment -\> Database
  /// - "DATABASE_DEPLOYMENT_HOSTING_SERVER" : A relation between a machine/VM
  /// and the database deployment it hosts.
  core.String? type;

  $Relation({
    this.createTime,
    this.dstAsset,
    this.name,
    this.srcAsset,
    this.type,
  });

  $Relation.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dstAsset: json_['dstAsset'] as core.String?,
        name: json_['name'] as core.String?,
        srcAsset: json_['srcAsset'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dstAsset != null) 'dstAsset': dstAsset!,
    if (name != null) 'name': name!,
    if (srcAsset != null) 'srcAsset': srcAsset!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : RelationshipNote
/// - containeranalysis:v1beta1 : RelationshipNote
class $RelationshipNote {
  /// The type of relationship between the source and target SPDX elements
  /// Possible string values are:
  /// - "RELATIONSHIP_TYPE_UNSPECIFIED" : Unspecified
  /// - "DESCRIBES" : Is to be used when SPDXRef-DOCUMENT describes SPDXRef-A
  /// - "DESCRIBED_BY" : Is to be used when SPDXRef-A is described by
  /// SPDXREF-Document
  /// - "CONTAINS" : Is to be used when SPDXRef-A contains SPDXRef-B
  /// - "CONTAINED_BY" : Is to be used when SPDXRef-A is contained by SPDXRef-B
  /// - "DEPENDS_ON" : Is to be used when SPDXRef-A depends on SPDXRef-B
  /// - "DEPENDENCY_OF" : Is to be used when SPDXRef-A is dependency of
  /// SPDXRef-B
  /// - "DEPENDENCY_MANIFEST_OF" : Is to be used when SPDXRef-A is a manifest
  /// file that lists a set of dependencies for SPDXRef-B
  /// - "BUILD_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a build
  /// dependency of SPDXRef-B
  /// - "DEV_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a development
  /// dependency of SPDXRef-B
  /// - "OPTIONAL_DEPENDENCY_OF" : Is to be used when SPDXRef-A is an optional
  /// dependency of SPDXRef-B
  /// - "PROVIDED_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a to be
  /// provided dependency of SPDXRef-B
  /// - "TEST_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a test dependency
  /// of SPDXRef-B
  /// - "RUNTIME_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a dependency
  /// required for the execution of SPDXRef-B
  /// - "EXAMPLE_OF" : Is to be used when SPDXRef-A is an example of SPDXRef-B
  /// - "GENERATES" : Is to be used when SPDXRef-A generates SPDXRef-B
  /// - "GENERATED_FROM" : Is to be used when SPDXRef-A was generated from
  /// SPDXRef-B
  /// - "ANCESTOR_OF" : Is to be used when SPDXRef-A is an ancestor (same
  /// lineage but pre-dates) SPDXRef-B
  /// - "DESCENDANT_OF" : Is to be used when SPDXRef-A is a descendant of (same
  /// lineage but postdates) SPDXRef-B
  /// - "VARIANT_OF" : Is to be used when SPDXRef-A is a variant of (same
  /// lineage but not clear which came first) SPDXRef-B
  /// - "DISTRIBUTION_ARTIFACT" : Is to be used when distributing SPDXRef-A
  /// requires that SPDXRef-B also be distributed
  /// - "PATCH_FOR" : Is to be used when SPDXRef-A is a patch file for (to be
  /// applied to) SPDXRef-B
  /// - "PATCH_APPLIED" : Is to be used when SPDXRef-A is a patch file that has
  /// been applied to SPDXRef-B
  /// - "COPY_OF" : Is to be used when SPDXRef-A is an exact copy of SPDXRef-B
  /// - "FILE_ADDED" : Is to be used when SPDXRef-A is a file that was added to
  /// SPDXRef-B
  /// - "FILE_DELETED" : Is to be used when SPDXRef-A is a file that was deleted
  /// from SPDXRef-B
  /// - "FILE_MODIFIED" : Is to be used when SPDXRef-A is a file that was
  /// modified from SPDXRef-B
  /// - "EXPANDED_FROM_ARCHIVE" : Is to be used when SPDXRef-A is expanded from
  /// the archive SPDXRef-B
  /// - "DYNAMIC_LINK" : Is to be used when SPDXRef-A dynamically links to
  /// SPDXRef-B
  /// - "STATIC_LINK" : Is to be used when SPDXRef-A statically links to
  /// SPDXRef-B
  /// - "DATA_FILE_OF" : Is to be used when SPDXRef-A is a data file used in
  /// SPDXRef-B
  /// - "TEST_CASE_OF" : Is to be used when SPDXRef-A is a test case used in
  /// testing SPDXRef-B
  /// - "BUILD_TOOL_OF" : Is to be used when SPDXRef-A is used to build
  /// SPDXRef-B
  /// - "DEV_TOOL_OF" : Is to be used when SPDXRef-A is used as a development
  /// tool for SPDXRef-B
  /// - "TEST_OF" : Is to be used when SPDXRef-A is used for testing SPDXRef-B
  /// - "TEST_TOOL_OF" : Is to be used when SPDXRef-A is used as a test tool for
  /// SPDXRef-B
  /// - "DOCUMENTATION_OF" : Is to be used when SPDXRef-A provides documentation
  /// of SPDXRef-B
  /// - "OPTIONAL_COMPONENT_OF" : Is to be used when SPDXRef-A is an optional
  /// component of SPDXRef-B
  /// - "METAFILE_OF" : Is to be used when SPDXRef-A is a metafile of SPDXRef-B
  /// - "PACKAGE_OF" : Is to be used when SPDXRef-A is used as a package as part
  /// of SPDXRef-B
  /// - "AMENDS" : Is to be used when (current) SPDXRef-DOCUMENT amends the SPDX
  /// information in SPDXRef-B
  /// - "PREREQUISITE_FOR" : Is to be used when SPDXRef-A is a prerequisite for
  /// SPDXRef-B
  /// - "HAS_PREREQUISITE" : Is to be used when SPDXRef-A has as a prerequisite
  /// SPDXRef-B
  /// - "OTHER" : Is to be used for a relationship which has not been defined in
  /// the formal SPDX specification. A description of the relationship should be
  /// included in the Relationship comments field
  core.String? type;

  $RelationshipNote({this.type});

  $RelationshipNote.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - containeranalysis:v1alpha1 : RelationshipOccurrence
/// - containeranalysis:v1beta1 : RelationshipOccurrence
class $RelationshipOccurrence {
  /// A place for the SPDX file creator to record any general comments about the
  /// relationship
  core.String? comment;

  /// Also referred to as SPDXRef-A The source SPDX element (file, package, etc)
  core.String? source;

  /// Also referred to as SPDXRef-B The target SPDC element (file, package, etc)
  /// In cases where there are "known unknowns", the use of the keyword
  /// NOASSERTION can be used The keywords NONE can be used to indicate that an
  /// SPDX element (package/file/snippet) has no other elements connected by
  /// some relationship to it
  core.String? target;

  /// The type of relationship between the source and target SPDX elements
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RELATIONSHIP_TYPE_UNSPECIFIED" : Unspecified
  /// - "DESCRIBES" : Is to be used when SPDXRef-DOCUMENT describes SPDXRef-A
  /// - "DESCRIBED_BY" : Is to be used when SPDXRef-A is described by
  /// SPDXREF-Document
  /// - "CONTAINS" : Is to be used when SPDXRef-A contains SPDXRef-B
  /// - "CONTAINED_BY" : Is to be used when SPDXRef-A is contained by SPDXRef-B
  /// - "DEPENDS_ON" : Is to be used when SPDXRef-A depends on SPDXRef-B
  /// - "DEPENDENCY_OF" : Is to be used when SPDXRef-A is dependency of
  /// SPDXRef-B
  /// - "DEPENDENCY_MANIFEST_OF" : Is to be used when SPDXRef-A is a manifest
  /// file that lists a set of dependencies for SPDXRef-B
  /// - "BUILD_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a build
  /// dependency of SPDXRef-B
  /// - "DEV_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a development
  /// dependency of SPDXRef-B
  /// - "OPTIONAL_DEPENDENCY_OF" : Is to be used when SPDXRef-A is an optional
  /// dependency of SPDXRef-B
  /// - "PROVIDED_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a to be
  /// provided dependency of SPDXRef-B
  /// - "TEST_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a test dependency
  /// of SPDXRef-B
  /// - "RUNTIME_DEPENDENCY_OF" : Is to be used when SPDXRef-A is a dependency
  /// required for the execution of SPDXRef-B
  /// - "EXAMPLE_OF" : Is to be used when SPDXRef-A is an example of SPDXRef-B
  /// - "GENERATES" : Is to be used when SPDXRef-A generates SPDXRef-B
  /// - "GENERATED_FROM" : Is to be used when SPDXRef-A was generated from
  /// SPDXRef-B
  /// - "ANCESTOR_OF" : Is to be used when SPDXRef-A is an ancestor (same
  /// lineage but pre-dates) SPDXRef-B
  /// - "DESCENDANT_OF" : Is to be used when SPDXRef-A is a descendant of (same
  /// lineage but postdates) SPDXRef-B
  /// - "VARIANT_OF" : Is to be used when SPDXRef-A is a variant of (same
  /// lineage but not clear which came first) SPDXRef-B
  /// - "DISTRIBUTION_ARTIFACT" : Is to be used when distributing SPDXRef-A
  /// requires that SPDXRef-B also be distributed
  /// - "PATCH_FOR" : Is to be used when SPDXRef-A is a patch file for (to be
  /// applied to) SPDXRef-B
  /// - "PATCH_APPLIED" : Is to be used when SPDXRef-A is a patch file that has
  /// been applied to SPDXRef-B
  /// - "COPY_OF" : Is to be used when SPDXRef-A is an exact copy of SPDXRef-B
  /// - "FILE_ADDED" : Is to be used when SPDXRef-A is a file that was added to
  /// SPDXRef-B
  /// - "FILE_DELETED" : Is to be used when SPDXRef-A is a file that was deleted
  /// from SPDXRef-B
  /// - "FILE_MODIFIED" : Is to be used when SPDXRef-A is a file that was
  /// modified from SPDXRef-B
  /// - "EXPANDED_FROM_ARCHIVE" : Is to be used when SPDXRef-A is expanded from
  /// the archive SPDXRef-B
  /// - "DYNAMIC_LINK" : Is to be used when SPDXRef-A dynamically links to
  /// SPDXRef-B
  /// - "STATIC_LINK" : Is to be used when SPDXRef-A statically links to
  /// SPDXRef-B
  /// - "DATA_FILE_OF" : Is to be used when SPDXRef-A is a data file used in
  /// SPDXRef-B
  /// - "TEST_CASE_OF" : Is to be used when SPDXRef-A is a test case used in
  /// testing SPDXRef-B
  /// - "BUILD_TOOL_OF" : Is to be used when SPDXRef-A is used to build
  /// SPDXRef-B
  /// - "DEV_TOOL_OF" : Is to be used when SPDXRef-A is used as a development
  /// tool for SPDXRef-B
  /// - "TEST_OF" : Is to be used when SPDXRef-A is used for testing SPDXRef-B
  /// - "TEST_TOOL_OF" : Is to be used when SPDXRef-A is used as a test tool for
  /// SPDXRef-B
  /// - "DOCUMENTATION_OF" : Is to be used when SPDXRef-A provides documentation
  /// of SPDXRef-B
  /// - "OPTIONAL_COMPONENT_OF" : Is to be used when SPDXRef-A is an optional
  /// component of SPDXRef-B
  /// - "METAFILE_OF" : Is to be used when SPDXRef-A is a metafile of SPDXRef-B
  /// - "PACKAGE_OF" : Is to be used when SPDXRef-A is used as a package as part
  /// of SPDXRef-B
  /// - "AMENDS" : Is to be used when (current) SPDXRef-DOCUMENT amends the SPDX
  /// information in SPDXRef-B
  /// - "PREREQUISITE_FOR" : Is to be used when SPDXRef-A is a prerequisite for
  /// SPDXRef-B
  /// - "HAS_PREREQUISITE" : Is to be used when SPDXRef-A has as a prerequisite
  /// SPDXRef-B
  /// - "OTHER" : Is to be used for a relationship which has not been defined in
  /// the formal SPDX specification. A description of the relationship should be
  /// included in the Relationship comments field
  core.String? type;

  $RelationshipOccurrence({this.comment, this.source, this.target, this.type});

  $RelationshipOccurrence.fromJson(core.Map json_)
    : this(
        comment: json_['comment'] as core.String?,
        source: json_['source'] as core.String?,
        target: json_['target'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (comment != null) 'comment': comment!,
    if (source != null) 'source': source!,
    if (target != null) 'target': target!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - playdeveloperreporting:v1alpha1 : GooglePlayDeveloperReportingV1alpha1Release
/// - playdeveloperreporting:v1beta1 : GooglePlayDeveloperReportingV1beta1Release
class $Release {
  /// Readable identifier of the release.
  core.String? displayName;

  /// The version codes contained in this release.
  core.List<core.String>? versionCodes;

  $Release({this.displayName, this.versionCodes});

  $Release.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        versionCodes:
            (json_['versionCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (versionCodes != null) 'versionCodes': versionCodes!,
  };
}

/// Used by:
///
/// - container:v1 : ReleaseChannel
/// - container:v1beta1 : ReleaseChannel
class $ReleaseChannel {
  /// channel specifies which release channel the cluster is subscribed to.
  /// Possible string values are:
  /// - "UNSPECIFIED" : No channel specified.
  /// - "RAPID" : RAPID channel is offered on an early access basis for
  /// customers who want to test new releases. WARNING: Versions available in
  /// the RAPID Channel may be subject to unresolved issues with no known
  /// workaround and are not subject to any SLAs.
  /// - "REGULAR" : Clusters subscribed to REGULAR receive versions that are
  /// considered GA quality. REGULAR is intended for production users who want
  /// to take advantage of new features.
  /// - "STABLE" : Clusters subscribed to STABLE receive versions that are known
  /// to be stable and reliable in production.
  /// - "EXTENDED" : Clusters subscribed to EXTENDED receive extended support
  /// and availability for versions which are known to be stable and reliable in
  /// production.
  core.String? channel;

  $ReleaseChannel({this.channel});

  $ReleaseChannel.fromJson(core.Map json_)
    : this(channel: json_['channel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (channel != null) 'channel': channel!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1ReliabilityProjection
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1ReliabilityProjection
class $ReliabilityProjection {
  /// Per-recommender projection.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? details;

  /// Reliability risks mitigated by this recommendation.
  core.List<core.String>? risks;

  $ReliabilityProjection({this.details, this.risks});

  $ReliabilityProjection.fromJson(core.Map json_)
    : this(
        details:
            json_.containsKey('details')
                ? json_['details'] as core.Map<core.String, core.dynamic>
                : null,
        risks:
            (json_['risks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (risks != null) 'risks': risks!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : RemarketingConfig
/// - displayvideo:v3 : RemarketingConfig
/// - displayvideo:v4 : RemarketingConfig
class $RemarketingConfig {
  /// The ID of the advertiser.
  ///
  /// Output only.
  core.String? advertiserId;

  /// Whether the Floodlight activity remarketing user list is available to the
  /// identified advertiser.
  ///
  /// Output only.
  core.bool? remarketingEnabled;

  $RemarketingConfig({this.advertiserId, this.remarketingEnabled});

  $RemarketingConfig.fromJson(core.Map json_)
    : this(
        advertiserId: json_['advertiserId'] as core.String?,
        remarketingEnabled: json_['remarketingEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertiserId != null) 'advertiserId': advertiserId!,
    if (remarketingEnabled != null) 'remarketingEnabled': remarketingEnabled!,
  };
}

/// Used by:
///
/// - redis:v1 : RemoteCluster
/// - redis:v1beta1 : RemoteCluster
class $RemoteCluster {
  /// The full resource path of the remote cluster in the format:
  /// projects//locations//clusters/
  ///
  /// Output only.
  core.String? cluster;

  /// The unique identifier of the remote cluster.
  ///
  /// Output only.
  core.String? uid;

  $RemoteCluster({this.cluster, this.uid});

  $RemoteCluster.fromJson(core.Map json_)
    : this(
        cluster: json_['cluster'] as core.String?,
        uid: json_['uid'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cluster != null) 'cluster': cluster!,
    if (uid != null) 'uid': uid!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : RemoveAddressGroupItemsRequest
/// - networksecurity:v1beta1 : RemoveAddressGroupItemsRequest
class $RemoveAddressGroupItemsRequest {
  /// List of items to remove.
  ///
  /// Required.
  core.List<core.String>? items;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes since the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  $RemoveAddressGroupItemsRequest({this.items, this.requestId});

  $RemoveAddressGroupItemsRequest.fromJson(core.Map json_)
    : this(
        items:
            (json_['items'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        requestId: json_['requestId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (items != null) 'items': items!,
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RemoveCatalogAttributeRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaRemoveCatalogAttributeRequest
/// - retail:v2beta : GoogleCloudRetailV2betaRemoveCatalogAttributeRequest
class $RemoveCatalogAttributeRequest {
  /// The attribute name key of the CatalogAttribute to remove.
  ///
  /// Required.
  core.String? key;

  $RemoveCatalogAttributeRequest({this.key});

  $RemoveCatalogAttributeRequest.fromJson(core.Map json_)
    : this(key: json_['key'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RemoveControlRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaRemoveControlRequest
/// - retail:v2beta : GoogleCloudRetailV2betaRemoveControlRequest
class $RemoveControlRequest {
  /// The id of the control to apply.
  ///
  /// Assumed to be in the same catalog as the serving config.
  ///
  /// Required.
  core.String? controlId;

  $RemoveControlRequest({this.controlId});

  $RemoveControlRequest.fromJson(core.Map json_)
    : this(controlId: json_['controlId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (controlId != null) 'controlId': controlId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RemoveDatapointsRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RemoveDatapointsRequest
class $RemoveDatapointsRequest {
  /// A list of datapoint ids to be deleted.
  core.List<core.String>? datapointIds;

  $RemoveDatapointsRequest({this.datapointIds});

  $RemoveDatapointsRequest.fromJson(core.Map json_)
    : this(
        datapointIds:
            (json_['datapointIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datapointIds != null) 'datapointIds': datapointIds!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaRemoveDedicatedCrawlRateRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaRemoveDedicatedCrawlRateRequest
class $RemoveDedicatedCrawlRateRequest {
  /// The scope of the crawl rate change.
  ///
  /// Currently, only domain and host name are supported. A domain name example:
  /// `example.com`. A host name example: `www.example.com`. Please do not
  /// include `/` in the domain or host name.
  ///
  /// Required.
  core.String? crawlRateScope;

  $RemoveDedicatedCrawlRateRequest({this.crawlRateScope});

  $RemoveDedicatedCrawlRateRequest.fromJson(core.Map json_)
    : this(crawlRateScope: json_['crawlRateScope'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (crawlRateScope != null) 'crawlRateScope': crawlRateScope!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RemoveFulfillmentPlacesRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaRemoveFulfillmentPlacesRequest
/// - retail:v2beta : GoogleCloudRetailV2betaRemoveFulfillmentPlacesRequest
class $RemoveFulfillmentPlacesRequest {
  /// If set to true, and the Product is not found, the fulfillment information
  /// will still be processed and retained for at most 1 day and processed once
  /// the Product is created.
  ///
  /// If set to false, a NOT_FOUND error is returned if the Product is not
  /// found.
  core.bool? allowMissing;

  /// The IDs for this type, such as the store IDs for "pickup-in-store" or the
  /// region IDs for "same-day-delivery", to be removed for this type.
  ///
  /// At least 1 value is required, and a maximum of 2000 values are allowed.
  /// Each value must be a string with a length limit of 10 characters, matching
  /// the pattern `[a-zA-Z0-9_-]+`, such as "store1" or "REGION-2". Otherwise,
  /// an INVALID_ARGUMENT error is returned.
  ///
  /// Required.
  core.List<core.String>? placeIds;

  /// The time when the fulfillment updates are issued, used to prevent
  /// out-of-order updates on fulfillment information.
  ///
  /// If not provided, the internal system time will be used.
  core.String? removeTime;

  /// The fulfillment type, including commonly used types (such as pickup in
  /// store and same day delivery), and custom types.
  ///
  /// Supported values: * "pickup-in-store" * "ship-to-store" *
  /// "same-day-delivery" * "next-day-delivery" * "custom-type-1" *
  /// "custom-type-2" * "custom-type-3" * "custom-type-4" * "custom-type-5" If
  /// this field is set to an invalid value other than these, an
  /// INVALID_ARGUMENT error is returned. This field directly corresponds to
  /// Product.fulfillment_info.type.
  ///
  /// Required.
  core.String? type;

  $RemoveFulfillmentPlacesRequest({
    this.allowMissing,
    this.placeIds,
    this.removeTime,
    this.type,
  });

  $RemoveFulfillmentPlacesRequest.fromJson(core.Map json_)
    : this(
        allowMissing: json_['allowMissing'] as core.bool?,
        placeIds:
            (json_['placeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        removeTime: json_['removeTime'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowMissing != null) 'allowMissing': allowMissing!,
    if (placeIds != null) 'placeIds': placeIds!,
    if (removeTime != null) 'removeTime': removeTime!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : RemoveGroupMigrationRequest
/// - vmmigration:v1alpha1 : RemoveGroupMigrationRequest
class $RemoveGroupMigrationRequest {
  /// The MigratingVm to remove.
  core.String? migratingVm;

  $RemoveGroupMigrationRequest({this.migratingVm});

  $RemoveGroupMigrationRequest.fromJson(core.Map json_)
    : this(migratingVm: json_['migratingVm'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (migratingVm != null) 'migratingVm': migratingVm!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : RemoveIamPolicyRequest
/// - metastore:v1beta : RemoveIamPolicyRequest
class $RemoveIamPolicyRequest {
  /// Removes IAM policy attached to database or table asynchronously when it is
  /// set.
  ///
  /// The default is false.
  ///
  /// Optional.
  core.bool? asynchronous;

  $RemoveIamPolicyRequest({this.asynchronous});

  $RemoveIamPolicyRequest.fromJson(core.Map json_)
    : this(asynchronous: json_['asynchronous'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (asynchronous != null) 'asynchronous': asynchronous!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : RemoveIamPolicyResponse
/// - metastore:v1beta : RemoveIamPolicyResponse
class $RemoveIamPolicyResponse {
  /// True if the policy is successfully removed.
  core.bool? success;

  $RemoveIamPolicyResponse({this.success});

  $RemoveIamPolicyResponse.fromJson(core.Map json_)
    : this(success: json_['success'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (success != null) 'success': success!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RemoveLocalInventoriesRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaRemoveLocalInventoriesRequest
/// - retail:v2beta : GoogleCloudRetailV2betaRemoveLocalInventoriesRequest
class $RemoveLocalInventoriesRequest {
  /// If set to true, and the Product is not found, the local inventory removal
  /// request will still be processed and retained for at most 1 day and
  /// processed once the Product is created.
  ///
  /// If set to false, a NOT_FOUND error is returned if the Product is not
  /// found.
  core.bool? allowMissing;

  /// A list of place IDs to have their inventory deleted.
  ///
  /// At most 3000 place IDs are allowed per request.
  ///
  /// Required.
  core.List<core.String>? placeIds;

  /// The time when the inventory deletions are issued.
  ///
  /// Used to prevent out-of-order updates and deletions on local inventory
  /// fields. If not provided, the internal system time will be used.
  core.String? removeTime;

  $RemoveLocalInventoriesRequest({
    this.allowMissing,
    this.placeIds,
    this.removeTime,
  });

  $RemoveLocalInventoriesRequest.fromJson(core.Map json_)
    : this(
        allowMissing: json_['allowMissing'] as core.bool?,
        placeIds:
            (json_['placeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        removeTime: json_['removeTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowMissing != null) 'allowMissing': allowMissing!,
    if (placeIds != null) 'placeIds': placeIds!,
    if (removeTime != null) 'removeTime': removeTime!,
  };
}

/// Used by:
///
/// - compute:alpha : NetworksRemovePeeringRequest
/// - compute:alpha : NetworksRequestRemovePeeringRequest
/// - compute:beta : NetworksRemovePeeringRequest
/// - compute:beta : NetworksRequestRemovePeeringRequest
/// - compute:v1 : NetworksRemovePeeringRequest
class $RemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String? name;

  $RemovePeeringRequest({this.name});

  $RemovePeeringRequest.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - datacatalog:v1 : GoogleCloudDatacatalogV1RenameTagTemplateFieldEnumValueRequest
/// - datacatalog:v1beta1 : GoogleCloudDatacatalogV1beta1RenameTagTemplateFieldEnumValueRequest
class $RenameTagTemplateFieldEnumValueRequest {
  /// The new display name of the enum value.
  ///
  /// For example, `my_new_enum_value`.
  ///
  /// Required.
  core.String? newEnumValueDisplayName;

  $RenameTagTemplateFieldEnumValueRequest({this.newEnumValueDisplayName});

  $RenameTagTemplateFieldEnumValueRequest.fromJson(core.Map json_)
    : this(
        newEnumValueDisplayName:
            json_['newEnumValueDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (newEnumValueDisplayName != null)
      'newEnumValueDisplayName': newEnumValueDisplayName!,
  };
}

/// Used by:
///
/// - datacatalog:v1 : GoogleCloudDatacatalogV1RenameTagTemplateFieldRequest
/// - datacatalog:v1beta1 : GoogleCloudDatacatalogV1beta1RenameTagTemplateFieldRequest
class $RenameTagTemplateFieldRequest {
  /// The new ID of this tag template field.
  ///
  /// For example, `my_new_field`.
  ///
  /// Required.
  core.String? newTagTemplateFieldId;

  $RenameTagTemplateFieldRequest({this.newTagTemplateFieldId});

  $RenameTagTemplateFieldRequest.fromJson(core.Map json_)
    : this(
        newTagTemplateFieldId: json_['newTagTemplateFieldId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (newTagTemplateFieldId != null)
      'newTagTemplateFieldId': newTagTemplateFieldId!,
  };
}

/// Used by:
///
/// - docs:v1 : ReplaceAllTextResponse
/// - slides:v1 : ReplaceAllTextResponse
class $ReplaceAllTextResponse {
  /// The number of occurrences changed by replacing all text.
  core.int? occurrencesChanged;

  $ReplaceAllTextResponse({this.occurrencesChanged});

  $ReplaceAllTextResponse.fromJson(core.Map json_)
    : this(occurrencesChanged: json_['occurrencesChanged'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (occurrencesChanged != null) 'occurrencesChanged': occurrencesChanged!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ReplicatingStep
/// - vmmigration:v1alpha1 : ReplicatingStep
class $ReplicatingStep {
  /// The source disks replication rate for the last 30 minutes in bytes per
  /// second.
  core.String? lastThirtyMinutesAverageBytesPerSecond;

  /// The source disks replication rate for the last 2 minutes in bytes per
  /// second.
  core.String? lastTwoMinutesAverageBytesPerSecond;

  /// Replicated bytes in the step.
  core.String? replicatedBytes;

  /// Total bytes to be handled in the step.
  core.String? totalBytes;

  $ReplicatingStep({
    this.lastThirtyMinutesAverageBytesPerSecond,
    this.lastTwoMinutesAverageBytesPerSecond,
    this.replicatedBytes,
    this.totalBytes,
  });

  $ReplicatingStep.fromJson(core.Map json_)
    : this(
        lastThirtyMinutesAverageBytesPerSecond:
            json_['lastThirtyMinutesAverageBytesPerSecond'] as core.String?,
        lastTwoMinutesAverageBytesPerSecond:
            json_['lastTwoMinutesAverageBytesPerSecond'] as core.String?,
        replicatedBytes: json_['replicatedBytes'] as core.String?,
        totalBytes: json_['totalBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastThirtyMinutesAverageBytesPerSecond != null)
      'lastThirtyMinutesAverageBytesPerSecond':
          lastThirtyMinutesAverageBytesPerSecond!,
    if (lastTwoMinutesAverageBytesPerSecond != null)
      'lastTwoMinutesAverageBytesPerSecond':
          lastTwoMinutesAverageBytesPerSecond!,
    if (replicatedBytes != null) 'replicatedBytes': replicatedBytes!,
    if (totalBytes != null) 'totalBytes': totalBytes!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : ReplicationCluster
/// - sqladmin:v1beta4 : ReplicationCluster
class $ReplicationCluster {
  /// Read-only field that indicates whether the replica is a DR replica.
  ///
  /// This field is not set if the instance is a primary instance.
  ///
  /// Output only.
  core.bool? drReplica;

  /// If the instance is a primary instance, then this field identifies the
  /// disaster recovery (DR) replica.
  ///
  /// A DR replica is an optional configuration for Enterprise Plus edition
  /// instances. If the instance is a read replica, then the field is not set.
  /// Set this field to a replica name to designate a DR replica for a primary
  /// instance. Remove the replica name to remove the DR replica designation.
  ///
  /// Optional.
  core.String? failoverDrReplicaName;

  /// If set, this field indicates this instance has a private service access
  /// (PSA) DNS endpoint that is pointing to the primary instance of the
  /// cluster.
  ///
  /// If this instance is the primary, then the DNS endpoint points to this
  /// instance. After a switchover or replica failover operation, this DNS
  /// endpoint points to the promoted instance. This is a read-only field,
  /// returned to the user as information. This field can exist even if a
  /// standalone instance doesn't have a DR replica yet or the DR replica is
  /// deleted.
  ///
  /// Output only.
  core.String? psaWriteEndpoint;

  $ReplicationCluster({
    this.drReplica,
    this.failoverDrReplicaName,
    this.psaWriteEndpoint,
  });

  $ReplicationCluster.fromJson(core.Map json_)
    : this(
        drReplica: json_['drReplica'] as core.bool?,
        failoverDrReplicaName: json_['failoverDrReplicaName'] as core.String?,
        psaWriteEndpoint: json_['psaWriteEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (drReplica != null) 'drReplica': drReplica!,
    if (failoverDrReplicaName != null)
      'failoverDrReplicaName': failoverDrReplicaName!,
    if (psaWriteEndpoint != null) 'psaWriteEndpoint': psaWriteEndpoint!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ReplicationSync
/// - vmmigration:v1alpha1 : ReplicationSync
class $ReplicationSync {
  /// The most updated snapshot created time in the source that finished
  /// replication.
  core.String? lastSyncTime;

  $ReplicationSync({this.lastSyncTime});

  $ReplicationSync.fromJson(core.Map json_)
    : this(lastSyncTime: json_['lastSyncTime'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastSyncTime != null) 'lastSyncTime': lastSyncTime!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaReplyReference
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaReplyReference
class $ReplyReference {
  /// Anchor text.
  core.String? anchorText;

  /// Anchor text end index.
  core.int? end;

  /// Anchor text start index.
  core.int? start;

  /// URI link reference.
  core.String? uri;

  $ReplyReference({this.anchorText, this.end, this.start, this.uri});

  $ReplyReference.fromJson(core.Map json_)
    : this(
        anchorText: json_['anchorText'] as core.String?,
        end: json_['end'] as core.int?,
        start: json_['start'] as core.int?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (anchorText != null) 'anchorText': anchorText!,
    if (end != null) 'end': end!,
    if (start != null) 'start': start!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : RepoSource
/// - cloudfunctions:v2alpha : RepoSource
/// - cloudfunctions:v2beta : RepoSource
class $RepoSource {
  /// Regex matching branches to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  core.String? branchName;

  /// Explicit commit SHA to build.
  core.String? commitSha;

  /// Directory, relative to the source root, in which to run the build.
  ///
  /// This must be a relative path. If a step's `dir` is specified and is an
  /// absolute path, this value is ignored for that step's execution. eg.
  /// helloworld (no leading slash allowed)
  core.String? dir;

  /// ID of the project that owns the Cloud Source Repository.
  ///
  /// If omitted, the project ID requesting the build is assumed.
  core.String? projectId;

  /// Name of the Cloud Source Repository.
  core.String? repoName;

  /// Regex matching tags to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  core.String? tagName;

  $RepoSource({
    this.branchName,
    this.commitSha,
    this.dir,
    this.projectId,
    this.repoName,
    this.tagName,
  });

  $RepoSource.fromJson(core.Map json_)
    : this(
        branchName: json_['branchName'] as core.String?,
        commitSha: json_['commitSha'] as core.String?,
        dir: json_['dir'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        repoName: json_['repoName'] as core.String?,
        tagName: json_['tagName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (branchName != null) 'branchName': branchName!,
    if (commitSha != null) 'commitSha': commitSha!,
    if (dir != null) 'dir': dir!,
    if (projectId != null) 'projectId': projectId!,
    if (repoName != null) 'repoName': repoName!,
    if (tagName != null) 'tagName': tagName!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ReportConfigGroupPreferenceSetAssignment
/// - migrationcenter:v1alpha1 : ReportConfigGroupPreferenceSetAssignment
class $ReportConfigGroupPreferenceSetAssignment {
  /// Name of the group.
  ///
  /// Required.
  core.String? group;

  /// Name of the Preference Set.
  ///
  /// Required.
  core.String? preferenceSet;

  $ReportConfigGroupPreferenceSetAssignment({this.group, this.preferenceSet});

  $ReportConfigGroupPreferenceSetAssignment.fromJson(core.Map json_)
    : this(
        group: json_['group'] as core.String?,
        preferenceSet: json_['preferenceSet'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (group != null) 'group': group!,
    if (preferenceSet != null) 'preferenceSet': preferenceSet!,
  };
}

/// Used by:
///
/// - admob:v1 : ReportRowDimensionValue
/// - admob:v1beta : ReportRowDimensionValue
class $ReportRowDimensionValue {
  /// The localized string representation of the value.
  ///
  /// If unspecified, the display label should be derived from the value.
  core.String? displayLabel;

  /// Dimension value in the format specified in the report's spec Dimension
  /// enum.
  core.String? value;

  $ReportRowDimensionValue({this.displayLabel, this.value});

  $ReportRowDimensionValue.fromJson(core.Map json_)
    : this(
        displayLabel: json_['displayLabel'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayLabel != null) 'displayLabel': displayLabel!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - admob:v1 : ReportRowMetricValue
/// - admob:v1beta : ReportRowMetricValue
class $ReportRowMetricValue {
  /// Double precision (approximate) decimal values.
  ///
  /// Rates are from 0 to 1.
  core.double? doubleValue;

  /// Metric integer value.
  core.String? integerValue;

  /// Amount in micros.
  ///
  /// One million is equivalent to one unit. Currency value is in the unit (USD,
  /// EUR or other) specified by the request. For example, $6.50 whould be
  /// represented as 6500000 micros.
  core.String? microsValue;

  $ReportRowMetricValue({
    this.doubleValue,
    this.integerValue,
    this.microsValue,
  });

  $ReportRowMetricValue.fromJson(core.Map json_)
    : this(
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        integerValue: json_['integerValue'] as core.String?,
        microsValue: json_['microsValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (integerValue != null) 'integerValue': integerValue!,
    if (microsValue != null) 'microsValue': microsValue!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ReportSummaryChartDataDataPoint
/// - migrationcenter:v1alpha1 : ReportSummaryChartDataDataPoint
class $ReportSummaryChartDataDataPoint {
  /// The X-axis label for this data point.
  core.String? label;

  /// The Y-axis value for this data point.
  core.double? value;

  $ReportSummaryChartDataDataPoint({this.label, this.value});

  $ReportSummaryChartDataDataPoint.fromJson(core.Map json_)
    : this(
        label: json_['label'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (label != null) 'label': label!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ReportSummaryHistogramChartDataBucket
/// - migrationcenter:v1alpha1 : ReportSummaryHistogramChartDataBucket
class $ReportSummaryHistogramChartDataBucket {
  /// Count of items in the bucket.
  core.String? count;

  /// Lower bound - inclusive.
  core.String? lowerBound;

  /// Upper bound - exclusive.
  core.String? upperBound;

  $ReportSummaryHistogramChartDataBucket({
    this.count,
    this.lowerBound,
    this.upperBound,
  });

  $ReportSummaryHistogramChartDataBucket.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.String?,
        lowerBound: json_['lowerBound'] as core.String?,
        upperBound: json_['upperBound'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (lowerBound != null) 'lowerBound': lowerBound!,
    if (upperBound != null) 'upperBound': upperBound!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : ReportSummaryUtilizationChartData
/// - migrationcenter:v1alpha1 : ReportSummaryUtilizationChartData
class $ReportSummaryUtilizationChartData {
  /// Aggregate value which falls into the "Free" bucket.
  core.String? free;

  /// Aggregate value which falls into the "Used" bucket.
  core.String? used;

  $ReportSummaryUtilizationChartData({this.free, this.used});

  $ReportSummaryUtilizationChartData.fromJson(core.Map json_)
    : this(
        free: json_['free'] as core.String?,
        used: json_['used'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (free != null) 'free': free!,
    if (used != null) 'used': used!,
  };
}

/// Used by:
///
/// - admob:v1 : ReportWarning
/// - admob:v1beta : ReportWarning
class $ReportWarning {
  /// Describes the details of the warning message, in English.
  core.String? description;

  /// Type of the warning.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value for an unset field. Do not use.
  /// - "DATA_BEFORE_ACCOUNT_TIMEZONE_CHANGE" : Some data in this report is
  /// aggregated based on a time zone different from the requested time zone.
  /// This could happen if a local time-zone report has the start time before
  /// the last time this time zone changed. The description field will contain
  /// the date of the last time zone change.
  /// - "DATA_DELAYED" : There is an unusual delay in processing the source data
  /// for the requested date range. The report results might be less up to date
  /// than usual. AdMob is aware of the issue and is actively working to resolve
  /// it.
  /// - "OTHER" : Warnings that are exposed without a specific type. Useful when
  /// new warning types are added but the API is not changed yet.
  /// - "REPORT_CURRENCY_NOT_ACCOUNT_CURRENCY" : The currency being requested is
  /// not the account currency. The earning metrics will be based on the
  /// requested currency, and thus not a good estimation of the final payment
  /// anymore, due to the currency rate fluctuation.
  core.String? type;

  $ReportWarning({this.description, this.type});

  $ReportWarning.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersDeletePerInstanceConfigsReq
/// - compute:alpha : RegionInstanceGroupManagerDeleteInstanceConfigReq
/// - compute:beta : InstanceGroupManagersDeletePerInstanceConfigsReq
/// - compute:beta : RegionInstanceGroupManagerDeleteInstanceConfigReq
/// - compute:v1 : InstanceGroupManagersDeletePerInstanceConfigsReq
/// - compute:v1 : RegionInstanceGroupManagerDeleteInstanceConfigReq
class $Req {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String>? names;

  $Req({this.names});

  $Req.fromJson(core.Map json_)
    : this(
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - backupdr:v1 : RemoveDataSourceRequest
/// - batch:v1 : CancelJobRequest
/// - migrationcenter:v1 : RunImportJobRequest
/// - migrationcenter:v1 : ValidateImportJobRequest
/// - migrationcenter:v1alpha1 : RunAssetsExportJobRequest
/// - migrationcenter:v1alpha1 : RunImportJobRequest
/// - migrationcenter:v1alpha1 : ValidateImportJobRequest
/// - rapidmigrationassessment:v1 : PauseCollectorRequest
/// - rapidmigrationassessment:v1 : RegisterCollectorRequest
/// - rapidmigrationassessment:v1 : ResumeCollectorRequest
class $Request00 {
  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes after the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  $Request00({this.requestId});

  $Request00.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - alloydb:v1 : FailoverInstanceRequest
/// - alloydb:v1 : SwitchoverClusterRequest
/// - alloydb:v1alpha : FailoverInstanceRequest
/// - alloydb:v1alpha : SwitchoverClusterRequest
/// - alloydb:v1beta : FailoverInstanceRequest
/// - alloydb:v1beta : SwitchoverClusterRequest
class $Request01 {
  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server ignores the request if it has already been completed. The server
  /// guarantees that for at least 60 minutes since the first request. For
  /// example, consider a situation where you make an initial request and the
  /// request times out. If you make the request again with the same request ID,
  /// the server can check if the original operation with the same request ID
  /// was received, and if so, ignores the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported
  /// (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// If set, performs request validation, for example, permission checks and
  /// any other type of validation, but does not actually execute the create
  /// request.
  ///
  /// Optional.
  core.bool? validateOnly;

  $Request01({this.requestId, this.validateOnly});

  $Request01.fromJson(core.Map json_)
    : this(
        requestId: json_['requestId'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - compute:alpha : InstanceGroupManagersRecreateInstancesRequest
/// - compute:alpha : RegionInstanceGroupManagersRecreateRequest
/// - compute:beta : InstanceGroupManagersRecreateInstancesRequest
/// - compute:beta : RegionInstanceGroupManagersRecreateRequest
/// - compute:v1 : InstanceGroupManagersRecreateInstancesRequest
/// - compute:v1 : RegionInstanceGroupManagersRecreateRequest
class $Request02 {
  /// The URLs of one or more instances to recreate.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  $Request02({this.instances});

  $Request02.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1MarkRecommendationClaimedRequest
/// - recommender:v1 : GoogleCloudRecommenderV1MarkRecommendationFailedRequest
/// - recommender:v1 : GoogleCloudRecommenderV1MarkRecommendationSucceededRequest
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1MarkRecommendationClaimedRequest
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1MarkRecommendationFailedRequest
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1MarkRecommendationSucceededRequest
class $Request03 {
  /// Fingerprint of the Recommendation.
  ///
  /// Provides optimistic locking.
  ///
  /// Required.
  core.String? etag;

  /// State properties to include with this state.
  ///
  /// Overwrites any existing `state_metadata`. Keys must match the regex
  /// `/^a-z0-9{0,62}$/`. Values must match the regex
  /// `/^[a-zA-Z0-9_./-]{0,255}$/`.
  core.Map<core.String, core.String>? stateMetadata;

  $Request03({this.etag, this.stateMetadata});

  $Request03.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        stateMetadata: (json_['stateMetadata']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (stateMetadata != null) 'stateMetadata': stateMetadata!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1ApproveDeviceUserRequest
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1BlockDeviceUserRequest
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1CancelWipeDeviceRequest
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1CancelWipeDeviceUserRequest
/// - cloudidentity:v1 : GoogleAppsCloudidentityDevicesV1WipeDeviceUserRequest
class $Request04 {
  /// [Resource name](https://cloud.google.com/apis/design/resource_names) of
  /// the customer.
  ///
  /// If you're using this API for your own organization, use
  /// `customers/my_customer` If you're using this API to manage another
  /// organization, use `customers/{customer}`, where customer is the customer
  /// to whom the device belongs.
  ///
  /// Optional.
  core.String? customer;

  $Request04({this.customer});

  $Request04.fromJson(core.Map json_)
    : this(customer: json_['customer'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (customer != null) 'customer': customer!,
  };
}

/// Used by:
///
/// - cloudidentity:v1beta1 : ApproveDeviceUserRequest
/// - cloudidentity:v1beta1 : BlockDeviceUserRequest
/// - cloudidentity:v1beta1 : CancelWipeDeviceRequest
/// - cloudidentity:v1beta1 : CancelWipeDeviceUserRequest
/// - cloudidentity:v1beta1 : WipeDeviceUserRequest
class $Request05 {
  /// [Resource name](https://cloud.google.com/apis/design/resource_names) of
  /// the customer.
  ///
  /// If you're using this API for your own organization, use
  /// `customers/my_customer` If you're using this API to manage another
  /// organization, use `customers/{customer_id}`, where customer_id is the
  /// customer to whom the device belongs.
  ///
  /// Optional.
  core.String? customer;

  $Request05({this.customer});

  $Request05.fromJson(core.Map json_)
    : this(customer: json_['customer'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (customer != null) 'customer': customer!,
  };
}

/// Used by:
///
/// - cloudchannel:v1 : GoogleCloudChannelV1ActivateEntitlementRequest
/// - cloudchannel:v1 : GoogleCloudChannelV1CancelEntitlementRequest
/// - cloudchannel:v1 : GoogleCloudChannelV1StartPaidServiceRequest
/// - cloudchannel:v1 : GoogleCloudChannelV1SuspendEntitlementRequest
class $Request06 {
  /// You can specify an optional unique request ID, and if you need to retry
  /// your request, the server will know to ignore the request if it's complete.
  ///
  /// For example, you make an initial request and the request times out. If you
  /// make the request again with the same request ID, the server can check if
  /// it received the original operation with the same request ID. If it did, it
  /// will ignore the second request. The request ID must be a valid
  /// [UUID](https://tools.ietf.org/html/rfc4122) with the exception that zero
  /// UUID is not supported (`00000000-0000-0000-0000-000000000000`).
  ///
  /// Optional.
  core.String? requestId;

  $Request06({this.requestId});

  $Request06.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ValidateAgentRequest
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ValidateFlowRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ValidateAgentRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ValidateFlowRequest
class $Request07 {
  /// If not specified, the agent's default language is used.
  core.String? languageCode;

  $Request07({this.languageCode});

  $Request07.fromJson(core.Map json_)
    : this(languageCode: json_['languageCode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : ExecuteMutationRequest
/// - firebasedataconnect:v1 : ExecuteQueryRequest
/// - firebasedataconnect:v1beta : ExecuteMutationRequest
/// - firebasedataconnect:v1beta : ExecuteQueryRequest
class $Request08 {
  /// The name of the GraphQL operation name.
  ///
  /// Required because all Connector operations must be named. See
  /// https://graphql.org/learn/queries/#operation-name.
  ///
  /// Required.
  core.String? operationName;

  /// Values for GraphQL variables provided in this request.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? variables;

  $Request08({this.operationName, this.variables});

  $Request08.fromJson(core.Map json_)
    : this(
        operationName: json_['operationName'] as core.String?,
        variables:
            json_.containsKey('variables')
                ? json_['variables'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (operationName != null) 'operationName': operationName!,
    if (variables != null) 'variables': variables!,
  };
}

/// Used by:
///
/// - privateca:v1 : EnableCertificateAuthorityRequest
/// - privateca:v1 : FetchCaCertsRequest
/// - privateca:v1 : UndeleteCertificateAuthorityRequest
class $Request09 {
  /// An ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes since the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  $Request09({this.requestId});

  $Request09.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1AcceptPublisherModelEulaRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CheckPublisherModelEulaAcceptanceRequest
class $Request10 {
  /// The name of the PublisherModel resource.
  ///
  /// Format: `publishers/{publisher}/models/{publisher_model}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}`
  ///
  /// Required.
  core.String? publisherModel;

  $Request10({this.publisherModel});

  $Request10.fromJson(core.Map json_)
    : this(publisherModel: json_['publisherModel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (publisherModel != null) 'publisherModel': publisherModel!,
  };
}

/// Used by:
///
/// - clouddeploy:v1 : CancelRolloutRequest
/// - clouddeploy:v1 : TerminateJobRunRequest
class $Request11 {
  /// Deploy policies to override.
  ///
  /// Format is
  /// `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
  ///
  /// Optional.
  core.List<core.String>? overrideDeployPolicy;

  $Request11({this.overrideDeployPolicy});

  $Request11.fromJson(core.Map json_)
    : this(
        overrideDeployPolicy:
            (json_['overrideDeployPolicy'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (overrideDeployPolicy != null)
      'overrideDeployPolicy': overrideDeployPolicy!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v1 : ListAvailableOrgPolicyConstraintsRequest
/// - cloudresourcemanager:v1 : ListOrgPoliciesRequest
class $Request12 {
  /// Size of the pages to be returned.
  ///
  /// This is currently unsupported and will be ignored. The server may at any
  /// point start using this field to limit page size.
  core.int? pageSize;

  /// Page token used to retrieve the next page.
  ///
  /// This is currently unsupported and will be ignored. The server may at any
  /// point start using this field.
  core.String? pageToken;

  $Request12({this.pageSize, this.pageToken});

  $Request12.fromJson(core.Map json_)
    : this(
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
  };
}

/// Used by:
///
/// - content:v2.1 : RequestReviewFreeListingsRequest
/// - content:v2.1 : RequestReviewShoppingAdsRequest
class $Request13 {
  /// The code \[ISO 3166-1
  /// alpha-2\](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the country
  /// for which review is to be requested.
  core.String? regionCode;

  $Request13({this.regionCode});

  $Request13.fromJson(core.Map json_)
    : this(regionCode: json_['regionCode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (regionCode != null) 'regionCode': regionCode!,
  };
}

/// Used by:
///
/// - notebooks:v1 : RefreshRuntimeTokenInternalRequest
/// - notebooks:v2 : UpgradeInstanceSystemRequest
class $Request14 {
  /// The VM hardware token for authenticating the VM.
  ///
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity
  ///
  /// Required.
  core.String? vmId;

  $Request14({this.vmId});

  $Request14.fromJson(core.Map json_)
    : this(vmId: json_['vmId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vmId != null) 'vmId': vmId!,
  };
}

/// Used by:
///
/// - compute:alpha : RequestMirrorPolicy
/// - compute:beta : RequestMirrorPolicy
class $RequestMirrorPolicy {
  /// The full or partial URL to the BackendService resource being mirrored to.
  ///
  /// The backend service configured for a mirroring policy must reference
  /// backends that are of the same type as the original backend service matched
  /// in the URL map. Serverless NEG backends are not currently supported as a
  /// mirrored backend service.
  core.String? backendService;

  /// The percentage of requests to be mirrored to `backend_service`.
  core.double? mirrorPercent;

  $RequestMirrorPolicy({this.backendService, this.mirrorPercent});

  $RequestMirrorPolicy.fromJson(core.Map json_)
    : this(
        backendService: json_['backendService'] as core.String?,
        mirrorPercent: (json_['mirrorPercent'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backendService != null) 'backendService': backendService!,
    if (mirrorPercent != null) 'mirrorPercent': mirrorPercent!,
  };
}

/// Used by:
///
/// - appengine:v1 : RequestUtilization
/// - appengine:v1beta : RequestUtilization
class $RequestUtilization {
  /// Target number of concurrent requests.
  core.int? targetConcurrentRequests;

  /// Target requests per second.
  core.int? targetRequestCountPerSecond;

  $RequestUtilization({
    this.targetConcurrentRequests,
    this.targetRequestCountPerSecond,
  });

  $RequestUtilization.fromJson(core.Map json_)
    : this(
        targetConcurrentRequests:
            json_['targetConcurrentRequests'] as core.int?,
        targetRequestCountPerSecond:
            json_['targetRequestCountPerSecond'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetConcurrentRequests != null)
      'targetConcurrentRequests': targetConcurrentRequests!,
    if (targetRequestCountPerSecond != null)
      'targetRequestCountPerSecond': targetRequestCountPerSecond!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : Reschedule
/// - sqladmin:v1beta4 : Reschedule
class $Reschedule {
  /// The type of the reschedule.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESCHEDULE_TYPE_UNSPECIFIED"
  /// - "IMMEDIATE" : Reschedules maintenance to happen now (within 5 minutes).
  /// - "NEXT_AVAILABLE_WINDOW" : Reschedules maintenance to occur within one
  /// week from the originally scheduled day and time.
  /// - "SPECIFIC_TIME" : Reschedules maintenance to a specific time and day.
  core.String? rescheduleType;

  /// Timestamp when the maintenance shall be rescheduled to if
  /// reschedule_type=SPECIFIC_TIME, in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
  /// `2012-11-15T16:19:00.094Z`.
  ///
  /// Optional.
  core.String? scheduleTime;

  $Reschedule({this.rescheduleType, this.scheduleTime});

  $Reschedule.fromJson(core.Map json_)
    : this(
        rescheduleType: json_['rescheduleType'] as core.String?,
        scheduleTime: json_['scheduleTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rescheduleType != null) 'rescheduleType': rescheduleType!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
  };
}

/// Used by:
///
/// - redis:v1 : RescheduleClusterMaintenanceRequest
/// - redis:v1beta1 : RescheduleClusterMaintenanceRequest
class $RescheduleClusterMaintenanceRequest {
  /// If reschedule type is SPECIFIC_TIME, must set up schedule_time as well.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESCHEDULE_TYPE_UNSPECIFIED" : Not set.
  /// - "IMMEDIATE" : If the user wants to schedule the maintenance to happen
  /// now.
  /// - "SPECIFIC_TIME" : If the user wants to reschedule the maintenance to a
  /// specific time.
  core.String? rescheduleType;

  /// Timestamp when the maintenance shall be rescheduled to if
  /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for example
  /// `2012-11-15T16:19:00.094Z`.
  ///
  /// Optional.
  core.String? scheduleTime;

  $RescheduleClusterMaintenanceRequest({
    this.rescheduleType,
    this.scheduleTime,
  });

  $RescheduleClusterMaintenanceRequest.fromJson(core.Map json_)
    : this(
        rescheduleType: json_['rescheduleType'] as core.String?,
        scheduleTime: json_['scheduleTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rescheduleType != null) 'rescheduleType': rescheduleType!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
  };
}

/// Used by:
///
/// - memcache:v1 : RescheduleMaintenanceRequest
/// - memcache:v1beta2 : RescheduleMaintenanceRequest
class $RescheduleMaintenanceRequest00 {
  /// If reschedule type is SPECIFIC_TIME, must set up schedule_time as well.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESCHEDULE_TYPE_UNSPECIFIED" : Not set.
  /// - "IMMEDIATE" : If the user wants to schedule the maintenance to happen
  /// now.
  /// - "NEXT_AVAILABLE_WINDOW" : If the user wants to use the existing
  /// maintenance policy to find the next available window.
  /// - "SPECIFIC_TIME" : If the user wants to reschedule the maintenance to a
  /// specific time.
  core.String? rescheduleType;

  /// Timestamp when the maintenance shall be rescheduled to if
  /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for example
  /// `2012-11-15T16:19:00.094Z`.
  core.String? scheduleTime;

  $RescheduleMaintenanceRequest00({this.rescheduleType, this.scheduleTime});

  $RescheduleMaintenanceRequest00.fromJson(core.Map json_)
    : this(
        rescheduleType: json_['rescheduleType'] as core.String?,
        scheduleTime: json_['scheduleTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rescheduleType != null) 'rescheduleType': rescheduleType!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
  };
}

/// Used by:
///
/// - redis:v1 : RescheduleMaintenanceRequest
/// - redis:v1beta1 : RescheduleMaintenanceRequest
class $RescheduleMaintenanceRequest01 {
  /// If reschedule type is SPECIFIC_TIME, must set up schedule_time as well.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESCHEDULE_TYPE_UNSPECIFIED" : Not set.
  /// - "IMMEDIATE" : If the user wants to schedule the maintenance to happen
  /// now.
  /// - "NEXT_AVAILABLE_WINDOW" : If the user wants to use the existing
  /// maintenance policy to find the next available window.
  /// - "SPECIFIC_TIME" : If the user wants to reschedule the maintenance to a
  /// specific time.
  core.String? rescheduleType;

  /// Timestamp when the maintenance shall be rescheduled to if
  /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for example
  /// `2012-11-15T16:19:00.094Z`.
  ///
  /// Optional.
  core.String? scheduleTime;

  $RescheduleMaintenanceRequest01({this.rescheduleType, this.scheduleTime});

  $RescheduleMaintenanceRequest01.fromJson(core.Map json_)
    : this(
        rescheduleType: json_['rescheduleType'] as core.String?,
        scheduleTime: json_['scheduleTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rescheduleType != null) 'rescheduleType': rescheduleType!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ReservationAffinity
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ReservationAffinity
class $ReservationAffinity00 {
  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, use
  /// `compute.googleapis.com/reservation-name` as the key and specify the name
  /// of your reservation as its value.
  ///
  /// Optional.
  core.String? key;

  /// Specifies the reservation affinity type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value. This should not be used.
  /// - "NO_RESERVATION" : Do not consume from any reserved capacity, only use
  /// on-demand.
  /// - "ANY_RESERVATION" : Consume any reservation available, falling back to
  /// on-demand.
  /// - "SPECIFIC_RESERVATION" : Consume from a specific reservation. When
  /// chosen, the reservation must be identified via the `key` and `values`
  /// fields.
  core.String? reservationAffinityType;

  /// Corresponds to the label values of a reservation resource.
  ///
  /// This must be the full resource name of the reservation or reservation
  /// block.
  ///
  /// Optional.
  core.List<core.String>? values;

  $ReservationAffinity00({this.key, this.reservationAffinityType, this.values});

  $ReservationAffinity00.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        reservationAffinityType:
            json_['reservationAffinityType'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (reservationAffinityType != null)
      'reservationAffinityType': reservationAffinityType!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationAffinity
/// - compute:beta : ReservationAffinity
class $ReservationAffinity01 {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
  /// NO_RESERVATION.
  ///
  /// See Consuming reserved instances for examples.
  /// Possible string values are:
  /// - "ANY_RESERVATION" : Consume any allocation available.
  /// - "NO_RESERVATION" : Do not consume from any allocated capacity.
  /// - "SPECIFIC_RESERVATION" : Must consume from a specific reservation. Must
  /// specify key value fields for specifying the reservations.
  /// - "SPECIFIC_THEN_ANY_RESERVATION" : Prefer to consume from a specific
  /// reservation, but still consume any reservation available if the specified
  /// reservation is not available or exhausted. Must specify key value fields
  /// for specifying the reservations.
  /// - "SPECIFIC_THEN_NO_RESERVATION" : Prefer to consume from a specific
  /// reservation, but still consume from the on-demand pool if the specified
  /// reservation is exhausted. Must specify key value fields for specifying the
  /// reservations.
  /// - "UNSPECIFIED"
  core.String? consumeReservationType;

  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, specify
  /// googleapis.com/reservation-name as the key and specify the name of your
  /// reservation as its value.
  core.String? key;

  /// Corresponds to the label values of a reservation resource.
  ///
  /// This can be either a name to a reservation in the same project or
  /// "projects/different-project/reservations/some-reservation-name" to target
  /// a shared reservation in the same zone but in a different project.
  core.List<core.String>? values;

  $ReservationAffinity01({this.consumeReservationType, this.key, this.values});

  $ReservationAffinity01.fromJson(core.Map json_)
    : this(
        consumeReservationType: json_['consumeReservationType'] as core.String?,
        key: json_['key'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumeReservationType != null)
      'consumeReservationType': consumeReservationType!,
    if (key != null) 'key': key!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - container:v1 : ReservationAffinity
/// - container:v1beta1 : ReservationAffinity
class $ReservationAffinity02 {
  /// Corresponds to the type of reservation consumption.
  /// Possible string values are:
  /// - "UNSPECIFIED" : Default value. This should not be used.
  /// - "NO_RESERVATION" : Do not consume from any reserved capacity.
  /// - "ANY_RESERVATION" : Consume any reservation available.
  /// - "SPECIFIC_RESERVATION" : Must consume from a specific reservation. Must
  /// specify key value fields for specifying the reservations.
  core.String? consumeReservationType;

  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, specify
  /// "compute.googleapis.com/reservation-name" as the key and specify the name
  /// of your reservation as its value.
  core.String? key;

  /// Corresponds to the label value(s) of reservation resource(s).
  core.List<core.String>? values;

  $ReservationAffinity02({this.consumeReservationType, this.key, this.values});

  $ReservationAffinity02.fromJson(core.Map json_)
    : this(
        consumeReservationType: json_['consumeReservationType'] as core.String?,
        key: json_['key'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumeReservationType != null)
      'consumeReservationType': consumeReservationType!,
    if (key != null) 'key': key!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationBlockHealthInfo
/// - compute:beta : ReservationBlockHealthInfo
/// - compute:v1 : ReservationBlockHealthInfo
class $ReservationBlockHealthInfo {
  /// The number of subBlocks that are degraded.
  core.int? degradedSubBlockCount;

  /// The health status of the reservation block.
  /// Possible string values are:
  /// - "DEGRADED" : The reservation block is degraded.
  /// - "HEALTHY" : The reservation block is healthy.
  /// - "HEALTH_STATUS_UNSPECIFIED" : The health status of the reservation block
  /// is unspecified.
  core.String? healthStatus;

  /// The number of subBlocks that are healthy.
  core.int? healthySubBlockCount;

  $ReservationBlockHealthInfo({
    this.degradedSubBlockCount,
    this.healthStatus,
    this.healthySubBlockCount,
  });

  $ReservationBlockHealthInfo.fromJson(core.Map json_)
    : this(
        degradedSubBlockCount: json_['degradedSubBlockCount'] as core.int?,
        healthStatus: json_['healthStatus'] as core.String?,
        healthySubBlockCount: json_['healthySubBlockCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (degradedSubBlockCount != null)
      'degradedSubBlockCount': degradedSubBlockCount!,
    if (healthStatus != null) 'healthStatus': healthStatus!,
    if (healthySubBlockCount != null)
      'healthySubBlockCount': healthySubBlockCount!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationBlockPhysicalTopologyInstancePhysicalHostTopology
/// - compute:beta : ReservationBlockPhysicalTopologyInstancePhysicalHostTopology
/// - compute:v1 : ReservationBlockPhysicalTopologyInstancePhysicalHostTopology
class $ReservationBlockPhysicalTopologyInstancePhysicalHostTopology {
  /// Host hash for a given instance
  core.String? host;

  /// Sub block hash for a given instance
  core.String? subBlock;

  $ReservationBlockPhysicalTopologyInstancePhysicalHostTopology({
    this.host,
    this.subBlock,
  });

  $ReservationBlockPhysicalTopologyInstancePhysicalHostTopology.fromJson(
    core.Map json_,
  ) : this(
        host: json_['host'] as core.String?,
        subBlock: json_['subBlock'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (subBlock != null) 'subBlock': subBlock!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationSubBlockHealthInfo
/// - compute:beta : ReservationSubBlockHealthInfo
/// - compute:v1 : ReservationSubBlockHealthInfo
class $ReservationSubBlockHealthInfo {
  /// The number of degraded hosts in the reservation subBlock.
  core.int? degradedHostCount;

  /// The number of degraded infrastructure (e.g NV link domain) in the
  /// reservation subblock.
  core.int? degradedInfraCount;

  /// The health status of the reservation subBlock.
  /// Possible string values are:
  /// - "DEGRADED" : The reservation subBlock is degraded.
  /// - "HEALTHY" : The reservation subBlock is healthy.
  /// - "HEALTH_STATUS_UNSPECIFIED" : The health status of the reservation
  /// subBlock is unspecified.
  core.String? healthStatus;

  /// The number of healthy hosts in the reservation subBlock.
  core.int? healthyHostCount;

  /// The number of healthy infrastructure (e.g NV link domain) in the
  /// reservation subblock.
  core.int? healthyInfraCount;

  $ReservationSubBlockHealthInfo({
    this.degradedHostCount,
    this.degradedInfraCount,
    this.healthStatus,
    this.healthyHostCount,
    this.healthyInfraCount,
  });

  $ReservationSubBlockHealthInfo.fromJson(core.Map json_)
    : this(
        degradedHostCount: json_['degradedHostCount'] as core.int?,
        degradedInfraCount: json_['degradedInfraCount'] as core.int?,
        healthStatus: json_['healthStatus'] as core.String?,
        healthyHostCount: json_['healthyHostCount'] as core.int?,
        healthyInfraCount: json_['healthyInfraCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (degradedHostCount != null) 'degradedHostCount': degradedHostCount!,
    if (degradedInfraCount != null) 'degradedInfraCount': degradedInfraCount!,
    if (healthStatus != null) 'healthStatus': healthStatus!,
    if (healthyHostCount != null) 'healthyHostCount': healthyHostCount!,
    if (healthyInfraCount != null) 'healthyInfraCount': healthyInfraCount!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationSubBlockPhysicalTopology
/// - compute:beta : ReservationSubBlockPhysicalTopology
/// - compute:v1 : ReservationSubBlockPhysicalTopology
class $ReservationSubBlockPhysicalTopology {
  /// The hash of the capacity block within the cluster.
  core.String? block;

  /// The cluster name of the reservation subBlock.
  core.String? cluster;

  /// The hash of the capacity sub-block within the capacity block.
  core.String? subBlock;

  $ReservationSubBlockPhysicalTopology({
    this.block,
    this.cluster,
    this.subBlock,
  });

  $ReservationSubBlockPhysicalTopology.fromJson(core.Map json_)
    : this(
        block: json_['block'] as core.String?,
        cluster: json_['cluster'] as core.String?,
        subBlock: json_['subBlock'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (block != null) 'block': block!,
    if (cluster != null) 'cluster': cluster!,
    if (subBlock != null) 'subBlock': subBlock!,
  };
}

/// Used by:
///
/// - compute:alpha : ReservationsResizeRequest
/// - compute:beta : ReservationsResizeRequest
/// - compute:v1 : ReservationsResizeRequest
class $ReservationsResizeRequest {
  /// Number of allocated resources can be resized with minimum = 1 and maximum
  /// = 1000.
  core.String? specificSkuCount;

  $ReservationsResizeRequest({this.specificSkuCount});

  $ReservationsResizeRequest.fromJson(core.Map json_)
    : this(specificSkuCount: json_['specificSkuCount'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (specificSkuCount != null) 'specificSkuCount': specificSkuCount!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : ResetAdminPasswordResponse
/// - managedidentities:v1alpha1 : ResetAdminPasswordResponse
/// - managedidentities:v1beta1 : ResetAdminPasswordResponse
class $ResetAdminPasswordResponse {
  /// A random password.
  ///
  /// See admin for more information.
  core.String? password;

  $ResetAdminPasswordResponse({this.password});

  $ResetAdminPasswordResponse.fromJson(core.Map json_)
    : this(password: json_['password'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : ResourceAccessControl
/// - deploymentmanager:v2 : ResourceAccessControl
/// - deploymentmanager:v2beta : ResourceAccessControl
class $ResourceAccessControl {
  /// The GCP IAM Policy to set on the resource.
  core.String? gcpIamPolicy;

  $ResourceAccessControl({this.gcpIamPolicy});

  $ResourceAccessControl.fromJson(core.Map json_)
    : this(gcpIamPolicy: json_['gcpIamPolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcpIamPolicy != null) 'gcpIamPolicy': gcpIamPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourceCommitment
/// - compute:beta : ResourceCommitment
/// - compute:v1 : ResourceCommitment
class $ResourceCommitment {
  /// Name of the accelerator type or GPU resource.
  ///
  /// Specify this field only when the type of hardware resource is ACCELERATOR.
  core.String? acceleratorType;

  /// The quantity of the hardware resource that you want to commit to
  /// purchasing (in a type-dependent unit).
  ///
  /// - For vCPUs, you must specify an integer value. - For memory, you specify
  /// the amount of MB that you want. The value you specify must be a multiple
  /// of 256 MB, with up to 6.5 GB of memory per every vCPU. - For GPUs, you
  /// must specify an integer value. - For Local SSD disks, you must specify the
  /// amount in GB. The size of a single Local SSD disk is 375 GB.
  core.String? amount;

  /// The type of hardware resource that you want to specify.
  ///
  /// You can specify any of the following values: - VCPU - MEMORY - LOCAL_SSD -
  /// ACCELERATOR Specify as a separate entry in the list for each individual
  /// resource type.
  /// Possible string values are:
  /// - "ACCELERATOR"
  /// - "LOCAL_SSD"
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String? type;

  $ResourceCommitment({this.acceleratorType, this.amount, this.type});

  $ResourceCommitment.fromJson(core.Map json_)
    : this(
        acceleratorType: json_['acceleratorType'] as core.String?,
        amount: json_['amount'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorType != null) 'acceleratorType': acceleratorType!,
    if (amount != null) 'amount': amount!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - policysimulator:v1 : GoogleCloudPolicysimulatorV1ResourceContext
/// - policysimulator:v1beta : GoogleCloudPolicysimulatorV1betaResourceContext
class $ResourceContext {
  /// The ancestry path of the resource in Google Cloud
  /// [resource hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
  /// represented as a list of relative resource names.
  ///
  /// An ancestry path starts with the closest ancestor in the hierarchy and
  /// ends at root. If the resource is a project, folder, or organization, the
  /// ancestry path starts from the resource itself. Example:
  /// `["projects/123456789", "folders/5432", "organizations/1234"]`
  core.List<core.String>? ancestors;

  /// The asset type of the resource as defined by CAIS.
  ///
  /// Example: `compute.googleapis.com/Firewall` See
  /// [Supported asset types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
  /// for more information.
  core.String? assetType;

  /// The full name of the resource.
  ///
  /// Example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
  /// See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
  /// for more information.
  core.String? resource;

  $ResourceContext({this.ancestors, this.assetType, this.resource});

  $ResourceContext.fromJson(core.Map json_)
    : this(
        ancestors:
            (json_['ancestors'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        assetType: json_['assetType'] as core.String?,
        resource: json_['resource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ancestors != null) 'ancestors': ancestors!,
    if (assetType != null) 'assetType': assetType!,
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : ResourceDescriptor
/// - containeranalysis:v1alpha1 : ResourceDescriptor
/// - containeranalysis:v1beta1 : ResourceDescriptor
/// - ondemandscanning:v1 : ResourceDescriptor
/// - ondemandscanning:v1beta1 : ResourceDescriptor
class $ResourceDescriptor {
  ///
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? annotations;
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  core.Map<core.String, core.String>? digest;
  core.String? downloadLocation;
  core.String? mediaType;
  core.String? name;
  core.String? uri;

  $ResourceDescriptor({
    this.annotations,
    this.content,
    this.digest,
    this.downloadLocation,
    this.mediaType,
    this.name,
    this.uri,
  });

  $ResourceDescriptor.fromJson(core.Map json_)
    : this(
        annotations:
            json_.containsKey('annotations')
                ? json_['annotations'] as core.Map<core.String, core.dynamic>
                : null,
        content: json_['content'] as core.String?,
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        downloadLocation: json_['downloadLocation'] as core.String?,
        mediaType: json_['mediaType'] as core.String?,
        name: json_['name'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (content != null) 'content': content!,
    if (digest != null) 'digest': digest!,
    if (downloadLocation != null) 'downloadLocation': downloadLocation!,
    if (mediaType != null) 'mediaType': mediaType!,
    if (name != null) 'name': name!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourceGroupReference
/// - compute:beta : ResourceGroupReference
/// - compute:v1 : ResourceGroupReference
class $ResourceGroupReference {
  /// A URI referencing one of the instance groups or network endpoint groups
  /// listed in the backend service.
  core.String? group;

  $ResourceGroupReference({this.group});

  $ResourceGroupReference.fromJson(core.Map json_)
    : this(group: json_['group'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (group != null) 'group': group!,
  };
}

/// Used by:
///
/// - container:v1 : ResourceLimit
/// - container:v1beta1 : ResourceLimit
class $ResourceLimit {
  /// Maximum amount of the resource in the cluster.
  core.String? maximum;

  /// Minimum amount of the resource in the cluster.
  core.String? minimum;

  /// Resource name "cpu", "memory" or gpu-specific string.
  core.String? resourceType;

  $ResourceLimit({this.maximum, this.minimum, this.resourceType});

  $ResourceLimit.fromJson(core.Map json_)
    : this(
        maximum: json_['maximum'] as core.String?,
        minimum: json_['minimum'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maximum != null) 'maximum': maximum!,
    if (minimum != null) 'minimum': minimum!,
    if (resourceType != null) 'resourceType': resourceType!,
  };
}

/// Used by:
///
/// - connectors:v1 : ResourceLimits
/// - integrations:v1 : GoogleCloudConnectorsV1ResourceLimits
class $ResourceLimits {
  /// CPU limit.
  ///
  /// Output only.
  core.String? cpu;

  /// Memory limit.
  ///
  /// Output only.
  core.String? memory;

  $ResourceLimits({this.cpu, this.memory});

  $ResourceLimits.fromJson(core.Map json_)
    : this(
        cpu: json_['cpu'] as core.String?,
        memory: json_['memory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpu != null) 'cpu': cpu!,
    if (memory != null) 'memory': memory!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ResourceManifest
/// - gkehub:v1alpha : ResourceManifest
/// - gkehub:v1beta : ResourceManifest
class $ResourceManifest {
  /// Whether the resource provided in the manifest is `cluster_scoped`.
  ///
  /// If unset, the manifest is assumed to be namespace scoped. This field is
  /// used for REST mapping when applying the resource in a cluster.
  ///
  /// Output only.
  core.bool? clusterScoped;

  /// YAML manifest of the resource.
  ///
  /// Output only.
  core.String? manifest;

  $ResourceManifest({this.clusterScoped, this.manifest});

  $ResourceManifest.fromJson(core.Map json_)
    : this(
        clusterScoped: json_['clusterScoped'] as core.bool?,
        manifest: json_['manifest'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterScoped != null) 'clusterScoped': clusterScoped!,
    if (manifest != null) 'manifest': manifest!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResourceName
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResourceName
class $ResourceName {
  /// Display name.
  core.String? displayName;

  /// Name.
  core.String? name;

  $ResourceName({this.displayName, this.name});

  $ResourceName.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ResourceOptions
/// - gkehub:v1alpha : ResourceOptions
/// - gkehub:v1beta : ResourceOptions
/// - gkehub:v1beta1 : ResourceOptions
class $ResourceOptions {
  /// The Connect agent version to use for connect_resources.
  ///
  /// Defaults to the latest GKE Connect version. The version must be a
  /// currently supported version, obsolete versions will be rejected.
  ///
  /// Optional.
  core.String? connectVersion;

  /// Major version of the Kubernetes cluster.
  ///
  /// This is only used to determine which version to use for the
  /// CustomResourceDefinition resources, `apiextensions/v1beta1`
  /// or`apiextensions/v1`.
  ///
  /// Optional.
  core.String? k8sVersion;

  /// Use `apiextensions/v1beta1` instead of `apiextensions/v1` for
  /// CustomResourceDefinition resources.
  ///
  /// This option should be set for clusters with Kubernetes apiserver versions
  /// \<1.16.
  ///
  /// Optional.
  core.bool? v1beta1Crd;

  $ResourceOptions({this.connectVersion, this.k8sVersion, this.v1beta1Crd});

  $ResourceOptions.fromJson(core.Map json_)
    : this(
        connectVersion: json_['connectVersion'] as core.String?,
        k8sVersion: json_['k8sVersion'] as core.String?,
        v1beta1Crd: json_['v1beta1Crd'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectVersion != null) 'connectVersion': connectVersion!,
    if (k8sVersion != null) 'k8sVersion': k8sVersion!,
    if (v1beta1Crd != null) 'v1beta1Crd': v1beta1Crd!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyDailyCycle
/// - compute:beta : ResourcePolicyDailyCycle
/// - compute:v1 : ResourcePolicyDailyCycle
class $ResourcePolicyDailyCycle {
  /// Defines a schedule with units measured in days.
  ///
  /// The value determines how many days pass between the start of each cycle.
  core.int? daysInCycle;

  /// A predetermined duration for the window, automatically chosen to be the
  /// smallest possible in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Start time of the window.
  ///
  /// This must be in UTC format that resolves to one of 00:00, 04:00, 08:00,
  /// 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
  core.String? startTime;

  $ResourcePolicyDailyCycle({this.daysInCycle, this.duration, this.startTime});

  $ResourcePolicyDailyCycle.fromJson(core.Map json_)
    : this(
        daysInCycle: json_['daysInCycle'] as core.int?,
        duration: json_['duration'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (daysInCycle != null) 'daysInCycle': daysInCycle!,
    if (duration != null) 'duration': duration!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyHourlyCycle
/// - compute:beta : ResourcePolicyHourlyCycle
/// - compute:v1 : ResourcePolicyHourlyCycle
class $ResourcePolicyHourlyCycle {
  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Defines a schedule with units measured in hours.
  ///
  /// The value determines how many hours pass between the start of each cycle.
  core.int? hoursInCycle;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  $ResourcePolicyHourlyCycle({
    this.duration,
    this.hoursInCycle,
    this.startTime,
  });

  $ResourcePolicyHourlyCycle.fromJson(core.Map json_)
    : this(
        duration: json_['duration'] as core.String?,
        hoursInCycle: json_['hoursInCycle'] as core.int?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (duration != null) 'duration': duration!,
    if (hoursInCycle != null) 'hoursInCycle': hoursInCycle!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyInstanceSchedulePolicySchedule
/// - compute:beta : ResourcePolicyInstanceSchedulePolicySchedule
/// - compute:v1 : ResourcePolicyInstanceSchedulePolicySchedule
class $ResourcePolicyInstanceSchedulePolicySchedule {
  /// Specifies the frequency for the operation, using the unix-cron format.
  core.String? schedule;

  $ResourcePolicyInstanceSchedulePolicySchedule({this.schedule});

  $ResourcePolicyInstanceSchedulePolicySchedule.fromJson(core.Map json_)
    : this(schedule: json_['schedule'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (schedule != null) 'schedule': schedule!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
/// - compute:beta : ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
/// - compute:v1 : ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
class $ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
  /// The last time the schedule successfully ran.
  ///
  /// The timestamp is an RFC3339 string.
  ///
  /// Output only.
  core.String? lastRunStartTime;

  /// The next time the schedule is planned to run.
  ///
  /// The actual time might be slightly different. The timestamp is an RFC3339
  /// string.
  ///
  /// Output only.
  core.String? nextRunStartTime;

  $ResourcePolicyResourceStatusInstanceSchedulePolicyStatus({
    this.lastRunStartTime,
    this.nextRunStartTime,
  });

  $ResourcePolicyResourceStatusInstanceSchedulePolicyStatus.fromJson(
    core.Map json_,
  ) : this(
        lastRunStartTime: json_['lastRunStartTime'] as core.String?,
        nextRunStartTime: json_['nextRunStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastRunStartTime != null) 'lastRunStartTime': lastRunStartTime!,
    if (nextRunStartTime != null) 'nextRunStartTime': nextRunStartTime!,
  };
}

/// Used by:
///
/// - compute:beta : ResourcePolicySnapshotSchedulePolicyRetentionPolicy
/// - compute:v1 : ResourcePolicySnapshotSchedulePolicyRetentionPolicy
class $ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /// Maximum age of the snapshot that is allowed to be kept.
  core.int? maxRetentionDays;

  /// Specifies the behavior to apply to scheduled snapshots when the source
  /// disk is deleted.
  /// Possible string values are:
  /// - "APPLY_RETENTION_POLICY"
  /// - "KEEP_AUTO_SNAPSHOTS"
  /// - "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
  core.String? onSourceDiskDelete;

  $ResourcePolicySnapshotSchedulePolicyRetentionPolicy({
    this.maxRetentionDays,
    this.onSourceDiskDelete,
  });

  $ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(core.Map json_)
    : this(
        maxRetentionDays: json_['maxRetentionDays'] as core.int?,
        onSourceDiskDelete: json_['onSourceDiskDelete'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxRetentionDays != null) 'maxRetentionDays': maxRetentionDays!,
    if (onSourceDiskDelete != null) 'onSourceDiskDelete': onSourceDiskDelete!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicySnapshotSchedulePolicySnapshotProperties
/// - compute:beta : ResourcePolicySnapshotSchedulePolicySnapshotProperties
class $ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /// Chain name that the snapshot is created in.
  core.String? chainName;

  /// Indication to perform a 'guest aware' snapshot.
  core.bool? guestFlush;

  /// Labels to apply to scheduled snapshots.
  ///
  /// These can be later modified by the setLabels method. Label values may be
  /// empty.
  core.Map<core.String, core.String>? labels;

  /// Region where the snapshot is scoped to.
  core.String? region;

  /// Cloud Storage bucket storage location of the auto snapshot (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  $ResourcePolicySnapshotSchedulePolicySnapshotProperties({
    this.chainName,
    this.guestFlush,
    this.labels,
    this.region,
    this.storageLocations,
  });

  $ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
    core.Map json_,
  ) : this(
        chainName: json_['chainName'] as core.String?,
        guestFlush: json_['guestFlush'] as core.bool?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        region: json_['region'] as core.String?,
        storageLocations:
            (json_['storageLocations'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chainName != null) 'chainName': chainName!,
    if (guestFlush != null) 'guestFlush': guestFlush!,
    if (labels != null) 'labels': labels!,
    if (region != null) 'region': region!,
    if (storageLocations != null) 'storageLocations': storageLocations!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyWeeklyCycleDayOfWeek
/// - compute:beta : ResourcePolicyWeeklyCycleDayOfWeek
/// - compute:v1 : ResourcePolicyWeeklyCycleDayOfWeek
class $ResourcePolicyWeeklyCycleDayOfWeek {
  /// Defines a schedule that runs on specific days of the week.
  ///
  /// Specify one or more days. The following options are available: MONDAY,
  /// TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
  /// Possible string values are:
  /// - "FRIDAY"
  /// - "INVALID"
  /// - "MONDAY"
  /// - "SATURDAY"
  /// - "SUNDAY"
  /// - "THURSDAY"
  /// - "TUESDAY"
  /// - "WEDNESDAY"
  core.String? day;

  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  $ResourcePolicyWeeklyCycleDayOfWeek({
    this.day,
    this.duration,
    this.startTime,
  });

  $ResourcePolicyWeeklyCycleDayOfWeek.fromJson(core.Map json_)
    : this(
        day: json_['day'] as core.String?,
        duration: json_['duration'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (day != null) 'day': day!,
    if (duration != null) 'duration': duration!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourcePolicyWorkloadPolicy
/// - compute:beta : ResourcePolicyWorkloadPolicy
/// - compute:v1 : ResourcePolicyWorkloadPolicy
class $ResourcePolicyWorkloadPolicy {
  core.String? acceleratorTopology;

  ///
  /// Possible string values are:
  /// - "BLOCK" : VMs must be provisioned in the same block.
  /// - "CLUSTER" : VMs must be provisioned in the same cluster.
  /// - "SUBBLOCK" : VMs must be provisioned in the same subblock.
  core.String? maxTopologyDistance;

  ///
  /// Possible string values are:
  /// - "HIGH_AVAILABILITY" : VMs will be provisioned in such a way which
  /// provides high availability.
  /// - "HIGH_THROUGHPUT" : VMs will be provisioned in such a way which provides
  /// high throughput.
  core.String? type;

  $ResourcePolicyWorkloadPolicy({
    this.acceleratorTopology,
    this.maxTopologyDistance,
    this.type,
  });

  $ResourcePolicyWorkloadPolicy.fromJson(core.Map json_)
    : this(
        acceleratorTopology: json_['acceleratorTopology'] as core.String?,
        maxTopologyDistance: json_['maxTopologyDistance'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorTopology != null)
      'acceleratorTopology': acceleratorTopology!,
    if (maxTopologyDistance != null)
      'maxTopologyDistance': maxTopologyDistance!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ResourcePoolAutoscalingSpec
class $ResourcePoolAutoscalingSpec {
  /// max replicas in the node pool, must be  replica_count and \>
  /// min_replica_count or will throw error
  ///
  /// Optional.
  core.String? maxReplicaCount;

  /// min replicas in the node pool, must be  replica_count and \<
  /// max_replica_count or will throw error.
  ///
  /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
  /// resource_pool to be 0 to match the OSS Ray
  /// behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
  /// As for Persistent Resource, the min_replica_count must be \> 0, we added a
  /// corresponding validation inside
  /// CreatePersistentResourceRequestValidator.java.
  ///
  /// Optional.
  core.String? minReplicaCount;

  $ResourcePoolAutoscalingSpec({this.maxReplicaCount, this.minReplicaCount});

  $ResourcePoolAutoscalingSpec.fromJson(core.Map json_)
    : this(
        maxReplicaCount: json_['maxReplicaCount'] as core.String?,
        minReplicaCount: json_['minReplicaCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
    if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
  };
}

/// Used by:
///
/// - appengine:v1alpha : ResourceRecord
/// - appengine:v1beta : ResourceRecord
class $ResourceRecord {
  /// Relative name of the object affected by this record.
  ///
  /// Only applicable for CNAME records. Example: 'www'.
  core.String? name;

  /// Data for this record.
  ///
  /// Values vary by record type, as defined in RFC 1035 (section 5) and RFC
  /// 1034 (section 3.6.1).
  core.String? rrdata;

  /// Resource record type.
  ///
  /// Example: AAAA.
  /// Possible string values are:
  /// - "A" : An A resource record. Data is an IPv4 address.
  /// - "AAAA" : An AAAA resource record. Data is an IPv6 address.
  /// - "CNAME" : A CNAME resource record. Data is a domain name to be aliased.
  core.String? type;

  $ResourceRecord({this.name, this.rrdata, this.type});

  $ResourceRecord.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        rrdata: json_['rrdata'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (rrdata != null) 'rrdata': rrdata!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - connectors:v1 : ResourceRequests
/// - integrations:v1 : GoogleCloudConnectorsV1ResourceRequests
class $ResourceRequests {
  /// CPU request.
  ///
  /// Output only.
  core.String? cpu;

  /// Memory request.
  ///
  /// Output only.
  core.String? memory;

  $ResourceRequests({this.cpu, this.memory});

  $ResourceRequests.fromJson(core.Map json_)
    : this(
        cpu: json_['cpu'] as core.String?,
        memory: json_['memory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpu != null) 'cpu': cpu!,
    if (memory != null) 'memory': memory!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourceStatusPhysicalHostTopology
/// - compute:beta : ResourceStatusPhysicalHostTopology
/// - compute:v1 : ResourceStatusPhysicalHostTopology
class $ResourceStatusPhysicalHostTopology {
  /// The ID of the block in which the running instance is located.
  ///
  /// Instances within the same block experience low network latency.
  ///
  /// Output only.
  core.String? block;

  /// The global name of the Compute Engine cluster where the running instance
  /// is located.
  ///
  /// Output only.
  core.String? cluster;

  /// The ID of the host on which the running instance is located.
  ///
  /// Instances on the same host experience the lowest possible network latency.
  ///
  /// Output only.
  core.String? host;

  /// The ID of the sub-block in which the running instance is located.
  ///
  /// Instances in the same sub-block experience lower network latency than
  /// instances in the same block.
  ///
  /// Output only.
  core.String? subblock;

  $ResourceStatusPhysicalHostTopology({
    this.block,
    this.cluster,
    this.host,
    this.subblock,
  });

  $ResourceStatusPhysicalHostTopology.fromJson(core.Map json_)
    : this(
        block: json_['block'] as core.String?,
        cluster: json_['cluster'] as core.String?,
        host: json_['host'] as core.String?,
        subblock: json_['subblock'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (block != null) 'block': block!,
    if (cluster != null) 'cluster': cluster!,
    if (host != null) 'host': host!,
    if (subblock != null) 'subblock': subblock!,
  };
}

/// Used by:
///
/// - compute:alpha : ResourceStatusScheduling
/// - compute:beta : ResourceStatusScheduling
class $ResourceStatusScheduling {
  /// Specifies the availability domain to place the instance in.
  ///
  /// The value must be a number between 1 and the number of availability
  /// domains specified in the spread placement policy attached to the instance.
  core.int? availabilityDomain;

  /// Time in future when the instance will be terminated in RFC3339 text
  /// format.
  core.String? terminationTimestamp;

  $ResourceStatusScheduling({
    this.availabilityDomain,
    this.terminationTimestamp,
  });

  $ResourceStatusScheduling.fromJson(core.Map json_)
    : this(
        availabilityDomain: json_['availabilityDomain'] as core.int?,
        terminationTimestamp: json_['terminationTimestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (availabilityDomain != null) 'availabilityDomain': availabilityDomain!,
    if (terminationTimestamp != null)
      'terminationTimestamp': terminationTimestamp!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Resources
/// - healthcare:v1beta1 : Resources
class $Resources {
  /// List of resources IDs.
  ///
  /// For example, "Patient/1234".
  core.List<core.String>? resources;

  $Resources({this.resources});

  $Resources.fromJson(core.Map json_)
    : this(
        resources:
            (json_['resources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resources != null) 'resources': resources!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ResourcesConsumed
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ResourcesConsumed
class $ResourcesConsumed {
  /// The number of replica hours used.
  ///
  /// Note that many replicas may run in parallel, and additionally any given
  /// work may be queued for some time. Therefore this value is not strictly
  /// related to wall time.
  ///
  /// Output only.
  core.double? replicaHours;

  $ResourcesConsumed({this.replicaHours});

  $ResourcesConsumed.fromJson(core.Map json_)
    : this(replicaHours: (json_['replicaHours'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (replicaHours != null) 'replicaHours': replicaHours!,
  };
}

/// Used by:
///
/// - notebooks:v1 : IsInstanceUpgradeableResponse
/// - notebooks:v2 : CheckInstanceUpgradabilityResponse
class $Response00 {
  /// The new image self link this instance will be upgraded to if calling the
  /// upgrade endpoint.
  ///
  /// This field will only be populated if field upgradeable is true.
  core.String? upgradeImage;

  /// Additional information about upgrade.
  core.String? upgradeInfo;

  /// The version this instance will be upgraded to if calling the upgrade
  /// endpoint.
  ///
  /// This field will only be populated if field upgradeable is true.
  core.String? upgradeVersion;

  /// If an instance is upgradeable.
  core.bool? upgradeable;

  $Response00({
    this.upgradeImage,
    this.upgradeInfo,
    this.upgradeVersion,
    this.upgradeable,
  });

  $Response00.fromJson(core.Map json_)
    : this(
        upgradeImage: json_['upgradeImage'] as core.String?,
        upgradeInfo: json_['upgradeInfo'] as core.String?,
        upgradeVersion: json_['upgradeVersion'] as core.String?,
        upgradeable: json_['upgradeable'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (upgradeImage != null) 'upgradeImage': upgradeImage!,
    if (upgradeInfo != null) 'upgradeInfo': upgradeInfo!,
    if (upgradeVersion != null) 'upgradeVersion': upgradeVersion!,
    if (upgradeable != null) 'upgradeable': upgradeable!,
  };
}

/// Used by:
///
/// - pubsub:v1beta1a : PublishBatchResponse
/// - pubsub:v1beta2 : PublishResponse
class $Response01 {
  /// The server-assigned ID of each published message, in the same order as the
  /// messages in the request.
  ///
  /// IDs are guaranteed to be unique within the topic.
  core.List<core.String>? messageIds;

  $Response01({this.messageIds});

  $Response01.fromJson(core.Map json_)
    : this(
        messageIds:
            (json_['messageIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (messageIds != null) 'messageIds': messageIds!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageConversationSuccess
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageConversationSuccess
class $ResponseMessageConversationSuccess {
  /// Custom metadata.
  ///
  /// Dialogflow doesn't impose any structure on this.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  $ResponseMessageConversationSuccess({this.metadata});

  $ResponseMessageConversationSuccess.fromJson(core.Map json_)
    : this(
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Used by:
///
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ResponseMessageLiveAgentHandoff
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageLiveAgentHandoff
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageLiveAgentHandoff
class $ResponseMessageLiveAgentHandoff {
  /// Custom metadata for your handoff procedure.
  ///
  /// Dialogflow doesn't impose any structure on this.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  $ResponseMessageLiveAgentHandoff({this.metadata});

  $ResponseMessageLiveAgentHandoff.fromJson(core.Map json_)
    : this(
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageMixedAudioSegment
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageMixedAudioSegment
class $ResponseMessageMixedAudioSegment {
  /// Whether the playback of this segment can be interrupted by the end user's
  /// speech and the client should then start the next Dialogflow request.
  ///
  /// Output only.
  core.bool? allowPlaybackInterruption;

  /// Raw audio synthesized from the Dialogflow agent's response using the
  /// output config specified in the request.
  core.String? audio;
  core.List<core.int> get audioAsBytes => convert.base64.decode(audio!);

  set audioAsBytes(core.List<core.int> bytes_) {
    audio = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Client-specific URI that points to an audio clip accessible to the client.
  ///
  /// Dialogflow does not impose any validation on it.
  core.String? uri;

  $ResponseMessageMixedAudioSegment({
    this.allowPlaybackInterruption,
    this.audio,
    this.uri,
  });

  $ResponseMessageMixedAudioSegment.fromJson(core.Map json_)
    : this(
        allowPlaybackInterruption:
            json_['allowPlaybackInterruption'] as core.bool?,
        audio: json_['audio'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowPlaybackInterruption != null)
      'allowPlaybackInterruption': allowPlaybackInterruption!,
    if (audio != null) 'audio': audio!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageOutputAudioText
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageOutputAudioText
class $ResponseMessageOutputAudioText {
  /// Whether the playback of this message can be interrupted by the end user's
  /// speech and the client can then starts the next Dialogflow request.
  ///
  /// Output only.
  core.bool? allowPlaybackInterruption;

  /// The SSML text to be synthesized.
  ///
  /// For more information, see \[SSML\](/speech/text-to-speech/docs/ssml).
  core.String? ssml;

  /// The raw text to be synthesized.
  core.String? text;

  $ResponseMessageOutputAudioText({
    this.allowPlaybackInterruption,
    this.ssml,
    this.text,
  });

  $ResponseMessageOutputAudioText.fromJson(core.Map json_)
    : this(
        allowPlaybackInterruption:
            json_['allowPlaybackInterruption'] as core.bool?,
        ssml: json_['ssml'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowPlaybackInterruption != null)
      'allowPlaybackInterruption': allowPlaybackInterruption!,
    if (ssml != null) 'ssml': ssml!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessagePlayAudio
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessagePlayAudio
class $ResponseMessagePlayAudio {
  /// Whether the playback of this message can be interrupted by the end user's
  /// speech and the client can then starts the next Dialogflow request.
  ///
  /// Output only.
  core.bool? allowPlaybackInterruption;

  /// URI of the audio clip.
  ///
  /// Dialogflow does not impose any validation on this value. It is specific to
  /// the client that reads it.
  ///
  /// Required.
  core.String? audioUri;

  $ResponseMessagePlayAudio({this.allowPlaybackInterruption, this.audioUri});

  $ResponseMessagePlayAudio.fromJson(core.Map json_)
    : this(
        allowPlaybackInterruption:
            json_['allowPlaybackInterruption'] as core.bool?,
        audioUri: json_['audioUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowPlaybackInterruption != null)
      'allowPlaybackInterruption': allowPlaybackInterruption!,
    if (audioUri != null) 'audioUri': audioUri!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageTelephonyTransferCall
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageTelephonyTransferCall
class $ResponseMessageTelephonyTransferCall {
  /// Transfer the call to a phone number in
  /// [E.164 format](https://en.wikipedia.org/wiki/E.164).
  core.String? phoneNumber;

  $ResponseMessageTelephonyTransferCall({this.phoneNumber});

  $ResponseMessageTelephonyTransferCall.fromJson(core.Map json_)
    : this(phoneNumber: json_['phoneNumber'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (phoneNumber != null) 'phoneNumber': phoneNumber!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ResponseMessageText
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ResponseMessageText
class $ResponseMessageText {
  /// Whether the playback of this message can be interrupted by the end user's
  /// speech and the client can then starts the next Dialogflow request.
  ///
  /// Output only.
  core.bool? allowPlaybackInterruption;

  /// A collection of text response variants.
  ///
  /// If multiple variants are defined, only one text response variant is
  /// returned at runtime.
  ///
  /// Required.
  core.List<core.String>? text;

  $ResponseMessageText({this.allowPlaybackInterruption, this.text});

  $ResponseMessageText.fromJson(core.Map json_)
    : this(
        allowPlaybackInterruption:
            json_['allowPlaybackInterruption'] as core.bool?,
        text:
            (json_['text'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowPlaybackInterruption != null)
      'allowPlaybackInterruption': allowPlaybackInterruption!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - jobs:v3 : ResponseMetadata
/// - jobs:v3p1beta1 : ResponseMetadata
/// - jobs:v4 : ResponseMetadata
class $ResponseMetadata {
  /// A unique id associated with this call.
  ///
  /// This id is logged for tracking purposes.
  core.String? requestId;

  $ResponseMetadata({this.requestId});

  $ResponseMetadata.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - dns:v1 : ResponsePolicyGKECluster
/// - dns:v1beta2 : ResponsePolicyGKECluster
class $ResponsePolicyGKECluster {
  /// The resource name of the cluster to bind this response policy to.
  ///
  /// This should be specified in the format like: projects / * /locations / *
  /// /clusters / * . This is referenced from GKE
  /// projects.locations.clusters.get API:
  /// https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/get
  core.String? gkeClusterName;
  core.String? kind;

  $ResponsePolicyGKECluster({this.gkeClusterName, this.kind});

  $ResponsePolicyGKECluster.fromJson(core.Map json_)
    : this(
        gkeClusterName: json_['gkeClusterName'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gkeClusterName != null) 'gkeClusterName': gkeClusterName!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - dns:v1 : ResponsePolicyNetwork
/// - dns:v1beta2 : ResponsePolicyNetwork
class $ResponsePolicyNetwork {
  core.String? kind;

  /// The fully qualified URL of the VPC network to bind to.
  ///
  /// This should be formatted like
  /// `https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}`
  core.String? networkUrl;

  $ResponsePolicyNetwork({this.kind, this.networkUrl});

  $ResponsePolicyNetwork.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        networkUrl: json_['networkUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
  };
}

/// Used by:
///
/// - alloydb:v1 : RestartInstanceRequest
/// - alloydb:v1alpha : RestartInstanceRequest
/// - alloydb:v1beta : RestartInstanceRequest
class $RestartInstanceRequest {
  /// Full name of the nodes as obtained from INSTANCE_VIEW_FULL to restart
  /// upon.
  ///
  /// Applicable only to read instances.
  ///
  /// Optional.
  core.List<core.String>? nodeIds;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server ignores the request if it has already been completed. The server
  /// guarantees that for at least 60 minutes since the first request. For
  /// example, consider a situation where you make an initial request and the
  /// request times out. If you make the request again with the same request ID,
  /// the server can check if the original operation with the same request ID
  /// was received, and if so, ignores the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported
  /// (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// If set, performs request validation, for example, permission checks and
  /// any other type of validation, but does not actually execute the create
  /// request.
  ///
  /// Optional.
  core.bool? validateOnly;

  $RestartInstanceRequest({this.nodeIds, this.requestId, this.validateOnly});

  $RestartInstanceRequest.fromJson(core.Map json_)
    : this(
        nodeIds:
            (json_['nodeIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        requestId: json_['requestId'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeIds != null) 'nodeIds': nodeIds!,
    if (requestId != null) 'requestId': requestId!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - metastore:v1 : Restore
/// - metastore:v1alpha : Restore
/// - metastore:v1beta : Restore
class $Restore {
  /// The relative resource name of the metastore service backup to restore
  /// from, in the following
  /// form:projects/{project_id}/locations/{location_id}/services/{service_id}/backups/{backup_id}.
  ///
  /// Output only.
  core.String? backup;

  /// A Cloud Storage URI specifying where the backup artifacts are stored, in
  /// the format gs:///.
  ///
  /// Optional.
  core.String? backupLocation;

  /// The restore details containing the revision of the service to be restored
  /// to, in format of JSON.
  ///
  /// Output only.
  core.String? details;

  /// The time when the restore ended.
  ///
  /// Output only.
  core.String? endTime;

  /// The time when the restore started.
  ///
  /// Output only.
  core.String? startTime;

  /// The current state of the restore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The state of the metadata restore is unknown.
  /// - "RUNNING" : The metadata restore is running.
  /// - "SUCCEEDED" : The metadata restore completed successfully.
  /// - "FAILED" : The metadata restore failed.
  /// - "CANCELLED" : The metadata restore is cancelled.
  core.String? state;

  /// The type of restore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RESTORE_TYPE_UNSPECIFIED" : The restore type is unknown.
  /// - "FULL" : The service's metadata and configuration are restored.
  /// - "METADATA_ONLY" : Only the service's metadata is restored.
  core.String? type;

  $Restore({
    this.backup,
    this.backupLocation,
    this.details,
    this.endTime,
    this.startTime,
    this.state,
    this.type,
  });

  $Restore.fromJson(core.Map json_)
    : this(
        backup: json_['backup'] as core.String?,
        backupLocation: json_['backupLocation'] as core.String?,
        details: json_['details'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backup != null) 'backup': backup!,
    if (backupLocation != null) 'backupLocation': backupLocation!,
    if (details != null) 'details': details!,
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2RestoreAgentRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1RestoreAgentRequest
class $RestoreAgentRequest {
  /// Zip compressed raw byte content for agent.
  core.String? agentContent;
  core.List<core.int> get agentContentAsBytes =>
      convert.base64.decode(agentContent!);

  set agentContentAsBytes(core.List<core.int> bytes_) {
    agentContent = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The URI to a Google Cloud Storage file containing the agent to restore.
  ///
  /// Note: The URI must start with "gs://". Dialogflow performs a read
  /// operation for the Cloud Storage object on the caller's behalf, so your
  /// request authentication must have read permissions for the object. For more
  /// information, see
  /// [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
  core.String? agentUri;

  $RestoreAgentRequest({this.agentContent, this.agentUri});

  $RestoreAgentRequest.fromJson(core.Map json_)
    : this(
        agentContent: json_['agentContent'] as core.String?,
        agentUri: json_['agentUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentContent != null) 'agentContent': agentContent!,
    if (agentUri != null) 'agentUri': agentUri!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RestoreAgentRequestGitSource
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RestoreAgentRequestGitSource
class $RestoreAgentRequestGitSource {
  /// tracking branch for the git pull
  core.String? trackingBranch;

  $RestoreAgentRequestGitSource({this.trackingBranch});

  $RestoreAgentRequestGitSource.fromJson(core.Map json_)
    : this(trackingBranch: json_['trackingBranch'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (trackingBranch != null) 'trackingBranch': trackingBranch!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : RestoreBackupContext
/// - sqladmin:v1beta4 : RestoreBackupContext
class $RestoreBackupContext {
  /// The ID of the backup run to restore from.
  core.String? backupRunId;

  /// The ID of the instance that the backup was taken from.
  core.String? instanceId;

  /// This is always `sql#restoreBackupContext`.
  core.String? kind;

  /// The full project ID of the source instance.
  core.String? project;

  $RestoreBackupContext({
    this.backupRunId,
    this.instanceId,
    this.kind,
    this.project,
  });

  $RestoreBackupContext.fromJson(core.Map json_)
    : this(
        backupRunId: json_['backupRunId'] as core.String?,
        instanceId: json_['instanceId'] as core.String?,
        kind: json_['kind'] as core.String?,
        project: json_['project'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupRunId != null) 'backupRunId': backupRunId!,
    if (instanceId != null) 'instanceId': instanceId!,
    if (kind != null) 'kind': kind!,
    if (project != null) 'project': project!,
  };
}

/// Used by:
///
/// - managedidentities:v1 : RestoreDomainRequest
/// - managedidentities:v1alpha1 : RestoreDomainRequest
/// - managedidentities:v1beta1 : RestoreDomainRequest
class $RestoreDomainRequest {
  /// ID of the backup to be restored
  ///
  /// Required.
  core.String? backupId;

  $RestoreDomainRequest({this.backupId});

  $RestoreDomainRequest.fromJson(core.Map json_)
    : this(backupId: json_['backupId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupId != null) 'backupId': backupId!,
  };
}

/// Used by:
///
/// - netapp:v1 : RestoreParameters
/// - netapp:v1beta1 : RestoreParameters
class $RestoreParameters {
  /// Full name of the backup resource.
  ///
  /// Format:
  /// projects/{project}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}
  core.String? sourceBackup;

  /// Full name of the snapshot resource.
  ///
  /// Format:
  /// projects/{project}/locations/{location}/volumes/{volume}/snapshots/{snapshot}
  core.String? sourceSnapshot;

  $RestoreParameters({this.sourceBackup, this.sourceSnapshot});

  $RestoreParameters.fromJson(core.Map json_)
    : this(
        sourceBackup: json_['sourceBackup'] as core.String?,
        sourceSnapshot: json_['sourceSnapshot'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceBackup != null) 'sourceBackup': sourceBackup!,
    if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
  };
}

/// Used by:
///
/// - metastore:v1 : RestoreServiceRequest
/// - metastore:v1alpha : RestoreServiceRequest
/// - metastore:v1beta : RestoreServiceRequest
class $RestoreServiceRequest {
  /// The relative resource name of the metastore service backup to restore
  /// from, in the following
  /// form:projects/{project_id}/locations/{location_id}/services/{service_id}/backups/{backup_id}.
  ///
  /// Mutually exclusive with backup_location, and exactly one of the two must
  /// be set.
  ///
  /// Optional.
  core.String? backup;

  /// A Cloud Storage URI specifying the location of the backup artifacts,
  /// namely - backup avro files under "avro/", backup_metastore.json and
  /// service.json, in the following form:gs://.
  ///
  /// Mutually exclusive with backup, and exactly one of the two must be set.
  ///
  /// Optional.
  core.String? backupLocation;

  /// A request ID.
  ///
  /// Specify a unique request ID to allow the server to ignore the request if
  /// it has completed. The server will ignore subsequent requests that provide
  /// a duplicate request ID for at least 60 minutes after the first request.For
  /// example, if an initial request times out, followed by another request with
  /// the same request ID, the server ignores the second request to prevent the
  /// creation of duplicate commitments.The request ID must be a valid UUID
  /// (https://en.wikipedia.org/wiki/Universally_unique_identifier#Format). A
  /// zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  ///
  /// Optional.
  core.String? requestId;

  /// The type of restore.
  ///
  /// If unspecified, defaults to METADATA_ONLY.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "RESTORE_TYPE_UNSPECIFIED" : The restore type is unknown.
  /// - "FULL" : The service's metadata and configuration are restored.
  /// - "METADATA_ONLY" : Only the service's metadata is restored.
  core.String? restoreType;

  $RestoreServiceRequest({
    this.backup,
    this.backupLocation,
    this.requestId,
    this.restoreType,
  });

  $RestoreServiceRequest.fromJson(core.Map json_)
    : this(
        backup: json_['backup'] as core.String?,
        backupLocation: json_['backupLocation'] as core.String?,
        requestId: json_['requestId'] as core.String?,
        restoreType: json_['restoreType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backup != null) 'backup': backup!,
    if (backupLocation != null) 'backupLocation': backupLocation!,
    if (requestId != null) 'requestId': requestId!,
    if (restoreType != null) 'restoreType': restoreType!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1RestrictAllowedResourcesRequest
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1RestrictAllowedResourcesRequest
class $RestrictAllowedResourcesRequest {
  /// The type of restriction for using gcp products in the Workload
  /// environment.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESTRICTION_TYPE_UNSPECIFIED" : Unknown restriction type.
  /// - "ALLOW_ALL_GCP_RESOURCES" : Allow the use all of all gcp products,
  /// irrespective of the compliance posture. This effectively removes
  /// gcp.restrictServiceUsage OrgPolicy on the AssuredWorkloads Folder.
  /// - "ALLOW_COMPLIANT_RESOURCES" : Based on Workload's compliance regime,
  /// allowed list changes. See -
  /// https://cloud.google.com/assured-workloads/docs/supported-products for the
  /// list of supported resources.
  /// - "APPEND_COMPLIANT_RESOURCES" : Similar to ALLOW_COMPLIANT_RESOURCES but
  /// adds the list of compliant resources to the existing list of compliant
  /// resources. Effective org-policy of the Folder is considered to ensure
  /// there is no disruption to the existing customer workflows.
  core.String? restrictionType;

  $RestrictAllowedResourcesRequest({this.restrictionType});

  $RestrictAllowedResourcesRequest.fromJson(core.Map json_)
    : this(restrictionType: json_['restrictionType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (restrictionType != null) 'restrictionType': restrictionType!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : RestrictedExportConfig
/// - analyticshub:v1beta1 : RestrictedExportConfig
class $RestrictedExportConfig {
  /// If true, enable restricted export.
  ///
  /// Optional.
  core.bool? enabled;

  /// If true, restrict direct table access(read api/tabledata.list) on linked
  /// table.
  ///
  /// Output only.
  core.bool? restrictDirectTableAccess;

  /// If true, restrict export of query result derived from restricted linked
  /// dataset table.
  ///
  /// Optional.
  core.bool? restrictQueryResult;

  $RestrictedExportConfig({
    this.enabled,
    this.restrictDirectTableAccess,
    this.restrictQueryResult,
  });

  $RestrictedExportConfig.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        restrictDirectTableAccess:
            json_['restrictDirectTableAccess'] as core.bool?,
        restrictQueryResult: json_['restrictQueryResult'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (restrictDirectTableAccess != null)
      'restrictDirectTableAccess': restrictDirectTableAccess!,
    if (restrictQueryResult != null)
      'restrictQueryResult': restrictQueryResult!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : RestrictionEvaluation
/// - cloudidentity:v1beta1 : RestrictionEvaluation
class $RestrictionEvaluation {
  /// The current state of the restriction
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default. Should not be used.
  /// - "EVALUATING" : The restriction state is currently being evaluated.
  /// - "COMPLIANT" : All transitive memberships are adhering to restriction.
  /// - "FORWARD_COMPLIANT" : Some transitive memberships violate the
  /// restriction. No new violating memberships can be added.
  /// - "NON_COMPLIANT" : Some transitive memberships violate the restriction.
  /// New violating direct memberships will be denied while indirect memberships
  /// may be added.
  core.String? state;

  $RestrictionEvaluation({this.state});

  $RestrictionEvaluation.fromJson(core.Map json_)
    : this(state: json_['state'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleCloudDataplexV1DataProfileResultPostScanActionsResultBigQueryExportResult
/// - dataplex:v1 : GoogleCloudDataplexV1DataQualityResultPostScanActionsResultBigQueryExportResult
class $ResultPostScanActionsResultBigQueryExportResult {
  /// Additional information about the BigQuery exporting.
  ///
  /// Output only.
  core.String? message;

  /// Execution state for the BigQuery exporting.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The exporting state is unspecified.
  /// - "SUCCEEDED" : The exporting completed successfully.
  /// - "FAILED" : The exporting is no longer running due to an error.
  /// - "SKIPPED" : The exporting is skipped due to no valid scan result to
  /// export (usually caused by scan failed).
  core.String? state;

  $ResultPostScanActionsResultBigQueryExportResult({this.message, this.state});

  $ResultPostScanActionsResultBigQueryExportResult.fromJson(core.Map json_)
    : this(
        message: json_['message'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (message != null) 'message': message!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ResumeScheduleRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ResumeScheduleRequest
class $ResumeScheduleRequest {
  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. This will also update
  /// Schedule.catch_up field. Default to false.
  ///
  /// Optional.
  core.bool? catchUp;

  $ResumeScheduleRequest({this.catchUp});

  $ResumeScheduleRequest.fromJson(core.Map json_)
    : this(catchUp: json_['catchUp'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (catchUp != null) 'catchUp': catchUp!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RetrievalMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RetrievalMetadata
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RetrievalMetadata
class $RetrievalMetadata {
  /// Score indicating how likely information from Google Search could help
  /// answer the prompt.
  ///
  /// The score is in the range `[0, 1]`, where 0 is the least likely and 1 is
  /// the most likely. This score is only populated when Google Search grounding
  /// and dynamic retrieval is enabled. It will be compared to the threshold to
  /// determine whether to trigger Google Search.
  ///
  /// Optional.
  core.double? googleSearchDynamicRetrievalScore;

  $RetrievalMetadata({this.googleSearchDynamicRetrievalScore});

  $RetrievalMetadata.fromJson(core.Map json_)
    : this(
        googleSearchDynamicRetrievalScore:
            (json_['googleSearchDynamicRetrievalScore'] as core.num?)
                ?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleSearchDynamicRetrievalScore != null)
      'googleSearchDynamicRetrievalScore': googleSearchDynamicRetrievalScore!,
  };
}

/// Used by:
///
/// - cloudscheduler:v1 : RetryConfig
/// - cloudscheduler:v1beta1 : RetryConfig
class $RetryConfig00 {
  /// The maximum amount of time to wait before retrying a job after it fails.
  ///
  /// The default value of this field is 1 hour.
  core.String? maxBackoffDuration;

  /// The time between retries will double `max_doublings` times.
  ///
  /// A job's retry interval starts at min_backoff_duration, then doubles
  /// `max_doublings` times, then increases linearly, and finally retries at
  /// intervals of max_backoff_duration up to retry_count times. For examples,
  /// see
  /// [Retry jobs](https://cloud.google.com/scheduler/docs/configuring/retry-jobs#max-doublings).
  /// The default value of this field is 5.
  core.int? maxDoublings;

  /// The time limit for retrying a failed job, measured from the time when an
  /// execution was first attempted.
  ///
  /// If specified with retry_count, the job will be retried until both limits
  /// are reached. The default value for max_retry_duration is zero, which means
  /// retry duration is unlimited. However, if retry_count is also 0, a job
  /// attempt won't be retried if it fails.
  core.String? maxRetryDuration;

  /// The minimum amount of time to wait before retrying a job after it fails.
  ///
  /// The default value of this field is 5 seconds.
  core.String? minBackoffDuration;

  /// The number of attempts that the system will make to run a job using the
  /// exponential backoff procedure described by max_doublings.
  ///
  /// The default value of retry_count is zero. If retry_count is 0 (and if
  /// max_retry_duration is also 0), a job attempt won't be retried if it fails.
  /// Instead, Cloud Scheduler system will wait for the next scheduled execution
  /// time. Setting retry_count to 0 doesn't prevent failed jobs from running
  /// according to schedule after the failure. If retry_count is set to a
  /// non-zero number, Cloud Scheduler will retry the failed job, using
  /// exponential backoff, for retry_count times until the job succeeds or the
  /// number of retries is exhausted. Note that the next scheduled execution
  /// time might be skipped if the retries continue through that time. Values
  /// greater than 5 and negative values are not allowed.
  core.int? retryCount;

  $RetryConfig00({
    this.maxBackoffDuration,
    this.maxDoublings,
    this.maxRetryDuration,
    this.minBackoffDuration,
    this.retryCount,
  });

  $RetryConfig00.fromJson(core.Map json_)
    : this(
        maxBackoffDuration: json_['maxBackoffDuration'] as core.String?,
        maxDoublings: json_['maxDoublings'] as core.int?,
        maxRetryDuration: json_['maxRetryDuration'] as core.String?,
        minBackoffDuration: json_['minBackoffDuration'] as core.String?,
        retryCount: json_['retryCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxBackoffDuration != null) 'maxBackoffDuration': maxBackoffDuration!,
    if (maxDoublings != null) 'maxDoublings': maxDoublings!,
    if (maxRetryDuration != null) 'maxRetryDuration': maxRetryDuration!,
    if (minBackoffDuration != null) 'minBackoffDuration': minBackoffDuration!,
    if (retryCount != null) 'retryCount': retryCount!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : RetryConfig
/// - cloudtasks:v2beta3 : RetryConfig
class $RetryConfig01 {
  /// Number of attempts per task.
  ///
  /// Cloud Tasks will attempt the task `max_attempts` times (that is, if the
  /// first attempt fails, then there will be `max_attempts - 1` retries). Must
  /// be \>= -1. If unspecified when the queue is created, Cloud Tasks will pick
  /// the default. -1 indicates unlimited attempts. This field has the same
  /// meaning as
  /// [task_retry_limit in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  /// Note: Cloud Tasks stops retrying only when `max_attempts` and
  /// `max_retry_duration` are both satisfied. When the task has been attempted
  /// `max_attempts` times and when the `max_retry_duration` time has passed, no
  /// further attempts are made, and the task is deleted. If you want your task
  /// to retry infinitely, you must set `max_attempts` to -1 and
  /// `max_retry_duration` to 0.
  core.int? maxAttempts;

  /// A task will be scheduled for retry between min_backoff and max_backoff
  /// duration after it fails, if the queue's RetryConfig specifies that the
  /// task should be retried.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default. The value must be given as a string that indicates the length of
  /// time (in seconds) followed by `s` (for "seconds"). For more information on
  /// the format, see the documentation for
  /// [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration).
  /// `max_backoff` will be truncated to the nearest second. This field has the
  /// same meaning as
  /// [max_backoff_seconds in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  core.String? maxBackoff;

  /// The time between retries will double `max_doublings` times.
  ///
  /// A task's retry interval starts at min_backoff, then doubles
  /// `max_doublings` times, then increases linearly, and finally retries at
  /// intervals of max_backoff up to max_attempts times. For example, if
  /// min_backoff is 10s, max_backoff is 300s, and `max_doublings` is 3, then
  /// the a task will first be retried in 10s. The retry interval will double
  /// three times, and then increase linearly by 2^3 * 10s. Finally, the task
  /// will retry at intervals of max_backoff until the task has been attempted
  /// max_attempts times. Thus, the requests will retry at 10s, 20s, 40s, 80s,
  /// 160s, 240s, 300s, 300s, .... If unspecified when the queue is created,
  /// Cloud Tasks will pick the default. This field has the same meaning as
  /// [max_doublings in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  core.int? maxDoublings;

  /// If positive, `max_retry_duration` specifies the time limit for retrying a
  /// failed task, measured from when the task was first attempted.
  ///
  /// Once `max_retry_duration` time has passed *and* the task has been
  /// attempted max_attempts times, no further attempts will be made and the
  /// task will be deleted. If zero, then the task age is unlimited. If
  /// unspecified when the queue is created, Cloud Tasks will pick the default.
  /// The value must be given as a string that indicates the length of time (in
  /// seconds) followed by `s` (for "seconds"). For the maximum possible value
  /// or the format, see the documentation for
  /// [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration).
  /// `max_retry_duration` will be truncated to the nearest second. This field
  /// has the same meaning as
  /// [task_age_limit in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  core.String? maxRetryDuration;

  /// A task will be scheduled for retry between min_backoff and max_backoff
  /// duration after it fails, if the queue's RetryConfig specifies that the
  /// task should be retried.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default. The value must be given as a string that indicates the length of
  /// time (in seconds) followed by `s` (for "seconds"). For more information on
  /// the format, see the documentation for
  /// [Duration](https://protobuf.dev/reference/protobuf/google.protobuf/#duration).
  /// `min_backoff` will be truncated to the nearest second. This field has the
  /// same meaning as
  /// [min_backoff_seconds in queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  core.String? minBackoff;

  $RetryConfig01({
    this.maxAttempts,
    this.maxBackoff,
    this.maxDoublings,
    this.maxRetryDuration,
    this.minBackoff,
  });

  $RetryConfig01.fromJson(core.Map json_)
    : this(
        maxAttempts: json_['maxAttempts'] as core.int?,
        maxBackoff: json_['maxBackoff'] as core.String?,
        maxDoublings: json_['maxDoublings'] as core.int?,
        maxRetryDuration: json_['maxRetryDuration'] as core.String?,
        minBackoff: json_['minBackoff'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxAttempts != null) 'maxAttempts': maxAttempts!,
    if (maxBackoff != null) 'maxBackoff': maxBackoff!,
    if (maxDoublings != null) 'maxDoublings': maxDoublings!,
    if (maxRetryDuration != null) 'maxRetryDuration': maxRetryDuration!,
    if (minBackoff != null) 'minBackoff': minBackoff!,
  };
}

/// Used by:
///
/// - analyticshub:v1 : RetryPolicy
/// - pubsub:v1 : RetryPolicy
class $RetryPolicy {
  /// The maximum delay between consecutive deliveries of a given message.
  ///
  /// Value should be between 0 and 600 seconds. Defaults to 600 seconds.
  ///
  /// Optional.
  core.String? maximumBackoff;

  /// The minimum delay between consecutive deliveries of a given message.
  ///
  /// Value should be between 0 and 600 seconds. Defaults to 10 seconds.
  ///
  /// Optional.
  core.String? minimumBackoff;

  $RetryPolicy({this.maximumBackoff, this.minimumBackoff});

  $RetryPolicy.fromJson(core.Map json_)
    : this(
        maximumBackoff: json_['maximumBackoff'] as core.String?,
        minimumBackoff: json_['minimumBackoff'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maximumBackoff != null) 'maximumBackoff': maximumBackoff!,
    if (minimumBackoff != null) 'minimumBackoff': minimumBackoff!,
  };
}

/// Used by:
///
/// - dataportability:v1 : RetryPortabilityArchiveResponse
/// - dataportability:v1beta : RetryPortabilityArchiveResponse
class $RetryPortabilityArchiveResponse {
  /// The archive job ID that is initiated by the retry endpoint.
  ///
  /// This can be used to get the state of the new job.
  core.String? archiveJobId;

  $RetryPortabilityArchiveResponse({this.archiveJobId});

  $RetryPortabilityArchiveResponse.fromJson(core.Map json_)
    : this(archiveJobId: json_['archiveJobId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (archiveJobId != null) 'archiveJobId': archiveJobId!,
  };
}

/// Used by:
///
/// - datamigration:v1 : ReverseSshConnectivity
/// - datamigration:v1beta1 : ReverseSshConnectivity
class $ReverseSshConnectivity {
  /// The name of the virtual machine (Compute Engine) used as the bastion
  /// server for the SSH tunnel.
  core.String? vm;

  /// The IP of the virtual machine (Compute Engine) used as the bastion server
  /// for the SSH tunnel.
  ///
  /// Required.
  core.String? vmIp;

  /// The forwarding port of the virtual machine (Compute Engine) used as the
  /// bastion server for the SSH tunnel.
  ///
  /// Required.
  core.int? vmPort;

  /// The name of the VPC to peer with the Cloud SQL private network.
  core.String? vpc;

  $ReverseSshConnectivity({this.vm, this.vmIp, this.vmPort, this.vpc});

  $ReverseSshConnectivity.fromJson(core.Map json_)
    : this(
        vm: json_['vm'] as core.String?,
        vmIp: json_['vmIp'] as core.String?,
        vmPort: json_['vmPort'] as core.int?,
        vpc: json_['vpc'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (vm != null) 'vm': vm!,
    if (vmIp != null) 'vmIp': vmIp!,
    if (vmPort != null) 'vmPort': vmPort!,
    if (vpc != null) 'vpc': vpc!,
  };
}

/// Used by:
///
/// - file:v1 : RevertInstanceRequest
/// - file:v1beta1 : RevertInstanceRequest
class $RevertInstanceRequest {
  /// The snapshot resource ID, in the format 'my-snapshot', where the specified
  /// ID is the {snapshot_id} of the fully qualified name like
  /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`
  ///
  /// Required.
  core.String? targetSnapshotId;

  $RevertInstanceRequest({this.targetSnapshotId});

  $RevertInstanceRequest.fromJson(core.Map json_)
    : this(targetSnapshotId: json_['targetSnapshotId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetSnapshotId != null) 'targetSnapshotId': targetSnapshotId!,
  };
}

/// Used by:
///
/// - netapp:v1 : RevertVolumeRequest
/// - netapp:v1beta1 : RevertVolumeRequest
class $RevertVolumeRequest {
  /// The snapshot resource ID, in the format 'my-snapshot', where the specified
  /// ID is the {snapshot_id} of the fully qualified name like
  /// projects/{project_id}/locations/{location_id}/volumes/{volume_id}/snapshots/{snapshot_id}
  ///
  /// Required.
  core.String? snapshotId;

  $RevertVolumeRequest({this.snapshotId});

  $RevertVolumeRequest.fromJson(core.Map json_)
    : this(snapshotId: json_['snapshotId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (snapshotId != null) 'snapshotId': snapshotId!,
  };
}

/// Used by:
///
/// - merchantapi:reviews_v1beta : MerchantReviewDestinationStatus
/// - merchantapi:reviews_v1beta : ProductReviewDestinationStatus
class $ReviewDestinationStatus {
  /// The name of the reporting context.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "REPORTING_CONTEXT_ENUM_UNSPECIFIED" : Not specified.
  /// - "SHOPPING_ADS" :
  /// [Shopping ads](https://support.google.com/merchants/answer/6149970).
  /// - "DISCOVERY_ADS" : Deprecated: Use `DEMAND_GEN_ADS` instead.
  /// [Discovery and Demand Gen ads](https://support.google.com/merchants/answer/13389785).
  /// - "DEMAND_GEN_ADS" :
  /// [Demand Gen ads](https://support.google.com/merchants/answer/13389785).
  /// - "DEMAND_GEN_ADS_DISCOVER_SURFACE" :
  /// [Demand Gen ads on Discover surface](https://support.google.com/merchants/answer/13389785).
  /// - "VIDEO_ADS" :
  /// [Video ads](https://support.google.com/google-ads/answer/6340491).
  /// - "DISPLAY_ADS" :
  /// [Display ads](https://support.google.com/merchants/answer/6069387).
  /// - "LOCAL_INVENTORY_ADS" :
  /// [Local inventory ads](https://support.google.com/merchants/answer/3271956).
  /// - "VEHICLE_INVENTORY_ADS" :
  /// [Vehicle inventory ads](https://support.google.com/merchants/answer/11544533).
  /// - "FREE_LISTINGS" :
  /// [Free product listings](https://support.google.com/merchants/answer/9199328).
  /// - "FREE_LOCAL_LISTINGS" :
  /// [Free local product listings](https://support.google.com/merchants/answer/9825611).
  /// - "FREE_LOCAL_VEHICLE_LISTINGS" :
  /// [Free local vehicle listings](https://support.google.com/merchants/answer/11544533).
  /// - "YOUTUBE_AFFILIATE" :
  /// [Youtube Affiliate](https://support.google.com/youtube/answer/13376398).
  /// - "YOUTUBE_SHOPPING" :
  /// [YouTube Shopping](https://support.google.com/merchants/answer/13478370).
  /// - "CLOUD_RETAIL" :
  /// [Cloud retail](https://cloud.google.com/solutions/retail).
  /// - "LOCAL_CLOUD_RETAIL" :
  /// [Local cloud retail](https://cloud.google.com/solutions/retail).
  /// - "PRODUCT_REVIEWS" :
  /// [Product Reviews](https://support.google.com/merchants/answer/14620732).
  /// - "MERCHANT_REVIEWS" :
  /// [Merchant Reviews](https://developers.google.com/merchant-review-feeds).
  /// - "YOUTUBE_CHECKOUT" : YouTube Checkout .
  core.String? reportingContext;

  $ReviewDestinationStatus({this.reportingContext});

  $ReviewDestinationStatus.fromJson(core.Map json_)
    : this(reportingContext: json_['reportingContext'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (reportingContext != null) 'reportingContext': reportingContext!,
  };
}

/// Used by:
///
/// - apigeeregistry:v1 : TagApiDeploymentRevisionRequest
/// - apigeeregistry:v1 : TagApiSpecRevisionRequest
class $RevisionRequest {
  /// The tag to apply.
  ///
  /// The tag should be at most 40 characters, and match `a-z{3,39}`.
  ///
  /// Required.
  core.String? tag;

  $RevisionRequest({this.tag});

  $RevisionRequest.fromJson(core.Map json_)
    : this(tag: json_['tag'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (tag != null) 'tag': tag!,
  };
}

/// Used by:
///
/// - healthcare:v1 : RevokeConsentRequest
/// - healthcare:v1beta1 : RevokeConsentRequest
class $RevokeConsentRequest {
  /// The resource name of the Consent artifact that contains proof of the
  /// user's revocation of the Consent, of the form
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/consentStores/{consent_store_id}/consentArtifacts/{consent_artifact_id}`.
  ///
  /// Optional.
  core.String? consentArtifact;

  $RevokeConsentRequest({this.consentArtifact});

  $RevokeConsentRequest.fromJson(core.Map json_)
    : this(consentArtifact: json_['consentArtifact'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (consentArtifact != null) 'consentArtifact': consentArtifact!,
  };
}

/// Used by:
///
/// - docs:v1 : RgbColor
/// - slides:v1 : RgbColor
class $RgbColor {
  /// The blue component of the color, from 0.0 to 1.0.
  core.double? blue;

  /// The green component of the color, from 0.0 to 1.0.
  core.double? green;

  /// The red component of the color, from 0.0 to 1.0.
  core.double? red;

  $RgbColor({this.blue, this.green, this.red});

  $RgbColor.fromJson(core.Map json_)
    : this(
        blue: (json_['blue'] as core.num?)?.toDouble(),
        green: (json_['green'] as core.num?)?.toDouble(),
        red: (json_['red'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blue != null) 'blue': blue!,
    if (green != null) 'green': green!,
    if (red != null) 'red': red!,
  };
}

/// Used by:
///
/// - gkehub:v1 : Role
/// - gkehub:v1alpha : Role
/// - gkehub:v1beta : Role
class $Role {
  /// custom_role is the name of a custom KubernetesClusterRole to use.
  ///
  /// Optional.
  core.String? customRole;

  /// predefined_role is the Kubernetes default role to use
  /// Possible string values are:
  /// - "UNKNOWN" : UNKNOWN
  /// - "ADMIN" : ADMIN has EDIT and RBAC permissions
  /// - "EDIT" : EDIT can edit all resources except RBAC
  /// - "VIEW" : VIEW can only read resources
  /// - "ANTHOS_SUPPORT" : ANTHOS_SUPPORT gives Google Support read-only access
  /// to a number of cluster resources.
  core.String? predefinedRole;

  $Role({this.customRole, this.predefinedRole});

  $Role.fromJson(core.Map json_)
    : this(
        customRole: json_['customRole'] as core.String?,
        predefinedRole: json_['predefinedRole'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customRole != null) 'customRole': customRole!,
    if (predefinedRole != null) 'predefinedRole': predefinedRole!,
  };
}

/// Used by:
///
/// - healthcare:v1 : RollbackHL7MessagesFilteringFields
/// - healthcare:v1beta1 : RollbackHL7MessagesFilteringFields
class $RollbackHL7MessagesFilteringFields {
  /// A list of operation IDs to roll back.
  ///
  /// Optional.
  core.List<core.String>? operationIds;

  $RollbackHL7MessagesFilteringFields({this.operationIds});

  $RollbackHL7MessagesFilteringFields.fromJson(core.Map json_)
    : this(
        operationIds:
            (json_['operationIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (operationIds != null) 'operationIds': operationIds!,
  };
}

/// Used by:
///
/// - container:v1 : RollbackNodePoolUpgradeRequest
/// - container:v1beta1 : RollbackNodePoolUpgradeRequest
class $RollbackNodePoolUpgradeRequest {
  /// The name of the cluster to rollback.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The name (project, location, cluster, node pool id) of the node poll to
  /// rollback upgrade.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / *
  /// /nodePools / * `.
  core.String? name;

  /// The name of the node pool to rollback.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? nodePoolId;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// Option for rollback to ignore the PodDisruptionBudget.
  ///
  /// Default value is false.
  core.bool? respectPdb;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $RollbackNodePoolUpgradeRequest({
    this.clusterId,
    this.name,
    this.nodePoolId,
    this.projectId,
    this.respectPdb,
    this.zone,
  });

  $RollbackNodePoolUpgradeRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        name: json_['name'] as core.String?,
        nodePoolId: json_['nodePoolId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        respectPdb: json_['respectPdb'] as core.bool?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (name != null) 'name': name!,
    if (nodePoolId != null) 'nodePoolId': nodePoolId!,
    if (projectId != null) 'projectId': projectId!,
    if (respectPdb != null) 'respectPdb': respectPdb!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - firestore:v1 : RollbackRequest
/// - firestore:v1beta1 : RollbackRequest
class $RollbackRequest {
  /// The transaction to roll back.
  ///
  /// Required.
  core.String? transaction;
  core.List<core.int> get transactionAsBytes =>
      convert.base64.decode(transaction!);

  set transactionAsBytes(core.List<core.int> bytes_) {
    transaction = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $RollbackRequest({this.transaction});

  $RollbackRequest.fromJson(core.Map json_)
    : this(transaction: json_['transaction'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (transaction != null) 'transaction': transaction!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RolloutConfigRolloutStep
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RolloutConfigRolloutStep
class $RolloutConfigRolloutStep {
  /// The name of the rollout step;
  core.String? displayName;

  /// The minimum time that this step should last.
  ///
  /// Should be longer than 1 hour. If not set, the default minimum duration for
  /// each step will be 1 hour.
  core.String? minDuration;

  /// The percentage of traffic allocated to the flow version of this rollout
  /// step.
  ///
  /// (0%, 100%\].
  core.int? trafficPercent;

  $RolloutConfigRolloutStep({
    this.displayName,
    this.minDuration,
    this.trafficPercent,
  });

  $RolloutConfigRolloutStep.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        minDuration: json_['minDuration'] as core.String?,
        trafficPercent: json_['trafficPercent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (minDuration != null) 'minDuration': minDuration!,
    if (trafficPercent != null) 'trafficPercent': trafficPercent!,
  };
}

/// Used by:
///
/// - serviceconsumermanagement:v1beta1 : V1Beta1RolloutInfo
/// - serviceusage:v1beta1 : RolloutInfo
class $RolloutInfo {
  /// Whether there is an ongoing rollout for the default limit or not.
  core.bool? defaultLimitOngoingRollout;

  $RolloutInfo({this.defaultLimitOngoingRollout});

  $RolloutInfo.fromJson(core.Map json_)
    : this(
        defaultLimitOngoingRollout:
            json_['defaultLimitOngoingRollout'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultLimitOngoingRollout != null)
      'defaultLimitOngoingRollout': defaultLimitOngoingRollout!,
  };
}

/// Used by:
///
/// - compute:alpha : RolloutPolicy
/// - compute:beta : RolloutPolicy
class $RolloutPolicy00 {
  /// An optional RFC3339 timestamp on or after which the update is considered
  /// rolled out to any zone that is not explicitly stated.
  core.String? defaultRolloutTime;

  /// Location based rollout policies to apply to the resource.
  ///
  /// Currently only zone names are supported and must be represented as valid
  /// URLs, like: zones/us-central1-a. The value expects an RFC3339 timestamp on
  /// or after which the update is considered rolled out to the specified
  /// location.
  core.Map<core.String, core.String>? locationRolloutPolicies;

  $RolloutPolicy00({this.defaultRolloutTime, this.locationRolloutPolicies});

  $RolloutPolicy00.fromJson(core.Map json_)
    : this(
        defaultRolloutTime: json_['defaultRolloutTime'] as core.String?,
        locationRolloutPolicies: (json_['locationRolloutPolicies']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultRolloutTime != null) 'defaultRolloutTime': defaultRolloutTime!,
    if (locationRolloutPolicies != null)
      'locationRolloutPolicies': locationRolloutPolicies!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : RolloutPolicy
/// - firebaseapphosting:v1beta : RolloutPolicy
class $RolloutPolicy01 {
  /// If set, specifies a branch that triggers a new build to be started with
  /// this policy.
  ///
  /// Otherwise, no automatic rollouts will happen.
  core.String? codebaseBranch;

  /// A flag that, if true, prevents automatic rollouts from being created via
  /// this RolloutPolicy.
  ///
  /// Optional.
  core.bool? disabled;

  /// If `disabled` is set, the time at which the automatic rollouts were
  /// disabled.
  ///
  /// Output only.
  core.String? disabledTime;

  $RolloutPolicy01({this.codebaseBranch, this.disabled, this.disabledTime});

  $RolloutPolicy01.fromJson(core.Map json_)
    : this(
        codebaseBranch: json_['codebaseBranch'] as core.String?,
        disabled: json_['disabled'] as core.bool?,
        disabledTime: json_['disabledTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (codebaseBranch != null) 'codebaseBranch': codebaseBranch!,
    if (disabled != null) 'disabled': disabled!,
    if (disabledTime != null) 'disabledTime': disabledTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RolloutState
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RolloutState
class $RolloutState {
  /// Start time of the current step.
  core.String? startTime;

  /// Display name of the current auto rollout step.
  core.String? step;

  /// Index of the current step in the auto rollout steps list.
  core.int? stepIndex;

  $RolloutState({this.startTime, this.step, this.stepIndex});

  $RolloutState.fromJson(core.Map json_)
    : this(
        startTime: json_['startTime'] as core.String?,
        step: json_['step'] as core.String?,
        stepIndex: json_['stepIndex'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (startTime != null) 'startTime': startTime!,
    if (step != null) 'step': step!,
    if (stepIndex != null) 'stepIndex': stepIndex!,
  };
}

/// Used by:
///
/// - metastore:v1alpha : RootCACertificate
/// - metastore:v1beta : RootCACertificate
class $RootCACertificate {
  /// The root CA certificate in PEM format.
  ///
  /// The maximum length is 65536 bytes.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? certificate;

  /// The certificate expiration time in timestamp format.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? expirationTime;

  $RootCACertificate({this.certificate, this.expirationTime});

  $RootCACertificate.fromJson(core.Map json_)
    : this(
        certificate: json_['certificate'] as core.String?,
        expirationTime: json_['expirationTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificate != null) 'certificate': certificate!,
    if (expirationTime != null) 'expirationTime': expirationTime!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : RotateServerCaContext
/// - sqladmin:v1beta4 : RotateServerCaContext
class $RotateServerCaContext {
  /// This is always `sql#rotateServerCaContext`.
  core.String? kind;

  /// The fingerprint of the next version to be rotated to.
  ///
  /// If left unspecified, will be rotated to the most recently added server CA
  /// version.
  core.String? nextVersion;

  $RotateServerCaContext({this.kind, this.nextVersion});

  $RotateServerCaContext.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        nextVersion: json_['nextVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (nextVersion != null) 'nextVersion': nextVersion!,
  };
}

/// Used by:
///
/// - secretmanager:v1 : Rotation
/// - secretmanager:v1beta2 : Rotation
class $Rotation {
  /// Timestamp in UTC at which the Secret is scheduled to rotate.
  ///
  /// Cannot be set to less than 300s (5 min) in the future and at most
  /// 3153600000s (100 years). next_rotation_time MUST be set if rotation_period
  /// is set.
  ///
  /// Optional.
  core.String? nextRotationTime;

  /// Input only.
  ///
  /// The Duration between rotation notifications. Must be in seconds and at
  /// least 3600s (1h) and at most 3153600000s (100 years). If rotation_period
  /// is set, next_rotation_time must be set. next_rotation_time will be
  /// advanced by this period when the service automatically sends rotation
  /// notifications.
  core.String? rotationPeriod;

  $Rotation({this.nextRotationTime, this.rotationPeriod});

  $Rotation.fromJson(core.Map json_)
    : this(
        nextRotationTime: json_['nextRotationTime'] as core.String?,
        rotationPeriod: json_['rotationPeriod'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextRotationTime != null) 'nextRotationTime': nextRotationTime!,
    if (rotationPeriod != null) 'rotationPeriod': rotationPeriod!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RougeMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RougeMetricValue
class $RougeMetricValue {
  /// Rouge score.
  ///
  /// Output only.
  core.double? score;

  $RougeMetricValue({this.score});

  $RougeMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RougeSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RougeSpec
class $RougeSpec {
  /// Supported rouge types are rougen\[1-9\], rougeL, and rougeLsum.
  ///
  /// Optional.
  core.String? rougeType;

  /// Whether to split summaries while using rougeLsum.
  ///
  /// Optional.
  core.bool? splitSummaries;

  /// Whether to use stemmer to compute rouge score.
  ///
  /// Optional.
  core.bool? useStemmer;

  $RougeSpec({this.rougeType, this.splitSummaries, this.useStemmer});

  $RougeSpec.fromJson(core.Map json_)
    : this(
        rougeType: json_['rougeType'] as core.String?,
        splitSummaries: json_['splitSummaries'] as core.bool?,
        useStemmer: json_['useStemmer'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rougeType != null) 'rougeType': rougeType!,
    if (splitSummaries != null) 'splitSummaries': splitSummaries!,
    if (useStemmer != null) 'useStemmer': useStemmer!,
  };
}

/// Used by:
///
/// - compute:alpha : RouteAsPath
/// - compute:beta : RouteAsPath
/// - compute:v1 : RouteAsPath
class $RouteAsPath {
  /// The AS numbers of the AS Path.
  ///
  /// Output only.
  core.List<core.int>? asLists;

  /// The type of the AS Path, which can be one of the following values: -
  /// 'AS_SET': unordered set of autonomous systems that the route in has
  /// traversed - 'AS_SEQUENCE': ordered set of autonomous systems that the
  /// route has traversed - 'AS_CONFED_SEQUENCE': ordered set of Member
  /// Autonomous Systems in the local confederation that the route has traversed
  /// - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local
  /// confederation that the route has traversed
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AS_CONFED_SEQUENCE"
  /// - "AS_CONFED_SET"
  /// - "AS_SEQUENCE"
  /// - "AS_SET"
  core.String? pathSegmentType;

  $RouteAsPath({this.asLists, this.pathSegmentType});

  $RouteAsPath.fromJson(core.Map json_)
    : this(
        asLists:
            (json_['asLists'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        pathSegmentType: json_['pathSegmentType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (asLists != null) 'asLists': asLists!,
    if (pathSegmentType != null) 'pathSegmentType': pathSegmentType!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteFaultInjectionPolicyAbort
/// - networkservices:v1 : HttpRouteFaultInjectionPolicyAbort
/// - networkservices:v1beta1 : GrpcRouteFaultInjectionPolicyAbort
/// - networkservices:v1beta1 : HttpRouteFaultInjectionPolicyAbort
class $RouteFaultInjectionPolicyAbort {
  /// The HTTP status code used to abort the request.
  ///
  /// The value must be between 200 and 599 inclusive.
  core.int? httpStatus;

  /// The percentage of traffic which will be aborted.
  ///
  /// The value must be between \[0, 100\]
  core.int? percentage;

  $RouteFaultInjectionPolicyAbort({this.httpStatus, this.percentage});

  $RouteFaultInjectionPolicyAbort.fromJson(core.Map json_)
    : this(
        httpStatus: json_['httpStatus'] as core.int?,
        percentage: json_['percentage'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (httpStatus != null) 'httpStatus': httpStatus!,
    if (percentage != null) 'percentage': percentage!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteFaultInjectionPolicyDelay
/// - networkservices:v1 : HttpRouteFaultInjectionPolicyDelay
/// - networkservices:v1beta1 : GrpcRouteFaultInjectionPolicyDelay
/// - networkservices:v1beta1 : HttpRouteFaultInjectionPolicyDelay
class $RouteFaultInjectionPolicyDelay {
  /// Specify a fixed delay before forwarding the request.
  core.String? fixedDelay;

  /// The percentage of traffic on which delay will be injected.
  ///
  /// The value must be between \[0, 100\]
  core.int? percentage;

  $RouteFaultInjectionPolicyDelay({this.fixedDelay, this.percentage});

  $RouteFaultInjectionPolicyDelay.fromJson(core.Map json_)
    : this(
        fixedDelay: json_['fixedDelay'] as core.String?,
        percentage: json_['percentage'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fixedDelay != null) 'fixedDelay': fixedDelay!,
    if (percentage != null) 'percentage': percentage!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : RouteInfo
/// - networkmanagement:v1beta1 : RouteInfo
class $RouteInfo {
  /// For ADVERTISED routes, the URI of their next hop, i.e. the URI of the
  /// hybrid endpoint (VPN tunnel, Interconnect attachment, NCC router
  /// appliance) the advertised prefix is advertised through, or URI of the
  /// source peered network.
  ///
  /// Deprecated in favor of the next_hop_uri field, not used in new tests.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? advertisedRouteNextHopUri;

  /// For ADVERTISED dynamic routes, the URI of the Cloud Router that advertised
  /// the corresponding IP prefix.
  core.String? advertisedRouteSourceRouterUri;

  /// Destination IP range of the route.
  core.String? destIpRange;

  /// Destination port ranges of the route.
  ///
  /// POLICY_BASED routes only.
  core.List<core.String>? destPortRanges;

  /// Name of a route.
  core.String? displayName;

  /// Instance tags of the route.
  core.List<core.String>? instanceTags;

  /// For PEERING_SUBNET and PEERING_DYNAMIC routes that are advertised by NCC
  /// Hub, the URI of the corresponding route in NCC Hub's routing table.
  core.String? nccHubRouteUri;

  /// URI of the NCC Hub the route is advertised by.
  ///
  /// PEERING_SUBNET and PEERING_DYNAMIC routes that are advertised by NCC Hub
  /// only.
  core.String? nccHubUri;

  /// URI of the destination NCC Spoke.
  ///
  /// PEERING_SUBNET and PEERING_DYNAMIC routes that are advertised by NCC Hub
  /// only.
  core.String? nccSpokeUri;

  /// URI of a VPC network where route is located.
  core.String? networkUri;

  /// String type of the next hop of the route (for example, "VPN tunnel").
  ///
  /// Deprecated in favor of the next_hop_type and next_hop_uri fields, not used
  /// in new tests.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? nextHop;

  /// URI of a VPC network where the next hop resource is located.
  core.String? nextHopNetworkUri;

  /// Type of next hop.
  /// Possible string values are:
  /// - "NEXT_HOP_TYPE_UNSPECIFIED" : Unspecified type. Default value.
  /// - "NEXT_HOP_IP" : Next hop is an IP address.
  /// - "NEXT_HOP_INSTANCE" : Next hop is a Compute Engine instance.
  /// - "NEXT_HOP_NETWORK" : Next hop is a VPC network gateway.
  /// - "NEXT_HOP_PEERING" : Next hop is a peering VPC. This scenario only
  /// happens when the user doesn't have permissions to the project where the
  /// next hop resource is located.
  /// - "NEXT_HOP_INTERCONNECT" : Next hop is an interconnect.
  /// - "NEXT_HOP_VPN_TUNNEL" : Next hop is a VPN tunnel.
  /// - "NEXT_HOP_VPN_GATEWAY" : Next hop is a VPN gateway. This scenario only
  /// happens when tracing connectivity from an on-premises network to Google
  /// Cloud through a VPN. The analysis simulates a packet departing from the
  /// on-premises network through a VPN tunnel and arriving at a Cloud VPN
  /// gateway.
  /// - "NEXT_HOP_INTERNET_GATEWAY" : Next hop is an internet gateway.
  /// - "NEXT_HOP_BLACKHOLE" : Next hop is blackhole; that is, the next hop
  /// either does not exist or is unusable.
  /// - "NEXT_HOP_ILB" : Next hop is the forwarding rule of an Internal Load
  /// Balancer.
  /// - "NEXT_HOP_ROUTER_APPLIANCE" : Next hop is a
  /// [router appliance instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
  /// - "NEXT_HOP_NCC_HUB" : Next hop is an NCC hub. This scenario only happens
  /// when the user doesn't have permissions to the project where the next hop
  /// resource is located.
  /// - "SECURE_WEB_PROXY_GATEWAY" : Next hop is Secure Web Proxy Gateway.
  core.String? nextHopType;

  /// URI of the next hop resource.
  core.String? nextHopUri;

  /// For PEERING_SUBNET, PEERING_STATIC and PEERING_DYNAMIC routes, the name of
  /// the originating SUBNET/STATIC/DYNAMIC route.
  core.String? originatingRouteDisplayName;

  /// For PEERING_SUBNET and PEERING_STATIC routes, the URI of the originating
  /// SUBNET/STATIC route.
  core.String? originatingRouteUri;

  /// Priority of the route.
  core.int? priority;

  /// Protocols of the route.
  ///
  /// POLICY_BASED routes only.
  core.List<core.String>? protocols;

  /// Region of the route.
  ///
  /// DYNAMIC, PEERING_DYNAMIC, POLICY_BASED and ADVERTISED routes only. If set
  /// for POLICY_BASED route, this is a region of VLAN attachments for Cloud
  /// Interconnect the route applies to.
  core.String? region;

  /// Indicates where route is applicable.
  ///
  /// Deprecated, routes with NCC_HUB scope are not included in the trace in new
  /// tests.
  /// Possible string values are:
  /// - "ROUTE_SCOPE_UNSPECIFIED" : Unspecified scope. Default value.
  /// - "NETWORK" : Route is applicable to packets in Network.
  /// - "NCC_HUB" : Route is applicable to packets using NCC Hub's routing
  /// table.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? routeScope;

  /// Type of route.
  /// Possible string values are:
  /// - "ROUTE_TYPE_UNSPECIFIED" : Unspecified type. Default value.
  /// - "SUBNET" : Route is a subnet route automatically created by the system.
  /// - "STATIC" : Static route created by the user, including the default route
  /// to the internet.
  /// - "DYNAMIC" : Dynamic route exchanged between BGP peers.
  /// - "PEERING_SUBNET" : A subnet route received from peering network or NCC
  /// Hub.
  /// - "PEERING_STATIC" : A static route received from peering network.
  /// - "PEERING_DYNAMIC" : A dynamic route received from peering network or NCC
  /// Hub.
  /// - "POLICY_BASED" : Policy based route.
  /// - "ADVERTISED" : Advertised route. Synthetic route which is used to
  /// transition from the StartFromPrivateNetwork state in Connectivity tests.
  core.String? routeType;

  /// Source IP address range of the route.
  ///
  /// POLICY_BASED routes only.
  core.String? srcIpRange;

  /// Source port ranges of the route.
  ///
  /// POLICY_BASED routes only.
  core.List<core.String>? srcPortRanges;

  /// URI of a route.
  ///
  /// SUBNET, STATIC, PEERING_SUBNET (only for peering network) and POLICY_BASED
  /// routes only.
  core.String? uri;

  $RouteInfo({
    this.advertisedRouteNextHopUri,
    this.advertisedRouteSourceRouterUri,
    this.destIpRange,
    this.destPortRanges,
    this.displayName,
    this.instanceTags,
    this.nccHubRouteUri,
    this.nccHubUri,
    this.nccSpokeUri,
    this.networkUri,
    this.nextHop,
    this.nextHopNetworkUri,
    this.nextHopType,
    this.nextHopUri,
    this.originatingRouteDisplayName,
    this.originatingRouteUri,
    this.priority,
    this.protocols,
    this.region,
    this.routeScope,
    this.routeType,
    this.srcIpRange,
    this.srcPortRanges,
    this.uri,
  });

  $RouteInfo.fromJson(core.Map json_)
    : this(
        advertisedRouteNextHopUri:
            json_['advertisedRouteNextHopUri'] as core.String?,
        advertisedRouteSourceRouterUri:
            json_['advertisedRouteSourceRouterUri'] as core.String?,
        destIpRange: json_['destIpRange'] as core.String?,
        destPortRanges:
            (json_['destPortRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        displayName: json_['displayName'] as core.String?,
        instanceTags:
            (json_['instanceTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        nccHubRouteUri: json_['nccHubRouteUri'] as core.String?,
        nccHubUri: json_['nccHubUri'] as core.String?,
        nccSpokeUri: json_['nccSpokeUri'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        nextHop: json_['nextHop'] as core.String?,
        nextHopNetworkUri: json_['nextHopNetworkUri'] as core.String?,
        nextHopType: json_['nextHopType'] as core.String?,
        nextHopUri: json_['nextHopUri'] as core.String?,
        originatingRouteDisplayName:
            json_['originatingRouteDisplayName'] as core.String?,
        originatingRouteUri: json_['originatingRouteUri'] as core.String?,
        priority: json_['priority'] as core.int?,
        protocols:
            (json_['protocols'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        region: json_['region'] as core.String?,
        routeScope: json_['routeScope'] as core.String?,
        routeType: json_['routeType'] as core.String?,
        srcIpRange: json_['srcIpRange'] as core.String?,
        srcPortRanges:
            (json_['srcPortRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advertisedRouteNextHopUri != null)
      'advertisedRouteNextHopUri': advertisedRouteNextHopUri!,
    if (advertisedRouteSourceRouterUri != null)
      'advertisedRouteSourceRouterUri': advertisedRouteSourceRouterUri!,
    if (destIpRange != null) 'destIpRange': destIpRange!,
    if (destPortRanges != null) 'destPortRanges': destPortRanges!,
    if (displayName != null) 'displayName': displayName!,
    if (instanceTags != null) 'instanceTags': instanceTags!,
    if (nccHubRouteUri != null) 'nccHubRouteUri': nccHubRouteUri!,
    if (nccHubUri != null) 'nccHubUri': nccHubUri!,
    if (nccSpokeUri != null) 'nccSpokeUri': nccSpokeUri!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (nextHop != null) 'nextHop': nextHop!,
    if (nextHopNetworkUri != null) 'nextHopNetworkUri': nextHopNetworkUri!,
    if (nextHopType != null) 'nextHopType': nextHopType!,
    if (nextHopUri != null) 'nextHopUri': nextHopUri!,
    if (originatingRouteDisplayName != null)
      'originatingRouteDisplayName': originatingRouteDisplayName!,
    if (originatingRouteUri != null)
      'originatingRouteUri': originatingRouteUri!,
    if (priority != null) 'priority': priority!,
    if (protocols != null) 'protocols': protocols!,
    if (region != null) 'region': region!,
    if (routeScope != null) 'routeScope': routeScope!,
    if (routeType != null) 'routeType': routeType!,
    if (srcIpRange != null) 'srcIpRange': srcIpRange!,
    if (srcPortRanges != null) 'srcPortRanges': srcPortRanges!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - networkservices:v1 : GrpcRouteStatefulSessionAffinityPolicy
/// - networkservices:v1 : HttpRouteStatefulSessionAffinityPolicy
/// - networkservices:v1beta1 : GrpcRouteStatefulSessionAffinityPolicy
/// - networkservices:v1beta1 : HttpRouteStatefulSessionAffinityPolicy
class $RouteStatefulSessionAffinityPolicy {
  /// The cookie TTL value for the Set-Cookie header generated by the data
  /// plane.
  ///
  /// The lifetime of the cookie may be set to a value from 0 to 86400 seconds
  /// (24 hours) inclusive. Set this to 0s to use a session cookie and disable
  /// cookie expiration.
  ///
  /// Required.
  core.String? cookieTtl;

  $RouteStatefulSessionAffinityPolicy({this.cookieTtl});

  $RouteStatefulSessionAffinityPolicy.fromJson(core.Map json_)
    : this(cookieTtl: json_['cookieTtl'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cookieTtl != null) 'cookieTtl': cookieTtl!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterAdvertisedIpRange
/// - compute:beta : RouterAdvertisedIpRange
/// - compute:v1 : RouterAdvertisedIpRange
class $RouterAdvertisedIpRange {
  /// User-specified description for the IP range.
  core.String? description;

  /// The IP range to advertise.
  ///
  /// The value must be a CIDR-formatted string.
  core.String? range;

  $RouterAdvertisedIpRange({this.description, this.range});

  $RouterAdvertisedIpRange.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        range: json_['range'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (range != null) 'range': range!,
  };
}

/// Used by:
///
/// - compute:beta : RouterBgpPeerBfd
/// - compute:v1 : RouterBgpPeerBfd
class $RouterBgpPeerBfd {
  /// The minimum interval, in milliseconds, between BFD control packets
  /// received from the peer router.
  ///
  /// The actual value is negotiated between the two routers and is equal to the
  /// greater of this value and the transmit interval of the other router. If
  /// set, this value must be between 1000 and 30000. The default is 1000.
  core.int? minReceiveInterval;

  /// The minimum interval, in milliseconds, between BFD control packets
  /// transmitted to the peer router.
  ///
  /// The actual value is negotiated between the two routers and is equal to the
  /// greater of this value and the corresponding receive interval of the other
  /// router. If set, this value must be between 1000 and 30000. The default is
  /// 1000.
  core.int? minTransmitInterval;

  /// The number of consecutive BFD packets that must be missed before BFD
  /// declares that a peer is unavailable.
  ///
  /// If set, the value must be a value between 5 and 16. The default is 5.
  core.int? multiplier;

  /// The BFD session initialization mode for this BGP peer.
  ///
  /// If set to ACTIVE, the Cloud Router will initiate the BFD session for this
  /// BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer
  /// router to initiate the BFD session for this BGP peer. If set to DISABLED,
  /// BFD is disabled for this BGP peer. The default is DISABLED.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DISABLED"
  /// - "PASSIVE"
  core.String? sessionInitializationMode;

  $RouterBgpPeerBfd({
    this.minReceiveInterval,
    this.minTransmitInterval,
    this.multiplier,
    this.sessionInitializationMode,
  });

  $RouterBgpPeerBfd.fromJson(core.Map json_)
    : this(
        minReceiveInterval: json_['minReceiveInterval'] as core.int?,
        minTransmitInterval: json_['minTransmitInterval'] as core.int?,
        multiplier: json_['multiplier'] as core.int?,
        sessionInitializationMode:
            json_['sessionInitializationMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (minReceiveInterval != null) 'minReceiveInterval': minReceiveInterval!,
    if (minTransmitInterval != null)
      'minTransmitInterval': minTransmitInterval!,
    if (multiplier != null) 'multiplier': multiplier!,
    if (sessionInitializationMode != null)
      'sessionInitializationMode': sessionInitializationMode!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterBgpPeerCustomLearnedIpRange
/// - compute:beta : RouterBgpPeerCustomLearnedIpRange
/// - compute:v1 : RouterBgpPeerCustomLearnedIpRange
class $RouterBgpPeerCustomLearnedIpRange {
  /// The custom learned route IP address range.
  ///
  /// Must be a valid CIDR-formatted prefix. If an IP address is provided
  /// without a subnet mask, it is interpreted as, for IPv4, a `/32` singular IP
  /// address range, and, for IPv6, `/128`.
  core.String? range;

  $RouterBgpPeerCustomLearnedIpRange({this.range});

  $RouterBgpPeerCustomLearnedIpRange.fromJson(core.Map json_)
    : this(range: json_['range'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (range != null) 'range': range!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterInterface
/// - compute:beta : RouterInterface
/// - compute:v1 : RouterInterface
class $RouterInterface {
  /// IP address and range of the interface.
  ///
  /// - For Internet Protocol version 4 (IPv4), the IP range must be in the
  /// RFC3927 link-local IP address space. The value must be a CIDR-formatted
  /// string, for example, 169.254.0.1/30. Note: Do not truncate the IP address,
  /// as it represents the IP address of the interface. - For Internet Protocol
  /// version 6 (IPv6), the value must be a unique local address (ULA) range
  /// from fdff:1::/64 with a mask length of 126 or less. This value should be a
  /// CIDR-formatted string, for example, fdff:1::1/112. Within the router's
  /// VPC, this IPv6 prefix will be reserved exclusively for this connection and
  /// cannot be used for any other purpose.
  core.String? ipRange;

  /// IP version of this interface.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  core.String? ipVersion;

  /// URI of the linked Interconnect attachment.
  ///
  /// It must be in the same region as the router. Each interface can have one
  /// linked resource, which can be a VPN tunnel, an Interconnect attachment, or
  /// a subnetwork.
  core.String? linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel, which must be in the same region as the
  /// router.
  ///
  /// Each interface can have one linked resource, which can be a VPN tunnel, an
  /// Interconnect attachment, or a subnetwork.
  core.String? linkedVpnTunnel;

  /// The resource that configures and manages this interface.
  ///
  /// - MANAGED_BY_USER is the default value and can be managed directly by
  /// users. - MANAGED_BY_ATTACHMENT is an interface that is configured and
  /// managed by Cloud Interconnect, specifically, by an InterconnectAttachment
  /// of type PARTNER. Google automatically creates, updates, and deletes this
  /// type of interface when the PARTNER InterconnectAttachment is created,
  /// updated, or deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT" : The interface is automatically created for
  /// PARTNER type InterconnectAttachment, Google will automatically
  /// create/update/delete this interface when the PARTNER
  /// InterconnectAttachment is created/provisioned/deleted. This type of
  /// interface cannot be manually managed by user.
  /// - "MANAGED_BY_USER" : Default value, the interface is manually created and
  /// managed by user.
  core.String? managementType;

  /// Name of this interface entry.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The regional private internal IP address that is used to establish BGP
  /// sessions to a VM instance acting as a third-party Router Appliance, such
  /// as a Next Gen Firewall, a Virtual Router, or an SD-WAN VM.
  core.String? privateIpAddress;

  /// Name of the interface that will be redundant with the current interface
  /// you are creating.
  ///
  /// The redundantInterface must belong to the same Cloud Router as the
  /// interface here. To establish the BGP session to a Router Appliance VM, you
  /// must create two BGP peers. The two BGP peers must be attached to two
  /// separate interfaces that are redundant with each other. The
  /// redundant_interface must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the redundant_interface must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String? redundantInterface;

  /// The URI of the subnetwork resource that this interface belongs to, which
  /// must be in the same region as the Cloud Router.
  ///
  /// When you establish a BGP session to a VM instance using this interface,
  /// the VM instance must belong to the same subnetwork as the subnetwork
  /// specified here.
  core.String? subnetwork;

  $RouterInterface({
    this.ipRange,
    this.ipVersion,
    this.linkedInterconnectAttachment,
    this.linkedVpnTunnel,
    this.managementType,
    this.name,
    this.privateIpAddress,
    this.redundantInterface,
    this.subnetwork,
  });

  $RouterInterface.fromJson(core.Map json_)
    : this(
        ipRange: json_['ipRange'] as core.String?,
        ipVersion: json_['ipVersion'] as core.String?,
        linkedInterconnectAttachment:
            json_['linkedInterconnectAttachment'] as core.String?,
        linkedVpnTunnel: json_['linkedVpnTunnel'] as core.String?,
        managementType: json_['managementType'] as core.String?,
        name: json_['name'] as core.String?,
        privateIpAddress: json_['privateIpAddress'] as core.String?,
        redundantInterface: json_['redundantInterface'] as core.String?,
        subnetwork: json_['subnetwork'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipRange != null) 'ipRange': ipRange!,
    if (ipVersion != null) 'ipVersion': ipVersion!,
    if (linkedInterconnectAttachment != null)
      'linkedInterconnectAttachment': linkedInterconnectAttachment!,
    if (linkedVpnTunnel != null) 'linkedVpnTunnel': linkedVpnTunnel!,
    if (managementType != null) 'managementType': managementType!,
    if (name != null) 'name': name!,
    if (privateIpAddress != null) 'privateIpAddress': privateIpAddress!,
    if (redundantInterface != null) 'redundantInterface': redundantInterface!,
    if (subnetwork != null) 'subnetwork': subnetwork!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterMd5AuthenticationKey
/// - compute:beta : RouterMd5AuthenticationKey
/// - compute:v1 : RouterMd5AuthenticationKey
class $RouterMd5AuthenticationKey {
  /// \[Input only\] Value of the key.
  ///
  /// For patch and update calls, it can be skipped to copy the value from the
  /// previous configuration. This is allowed if the key with the same name
  /// existed before the operation. Maximum length is 80 characters. Can only
  /// contain printable ASCII characters.
  core.String? key;

  /// Name used to identify the key.
  ///
  /// Must be unique within a router. Must be referenced by exactly one bgpPeer.
  /// Must comply with RFC1035.
  core.String? name;

  $RouterMd5AuthenticationKey({this.key, this.name});

  $RouterMd5AuthenticationKey.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterNatLogConfig
/// - compute:beta : RouterNatLogConfig
/// - compute:v1 : RouterNatLogConfig
class $RouterNatLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default.
  core.bool? enable;

  /// Specify the desired filtering of logs on this NAT.
  ///
  /// If unspecified, logs are exported for all connections handled by this NAT.
  /// This option can take one of the following values: - ERRORS_ONLY: Export
  /// logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only
  /// for successful connections. - ALL: Export logs for all connections,
  /// successful and unsuccessful.
  /// Possible string values are:
  /// - "ALL" : Export logs for all (successful and unsuccessful) connections.
  /// - "ERRORS_ONLY" : Export logs for connection failures only.
  /// - "TRANSLATIONS_ONLY" : Export logs for successful connections only.
  core.String? filter;

  $RouterNatLogConfig({this.enable, this.filter});

  $RouterNatLogConfig.fromJson(core.Map json_)
    : this(
        enable: json_['enable'] as core.bool?,
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterNatRuleAction
/// - compute:beta : RouterNatRuleAction
/// - compute:v1 : RouterNatRuleAction
class $RouterNatRuleAction {
  /// A list of URLs of the IP resources used for this NAT rule.
  ///
  /// These IP addresses must be valid static external IP addresses assigned to
  /// the project. This field is used for public NAT.
  core.List<core.String>? sourceNatActiveIps;

  /// A list of URLs of the subnetworks used as source ranges for this NAT Rule.
  ///
  /// These subnetworks must have purpose set to PRIVATE_NAT. This field is used
  /// for private NAT.
  core.List<core.String>? sourceNatActiveRanges;

  /// A list of URLs of the IP resources to be drained.
  ///
  /// These IPs must be valid static external IPs that have been assigned to the
  /// NAT. These IPs should be used for updating/patching a NAT rule only. This
  /// field is used for public NAT.
  core.List<core.String>? sourceNatDrainIps;

  /// A list of URLs of subnetworks representing source ranges to be drained.
  ///
  /// This is only supported on patch/update, and these subnetworks must have
  /// previously been used as active ranges in this NAT Rule. This field is used
  /// for private NAT.
  core.List<core.String>? sourceNatDrainRanges;

  $RouterNatRuleAction({
    this.sourceNatActiveIps,
    this.sourceNatActiveRanges,
    this.sourceNatDrainIps,
    this.sourceNatDrainRanges,
  });

  $RouterNatRuleAction.fromJson(core.Map json_)
    : this(
        sourceNatActiveIps:
            (json_['sourceNatActiveIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sourceNatActiveRanges:
            (json_['sourceNatActiveRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sourceNatDrainIps:
            (json_['sourceNatDrainIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sourceNatDrainRanges:
            (json_['sourceNatDrainRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sourceNatActiveIps != null) 'sourceNatActiveIps': sourceNatActiveIps!,
    if (sourceNatActiveRanges != null)
      'sourceNatActiveRanges': sourceNatActiveRanges!,
    if (sourceNatDrainIps != null) 'sourceNatDrainIps': sourceNatDrainIps!,
    if (sourceNatDrainRanges != null)
      'sourceNatDrainRanges': sourceNatDrainRanges!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterNatSubnetworkToNat
/// - compute:beta : RouterNatSubnetworkToNat
/// - compute:v1 : RouterNatSubnetworkToNat
class $RouterNatSubnetworkToNat {
  /// URL for the subnetwork resource that will use NAT.
  core.String? name;

  /// A list of the secondary ranges of the Subnetwork that are allowed to use
  /// NAT.
  ///
  /// This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of the
  /// values in source_ip_ranges_to_nat.
  core.List<core.String>? secondaryIpRangeNames;

  /// Specify the options for NAT ranges in the Subnetwork.
  ///
  /// All options of a single value are valid except
  /// NAT_IP_RANGE_OPTION_UNSPECIFIED. The only valid option with multiple
  /// values is: \["PRIMARY_IP_RANGE", "LIST_OF_SECONDARY_IP_RANGES"\] Default:
  /// \[ALL_IP_RANGES\]
  core.List<core.String>? sourceIpRangesToNat;

  $RouterNatSubnetworkToNat({
    this.name,
    this.secondaryIpRangeNames,
    this.sourceIpRangesToNat,
  });

  $RouterNatSubnetworkToNat.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        secondaryIpRangeNames:
            (json_['secondaryIpRangeNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sourceIpRangesToNat:
            (json_['sourceIpRangesToNat'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (secondaryIpRangeNames != null)
      'secondaryIpRangeNames': secondaryIpRangeNames!,
    if (sourceIpRangesToNat != null)
      'sourceIpRangesToNat': sourceIpRangesToNat!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterNatSubnetworkToNat64
/// - compute:beta : RouterNatSubnetworkToNat64
/// - compute:v1 : RouterNatSubnetworkToNat64
class $RouterNatSubnetworkToNat64 {
  /// URL for the subnetwork resource that will use NAT64.
  core.String? name;

  $RouterNatSubnetworkToNat64({this.name});

  $RouterNatSubnetworkToNat64.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterParams
/// - compute:beta : RouterParams
class $RouterParams {
  /// Tag keys/values directly bound to this resource.
  ///
  /// Tag keys and values have the same definition as resource manager tags. The
  /// field is allowed for INSERT only. The keys/values to set on the resource
  /// should be specified in either ID { : } or Namespaced format { : }. For
  /// example the following are valid inputs: * {"tagKeys/333" :
  /// "tagValues/444", "tagKeys/123" : "tagValues/456"} * {"123/environment" :
  /// "production", "345/abc" : "xyz"} Note: * Invalid combinations of ID &
  /// namespaced format is not supported. For instance: {"123/environment" :
  /// "tagValues/444"} is invalid. * Inconsistent format is not supported. For
  /// instance: {"tagKeys/333" : "tagValues/444", "123/env" : "prod"} is
  /// invalid.
  core.Map<core.String, core.String>? resourceManagerTags;

  $RouterParams({this.resourceManagerTags});

  $RouterParams.fromJson(core.Map json_)
    : this(
        resourceManagerTags: (json_['resourceManagerTags']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceManagerTags != null)
      'resourceManagerTags': resourceManagerTags!,
  };
}

/// Used by:
///
/// - compute:alpha : RouterStatusNatStatusNatRuleStatus
/// - compute:beta : RouterStatusNatStatusNatRuleStatus
/// - compute:v1 : RouterStatusNatStatusNatRuleStatus
class $RouterStatusNatStatusNatRuleStatus {
  /// A list of active IPs for NAT.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? activeNatIps;

  /// A list of IPs for NAT that are in drain mode.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? drainNatIps;

  /// The number of extra IPs to allocate.
  ///
  /// This will be greater than 0 only if the existing IPs in this NAT Rule are
  /// NOT enough to allow all configured VMs to use NAT.
  core.int? minExtraIpsNeeded;

  /// Number of VM endpoints (i.e., NICs) that have NAT Mappings from this NAT
  /// Rule.
  core.int? numVmEndpointsWithNatMappings;

  /// Rule number of the rule.
  core.int? ruleNumber;

  $RouterStatusNatStatusNatRuleStatus({
    this.activeNatIps,
    this.drainNatIps,
    this.minExtraIpsNeeded,
    this.numVmEndpointsWithNatMappings,
    this.ruleNumber,
  });

  $RouterStatusNatStatusNatRuleStatus.fromJson(core.Map json_)
    : this(
        activeNatIps:
            (json_['activeNatIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        drainNatIps:
            (json_['drainNatIps'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        minExtraIpsNeeded: json_['minExtraIpsNeeded'] as core.int?,
        numVmEndpointsWithNatMappings:
            json_['numVmEndpointsWithNatMappings'] as core.int?,
        ruleNumber: json_['ruleNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeNatIps != null) 'activeNatIps': activeNatIps!,
    if (drainNatIps != null) 'drainNatIps': drainNatIps!,
    if (minExtraIpsNeeded != null) 'minExtraIpsNeeded': minExtraIpsNeeded!,
    if (numVmEndpointsWithNatMappings != null)
      'numVmEndpointsWithNatMappings': numVmEndpointsWithNatMappings!,
    if (ruleNumber != null) 'ruleNumber': ruleNumber!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : RsaPublicKeyInfo
/// - cloudidentity:v1beta1 : RsaPublicKeyInfo
class $RsaPublicKeyInfo {
  /// Key size in bits (size of the modulus).
  core.int? keySize;

  $RsaPublicKeyInfo({this.keySize});

  $RsaPublicKeyInfo.fromJson(core.Map json_)
    : this(keySize: json_['keySize'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (keySize != null) 'keySize': keySize!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : RtbMetrics
/// - authorizedbuyersmarketplace:v1alpha : RtbMetrics
class $RtbMetrics {
  /// Ad impressions in last 7 days.
  core.String? adImpressions7Days;

  /// Bid rate in last 7 days, calculated by (bids / bid requests).
  core.double? bidRate7Days;

  /// Bid requests in last 7 days.
  core.String? bidRequests7Days;

  /// Bids in last 7 days.
  core.String? bids7Days;

  /// Filtered bid rate in last 7 days, calculated by (filtered bids / bids).
  core.double? filteredBidRate7Days;

  /// Must bid rate for current month.
  core.double? mustBidRateCurrentMonth;

  $RtbMetrics({
    this.adImpressions7Days,
    this.bidRate7Days,
    this.bidRequests7Days,
    this.bids7Days,
    this.filteredBidRate7Days,
    this.mustBidRateCurrentMonth,
  });

  $RtbMetrics.fromJson(core.Map json_)
    : this(
        adImpressions7Days: json_['adImpressions7Days'] as core.String?,
        bidRate7Days: (json_['bidRate7Days'] as core.num?)?.toDouble(),
        bidRequests7Days: json_['bidRequests7Days'] as core.String?,
        bids7Days: json_['bids7Days'] as core.String?,
        filteredBidRate7Days:
            (json_['filteredBidRate7Days'] as core.num?)?.toDouble(),
        mustBidRateCurrentMonth:
            (json_['mustBidRateCurrentMonth'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adImpressions7Days != null) 'adImpressions7Days': adImpressions7Days!,
    if (bidRate7Days != null) 'bidRate7Days': bidRate7Days!,
    if (bidRequests7Days != null) 'bidRequests7Days': bidRequests7Days!,
    if (bids7Days != null) 'bids7Days': bids7Days!,
    if (filteredBidRate7Days != null)
      'filteredBidRate7Days': filteredBidRate7Days!,
    if (mustBidRateCurrentMonth != null)
      'mustBidRateCurrentMonth': mustBidRateCurrentMonth!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RubricBasedInstructionFollowingInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInstance
class $RubricBasedInstructionFollowingInstance {
  /// Instance specified as a json string.
  ///
  /// String key-value pairs are expected in the json_instance to render
  /// RubricBasedInstructionFollowing prompt templates.
  ///
  /// Required.
  core.String? jsonInstance;

  $RubricBasedInstructionFollowingInstance({this.jsonInstance});

  $RubricBasedInstructionFollowingInstance.fromJson(core.Map json_)
    : this(jsonInstance: json_['jsonInstance'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (jsonInstance != null) 'jsonInstance': jsonInstance!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RubricCritiqueResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RubricCritiqueResult
class $RubricCritiqueResult {
  /// Rubric to be evaluated.
  ///
  /// Output only.
  core.String? rubric;

  /// Verdict for the rubric - true if the rubric is met, false otherwise.
  ///
  /// Output only.
  core.bool? verdict;

  $RubricCritiqueResult({this.rubric, this.verdict});

  $RubricCritiqueResult.fromJson(core.Map json_)
    : this(
        rubric: json_['rubric'] as core.String?,
        verdict: json_['verdict'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rubric != null) 'rubric': rubric!,
    if (verdict != null) 'verdict': verdict!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleBoostAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleBoostAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleBoostAction
class $RuleBoostAction {
  /// Strength of the condition boost, which must be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the
  /// item a big promotion. However, it does not necessarily mean that the
  /// boosted item will be the top result at all times, nor that other items
  /// will be excluded. Results could still be shown even when none of them
  /// matches the condition. And results that are significantly more relevant to
  /// the search query can still trump your heavily favored but irrelevant
  /// items. Setting to -1.0 gives the item a big demotion. However, results
  /// that are deeply relevant might still be shown. The item will have an
  /// upstream battle to get a fairly high ranking, but it is not blocked out
  /// completely. Setting to 0.0 means no boost applied. The boosting condition
  /// is ignored.
  core.double? boost;

  /// The filter can have a max size of 5000 characters.
  ///
  /// An expression which specifies which products to apply an action to. The
  /// syntax and supported fields are the same as a filter expression. See
  /// SearchRequest.filter for detail syntax and limitations. Examples: * To
  /// boost products with product ID "product_1" or "product_2", and color "Red"
  /// or "Blue": *(id: ANY("product_1", "product_2")) * *AND * *(colorFamilies:
  /// ANY("Red", "Blue")) *
  core.String? productsFilter;

  $RuleBoostAction({this.boost, this.productsFilter});

  $RuleBoostAction.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        productsFilter: json_['productsFilter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (productsFilter != null) 'productsFilter': productsFilter!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleDoNotAssociateAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleDoNotAssociateAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleDoNotAssociateAction
class $RuleDoNotAssociateAction {
  /// Cannot contain duplicates or the query term.
  ///
  /// Can specify up to 100 terms.
  core.List<core.String>? doNotAssociateTerms;

  /// Terms from the search query.
  ///
  /// Will not consider do_not_associate_terms for search if in search query.
  /// Can specify up to 100 terms.
  core.List<core.String>? queryTerms;

  /// Will be \[deprecated = true\] post migration;
  core.List<core.String>? terms;

  $RuleDoNotAssociateAction({
    this.doNotAssociateTerms,
    this.queryTerms,
    this.terms,
  });

  $RuleDoNotAssociateAction.fromJson(core.Map json_)
    : this(
        doNotAssociateTerms:
            (json_['doNotAssociateTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        queryTerms:
            (json_['queryTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        terms:
            (json_['terms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doNotAssociateTerms != null)
      'doNotAssociateTerms': doNotAssociateTerms!,
    if (queryTerms != null) 'queryTerms': queryTerms!,
    if (terms != null) 'terms': terms!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleFilterAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleFilterAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleFilterAction
class $RuleFilterAction {
  /// A filter to apply on the matching condition results.
  ///
  /// Supported features: * filter must be set. * Filter syntax is identical to
  /// SearchRequest.filter. For more information, see
  /// \[Filter\](/retail/docs/filter-and-order#filter). * To filter products
  /// with product ID "product_1" or "product_2", and color "Red" or "Blue":
  /// *(id: ANY("product_1", "product_2")) * *AND * *(colorFamilies: ANY("Red",
  /// "Blue")) *
  core.String? filter;

  $RuleFilterAction({this.filter});

  $RuleFilterAction.fromJson(core.Map json_)
    : this(filter: json_['filter'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleForceReturnFacetActionFacetPositionAdjustment
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleForceReturnFacetActionFacetPositionAdjustment
/// - retail:v2beta : GoogleCloudRetailV2betaRuleForceReturnFacetActionFacetPositionAdjustment
class $RuleForceReturnFacetActionFacetPositionAdjustment {
  /// The attribute name to force return as a facet.
  ///
  /// Each attribute name should be a valid attribute name, be non-empty and
  /// contain at most 80 characters long.
  core.String? attributeName;

  /// This is the position in the request as explained above.
  ///
  /// It should be strictly positive be at most 100.
  core.int? position;

  $RuleForceReturnFacetActionFacetPositionAdjustment({
    this.attributeName,
    this.position,
  });

  $RuleForceReturnFacetActionFacetPositionAdjustment.fromJson(core.Map json_)
    : this(
        attributeName: json_['attributeName'] as core.String?,
        position: json_['position'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeName != null) 'attributeName': attributeName!,
    if (position != null) 'position': position!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleIgnoreAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleIgnoreAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleIgnoreAction
class $RuleIgnoreAction {
  /// Terms to ignore in the search query.
  core.List<core.String>? ignoreTerms;

  $RuleIgnoreAction({this.ignoreTerms});

  $RuleIgnoreAction.fromJson(core.Map json_)
    : this(
        ignoreTerms:
            (json_['ignoreTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ignoreTerms != null) 'ignoreTerms': ignoreTerms!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleOnewaySynonymsAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleOnewaySynonymsAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleOnewaySynonymsAction
class $RuleOnewaySynonymsAction {
  /// Will be \[deprecated = true\] post migration;
  core.List<core.String>? onewayTerms;

  /// Terms from the search query.
  ///
  /// Will treat synonyms as their synonyms. Not themselves synonyms of the
  /// synonyms. Can specify up to 100 terms.
  core.List<core.String>? queryTerms;

  /// Defines a set of synonyms.
  ///
  /// Cannot contain duplicates. Can specify up to 100 synonyms.
  core.List<core.String>? synonyms;

  $RuleOnewaySynonymsAction({this.onewayTerms, this.queryTerms, this.synonyms});

  $RuleOnewaySynonymsAction.fromJson(core.Map json_)
    : this(
        onewayTerms:
            (json_['onewayTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        queryTerms:
            (json_['queryTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (onewayTerms != null) 'onewayTerms': onewayTerms!,
    if (queryTerms != null) 'queryTerms': queryTerms!,
    if (synonyms != null) 'synonyms': synonyms!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RulePinAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRulePinAction
/// - retail:v2beta : GoogleCloudRetailV2betaRulePinAction
class $RulePinAction {
  /// A map of positions to product_ids.
  ///
  /// Partial matches per action are allowed, if a certain position in the map
  /// is already filled that `[position, product_id]` pair will be ignored but
  /// the rest may still be applied. This case will only occur if multiple pin
  /// actions are matched to a single request, as the map guarantees that pin
  /// positions are unique within the same action. Duplicate product_ids are not
  /// permitted within a single pin map. The max size of this map is 120,
  /// equivalent to the max
  /// [request page size](https://cloud.google.com/retail/docs/reference/rest/v2/projects.locations.catalogs.placements/search#request-body).
  ///
  /// Required.
  core.Map<core.String, core.String>? pinMap;

  $RulePinAction({this.pinMap});

  $RulePinAction.fromJson(core.Map json_)
    : this(
        pinMap: (json_['pinMap'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pinMap != null) 'pinMap': pinMap!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleRedirectAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleRedirectAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleRedirectAction
class $RuleRedirectAction {
  /// URL must have length equal or less than 2000 characters.
  core.String? redirectUri;

  $RuleRedirectAction({this.redirectUri});

  $RuleRedirectAction.fromJson(core.Map json_)
    : this(redirectUri: json_['redirectUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (redirectUri != null) 'redirectUri': redirectUri!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleRemoveFacetAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleRemoveFacetAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleRemoveFacetAction
class $RuleRemoveFacetAction {
  /// The attribute names (i.e. facet keys) to remove from the dynamic facets
  /// (if present in the request).
  ///
  /// There can't be more 3 attribute names. Each attribute name should be a
  /// valid attribute name, be non-empty and contain at most 80 characters.
  core.List<core.String>? attributeNames;

  $RuleRemoveFacetAction({this.attributeNames});

  $RuleRemoveFacetAction.fromJson(core.Map json_)
    : this(
        attributeNames:
            (json_['attributeNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeNames != null) 'attributeNames': attributeNames!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleReplacementAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleReplacementAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleReplacementAction
class $RuleReplacementAction {
  /// Terms from the search query.
  ///
  /// Will be replaced by replacement term. Can specify up to 100 terms.
  core.List<core.String>? queryTerms;

  /// Term that will be used for replacement.
  core.String? replacementTerm;

  /// Will be \[deprecated = true\] post migration;
  core.String? term;

  $RuleReplacementAction({this.queryTerms, this.replacementTerm, this.term});

  $RuleReplacementAction.fromJson(core.Map json_)
    : this(
        queryTerms:
            (json_['queryTerms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        replacementTerm: json_['replacementTerm'] as core.String?,
        term: json_['term'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryTerms != null) 'queryTerms': queryTerms!,
    if (replacementTerm != null) 'replacementTerm': replacementTerm!,
    if (term != null) 'term': term!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2RuleTwowaySynonymsAction
/// - retail:v2alpha : GoogleCloudRetailV2alphaRuleTwowaySynonymsAction
/// - retail:v2beta : GoogleCloudRetailV2betaRuleTwowaySynonymsAction
class $RuleTwowaySynonymsAction {
  /// Defines a set of synonyms.
  ///
  /// Can specify up to 100 synonyms. Must specify at least 2 synonyms.
  core.List<core.String>? synonyms;

  $RuleTwowaySynonymsAction({this.synonyms});

  $RuleTwowaySynonymsAction.fromJson(core.Map json_)
    : this(
        synonyms:
            (json_['synonyms'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (synonyms != null) 'synonyms': synonyms!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : RunConfig
/// - firebaseapphosting:v1beta : RunConfig
class $RunConfig {
  /// Maximum number of requests that each Cloud Run instance can receive.
  ///
  /// By default, each instance can receive Cloud Run's default of up to 80
  /// requests at the same time. Concurrency can be set to any integer value up
  /// to 1000.
  ///
  /// Optional.
  core.int? concurrency;

  /// Number of CPUs used for each serving instance.
  ///
  /// By default, cpu defaults to the Cloud Run's default of 1.0. CPU can be set
  /// to value 1, 2, 4, 6, or 8 CPUs, and for less than 1 CPU, a value from 0.08
  /// to less than 1.00, in increments of 0.01. If you set a value of less than
  /// 1 CPU, you must set concurrency to 1, and CPU will only be allocated
  /// during request processing. Increasing CPUs limit may require increase in
  /// memory limits: - 4 CPUs: at least 2 GiB - 6 CPUs: at least 4 GiB - 8 CPUs:
  /// at least 4 GiB
  ///
  /// Optional.
  core.double? cpu;

  /// Number of Cloud Run instances to maintain at maximum for each revision.
  ///
  /// By default, each Cloud Run
  /// \[`service`\](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services#resource:-service)
  /// scales out to Cloud Run's default of a maximum of 100 instances. The
  /// maximum max_instances limit is based on your quota. See
  /// https://cloud.google.com/run/docs/configuring/max-instances#limits.
  ///
  /// Optional.
  core.int? maxInstances;

  /// Amount of memory allocated for each serving instance in MiB.
  ///
  /// By default, memory defaults to the Cloud Run's default where each instance
  /// is allocated 512 MiB of memory. Memory can be set to any integer value
  /// between 128 to 32768. Increasing memory limit may require increase in CPUs
  /// limits: - Over 4 GiB: at least 2 CPUs - Over 8 GiB: at least 4 CPUs - Over
  /// 16 GiB: at least 6 CPUs - Over 24 GiB: at least 8 CPUs
  ///
  /// Optional.
  core.int? memoryMib;

  /// Number of Cloud Run instances to maintain at minimum for each Cloud Run
  /// Service.
  ///
  /// By default, there are no minimum. Even if the service splits traffic
  /// across multiple revisions, the total number of instances for a service
  /// will be capped at this value.
  ///
  /// Optional.
  core.int? minInstances;

  $RunConfig({
    this.concurrency,
    this.cpu,
    this.maxInstances,
    this.memoryMib,
    this.minInstances,
  });

  $RunConfig.fromJson(core.Map json_)
    : this(
        concurrency: json_['concurrency'] as core.int?,
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        maxInstances: json_['maxInstances'] as core.int?,
        memoryMib: json_['memoryMib'] as core.int?,
        minInstances: json_['minInstances'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (concurrency != null) 'concurrency': concurrency!,
    if (cpu != null) 'cpu': cpu!,
    if (maxInstances != null) 'maxInstances': maxInstances!,
    if (memoryMib != null) 'memoryMib': memoryMib!,
    if (minInstances != null) 'minInstances': minInstances!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : RunService
/// - firebaseapphosting:v1beta : RunService
class $RunService {
  /// The name of the Cloud Run
  /// \[`service`\](https://cloud.google.com/run/docs/reference/rest/v2/projects.locations.services#resource:-service),
  /// in the format:
  /// `projects/{project}/locations/{location}/services/{serviceId}`
  ///
  /// Optional.
  core.String? service;

  $RunService({this.service});

  $RunService.fromJson(core.Map json_)
    : this(service: json_['service'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : RunTaskRequest
/// - cloudtasks:v2beta3 : RunTaskRequest
class $RunTaskRequest {
  /// The response_view specifies which subset of the Task will be returned.
  ///
  /// By default response_view is BASIC; not all information is retrieved by
  /// default because some data, such as payloads, might be desirable to return
  /// only when needed because of its large size or because of the sensitivity
  /// of data that it contains. Authorization for FULL requires
  /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
  /// permission on the Task resource.
  /// Possible string values are:
  /// - "VIEW_UNSPECIFIED" : Unspecified. Defaults to BASIC.
  /// - "BASIC" : The basic view omits fields which can be large or can contain
  /// sensitive data. This view does not include the body in
  /// AppEngineHttpRequest. Bodies are desirable to return only when needed,
  /// because they can be large and because of the sensitivity of the data that
  /// you choose to store in it.
  /// - "FULL" : All information is returned. Authorization for FULL requires
  /// `cloudtasks.tasks.fullView` [Google IAM](https://cloud.google.com/iam/)
  /// permission on the Queue resource.
  core.String? responseView;

  $RunTaskRequest({this.responseView});

  $RunTaskRequest.fromJson(core.Map json_)
    : this(responseView: json_['responseView'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (responseView != null) 'responseView': responseView!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3RunTestCaseRequest
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1RunTestCaseRequest
class $RunTestCaseRequest {
  /// Environment name.
  ///
  /// If not set, draft environment is assumed. Format:
  /// `projects//locations//agents//environments/`.
  ///
  /// Optional.
  core.String? environment;

  $RunTestCaseRequest({this.environment});

  $RunTestCaseRequest.fromJson(core.Map json_)
    : this(environment: json_['environment'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (environment != null) 'environment': environment!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : RunningProcess
/// - migrationcenter:v1alpha1 : RunningProcess
class $RunningProcess {
  /// Process extended attributes.
  core.Map<core.String, core.String>? attributes;

  /// Process full command line.
  core.String? cmdline;

  /// Process binary path.
  core.String? exePath;

  /// Process ID.
  core.String? pid;

  /// User running the process.
  core.String? user;

  $RunningProcess({
    this.attributes,
    this.cmdline,
    this.exePath,
    this.pid,
    this.user,
  });

  $RunningProcess.fromJson(core.Map json_)
    : this(
        attributes: (json_['attributes']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        cmdline: json_['cmdline'] as core.String?,
        exePath: json_['exePath'] as core.String?,
        pid: json_['pid'] as core.String?,
        user: json_['user'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributes != null) 'attributes': attributes!,
    if (cmdline != null) 'cmdline': cmdline!,
    if (exePath != null) 'exePath': exePath!,
    if (pid != null) 'pid': pid!,
    if (user != null) 'user': user!,
  };
}

/// Used by:
///
/// - notebooks:v1 : ResetRuntimeRequest
/// - notebooks:v1 : StartRuntimeRequest
/// - notebooks:v1 : StopRuntimeRequest
/// - notebooks:v1 : UpgradeRuntimeRequest
class $RuntimeRequest {
  /// Idempotent request UUID.
  core.String? requestId;

  $RuntimeRequest({this.requestId});

  $RuntimeRequest.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - tpu:v2 : RuntimeVersion
/// - tpu:v2alpha1 : RuntimeVersion
class $RuntimeVersion {
  /// The resource name.
  core.String? name;

  /// The runtime version.
  core.String? version;

  $RuntimeVersion({this.name, this.version});

  $RuntimeVersion.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : SBOMReferenceNote
/// - containeranalysis:v1alpha1 : SBOMReferenceNote
/// - containeranalysis:v1beta1 : SBOMReferenceNote
class $SBOMReferenceNote {
  /// The format that SBOM takes.
  ///
  /// E.g. may be spdx, cyclonedx, etc...
  core.String? format;

  /// The version of the format that the SBOM takes.
  ///
  /// E.g. if the format is spdx, the version may be 2.3.
  core.String? version;

  $SBOMReferenceNote({this.format, this.version});

  $SBOMReferenceNote.fromJson(core.Map json_)
    : this(
        format: json_['format'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (format != null) 'format': format!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : SBOMStatus
/// - containeranalysis:v1beta1 : SBOMStatus
/// - ondemandscanning:v1 : SBOMStatus
/// - ondemandscanning:v1beta1 : SBOMStatus
class $SBOMStatus {
  /// If there was an error generating an SBOM, this will indicate what that
  /// error was.
  core.String? error;

  /// The progress of the SBOM generation.
  /// Possible string values are:
  /// - "SBOM_STATE_UNSPECIFIED" : Default unknown state.
  /// - "PENDING" : SBOM scanning is pending.
  /// - "COMPLETE" : SBOM scanning has completed.
  core.String? sbomState;

  $SBOMStatus({this.error, this.sbomState});

  $SBOMStatus.fromJson(core.Map json_)
    : this(
        error: json_['error'] as core.String?,
        sbomState: json_['sbomState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (sbomState != null) 'sbomState': sbomState!,
  };
}

/// Used by:
///
/// - compute:alpha : SSLHealthCheck
/// - compute:beta : SSLHealthCheck
/// - compute:v1 : SSLHealthCheck
class $SSLHealthCheck {
  /// The TCP port number to which the health check prober sends packets.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Instructs the health check prober to send this exact ASCII string, up to
  /// 1024 bytes in length, after establishing the TCP connection and SSL
  /// handshake.
  core.String? request;

  /// Creates a content-based SSL health check.
  ///
  /// In addition to establishing a TCP connection and the TLS handshake, you
  /// can configure the health check to pass only when the backend sends this
  /// exact response ASCII string, up to 1024 bytes in length. For details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
  core.String? response;

  $SSLHealthCheck({
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.request,
    this.response,
  });

  $SSLHealthCheck.fromJson(core.Map json_)
    : this(
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        request: json_['request'] as core.String?,
        response: json_['response'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (request != null) 'request': request!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - cloudsearch:v1 : SafeHtmlProto
/// - toolresults:v1beta3 : SafeHtmlProto
class $SafeHtmlProto {
  /// IMPORTANT: Never set or read this field, even from tests, it is private.
  ///
  /// See documentation at the top of .proto file for programming language
  /// packages with which to create or read this message.
  core.String? privateDoNotAccessOrElseSafeHtmlWrappedValue;

  $SafeHtmlProto({this.privateDoNotAccessOrElseSafeHtmlWrappedValue});

  $SafeHtmlProto.fromJson(core.Map json_)
    : this(
        privateDoNotAccessOrElseSafeHtmlWrappedValue:
            json_['privateDoNotAccessOrElseSafeHtmlWrappedValue']
                as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (privateDoNotAccessOrElseSafeHtmlWrappedValue != null)
      'privateDoNotAccessOrElseSafeHtmlWrappedValue':
          privateDoNotAccessOrElseSafeHtmlWrappedValue!,
  };
}

/// Used by:
///
/// - vision:v1 : SafeSearchAnnotation
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1SafeSearchAnnotation
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1SafeSearchAnnotation
class $SafeSearchAnnotation {
  /// Represents the adult content likelihood for the image.
  ///
  /// Adult content may contain elements such as nudity, pornographic images or
  /// cartoons, or sexual activities.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown likelihood.
  /// - "VERY_UNLIKELY" : It is very unlikely.
  /// - "UNLIKELY" : It is unlikely.
  /// - "POSSIBLE" : It is possible.
  /// - "LIKELY" : It is likely.
  /// - "VERY_LIKELY" : It is very likely.
  core.String? adult;

  /// Likelihood that this is a medical image.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown likelihood.
  /// - "VERY_UNLIKELY" : It is very unlikely.
  /// - "UNLIKELY" : It is unlikely.
  /// - "POSSIBLE" : It is possible.
  /// - "LIKELY" : It is likely.
  /// - "VERY_LIKELY" : It is very likely.
  core.String? medical;

  /// Likelihood that the request image contains racy content.
  ///
  /// Racy content may include (but is not limited to) skimpy or sheer clothing,
  /// strategically covered nudity, lewd or provocative poses, or close-ups of
  /// sensitive body areas.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown likelihood.
  /// - "VERY_UNLIKELY" : It is very unlikely.
  /// - "UNLIKELY" : It is unlikely.
  /// - "POSSIBLE" : It is possible.
  /// - "LIKELY" : It is likely.
  /// - "VERY_LIKELY" : It is very likely.
  core.String? racy;

  /// Spoof likelihood.
  ///
  /// The likelihood that an modification was made to the image's canonical
  /// version to make it appear funny or offensive.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown likelihood.
  /// - "VERY_UNLIKELY" : It is very unlikely.
  /// - "UNLIKELY" : It is unlikely.
  /// - "POSSIBLE" : It is possible.
  /// - "LIKELY" : It is likely.
  /// - "VERY_LIKELY" : It is very likely.
  core.String? spoof;

  /// Likelihood that this image contains violent content.
  ///
  /// Violent content may include death, serious harm, or injury to individuals
  /// or groups of individuals.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown likelihood.
  /// - "VERY_UNLIKELY" : It is very unlikely.
  /// - "UNLIKELY" : It is unlikely.
  /// - "POSSIBLE" : It is possible.
  /// - "LIKELY" : It is likely.
  /// - "VERY_LIKELY" : It is very likely.
  core.String? violence;

  $SafeSearchAnnotation({
    this.adult,
    this.medical,
    this.racy,
    this.spoof,
    this.violence,
  });

  $SafeSearchAnnotation.fromJson(core.Map json_)
    : this(
        adult: json_['adult'] as core.String?,
        medical: json_['medical'] as core.String?,
        racy: json_['racy'] as core.String?,
        spoof: json_['spoof'] as core.String?,
        violence: json_['violence'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adult != null) 'adult': adult!,
    if (medical != null) 'medical': medical!,
    if (racy != null) 'racy': racy!,
    if (spoof != null) 'spoof': spoof!,
    if (violence != null) 'violence': violence!,
  };
}

/// Used by:
///
/// - firebaseappcheck:v1 : GoogleFirebaseAppcheckV1SafetyNetConfig
/// - firebaseappcheck:v1beta : GoogleFirebaseAppcheckV1betaSafetyNetConfig
class $SafetyNetConfig {
  /// The relative resource name of the SafetyNet configuration object, in the
  /// format: ``` projects/{project_number}/apps/{app_id}/safetyNetConfig ```
  ///
  /// Required.
  core.String? name;

  /// Specifies the duration for which App Check tokens exchanged from SafetyNet
  /// tokens will be valid.
  ///
  /// If unset, a default value of 1 hour is assumed. Must be between 30 minutes
  /// and 7 days, inclusive.
  core.String? tokenTtl;

  $SafetyNetConfig({this.name, this.tokenTtl});

  $SafetyNetConfig.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        tokenTtl: json_['tokenTtl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (tokenTtl != null) 'tokenTtl': tokenTtl!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SafetyRating
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SafetyRating
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1SafetyRating
class $SafetyRating00 {
  /// Indicates whether the content was filtered out because of this rating.
  ///
  /// Output only.
  core.bool? blocked;

  /// Harm category.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : Deprecated: Election filter is not
  /// longer supported. The harm category is civic integrity.
  /// - "HARM_CATEGORY_IMAGE_HATE" : The harm category is image hate.
  /// - "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT" : The harm category is image
  /// dangerous content.
  /// - "HARM_CATEGORY_IMAGE_HARASSMENT" : The harm category is image
  /// harassment.
  /// - "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT" : The harm category is image
  /// sexually explicit content.
  core.String? category;

  /// The overwritten threshold for the safety category of Gemini 2.0 image out.
  ///
  /// If minors are detected in the output image, the threshold of each safety
  /// category will be overwritten if user sets a lower threshold.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_BLOCK_THRESHOLD_UNSPECIFIED" : Unspecified harm block threshold.
  /// - "BLOCK_LOW_AND_ABOVE" : Block low threshold and above (i.e. block more).
  /// - "BLOCK_MEDIUM_AND_ABOVE" : Block medium threshold and above.
  /// - "BLOCK_ONLY_HIGH" : Block only high threshold (i.e. block less).
  /// - "BLOCK_NONE" : Block none.
  /// - "OFF" : Turn off the safety filter.
  core.String? overwrittenThreshold;

  /// Harm probability levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_PROBABILITY_UNSPECIFIED" : Harm probability unspecified.
  /// - "NEGLIGIBLE" : Negligible level of harm.
  /// - "LOW" : Low level of harm.
  /// - "MEDIUM" : Medium level of harm.
  /// - "HIGH" : High level of harm.
  core.String? probability;

  /// Harm probability score.
  ///
  /// Output only.
  core.double? probabilityScore;

  /// Harm severity levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_SEVERITY_UNSPECIFIED" : Harm severity unspecified.
  /// - "HARM_SEVERITY_NEGLIGIBLE" : Negligible level of harm severity.
  /// - "HARM_SEVERITY_LOW" : Low level of harm severity.
  /// - "HARM_SEVERITY_MEDIUM" : Medium level of harm severity.
  /// - "HARM_SEVERITY_HIGH" : High level of harm severity.
  core.String? severity;

  /// Harm severity score.
  ///
  /// Output only.
  core.double? severityScore;

  $SafetyRating00({
    this.blocked,
    this.category,
    this.overwrittenThreshold,
    this.probability,
    this.probabilityScore,
    this.severity,
    this.severityScore,
  });

  $SafetyRating00.fromJson(core.Map json_)
    : this(
        blocked: json_['blocked'] as core.bool?,
        category: json_['category'] as core.String?,
        overwrittenThreshold: json_['overwrittenThreshold'] as core.String?,
        probability: json_['probability'] as core.String?,
        probabilityScore: (json_['probabilityScore'] as core.num?)?.toDouble(),
        severity: json_['severity'] as core.String?,
        severityScore: (json_['severityScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blocked != null) 'blocked': blocked!,
    if (category != null) 'category': category!,
    if (overwrittenThreshold != null)
      'overwrittenThreshold': overwrittenThreshold!,
    if (probability != null) 'probability': probability!,
    if (probabilityScore != null) 'probabilityScore': probabilityScore!,
    if (severity != null) 'severity': severity!,
    if (severityScore != null) 'severityScore': severityScore!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SafetyRating
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSafetyRating
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSafetyRating
class $SafetyRating01 {
  /// Indicates whether the content was filtered out because of this rating.
  ///
  /// Output only.
  core.bool? blocked;

  /// Harm category.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : The harm category is civic integrity.
  core.String? category;

  /// Harm probability levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_PROBABILITY_UNSPECIFIED" : Harm probability unspecified.
  /// - "NEGLIGIBLE" : Negligible level of harm.
  /// - "LOW" : Low level of harm.
  /// - "MEDIUM" : Medium level of harm.
  /// - "HIGH" : High level of harm.
  core.String? probability;

  /// Harm probability score.
  ///
  /// Output only.
  core.double? probabilityScore;

  /// Harm severity levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_SEVERITY_UNSPECIFIED" : Harm severity unspecified.
  /// - "HARM_SEVERITY_NEGLIGIBLE" : Negligible level of harm severity.
  /// - "HARM_SEVERITY_LOW" : Low level of harm severity.
  /// - "HARM_SEVERITY_MEDIUM" : Medium level of harm severity.
  /// - "HARM_SEVERITY_HIGH" : High level of harm severity.
  core.String? severity;

  /// Harm severity score.
  ///
  /// Output only.
  core.double? severityScore;

  $SafetyRating01({
    this.blocked,
    this.category,
    this.probability,
    this.probabilityScore,
    this.severity,
    this.severityScore,
  });

  $SafetyRating01.fromJson(core.Map json_)
    : this(
        blocked: json_['blocked'] as core.bool?,
        category: json_['category'] as core.String?,
        probability: json_['probability'] as core.String?,
        probabilityScore: (json_['probabilityScore'] as core.num?)?.toDouble(),
        severity: json_['severity'] as core.String?,
        severityScore: (json_['severityScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blocked != null) 'blocked': blocked!,
    if (category != null) 'category': category!,
    if (probability != null) 'probability': probability!,
    if (probabilityScore != null) 'probabilityScore': probabilityScore!,
    if (severity != null) 'severity': severity!,
    if (severityScore != null) 'severityScore': severityScore!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SafetyResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SafetyResult
class $SafetyResult {
  /// Confidence for safety score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for safety score.
  ///
  /// Output only.
  core.String? explanation;

  /// Safety score.
  ///
  /// Output only.
  core.double? score;

  $SafetyResult({this.confidence, this.explanation, this.score});

  $SafetyResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SafetySetting
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SafetySetting
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1SafetySetting
class $SafetySetting {
  /// Harm category.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : Deprecated: Election filter is not
  /// longer supported. The harm category is civic integrity.
  /// - "HARM_CATEGORY_IMAGE_HATE" : The harm category is image hate.
  /// - "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT" : The harm category is image
  /// dangerous content.
  /// - "HARM_CATEGORY_IMAGE_HARASSMENT" : The harm category is image
  /// harassment.
  /// - "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT" : The harm category is image
  /// sexually explicit content.
  core.String? category;

  /// Specify if the threshold is used for probability or severity score.
  ///
  /// If not specified, the threshold is used for probability score.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HARM_BLOCK_METHOD_UNSPECIFIED" : The harm block method is unspecified.
  /// - "SEVERITY" : The harm block method uses both probability and severity
  /// scores.
  /// - "PROBABILITY" : The harm block method uses the probability score.
  core.String? method;

  /// The harm block threshold.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_BLOCK_THRESHOLD_UNSPECIFIED" : Unspecified harm block threshold.
  /// - "BLOCK_LOW_AND_ABOVE" : Block low threshold and above (i.e. block more).
  /// - "BLOCK_MEDIUM_AND_ABOVE" : Block medium threshold and above.
  /// - "BLOCK_ONLY_HIGH" : Block only high threshold (i.e. block less).
  /// - "BLOCK_NONE" : Block none.
  /// - "OFF" : Turn off the safety filter.
  core.String? threshold;

  $SafetySetting({this.category, this.method, this.threshold});

  $SafetySetting.fromJson(core.Map json_)
    : this(
        category: json_['category'] as core.String?,
        method: json_['method'] as core.String?,
        threshold: json_['threshold'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (method != null) 'method': method!,
    if (threshold != null) 'threshold': threshold!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SafetySettingsPhrase
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SafetySettingsPhrase
class $SafetySettingsPhrase {
  /// Language code of the phrase.
  ///
  /// Required.
  core.String? languageCode;

  /// Text input which can be used for prompt or banned phrases.
  ///
  /// Required.
  core.String? text;

  $SafetySettingsPhrase({this.languageCode, this.text});

  $SafetySettingsPhrase.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SafetySettingsPromptSecuritySettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SafetySettingsPromptSecuritySettings
class $SafetySettingsPromptSecuritySettings {
  /// Enable prompt security checks.
  ///
  /// Optional.
  core.bool? enablePromptSecurity;

  $SafetySettingsPromptSecuritySettings({this.enablePromptSecurity});

  $SafetySettingsPromptSecuritySettings.fromJson(core.Map json_)
    : this(enablePromptSecurity: json_['enablePromptSecurity'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enablePromptSecurity != null)
      'enablePromptSecurity': enablePromptSecurity!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : SamlIdpConfig
/// - cloudidentity:v1beta1 : SamlIdpConfig
class $SamlIdpConfig {
  /// The **Change Password URL** of the identity provider.
  ///
  /// Users will be sent to this URL when changing their passwords at
  /// `myaccount.google.com`. This takes precedence over the change password URL
  /// configured at customer-level. Must use `HTTPS`.
  core.String? changePasswordUri;

  /// The SAML **Entity ID** of the identity provider.
  ///
  /// Required.
  core.String? entityId;

  /// The **Logout Redirect URL** (sign-out page URL) of the identity provider.
  ///
  /// When a user clicks the sign-out link on a Google page, they will be
  /// redirected to this URL. This is a pure redirect with no attached SAML
  /// `LogoutRequest` i.e. SAML single logout is not supported. Must use
  /// `HTTPS`.
  core.String? logoutRedirectUri;

  /// The `SingleSignOnService` endpoint location (sign-in page URL) of the
  /// identity provider.
  ///
  /// This is the URL where the `AuthnRequest` will be sent. Must use `HTTPS`.
  /// Assumed to accept the `HTTP-Redirect` binding.
  ///
  /// Required.
  core.String? singleSignOnServiceUri;

  $SamlIdpConfig({
    this.changePasswordUri,
    this.entityId,
    this.logoutRedirectUri,
    this.singleSignOnServiceUri,
  });

  $SamlIdpConfig.fromJson(core.Map json_)
    : this(
        changePasswordUri: json_['changePasswordUri'] as core.String?,
        entityId: json_['entityId'] as core.String?,
        logoutRedirectUri: json_['logoutRedirectUri'] as core.String?,
        singleSignOnServiceUri: json_['singleSignOnServiceUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (changePasswordUri != null) 'changePasswordUri': changePasswordUri!,
    if (entityId != null) 'entityId': entityId!,
    if (logoutRedirectUri != null) 'logoutRedirectUri': logoutRedirectUri!,
    if (singleSignOnServiceUri != null)
      'singleSignOnServiceUri': singleSignOnServiceUri!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : SamlSpConfig
/// - cloudidentity:v1beta1 : SamlSpConfig
class $SamlSpConfig {
  /// The SAML **Assertion Consumer Service (ACS) URL** to be used for the
  /// IDP-initiated login.
  ///
  /// Assumed to accept response messages via the `HTTP-POST` binding.
  ///
  /// Output only.
  core.String? assertionConsumerServiceUri;

  /// The SAML **Entity ID** for this service provider.
  ///
  /// Output only.
  core.String? entityId;

  $SamlSpConfig({this.assertionConsumerServiceUri, this.entityId});

  $SamlSpConfig.fromJson(core.Map json_)
    : this(
        assertionConsumerServiceUri:
            json_['assertionConsumerServiceUri'] as core.String?,
        entityId: json_['entityId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assertionConsumerServiceUri != null)
      'assertionConsumerServiceUri': assertionConsumerServiceUri!,
    if (entityId != null) 'entityId': entityId!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : SamlSsoInfo
/// - cloudidentity:v1beta1 : SamlSsoInfo
class $SamlSsoInfo {
  /// Name of the `InboundSamlSsoProfile` to use.
  ///
  /// Must be of the form `inboundSamlSsoProfiles/{inbound_saml_sso_profile}`.
  ///
  /// Required.
  core.String? inboundSamlSsoProfile;

  $SamlSsoInfo({this.inboundSamlSsoProfile});

  $SamlSsoInfo.fromJson(core.Map json_)
    : this(
        inboundSamlSsoProfile: json_['inboundSamlSsoProfile'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inboundSamlSsoProfile != null)
      'inboundSamlSsoProfile': inboundSamlSsoProfile!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SampleConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SampleConfig
class $SampleConfig {
  /// The percentage of data needed to be labeled in each following batch
  /// (except the first batch).
  core.int? followingBatchSamplePercentage;

  /// The percentage of data needed to be labeled in the first batch.
  core.int? initialBatchSamplePercentage;

  /// Field to choose sampling strategy.
  ///
  /// Sampling strategy will decide which data should be selected for human
  /// labeling in every batch.
  /// Possible string values are:
  /// - "SAMPLE_STRATEGY_UNSPECIFIED" : Default will be treated as UNCERTAINTY.
  /// - "UNCERTAINTY" : Sample the most uncertain data to label.
  core.String? sampleStrategy;

  $SampleConfig({
    this.followingBatchSamplePercentage,
    this.initialBatchSamplePercentage,
    this.sampleStrategy,
  });

  $SampleConfig.fromJson(core.Map json_)
    : this(
        followingBatchSamplePercentage:
            json_['followingBatchSamplePercentage'] as core.int?,
        initialBatchSamplePercentage:
            json_['initialBatchSamplePercentage'] as core.int?,
        sampleStrategy: json_['sampleStrategy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (followingBatchSamplePercentage != null)
      'followingBatchSamplePercentage': followingBatchSamplePercentage!,
    if (initialBatchSamplePercentage != null)
      'initialBatchSamplePercentage': initialBatchSamplePercentage!,
    if (sampleStrategy != null) 'sampleStrategy': sampleStrategy!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntryTarget
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSampleQueryQueryEntryTarget
class $SampleQueryQueryEntryTarget {
  /// Expected page numbers of the target.
  ///
  /// Each page number must be non negative.
  core.List<core.int>? pageNumbers;

  /// Relevance score of the target.
  core.double? score;

  /// Expected uri of the target.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 2048
  /// characters. Example of valid uris: `https://example.com/abc`,
  /// `gcs://example/example.pdf`.
  core.String? uri;

  $SampleQueryQueryEntryTarget({this.pageNumbers, this.score, this.uri});

  $SampleQueryQueryEntryTarget.fromJson(core.Map json_)
    : this(
        pageNumbers:
            (json_['pageNumbers'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        score: (json_['score'] as core.num?)?.toDouble(),
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageNumbers != null) 'pageNumbers': pageNumbers!,
    if (score != null) 'score': score!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSampleQuerySet
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSampleQuerySet
class $SampleQuerySet {
  /// Timestamp the SampleQuerySet was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the SampleQuerySet.
  core.String? description;

  /// The sample query set display name.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 128
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Identifier.
  ///
  /// The full resource name of the SampleQuerySet, in the format of
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  core.String? name;

  $SampleQuerySet({
    this.createTime,
    this.description,
    this.displayName,
    this.name,
  });

  $SampleQuerySet.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SampledShapleyAttribution
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SampledShapleyAttribution
class $SampledShapleyAttribution {
  /// The number of feature permutations to consider when approximating the
  /// Shapley values.
  ///
  /// Valid range of its value is \[1, 50\], inclusively.
  ///
  /// Required.
  core.int? pathCount;

  $SampledShapleyAttribution({this.pathCount});

  $SampledShapleyAttribution.fromJson(core.Map json_)
    : this(pathCount: json_['pathCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (pathCount != null) 'pathCount': pathCount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SamplingStrategyRandomSampleConfig
class $SamplingStrategyRandomSampleConfig {
  /// Sample rate (0, 1\]
  core.double? sampleRate;

  $SamplingStrategyRandomSampleConfig({this.sampleRate});

  $SamplingStrategyRandomSampleConfig.fromJson(core.Map json_)
    : this(sampleRate: (json_['sampleRate'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (sampleRate != null) 'sampleRate': sampleRate!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalAssignment
/// - sasportal:v1alpha1 : SasPortalAssignment
class $SasPortalAssignment {
  /// The identities the role is assigned to.
  ///
  /// It can have the following values: * `{user_email}`: An email address that
  /// represents a specific Google account. For example: `alice@gmail.com`. *
  /// `{group_email}`: An email address that represents a Google group. For
  /// example, `viewers@gmail.com`.
  core.List<core.String>? members;

  /// Role that is assigned to `members`.
  ///
  /// Required.
  core.String? role;

  $SasPortalAssignment({this.members, this.role});

  $SasPortalAssignment.fromJson(core.Map json_)
    : this(
        members:
            (json_['members'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        role: json_['role'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (members != null) 'members': members!,
    if (role != null) 'role': role!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalCreateSignedDeviceRequest
/// - sasportal:v1alpha1 : SasPortalCreateSignedDeviceRequest
class $SasPortalCreateSignedDeviceRequest {
  /// JSON Web Token signed using a CPI private key.
  ///
  /// Payload must be the JSON encoding of the device. The user_id field must be
  /// set.
  ///
  /// Required.
  core.String? encodedDevice;
  core.List<core.int> get encodedDeviceAsBytes =>
      convert.base64.decode(encodedDevice!);

  set encodedDeviceAsBytes(core.List<core.int> bytes_) {
    encodedDevice = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Unique installer id (CPI ID) from the Certified Professional Installers
  /// database.
  ///
  /// Required.
  core.String? installerId;

  $SasPortalCreateSignedDeviceRequest({this.encodedDevice, this.installerId});

  $SasPortalCreateSignedDeviceRequest.fromJson(core.Map json_)
    : this(
        encodedDevice: json_['encodedDevice'] as core.String?,
        installerId: json_['installerId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encodedDevice != null) 'encodedDevice': encodedDevice!,
    if (installerId != null) 'installerId': installerId!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalCustomer
/// - sasportal:v1alpha1 : SasPortalCustomer
class $SasPortalCustomer {
  /// Name of the organization that the customer entity represents.
  ///
  /// Required.
  core.String? displayName;

  /// Resource name of the customer.
  ///
  /// Output only.
  core.String? name;

  /// User IDs used by the devices belonging to this customer.
  core.List<core.String>? sasUserIds;

  $SasPortalCustomer({this.displayName, this.name, this.sasUserIds});

  $SasPortalCustomer.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        sasUserIds:
            (json_['sasUserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (sasUserIds != null) 'sasUserIds': sasUserIds!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalDeployment
/// - sasportal:v1alpha1 : SasPortalDeployment
class $SasPortalDeployment {
  /// The deployment's display name.
  core.String? displayName;

  /// The FCC Registration Numbers (FRNs) copied from its direct parent.
  ///
  /// Output only.
  core.List<core.String>? frns;

  /// Resource name.
  ///
  /// Output only.
  core.String? name;

  /// User ID used by the devices belonging to this deployment.
  ///
  /// Each deployment should be associated with one unique user ID.
  core.List<core.String>? sasUserIds;

  $SasPortalDeployment({
    this.displayName,
    this.frns,
    this.name,
    this.sasUserIds,
  });

  $SasPortalDeployment.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        frns:
            (json_['frns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        sasUserIds:
            (json_['sasUserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (frns != null) 'frns': frns!,
    if (name != null) 'name': name!,
    if (sasUserIds != null) 'sasUserIds': sasUserIds!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalDeviceAirInterface
/// - sasportal:v1alpha1 : SasPortalDeviceAirInterface
class $SasPortalDeviceAirInterface {
  /// Conditional.
  ///
  /// This field specifies the radio access technology that is used for the
  /// CBSD.
  /// Possible string values are:
  /// - "RADIO_TECHNOLOGY_UNSPECIFIED"
  /// - "E_UTRA"
  /// - "CAMBIUM_NETWORKS"
  /// - "FOUR_G_BBW_SAA_1"
  /// - "NR"
  /// - "DOODLE_CBRS"
  /// - "CW"
  /// - "REDLINE"
  /// - "TARANA_WIRELESS"
  /// - "FAROS"
  core.String? radioTechnology;

  /// This field is related to the `radioTechnology` and provides the air
  /// interface specification that the CBSD is compliant with at the time of
  /// registration.
  ///
  /// Optional.
  core.String? supportedSpec;

  $SasPortalDeviceAirInterface({this.radioTechnology, this.supportedSpec});

  $SasPortalDeviceAirInterface.fromJson(core.Map json_)
    : this(
        radioTechnology: json_['radioTechnology'] as core.String?,
        supportedSpec: json_['supportedSpec'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (radioTechnology != null) 'radioTechnology': radioTechnology!,
    if (supportedSpec != null) 'supportedSpec': supportedSpec!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalDeviceModel
/// - sasportal:v1alpha1 : SasPortalDeviceModel
class $SasPortalDeviceModel {
  /// The firmware version of the device.
  core.String? firmwareVersion;

  /// The hardware version of the device.
  core.String? hardwareVersion;

  /// The name of the device model.
  core.String? name;

  /// The software version of the device.
  core.String? softwareVersion;

  /// The name of the device vendor.
  core.String? vendor;

  $SasPortalDeviceModel({
    this.firmwareVersion,
    this.hardwareVersion,
    this.name,
    this.softwareVersion,
    this.vendor,
  });

  $SasPortalDeviceModel.fromJson(core.Map json_)
    : this(
        firmwareVersion: json_['firmwareVersion'] as core.String?,
        hardwareVersion: json_['hardwareVersion'] as core.String?,
        name: json_['name'] as core.String?,
        softwareVersion: json_['softwareVersion'] as core.String?,
        vendor: json_['vendor'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (firmwareVersion != null) 'firmwareVersion': firmwareVersion!,
    if (hardwareVersion != null) 'hardwareVersion': hardwareVersion!,
    if (name != null) 'name': name!,
    if (softwareVersion != null) 'softwareVersion': softwareVersion!,
    if (vendor != null) 'vendor': vendor!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalFrequencyRange
/// - sasportal:v1alpha1 : SasPortalFrequencyRange
class $SasPortalFrequencyRange {
  /// The highest frequency of the frequency range in MHz.
  core.double? highFrequencyMhz;

  /// The lowest frequency of the frequency range in MHz.
  core.double? lowFrequencyMhz;

  $SasPortalFrequencyRange({this.highFrequencyMhz, this.lowFrequencyMhz});

  $SasPortalFrequencyRange.fromJson(core.Map json_)
    : this(
        highFrequencyMhz: (json_['highFrequencyMhz'] as core.num?)?.toDouble(),
        lowFrequencyMhz: (json_['lowFrequencyMhz'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (highFrequencyMhz != null) 'highFrequencyMhz': highFrequencyMhz!,
    if (lowFrequencyMhz != null) 'lowFrequencyMhz': lowFrequencyMhz!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalGenerateSecretResponse
/// - sasportal:v1alpha1 : SasPortalGenerateSecretResponse
class $SasPortalGenerateSecretResponse {
  /// The secret generated by the string and used by ValidateInstaller.
  core.String? secret;

  $SasPortalGenerateSecretResponse({this.secret});

  $SasPortalGenerateSecretResponse.fromJson(core.Map json_)
    : this(secret: json_['secret'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (secret != null) 'secret': secret!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalGetPolicyRequest
/// - sasportal:v1alpha1 : SasPortalGetPolicyRequest
class $SasPortalGetPolicyRequest {
  /// The resource for which the policy is being requested.
  ///
  /// Required.
  core.String? resource;

  $SasPortalGetPolicyRequest({this.resource});

  $SasPortalGetPolicyRequest.fromJson(core.Map json_)
    : this(resource: json_['resource'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalInstallationParams
/// - sasportal:v1alpha1 : SasPortalInstallationParams
class $SasPortalInstallationParams {
  /// Boresight direction of the horizontal plane of the antenna in degrees with
  /// respect to true north.
  ///
  /// The value of this parameter is an integer with a value between 0 and 359
  /// inclusive. A value of 0 degrees means true north; a value of 90 degrees
  /// means east. This parameter is optional for Category A devices and
  /// conditional for Category B devices.
  core.int? antennaAzimuth;

  /// 3-dB antenna beamwidth of the antenna in the horizontal-plane in degrees.
  ///
  /// This parameter is an unsigned integer having a value between 0 and 360
  /// (degrees) inclusive; it is optional for Category A devices and conditional
  /// for Category B devices.
  core.int? antennaBeamwidth;

  /// Antenna downtilt in degrees and is an integer with a value between -90 and
  /// +90 inclusive; a negative value means the antenna is tilted up (above
  /// horizontal).
  ///
  /// This parameter is optional for Category A devices and conditional for
  /// Category B devices.
  core.int? antennaDowntilt;

  /// Peak antenna gain in dBi.
  ///
  /// This parameter is a double with a value between -127 and +128 (dBi)
  /// inclusive. Part of Release 2 to support floating-point value
  core.double? antennaGain;

  /// If an external antenna is used, the antenna model is optionally provided
  /// in this field.
  ///
  /// The string has a maximum length of 128 octets.
  core.String? antennaModel;

  /// If present, this parameter specifies whether the CBSD is a CPE-CBSD or
  /// not.
  core.bool? cpeCbsdIndication;

  /// This parameter is the maximum device EIRP in units of dBm/10MHz and is an
  /// integer with a value between -127 and +47 (dBm/10 MHz) inclusive.
  ///
  /// If not included, SAS interprets it as maximum allowable EIRP in units of
  /// dBm/10MHz for device category.
  core.int? eirpCapability;

  /// Device antenna height in meters.
  ///
  /// When the `heightType` parameter value is "AGL", the antenna height should
  /// be given relative to ground level. When the `heightType` parameter value
  /// is "AMSL", it is given with respect to WGS84 datum.
  core.double? height;

  /// Specifies how the height is measured.
  /// Possible string values are:
  /// - "HEIGHT_TYPE_UNSPECIFIED" : Unspecified height type.
  /// - "HEIGHT_TYPE_AGL" : AGL height is measured relative to the ground level.
  /// - "HEIGHT_TYPE_AMSL" : AMSL height is measured relative to the mean sea
  /// level.
  core.String? heightType;

  /// A positive number in meters to indicate accuracy of the device antenna
  /// horizontal location.
  ///
  /// This optional parameter should only be present if its value is less than
  /// the FCC requirement of 50 meters.
  core.double? horizontalAccuracy;

  /// Whether the device antenna is indoor or not.
  ///
  /// `true`: indoor. `false`: outdoor.
  core.bool? indoorDeployment;

  /// Latitude of the device antenna location in degrees relative to the WGS 84
  /// datum.
  ///
  /// The allowed range is from -90.000000 to +90.000000. Positive values
  /// represent latitudes north of the equator; negative values south of the
  /// equator.
  core.double? latitude;

  /// Longitude of the device antenna location in degrees relative to the WGS 84
  /// datum.
  ///
  /// The allowed range is from -180.000000 to +180.000000. Positive values
  /// represent longitudes east of the prime meridian; negative values west of
  /// the prime meridian.
  core.double? longitude;

  /// A positive number in meters to indicate accuracy of the device antenna
  /// vertical location.
  ///
  /// This optional parameter should only be present if its value is less than
  /// the FCC requirement of 3 meters.
  core.double? verticalAccuracy;

  $SasPortalInstallationParams({
    this.antennaAzimuth,
    this.antennaBeamwidth,
    this.antennaDowntilt,
    this.antennaGain,
    this.antennaModel,
    this.cpeCbsdIndication,
    this.eirpCapability,
    this.height,
    this.heightType,
    this.horizontalAccuracy,
    this.indoorDeployment,
    this.latitude,
    this.longitude,
    this.verticalAccuracy,
  });

  $SasPortalInstallationParams.fromJson(core.Map json_)
    : this(
        antennaAzimuth: json_['antennaAzimuth'] as core.int?,
        antennaBeamwidth: json_['antennaBeamwidth'] as core.int?,
        antennaDowntilt: json_['antennaDowntilt'] as core.int?,
        antennaGain: (json_['antennaGain'] as core.num?)?.toDouble(),
        antennaModel: json_['antennaModel'] as core.String?,
        cpeCbsdIndication: json_['cpeCbsdIndication'] as core.bool?,
        eirpCapability: json_['eirpCapability'] as core.int?,
        height: (json_['height'] as core.num?)?.toDouble(),
        heightType: json_['heightType'] as core.String?,
        horizontalAccuracy:
            (json_['horizontalAccuracy'] as core.num?)?.toDouble(),
        indoorDeployment: json_['indoorDeployment'] as core.bool?,
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
        verticalAccuracy: (json_['verticalAccuracy'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (antennaAzimuth != null) 'antennaAzimuth': antennaAzimuth!,
    if (antennaBeamwidth != null) 'antennaBeamwidth': antennaBeamwidth!,
    if (antennaDowntilt != null) 'antennaDowntilt': antennaDowntilt!,
    if (antennaGain != null) 'antennaGain': antennaGain!,
    if (antennaModel != null) 'antennaModel': antennaModel!,
    if (cpeCbsdIndication != null) 'cpeCbsdIndication': cpeCbsdIndication!,
    if (eirpCapability != null) 'eirpCapability': eirpCapability!,
    if (height != null) 'height': height!,
    if (heightType != null) 'heightType': heightType!,
    if (horizontalAccuracy != null) 'horizontalAccuracy': horizontalAccuracy!,
    if (indoorDeployment != null) 'indoorDeployment': indoorDeployment!,
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
    if (verticalAccuracy != null) 'verticalAccuracy': verticalAccuracy!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalMigrateOrganizationRequest
/// - sasportal:v1alpha1 : SasPortalMigrateOrganizationRequest
class $SasPortalMigrateOrganizationRequest {
  /// Id of the SAS organization to be migrated.
  ///
  /// Required.
  core.String? organizationId;

  $SasPortalMigrateOrganizationRequest({this.organizationId});

  $SasPortalMigrateOrganizationRequest.fromJson(core.Map json_)
    : this(organizationId: json_['organizationId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (organizationId != null) 'organizationId': organizationId!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalMoveDeploymentRequest
/// - sasportal:v1alpha1 : SasPortalMoveDeploymentRequest
class $SasPortalMoveDeploymentRequest {
  /// The name of the new parent resource node or customer to reparent the
  /// deployment under.
  ///
  /// Required.
  core.String? destination;

  $SasPortalMoveDeploymentRequest({this.destination});

  $SasPortalMoveDeploymentRequest.fromJson(core.Map json_)
    : this(destination: json_['destination'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (destination != null) 'destination': destination!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalMoveDeviceRequest
/// - sasportal:v1alpha1 : SasPortalMoveDeviceRequest
class $SasPortalMoveDeviceRequest {
  /// The name of the new parent resource node or customer to reparent the
  /// device under.
  ///
  /// Required.
  core.String? destination;

  $SasPortalMoveDeviceRequest({this.destination});

  $SasPortalMoveDeviceRequest.fromJson(core.Map json_)
    : this(destination: json_['destination'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (destination != null) 'destination': destination!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalMoveNodeRequest
/// - sasportal:v1alpha1 : SasPortalMoveNodeRequest
class $SasPortalMoveNodeRequest {
  /// The name of the new parent resource node or customer to reparent the node
  /// under.
  ///
  /// Required.
  core.String? destination;

  $SasPortalMoveNodeRequest({this.destination});

  $SasPortalMoveNodeRequest.fromJson(core.Map json_)
    : this(destination: json_['destination'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (destination != null) 'destination': destination!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalNode
/// - sasportal:v1alpha1 : SasPortalNode
class $SasPortalNode {
  /// The node's display name.
  core.String? displayName;

  /// Resource name.
  ///
  /// Output only.
  core.String? name;

  /// User ids used by the devices belonging to this node.
  core.List<core.String>? sasUserIds;

  $SasPortalNode({this.displayName, this.name, this.sasUserIds});

  $SasPortalNode.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        sasUserIds:
            (json_['sasUserIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (sasUserIds != null) 'sasUserIds': sasUserIds!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalNrqzValidation
/// - sasportal:v1alpha1 : SasPortalNrqzValidation
class $SasPortalNrqzValidation {
  /// Validation case ID.
  core.String? caseId;

  /// CPI who signed the validation.
  core.String? cpiId;

  /// Device latitude that's associated with the validation.
  core.double? latitude;

  /// Device longitude that's associated with the validation.
  core.double? longitude;

  /// State of the NRQZ validation info.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state.
  /// - "DRAFT" : Draft state.
  /// - "FINAL" : Final state.
  core.String? state;

  $SasPortalNrqzValidation({
    this.caseId,
    this.cpiId,
    this.latitude,
    this.longitude,
    this.state,
  });

  $SasPortalNrqzValidation.fromJson(core.Map json_)
    : this(
        caseId: json_['caseId'] as core.String?,
        cpiId: json_['cpiId'] as core.String?,
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseId != null) 'caseId': caseId!,
    if (cpiId != null) 'cpiId': cpiId!,
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalOrganization
/// - sasportal:v1alpha1 : SasPortalOrganization
class $SasPortalOrganization {
  /// Name of organization
  core.String? displayName;

  /// Id of organization
  core.String? id;

  $SasPortalOrganization({this.displayName, this.id});

  $SasPortalOrganization.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalProvisionDeploymentRequest
/// - sasportal:v1alpha1 : SasPortalProvisionDeploymentRequest
class $SasPortalProvisionDeploymentRequest {
  /// If this field is set, and a new SAS Portal Deployment needs to be created,
  /// its display name will be set to the value of this field.
  ///
  /// Optional.
  core.String? newDeploymentDisplayName;

  /// If this field is set, and a new SAS Portal Organization needs to be
  /// created, its display name will be set to the value of this field.
  ///
  /// Optional.
  core.String? newOrganizationDisplayName;

  /// If this field is set then a new deployment will be created under the
  /// organization specified by this id.
  ///
  /// Optional.
  core.String? organizationId;

  $SasPortalProvisionDeploymentRequest({
    this.newDeploymentDisplayName,
    this.newOrganizationDisplayName,
    this.organizationId,
  });

  $SasPortalProvisionDeploymentRequest.fromJson(core.Map json_)
    : this(
        newDeploymentDisplayName:
            json_['newDeploymentDisplayName'] as core.String?,
        newOrganizationDisplayName:
            json_['newOrganizationDisplayName'] as core.String?,
        organizationId: json_['organizationId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (newDeploymentDisplayName != null)
      'newDeploymentDisplayName': newDeploymentDisplayName!,
    if (newOrganizationDisplayName != null)
      'newOrganizationDisplayName': newOrganizationDisplayName!,
    if (organizationId != null) 'organizationId': organizationId!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalProvisionDeploymentResponse
/// - sasportal:v1alpha1 : SasPortalProvisionDeploymentResponse
class $SasPortalProvisionDeploymentResponse {
  /// Optional error message if the provisioning request is not successful.
  ///
  /// Optional.
  core.String? errorMessage;

  $SasPortalProvisionDeploymentResponse({this.errorMessage});

  $SasPortalProvisionDeploymentResponse.fromJson(core.Map json_)
    : this(errorMessage: json_['errorMessage'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalSetupSasAnalyticsRequest
/// - sasportal:v1alpha1 : SasPortalSetupSasAnalyticsRequest
class $SasPortalSetupSasAnalyticsRequest {
  /// User id to setup analytics for, if not provided the user id associated
  /// with the project is used.
  ///
  /// optional
  ///
  /// Optional.
  core.String? userId;

  $SasPortalSetupSasAnalyticsRequest({this.userId});

  $SasPortalSetupSasAnalyticsRequest.fromJson(core.Map json_)
    : this(userId: json_['userId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalTestPermissionsRequest
/// - sasportal:v1alpha1 : SasPortalTestPermissionsRequest
class $SasPortalTestPermissionsRequest {
  /// The set of permissions to check for the `resource`.
  core.List<core.String>? permissions;

  /// The resource for which the permissions are being requested.
  ///
  /// Required.
  core.String? resource;

  $SasPortalTestPermissionsRequest({this.permissions, this.resource});

  $SasPortalTestPermissionsRequest.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        resource: json_['resource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
    if (resource != null) 'resource': resource!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalTestPermissionsResponse
/// - sasportal:v1alpha1 : SasPortalTestPermissionsResponse
class $SasPortalTestPermissionsResponse {
  /// A set of permissions that the caller is allowed.
  core.List<core.String>? permissions;

  $SasPortalTestPermissionsResponse({this.permissions});

  $SasPortalTestPermissionsResponse.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalUpdateSignedDeviceRequest
/// - sasportal:v1alpha1 : SasPortalUpdateSignedDeviceRequest
class $SasPortalUpdateSignedDeviceRequest {
  /// The JSON Web Token signed using a CPI private key.
  ///
  /// Payload must be the JSON encoding of the device. The user_id field must be
  /// set.
  ///
  /// Required.
  core.String? encodedDevice;
  core.List<core.int> get encodedDeviceAsBytes =>
      convert.base64.decode(encodedDevice!);

  set encodedDeviceAsBytes(core.List<core.int> bytes_) {
    encodedDevice = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Unique installer ID (CPI ID) from the Certified Professional Installers
  /// database.
  ///
  /// Required.
  core.String? installerId;

  $SasPortalUpdateSignedDeviceRequest({this.encodedDevice, this.installerId});

  $SasPortalUpdateSignedDeviceRequest.fromJson(core.Map json_)
    : this(
        encodedDevice: json_['encodedDevice'] as core.String?,
        installerId: json_['installerId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encodedDevice != null) 'encodedDevice': encodedDevice!,
    if (installerId != null) 'installerId': installerId!,
  };
}

/// Used by:
///
/// - prod_tt_sasportal:v1alpha1 : SasPortalValidateInstallerRequest
/// - sasportal:v1alpha1 : SasPortalValidateInstallerRequest
class $SasPortalValidateInstallerRequest {
  /// JSON Web Token signed using a CPI private key.
  ///
  /// Payload must include a "secret" claim whose value is the secret.
  ///
  /// Required.
  core.String? encodedSecret;

  /// Unique installer id (CPI ID) from the Certified Professional Installers
  /// database.
  ///
  /// Required.
  core.String? installerId;

  /// Secret returned by the GenerateSecret.
  ///
  /// Required.
  core.String? secret;

  $SasPortalValidateInstallerRequest({
    this.encodedSecret,
    this.installerId,
    this.secret,
  });

  $SasPortalValidateInstallerRequest.fromJson(core.Map json_)
    : this(
        encodedSecret: json_['encodedSecret'] as core.String?,
        installerId: json_['installerId'] as core.String?,
        secret: json_['secret'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encodedSecret != null) 'encodedSecret': encodedSecret!,
    if (installerId != null) 'installerId': installerId!,
    if (secret != null) 'secret': secret!,
  };
}

/// Used by:
///
/// - composer:v1 : SaveSnapshotRequest
/// - composer:v1beta1 : SaveSnapshotRequest
class $SaveSnapshotRequest {
  /// Location in a Cloud Storage where the snapshot is going to be stored,
  /// e.g.: "gs://my-bucket/snapshots".
  core.String? snapshotLocation;

  $SaveSnapshotRequest({this.snapshotLocation});

  $SaveSnapshotRequest.fromJson(core.Map json_)
    : this(snapshotLocation: json_['snapshotLocation'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (snapshotLocation != null) 'snapshotLocation': snapshotLocation!,
  };
}

/// Used by:
///
/// - compute:alpha : SavedDisk
/// - compute:beta : SavedDisk
/// - compute:v1 : SavedDisk
class $SavedDisk {
  /// The architecture of the attached disk.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ARCHITECTURE_UNSPECIFIED" : Default value indicating Architecture is
  /// not set.
  /// - "ARM64" : Machines with architecture ARM64
  /// - "X86_64" : Machines with architecture X86_64
  core.String? architecture;

  /// Type of the resource.
  ///
  /// Always compute#savedDisk for attached disks.
  ///
  /// Output only.
  core.String? kind;

  /// Specifies a URL of the disk attached to the source instance.
  core.String? sourceDisk;

  /// Size of the individual disk snapshot used by this machine image.
  ///
  /// Output only.
  core.String? storageBytes;

  /// An indicator whether storageBytes is in a stable state or it is being
  /// adjusted as a result of shared storage reallocation.
  ///
  /// This status can either be UPDATING, meaning the size of the snapshot is
  /// being updated, or UP_TO_DATE, meaning the size of the snapshot is
  /// up-to-date.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String? storageBytesStatus;

  $SavedDisk({
    this.architecture,
    this.kind,
    this.sourceDisk,
    this.storageBytes,
    this.storageBytesStatus,
  });

  $SavedDisk.fromJson(core.Map json_)
    : this(
        architecture: json_['architecture'] as core.String?,
        kind: json_['kind'] as core.String?,
        sourceDisk: json_['sourceDisk'] as core.String?,
        storageBytes: json_['storageBytes'] as core.String?,
        storageBytesStatus: json_['storageBytesStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (architecture != null) 'architecture': architecture!,
    if (kind != null) 'kind': kind!,
    if (sourceDisk != null) 'sourceDisk': sourceDisk!,
    if (storageBytes != null) 'storageBytes': storageBytes!,
    if (storageBytesStatus != null) 'storageBytesStatus': storageBytesStatus!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SavedQuery
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SavedQuery
class $SavedQuery {
  /// Filters on the Annotations in the dataset.
  ///
  /// Output only.
  core.String? annotationFilter;

  /// Number of AnnotationSpecs in the context of the SavedQuery.
  ///
  /// Output only.
  core.int? annotationSpecCount;

  /// Timestamp when this SavedQuery was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the SavedQuery.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write update.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Some additional information about the SavedQuery.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Resource name of the SavedQuery.
  ///
  /// Output only.
  core.String? name;

  /// Problem type of the SavedQuery.
  ///
  /// Allowed values: * IMAGE_CLASSIFICATION_SINGLE_LABEL *
  /// IMAGE_CLASSIFICATION_MULTI_LABEL * IMAGE_BOUNDING_POLY *
  /// IMAGE_BOUNDING_BOX * TEXT_CLASSIFICATION_SINGLE_LABEL *
  /// TEXT_CLASSIFICATION_MULTI_LABEL * TEXT_EXTRACTION * TEXT_SENTIMENT *
  /// VIDEO_CLASSIFICATION * VIDEO_OBJECT_TRACKING
  ///
  /// Required.
  core.String? problemType;

  /// If the Annotations belonging to the SavedQuery can be used for AutoML
  /// training.
  ///
  /// Output only.
  core.bool? supportAutomlTraining;

  /// Timestamp when SavedQuery was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $SavedQuery({
    this.annotationFilter,
    this.annotationSpecCount,
    this.createTime,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.problemType,
    this.supportAutomlTraining,
    this.updateTime,
  });

  $SavedQuery.fromJson(core.Map json_)
    : this(
        annotationFilter: json_['annotationFilter'] as core.String?,
        annotationSpecCount: json_['annotationSpecCount'] as core.int?,
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        metadata: json_['metadata'],
        name: json_['name'] as core.String?,
        problemType: json_['problemType'] as core.String?,
        supportAutomlTraining: json_['supportAutomlTraining'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationFilter != null) 'annotationFilter': annotationFilter!,
    if (annotationSpecCount != null)
      'annotationSpecCount': annotationSpecCount!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (problemType != null) 'problemType': problemType!,
    if (supportAutomlTraining != null)
      'supportAutomlTraining': supportAutomlTraining!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : SbomReferenceIntotoPredicate
/// - containeranalysis:v1alpha1 : SbomReferenceIntotoPredicate
/// - containeranalysis:v1beta1 : SbomReferenceIntotoPredicate
/// - ondemandscanning:v1 : SbomReferenceIntotoPredicate
/// - ondemandscanning:v1beta1 : SbomReferenceIntotoPredicate
class $SbomReferenceIntotoPredicate {
  /// A map of algorithm to digest of the contents of the SBOM.
  core.Map<core.String, core.String>? digest;

  /// The location of the SBOM.
  core.String? location;

  /// The mime type of the SBOM.
  core.String? mimeType;

  /// The person or system referring this predicate to the consumer.
  core.String? referrerId;

  $SbomReferenceIntotoPredicate({
    this.digest,
    this.location,
    this.mimeType,
    this.referrerId,
  });

  $SbomReferenceIntotoPredicate.fromJson(core.Map json_)
    : this(
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        location: json_['location'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
        referrerId: json_['referrerId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (location != null) 'location': location!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (referrerId != null) 'referrerId': referrerId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Scalar
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Scalar
class $Scalar {
  /// Value of the point at this step / timestamp.
  core.double? value;

  $Scalar({this.value});

  $Scalar.fromJson(core.Map json_)
    : this(value: (json_['value'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : ScalingScheduleStatus
/// - compute:beta : ScalingScheduleStatus
/// - compute:v1 : ScalingScheduleStatus
class $ScalingScheduleStatus {
  /// The last time the scaling schedule became active.
  ///
  /// Note: this is a timestamp when a schedule actually became active, not when
  /// it was planned to do so. The timestamp is in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStartTime;

  /// The next time the scaling schedule is to become active.
  ///
  /// Note: this is a timestamp when a schedule is planned to run, but the
  /// actual time might be slightly different. The timestamp is in RFC3339 text
  /// format.
  ///
  /// Output only.
  core.String? nextStartTime;

  /// The current state of a scaling schedule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : The current autoscaling recommendation is influenced by this
  /// scaling schedule.
  /// - "DISABLED" : This scaling schedule has been disabled by the user.
  /// - "OBSOLETE" : This scaling schedule will never become active again.
  /// - "READY" : The current autoscaling recommendation is not influenced by
  /// this scaling schedule.
  core.String? state;

  $ScalingScheduleStatus({this.lastStartTime, this.nextStartTime, this.state});

  $ScalingScheduleStatus.fromJson(core.Map json_)
    : this(
        lastStartTime: json_['lastStartTime'] as core.String?,
        nextStartTime: json_['nextStartTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastStartTime != null) 'lastStartTime': lastStartTime!,
    if (nextStartTime != null) 'nextStartTime': nextStartTime!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : Schedule
/// - websecurityscanner:v1alpha : Schedule
/// - websecurityscanner:v1beta : Schedule
class $Schedule {
  /// The duration of time between executions in days.
  ///
  /// Required.
  core.int? intervalDurationDays;

  /// A timestamp indicates when the next run will be scheduled.
  ///
  /// The value is refreshed by the server after each run. If unspecified, it
  /// will default to current server time, which means the scan will be
  /// scheduled to start immediately.
  core.String? scheduleTime;

  $Schedule({this.intervalDurationDays, this.scheduleTime});

  $Schedule.fromJson(core.Map json_)
    : this(
        intervalDurationDays: json_['intervalDurationDays'] as core.int?,
        scheduleTime: json_['scheduleTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (intervalDurationDays != null)
      'intervalDurationDays': intervalDurationDays!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : SchedulePolicy
/// - vmmigration:v1alpha1 : SchedulePolicy
class $SchedulePolicy {
  /// The idle duration between replication stages.
  core.String? idleDuration;

  /// A flag to indicate whether to skip OS adaptation during the replication
  /// sync.
  ///
  /// OS adaptation is a process where the VM's operating system undergoes
  /// changes and adaptations to fully function on Compute Engine.
  core.bool? skipOsAdaptation;

  $SchedulePolicy({this.idleDuration, this.skipOsAdaptation});

  $SchedulePolicy.fromJson(core.Map json_)
    : this(
        idleDuration: json_['idleDuration'] as core.String?,
        skipOsAdaptation: json_['skipOsAdaptation'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idleDuration != null) 'idleDuration': idleDuration!,
    if (skipOsAdaptation != null) 'skipOsAdaptation': skipOsAdaptation!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ScheduleRunResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ScheduleRunResponse
class $ScheduleRunResponse {
  /// The response of the scheduled run.
  core.String? runResponse;

  /// The scheduled run time based on the user-specified schedule.
  core.String? scheduledRunTime;

  $ScheduleRunResponse({this.runResponse, this.scheduledRunTime});

  $ScheduleRunResponse.fromJson(core.Map json_)
    : this(
        runResponse: json_['runResponse'] as core.String?,
        scheduledRunTime: json_['scheduledRunTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (runResponse != null) 'runResponse': runResponse!,
    if (scheduledRunTime != null) 'scheduledRunTime': scheduledRunTime!,
  };
}

/// Used by:
///
/// - composer:v1 : ScheduledSnapshotsConfig
/// - composer:v1beta1 : ScheduledSnapshotsConfig
class $ScheduledSnapshotsConfig {
  /// Whether scheduled snapshots creation is enabled.
  ///
  /// Optional.
  core.bool? enabled;

  /// The cron expression representing the time when snapshots creation
  /// mechanism runs.
  ///
  /// This field is subject to additional validation around frequency of
  /// execution.
  ///
  /// Optional.
  core.String? snapshotCreationSchedule;

  /// The Cloud Storage location for storing automatically created snapshots.
  ///
  /// Optional.
  core.String? snapshotLocation;

  /// Time zone that sets the context to interpret snapshot_creation_schedule.
  ///
  /// Optional.
  core.String? timeZone;

  $ScheduledSnapshotsConfig({
    this.enabled,
    this.snapshotCreationSchedule,
    this.snapshotLocation,
    this.timeZone,
  });

  $ScheduledSnapshotsConfig.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        snapshotCreationSchedule:
            json_['snapshotCreationSchedule'] as core.String?,
        snapshotLocation: json_['snapshotLocation'] as core.String?,
        timeZone: json_['timeZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (snapshotCreationSchedule != null)
      'snapshotCreationSchedule': snapshotCreationSchedule!,
    if (snapshotLocation != null) 'snapshotLocation': snapshotLocation!,
    if (timeZone != null) 'timeZone': timeZone!,
  };
}

/// Used by:
///
/// - composer:v1 : SchedulerResource
/// - composer:v1beta1 : SchedulerResource
class $SchedulerResource {
  /// The number of schedulers.
  ///
  /// Optional.
  core.int? count;

  /// CPU request and limit for a single Airflow scheduler replica.
  ///
  /// Optional.
  core.double? cpu;

  /// Memory (GB) request and limit for a single Airflow scheduler replica.
  ///
  /// Optional.
  core.double? memoryGb;

  /// Storage (GB) request and limit for a single Airflow scheduler replica.
  ///
  /// Optional.
  core.double? storageGb;

  $SchedulerResource({this.count, this.cpu, this.memoryGb, this.storageGb});

  $SchedulerResource.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.int?,
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        memoryGb: (json_['memoryGb'] as core.num?)?.toDouble(),
        storageGb: (json_['storageGb'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (cpu != null) 'cpu': cpu!,
    if (memoryGb != null) 'memoryGb': memoryGb!,
    if (storageGb != null) 'storageGb': storageGb!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Scheduling
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Scheduling
class $Scheduling {
  /// Indicates if the job should retry for internal errors after the job starts
  /// running.
  ///
  /// If true, overrides `Scheduling.restart_job_on_worker_restart` to false.
  ///
  /// Optional.
  core.bool? disableRetries;

  /// This is the maximum duration that a job will wait for the requested
  /// resources to be provisioned if the scheduling strategy is set to
  /// \[Strategy.DWS_FLEX_START\].
  ///
  /// If set to 0, the job will wait indefinitely. The default is 24 hours.
  ///
  /// Optional.
  core.String? maxWaitDuration;

  /// Restarts the entire CustomJob if a worker gets restarted.
  ///
  /// This feature can be used by distributed training jobs that are not
  /// resilient to workers leaving and joining a job.
  ///
  /// Optional.
  core.bool? restartJobOnWorkerRestart;

  /// This determines which type of scheduling strategy to use.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "STRATEGY_UNSPECIFIED" : Strategy will default to STANDARD.
  /// - "ON_DEMAND" : Deprecated. Regular on-demand provisioning strategy.
  /// - "LOW_COST" : Deprecated. Low cost by making potential use of spot
  /// resources.
  /// - "STANDARD" : Standard provisioning strategy uses regular on-demand
  /// resources.
  /// - "SPOT" : Spot provisioning strategy uses spot resources.
  /// - "FLEX_START" : Flex Start strategy uses DWS to queue for resources.
  core.String? strategy;

  /// The maximum job running time.
  ///
  /// The default is 7 days.
  ///
  /// Optional.
  core.String? timeout;

  $Scheduling({
    this.disableRetries,
    this.maxWaitDuration,
    this.restartJobOnWorkerRestart,
    this.strategy,
    this.timeout,
  });

  $Scheduling.fromJson(core.Map json_)
    : this(
        disableRetries: json_['disableRetries'] as core.bool?,
        maxWaitDuration: json_['maxWaitDuration'] as core.String?,
        restartJobOnWorkerRestart:
            json_['restartJobOnWorkerRestart'] as core.bool?,
        strategy: json_['strategy'] as core.String?,
        timeout: json_['timeout'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableRetries != null) 'disableRetries': disableRetries!,
    if (maxWaitDuration != null) 'maxWaitDuration': maxWaitDuration!,
    if (restartJobOnWorkerRestart != null)
      'restartJobOnWorkerRestart': restartJobOnWorkerRestart!,
    if (strategy != null) 'strategy': strategy!,
    if (timeout != null) 'timeout': timeout!,
  };
}

/// Used by:
///
/// - tpu:v1 : SchedulingConfig
/// - tpu:v1alpha1 : SchedulingConfig
class $SchedulingConfig {
  /// Defines whether the node is preemptible.
  core.bool? preemptible;

  /// Whether the node is created under a reservation.
  core.bool? reserved;

  $SchedulingConfig({this.preemptible, this.reserved});

  $SchedulingConfig.fromJson(core.Map json_)
    : this(
        preemptible: json_['preemptible'] as core.bool?,
        reserved: json_['reserved'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (preemptible != null) 'preemptible': preemptible!,
    if (reserved != null) 'reserved': reserved!,
  };
}

/// Used by:
///
/// - compute:alpha : SchedulingNodeAffinity
/// - compute:beta : SchedulingNodeAffinity
/// - compute:v1 : SchedulingNodeAffinity
class $SchedulingNodeAffinity00 {
  /// Corresponds to the label key of Node resource.
  core.String? key;

  /// Defines the operation of node selection.
  ///
  /// Valid operators are IN for affinity and NOT_IN for anti-affinity.
  /// Possible string values are:
  /// - "IN" : Requires Compute Engine to seek for matched nodes.
  /// - "NOT_IN" : Requires Compute Engine to avoid certain nodes.
  /// - "OPERATOR_UNSPECIFIED"
  core.String? operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String>? values;

  $SchedulingNodeAffinity00({this.key, this.operator, this.values});

  $SchedulingNodeAffinity00.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        operator: json_['operator'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (operator != null) 'operator': operator!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : SchedulingNodeAffinity
/// - vmmigration:v1alpha1 : SchedulingNodeAffinity
class $SchedulingNodeAffinity01 {
  /// The label key of Node resource to reference.
  core.String? key;

  /// The operator to use for the node resources specified in the `values`
  /// parameter.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : An unknown, unexpected behavior.
  /// - "IN" : The node resource group should be in these resources affinity.
  /// - "NOT_IN" : The node resource group should not be in these resources
  /// affinity.
  core.String? operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String>? values;

  $SchedulingNodeAffinity01({this.key, this.operator, this.values});

  $SchedulingNodeAffinity01.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        operator: json_['operator'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (operator != null) 'operator': operator!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : SchedulingOnInstanceStopAction
/// - compute:beta : SchedulingOnInstanceStopAction
/// - compute:v1 : SchedulingOnInstanceStopAction
class $SchedulingOnInstanceStopAction {
  /// If true, the contents of any attached Local SSD disks will be discarded
  /// else, the Local SSD data will be preserved when the instance is stopped at
  /// the end of the run duration/termination time.
  core.bool? discardLocalSsd;

  $SchedulingOnInstanceStopAction({this.discardLocalSsd});

  $SchedulingOnInstanceStopAction.fromJson(core.Map json_)
    : this(discardLocalSsd: json_['discardLocalSsd'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (discardLocalSsd != null) 'discardLocalSsd': discardLocalSsd!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Schema
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSchema
class $Schema {
  /// The JSON representation of the schema.
  core.String? jsonSchema;

  /// The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// The structured representation of the schema.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structSchema;

  $Schema({this.jsonSchema, this.name, this.structSchema});

  $Schema.fromJson(core.Map json_)
    : this(
        jsonSchema: json_['jsonSchema'] as core.String?,
        name: json_['name'] as core.String?,
        structSchema:
            json_.containsKey('structSchema')
                ? json_['structSchema'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (jsonSchema != null) 'jsonSchema': jsonSchema!,
    if (name != null) 'name': name!,
    if (structSchema != null) 'structSchema': structSchema!,
  };
}

/// Used by:
///
/// - healthcare:v1 : SchemaSegment
/// - healthcare:v1beta1 : SchemaSegment
class $SchemaSegment {
  /// The maximum number of times this segment can be present in this group.
  ///
  /// 0 or -1 means unbounded.
  core.int? maxOccurs;

  /// The minimum number of times this segment can be present in this group.
  core.int? minOccurs;

  /// The Segment type.
  ///
  /// For example, "PID".
  core.String? type;

  $SchemaSegment({this.maxOccurs, this.minOccurs, this.type});

  $SchemaSegment.fromJson(core.Map json_)
    : this(
        maxOccurs: json_['maxOccurs'] as core.int?,
        minOccurs: json_['minOccurs'] as core.int?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxOccurs != null) 'maxOccurs': maxOccurs!,
    if (minOccurs != null) 'minOccurs': minOccurs!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - healthcare:v1 : SchematizedData
/// - healthcare:v1beta1 : SchematizedData
class $SchematizedData {
  /// JSON output of the parser.
  core.String? data;

  /// The error output of the parser.
  core.String? error;

  $SchematizedData({this.data, this.error});

  $SchematizedData.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        error: json_['error'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (error != null) 'error': error!,
  };
}

/// Used by:
///
/// - apphub:v1 : Scope
/// - apphub:v1alpha : Scope
class $Scope {
  /// Scope Type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified type.
  /// - "REGIONAL" : Regional type.
  /// - "GLOBAL" : Global type.
  core.String? type;

  $Scope({this.type});

  $Scope.fromJson(core.Map json_) : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ScopeLifecycleState
/// - gkehub:v1alpha : ScopeLifecycleState
/// - gkehub:v1beta : ScopeLifecycleState
class $ScopeLifecycleState {
  /// The current state of the scope resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : The code is not set.
  /// - "CREATING" : The scope is being created.
  /// - "READY" : The scope active.
  /// - "DELETING" : The scope is being deleted.
  /// - "UPDATING" : The scope is being updated.
  core.String? code;

  $ScopeLifecycleState({this.code});

  $ScopeLifecycleState.fromJson(core.Map json_)
    : this(code: json_['code'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
  };
}

/// Used by:
///
/// - compute:alpha : Screenshot
/// - compute:beta : Screenshot
/// - compute:v1 : Screenshot
class $Screenshot {
  /// The Base64-encoded screenshot data.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#screenshot for the screenshots.
  ///
  /// Output only.
  core.String? kind;

  $Screenshot({this.contents, this.kind});

  $Screenshot.fromJson(core.Map json_)
    : this(
        contents: json_['contents'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ScriptError
/// - displayvideo:v3 : ScriptError
/// - displayvideo:v4 : ScriptError
class $ScriptError {
  /// The column number in the script where the error was thrown.
  core.String? column;

  /// The type of error.
  /// Possible string values are:
  /// - "ERROR_CODE_UNSPECIFIED" : The script error is not specified or is
  /// unknown in this version.
  /// - "SYNTAX_ERROR" : The script has a syntax error.
  /// - "DEPRECATED_SYNTAX" : The script uses deprecated syntax.
  /// - "INTERNAL_ERROR" : Internal errors were thrown while processing the
  /// script.
  core.String? errorCode;

  /// The detailed error message.
  core.String? errorMessage;

  /// The line number in the script where the error was thrown.
  core.String? line;

  $ScriptError({this.column, this.errorCode, this.errorMessage, this.line});

  $ScriptError.fromJson(core.Map json_)
    : this(
        column: json_['column'] as core.String?,
        errorCode: json_['errorCode'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
        line: json_['line'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (column != null) 'column': column!,
    if (errorCode != null) 'errorCode': errorCode!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (line != null) 'line': line!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SdfConfig
/// - displayvideo:v3 : SdfConfig
/// - displayvideo:v4 : SdfConfig
class $SdfConfig {
  /// An administrator email address to which the SDF processing status reports
  /// will be sent.
  core.String? adminEmail;

  /// The version of SDF being used.
  ///
  /// Required.
  /// Possible string values are:
  /// - "SDF_VERSION_UNSPECIFIED" : SDF version value is not specified or is
  /// unknown in this version.
  /// - "SDF_VERSION_3_1" : SDF version 3.1
  /// - "SDF_VERSION_4" : SDF version 4
  /// - "SDF_VERSION_4_1" : SDF version 4.1
  /// - "SDF_VERSION_4_2" : SDF version 4.2
  /// - "SDF_VERSION_5" : SDF version 5.
  /// - "SDF_VERSION_5_1" : SDF version 5.1
  /// - "SDF_VERSION_5_2" : SDF version 5.2
  /// - "SDF_VERSION_5_3" : SDF version 5.3
  /// - "SDF_VERSION_5_4" : SDF version 5.4
  /// - "SDF_VERSION_5_5" : SDF version 5.5
  /// - "SDF_VERSION_6" : SDF version 6
  /// - "SDF_VERSION_7" : SDF version 7. Read the \[v7 migration
  /// guide\](/display-video/api/structured-data-file/v7-migration-guide) before
  /// migrating to this version.
  /// - "SDF_VERSION_7_1" : SDF version 7.1. Read the \[v7 migration
  /// guide\](/display-video/api/structured-data-file/v7-migration-guide) before
  /// migrating to this version.
  /// - "SDF_VERSION_8" : SDF version 8. Read the \[v8 migration
  /// guide\](/display-video/api/structured-data-file/v8-migration-guide) before
  /// migrating to this version.
  /// - "SDF_VERSION_8_1" : SDF version 8.1.
  core.String? version;

  $SdfConfig({this.adminEmail, this.version});

  $SdfConfig.fromJson(core.Map json_)
    : this(
        adminEmail: json_['adminEmail'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adminEmail != null) 'adminEmail': adminEmail!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SearchEntryPoint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SearchEntryPoint
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1SearchEntryPoint
class $SearchEntryPoint {
  /// Web content snippet that can be embedded in a web page or an app webview.
  ///
  /// Optional.
  core.String? renderedContent;

  /// Base64 encoded JSON representing array of tuple.
  ///
  /// Optional.
  core.String? sdkBlob;
  core.List<core.int> get sdkBlobAsBytes => convert.base64.decode(sdkBlob!);

  set sdkBlobAsBytes(core.List<core.int> bytes_) {
    sdkBlob = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $SearchEntryPoint({this.renderedContent, this.sdkBlob});

  $SearchEntryPoint.fromJson(core.Map json_)
    : this(
        renderedContent: json_['renderedContent'] as core.String?,
        sdkBlob: json_['sdkBlob'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (renderedContent != null) 'renderedContent': renderedContent!,
    if (sdkBlob != null) 'sdkBlob': sdkBlob!,
  };
}

/// Used by:
///
/// - cloudresourcemanager:v2 : SearchFoldersRequest
/// - cloudresourcemanager:v2beta1 : SearchFoldersRequest
class $SearchFoldersRequest {
  /// The maximum number of folders to return in the response.
  ///
  /// The server can return fewer folders than requested. If unspecified, server
  /// picks an appropriate default.
  ///
  /// Optional.
  core.int? pageSize;

  /// A pagination token returned from a previous call to `SearchFolders` that
  /// indicates from where search should continue.
  ///
  /// Optional.
  core.String? pageToken;

  /// Search criteria used to select the Folders to return.
  ///
  /// If no search criteria is specified then all accessible folders will be
  /// returned. Query expressions can be used to restrict results based upon
  /// displayName, lifecycleState and parent, where the operators `=`, `NOT`,
  /// `AND` and `OR` can be used along with the suffix wildcard symbol `*`. The
  /// displayName field in a query expression should use escaped quotes for
  /// values that include whitespace to prevent unexpected behavior. Some
  /// example queries are: * Query `displayName=Test*` returns Folder resources
  /// whose display name starts with "Test". * Query `lifecycleState=ACTIVE`
  /// returns Folder resources with `lifecycleState` set to `ACTIVE`. * Query
  /// `parent=folders/123` returns Folder resources that have `folders/123` as a
  /// parent resource. * Query `parent=folders/123 AND lifecycleState=ACTIVE`
  /// returns active Folder resources that have `folders/123` as a parent
  /// resource. * Query `displayName=\\"Test String\\"` returns Folder resources
  /// with display names that include both "Test" and "String".
  core.String? query;

  $SearchFoldersRequest({this.pageSize, this.pageToken, this.query});

  $SearchFoldersRequest.fromJson(core.Map json_)
    : this(
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        query: json_['query'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (query != null) 'query': query!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchInfo
class $SearchInfo {
  /// An integer that specifies the current offset for pagination (the 0-indexed
  /// starting location, amongst the products deemed by the API as relevant).
  ///
  /// See SearchRequest.offset for definition. If this field is negative, an
  /// `INVALID_ARGUMENT` is returned. This can only be set for `search` events.
  /// Other event types should not set this field. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  core.int? offset;

  /// The order in which products are returned, if applicable.
  ///
  /// See SearchRequest.order_by for definition and syntax. The value must be a
  /// UTF-8 encoded string with a length limit of 1,000 characters. Otherwise,
  /// an `INVALID_ARGUMENT` error is returned. This can only be set for `search`
  /// events. Other event types should not set this field. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  core.String? orderBy;

  /// The user's search query.
  ///
  /// See SearchRequest.query for definition. The value must be a UTF-8 encoded
  /// string with a length limit of 5,000 characters. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned. At least one of search_query or
  /// PageInfo.page_category is required for `search` events. Other event types
  /// should not set this field. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  core.String? searchQuery;

  $SearchInfo({this.offset, this.orderBy, this.searchQuery});

  $SearchInfo.fromJson(core.Map json_)
    : this(
        offset: json_['offset'] as core.int?,
        orderBy: json_['orderBy'] as core.String?,
        searchQuery: json_['searchQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (offset != null) 'offset': offset!,
    if (orderBy != null) 'orderBy': orderBy!,
    if (searchQuery != null) 'searchQuery': searchQuery!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SearchKnowledgeAnswerAnswerSource
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SearchKnowledgeAnswerAnswerSource
class $SearchKnowledgeAnswerAnswerSource {
  /// Metadata associated with the article.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The relevant snippet of the article.
  core.String? snippet;

  /// The title of the article.
  core.String? title;

  /// The URI of the article.
  core.String? uri;

  $SearchKnowledgeAnswerAnswerSource({
    this.metadata,
    this.snippet,
    this.title,
    this.uri,
  });

  $SearchKnowledgeAnswerAnswerSource.fromJson(core.Map json_)
    : this(
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        snippet: json_['snippet'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
    if (snippet != null) 'snippet': snippet!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SearchKnowledgeRequestSearchConfigFilterSpecs
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SearchKnowledgeRequestSearchConfigFilterSpecs
class $SearchKnowledgeRequestSearchConfigFilterSpecs {
  /// The data store where the filter configuration is applied.
  ///
  /// Full resource name of data store, such as
  /// projects/{project}/locations/{location}/collections/{collectionId}/
  /// dataStores/{dataStoreId}.
  ///
  /// Optional.
  core.List<core.String>? dataStores;

  /// The filter expression to be applied.
  ///
  /// Expression syntax is documented at
  /// https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax
  ///
  /// Optional.
  core.String? filter;

  $SearchKnowledgeRequestSearchConfigFilterSpecs({
    this.dataStores,
    this.filter,
  });

  $SearchKnowledgeRequestSearchConfigFilterSpecs.fromJson(core.Map json_)
    : this(
        dataStores:
            (json_['dataStores'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStores != null) 'dataStores': dataStores!,
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchLinkPromotion
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchLinkPromotion
class $SearchLinkPromotion {
  /// The Promotion description.
  ///
  /// Maximum length: 200 characters.
  ///
  /// Optional.
  core.String? description;

  /// The Document the user wants to promote.
  ///
  /// For site search, leave unset and only populate uri. Can be set along with
  /// uri.
  ///
  /// Optional.
  core.String? document;

  /// The enabled promotion will be returned for any serving configs associated
  /// with the parent of the control this promotion is attached to.
  ///
  /// This flag is used for basic site search only.
  ///
  /// Optional.
  core.bool? enabled;

  /// The promotion thumbnail image url.
  ///
  /// Optional.
  core.String? imageUri;

  /// The title of the promotion.
  ///
  /// Maximum length: 160 characters.
  ///
  /// Required.
  core.String? title;

  /// The URL for the page the user wants to promote.
  ///
  /// Must be set for site search. For other verticals, this is optional.
  ///
  /// Optional.
  core.String? uri;

  $SearchLinkPromotion({
    this.description,
    this.document,
    this.enabled,
    this.imageUri,
    this.title,
    this.uri,
  });

  $SearchLinkPromotion.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        document: json_['document'] as core.String?,
        enabled: json_['enabled'] as core.bool?,
        imageUri: json_['imageUri'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (document != null) 'document': document!,
    if (enabled != null) 'enabled': enabled!,
    if (imageUri != null) 'imageUri': imageUri!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SearchMigratableResourcesRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SearchMigratableResourcesRequest
class $SearchMigratableResourcesRequest {
  /// A filter for your search.
  ///
  /// You can use the following types of filters: * Resource type filters. The
  /// following strings filter for a specific type of MigratableResource: *
  /// `ml_engine_model_version:*` * `automl_model:*` * `automl_dataset:*` *
  /// `data_labeling_dataset:*` * "Migrated or not" filters. The following
  /// strings filter for resources that either have or have not already been
  /// migrated: * `last_migrate_time:*` filters for migrated resources. * `NOT
  /// last_migrate_time:*` filters for not yet migrated resources.
  core.String? filter;

  /// The standard page size.
  ///
  /// The default and maximum value is 100.
  core.int? pageSize;

  /// The standard page token.
  core.String? pageToken;

  $SearchMigratableResourcesRequest({
    this.filter,
    this.pageSize,
    this.pageToken,
  });

  $SearchMigratableResourcesRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
class $SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective {
  /// If set, all attribution scores between
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time and
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time are fetched,
  /// and page token doesn't take effect in this case.
  ///
  /// Only used to retrieve attribution score for the top Features which has the
  /// highest attribution score in the latest monitoring run.
  core.int? topFeatureCount;

  ///
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? type;

  $SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective({
    this.topFeatureCount,
    this.type,
  });

  $SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective.fromJson(
    core.Map json_,
  ) : this(
        topFeatureCount: json_['topFeatureCount'] as core.int?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (topFeatureCount != null) 'topFeatureCount': topFeatureCount!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SearchRequestBoostSpecConditionBoostSpec
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchRequestBoostSpecConditionBoostSpec
/// - retail:v2beta : GoogleCloudRetailV2betaSearchRequestBoostSpecConditionBoostSpec
class $SearchRequestBoostSpecConditionBoostSpec {
  /// Strength of the condition boost, which should be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the
  /// item a big promotion. However, it does not necessarily mean that the
  /// boosted item will be the top result at all times, nor that other items
  /// will be excluded. Results could still be shown even when none of them
  /// matches the condition. And results that are significantly more relevant to
  /// the search query can still trump your heavily favored but irrelevant
  /// items. Setting to -1.0 gives the item a big demotion. However, results
  /// that are deeply relevant might still be shown. The item will have an
  /// upstream battle to get a fairly high ranking, but it is not blocked out
  /// completely. Setting to 0.0 means no boost applied. The boosting condition
  /// is ignored.
  core.double? boost;

  /// An expression which specifies a boost condition.
  ///
  /// The syntax and supported fields are the same as a filter expression. See
  /// SearchRequest.filter for detail syntax and limitations. Examples: * To
  /// boost products with product ID "product_1" or "product_2", and color "Red"
  /// or "Blue": * (id: ANY("product_1", "product_2")) AND (colorFamilies:
  /// ANY("Red","Blue"))
  core.String? condition;

  $SearchRequestBoostSpecConditionBoostSpec({this.boost, this.condition});

  $SearchRequestBoostSpecConditionBoostSpec.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        condition: json_['condition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (condition != null) 'condition': condition!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint
class $SearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint {
  /// Can be one of: 1.
  ///
  /// The numerical field value. 2. The duration spec for freshness: The value
  /// must be formatted as an XSD `dayTimeDuration` value (a restricted subset
  /// of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
  core.String? attributeValue;

  /// The value between -1 to 1 by which to boost the score if the
  /// attribute_value evaluates to the value specified above.
  core.double? boostAmount;

  $SearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint({
    this.attributeValue,
    this.boostAmount,
  });

  $SearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint.fromJson(
    core.Map json_,
  ) : this(
        attributeValue: json_['attributeValue'] as core.String?,
        boostAmount: (json_['boostAmount'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeValue != null) 'attributeValue': attributeValue!,
    if (boostAmount != null) 'boostAmount': boostAmount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestContentSearchSpecChunkSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecChunkSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecChunkSpec
class $SearchRequestContentSearchSpecChunkSpec {
  /// The number of next chunks to be returned of the current chunk.
  ///
  /// The maximum allowed value is 3. If not specified, no next chunks will be
  /// returned.
  core.int? numNextChunks;

  /// The number of previous chunks to be returned of the current chunk.
  ///
  /// The maximum allowed value is 3. If not specified, no previous chunks will
  /// be returned.
  core.int? numPreviousChunks;

  $SearchRequestContentSearchSpecChunkSpec({
    this.numNextChunks,
    this.numPreviousChunks,
  });

  $SearchRequestContentSearchSpecChunkSpec.fromJson(core.Map json_)
    : this(
        numNextChunks: json_['numNextChunks'] as core.int?,
        numPreviousChunks: json_['numPreviousChunks'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (numNextChunks != null) 'numNextChunks': numNextChunks!,
    if (numPreviousChunks != null) 'numPreviousChunks': numPreviousChunks!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestContentSearchSpecExtractiveContentSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecExtractiveContentSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecExtractiveContentSpec
class $SearchRequestContentSearchSpecExtractiveContentSpec {
  /// The maximum number of extractive answers returned in each search result.
  ///
  /// An extractive answer is a verbatim answer extracted from the original
  /// document, which provides a precise and contextually relevant answer to the
  /// search query. If the number of matching answers is less than the
  /// `max_extractive_answer_count`, return all of the answers. Otherwise,
  /// return the `max_extractive_answer_count`. At most five answers are
  /// returned for each SearchResult.
  core.int? maxExtractiveAnswerCount;

  /// The max number of extractive segments returned in each search result.
  ///
  /// Only applied if the DataStore is set to
  /// DataStore.ContentConfig.CONTENT_REQUIRED or DataStore.solution_types is
  /// SOLUTION_TYPE_CHAT. An extractive segment is a text segment extracted from
  /// the original document that is relevant to the search query, and, in
  /// general, more verbose than an extractive answer. The segment could then be
  /// used as input for LLMs to generate summaries and answers. If the number of
  /// matching segments is less than `max_extractive_segment_count`, return all
  /// of the segments. Otherwise, return the `max_extractive_segment_count`.
  core.int? maxExtractiveSegmentCount;

  /// Return at most `num_next_segments` segments after each selected segments.
  core.int? numNextSegments;

  /// Specifies whether to also include the adjacent from each selected
  /// segments.
  ///
  /// Return at most `num_previous_segments` segments before each selected
  /// segments.
  core.int? numPreviousSegments;

  /// Specifies whether to return the confidence score from the extractive
  /// segments in each search result.
  ///
  /// This feature is available only for new or allowlisted data stores. To
  /// allowlist your data store, contact your Customer Engineer. The default
  /// value is `false`.
  core.bool? returnExtractiveSegmentScore;

  $SearchRequestContentSearchSpecExtractiveContentSpec({
    this.maxExtractiveAnswerCount,
    this.maxExtractiveSegmentCount,
    this.numNextSegments,
    this.numPreviousSegments,
    this.returnExtractiveSegmentScore,
  });

  $SearchRequestContentSearchSpecExtractiveContentSpec.fromJson(core.Map json_)
    : this(
        maxExtractiveAnswerCount:
            json_['maxExtractiveAnswerCount'] as core.int?,
        maxExtractiveSegmentCount:
            json_['maxExtractiveSegmentCount'] as core.int?,
        numNextSegments: json_['numNextSegments'] as core.int?,
        numPreviousSegments: json_['numPreviousSegments'] as core.int?,
        returnExtractiveSegmentScore:
            json_['returnExtractiveSegmentScore'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxExtractiveAnswerCount != null)
      'maxExtractiveAnswerCount': maxExtractiveAnswerCount!,
    if (maxExtractiveSegmentCount != null)
      'maxExtractiveSegmentCount': maxExtractiveSegmentCount!,
    if (numNextSegments != null) 'numNextSegments': numNextSegments!,
    if (numPreviousSegments != null)
      'numPreviousSegments': numPreviousSegments!,
    if (returnExtractiveSegmentScore != null)
      'returnExtractiveSegmentScore': returnExtractiveSegmentScore!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestContentSearchSpecSnippetSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSnippetSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecSnippetSpec
class $SearchRequestContentSearchSpecSnippetSpec {
  /// This field is deprecated.
  ///
  /// To control snippet return, use `return_snippet` field. For backwards
  /// compatibility, we will return snippet if max_snippet_count \> 0.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? maxSnippetCount;

  /// This field is deprecated and will have no affect on the snippet.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? referenceOnly;

  /// If `true`, then return snippet.
  ///
  /// If no snippet can be generated, we return "No snippet is available for
  /// this page." A `snippet_status` with `SUCCESS` or `NO_SNIPPET_AVAILABLE`
  /// will also be returned.
  core.bool? returnSnippet;

  $SearchRequestContentSearchSpecSnippetSpec({
    this.maxSnippetCount,
    this.referenceOnly,
    this.returnSnippet,
  });

  $SearchRequestContentSearchSpecSnippetSpec.fromJson(core.Map json_)
    : this(
        maxSnippetCount: json_['maxSnippetCount'] as core.int?,
        referenceOnly: json_['referenceOnly'] as core.bool?,
        returnSnippet: json_['returnSnippet'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxSnippetCount != null) 'maxSnippetCount': maxSnippetCount!,
    if (referenceOnly != null) 'referenceOnly': referenceOnly!,
    if (returnSnippet != null) 'returnSnippet': returnSnippet!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestContentSearchSpecSummarySpecModelPromptSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelPromptSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecSummarySpecModelPromptSpec
class $SearchRequestContentSearchSpecSummarySpecModelPromptSpec {
  /// Text at the beginning of the prompt that instructs the assistant.
  ///
  /// Examples are available in the user guide.
  core.String? preamble;

  $SearchRequestContentSearchSpecSummarySpecModelPromptSpec({this.preamble});

  $SearchRequestContentSearchSpecSummarySpecModelPromptSpec.fromJson(
    core.Map json_,
  ) : this(preamble: json_['preamble'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (preamble != null) 'preamble': preamble!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestContentSearchSpecSummarySpecModelSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecSummarySpecModelSpec
class $SearchRequestContentSearchSpecSummarySpecModelSpec {
  /// The model version used to generate the summary.
  ///
  /// Supported values are: * `stable`: string. Default value when no value is
  /// specified. Uses a generally available, fine-tuned model. For more
  /// information, see
  /// [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
  /// * `preview`: string. (Public preview) Uses a preview model. For more
  /// information, see
  /// [Answer generation model versions and lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
  core.String? version;

  $SearchRequestContentSearchSpecSummarySpecModelSpec({this.version});

  $SearchRequestContentSearchSpecSummarySpecModelSpec.fromJson(core.Map json_)
    : this(version: json_['version'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestDisplaySpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestDisplaySpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestDisplaySpec
class $SearchRequestDisplaySpec {
  /// The condition under which match highlighting should occur.
  /// Possible string values are:
  /// - "MATCH_HIGHLIGHTING_CONDITION_UNSPECIFIED" : Server behavior is the same
  /// as `MATCH_HIGHLIGHTING_DISABLED`.
  /// - "MATCH_HIGHLIGHTING_DISABLED" : Disables match highlighting on all
  /// documents.
  /// - "MATCH_HIGHLIGHTING_ENABLED" : Enables match highlighting on all
  /// documents.
  core.String? matchHighlightingCondition;

  $SearchRequestDisplaySpec({this.matchHighlightingCondition});

  $SearchRequestDisplaySpec.fromJson(core.Map json_)
    : this(
        matchHighlightingCondition:
            json_['matchHighlightingCondition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (matchHighlightingCondition != null)
      'matchHighlightingCondition': matchHighlightingCondition!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SearchRequestDynamicFacetSpec
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchRequestDynamicFacetSpec
/// - retail:v2beta : GoogleCloudRetailV2betaSearchRequestDynamicFacetSpec
class $SearchRequestDynamicFacetSpec {
  /// Mode of the DynamicFacet feature.
  ///
  /// Defaults to Mode.DISABLED if it's unset.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value.
  /// - "DISABLED" : Disable Dynamic Facet.
  /// - "ENABLED" : Automatic mode built by Google Retail Search.
  core.String? mode;

  $SearchRequestDynamicFacetSpec({this.mode});

  $SearchRequestDynamicFacetSpec.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpecEmbeddingVector
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestEmbeddingSpecEmbeddingVector
class $SearchRequestEmbeddingSpecEmbeddingVector {
  /// Embedding field path in schema.
  core.String? fieldPath;

  /// Query embedding vector.
  core.List<core.double>? vector;

  $SearchRequestEmbeddingSpecEmbeddingVector({this.fieldPath, this.vector});

  $SearchRequestEmbeddingSpecEmbeddingVector.fromJson(core.Map json_)
    : this(
        fieldPath: json_['fieldPath'] as core.String?,
        vector:
            (json_['vector'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldPath != null) 'fieldPath': fieldPath!,
    if (vector != null) 'vector': vector!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestImageQuery
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestImageQuery
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestImageQuery
class $SearchRequestImageQuery {
  /// Base64 encoded image bytes.
  ///
  /// Supported image formats: JPEG, PNG, and BMP.
  core.String? imageBytes;

  $SearchRequestImageQuery({this.imageBytes});

  $SearchRequestImageQuery.fromJson(core.Map json_)
    : this(imageBytes: json_['imageBytes'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageBytes != null) 'imageBytes': imageBytes!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestNaturalLanguageQueryUnderstandingSpec
class $SearchRequestNaturalLanguageQueryUnderstandingSpec {
  /// Controls behavior of how extracted filters are applied to the search.
  ///
  /// The default behavior depends on the request. For single datastore
  /// structured search, the default is `HARD_FILTER`. For multi-datastore
  /// search, the default behavior is `SOFT_BOOST`. Location-based filters are
  /// always applied as hard filters, and the `SOFT_BOOST` setting will not
  /// affect them. This field is only used if
  /// SearchRequest.natural_language_query_understanding_spec.filter_extraction_condition
  /// is set to FilterExtractionCondition.ENABLED.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "EXTRACTED_FILTER_BEHAVIOR_UNSPECIFIED" :
  /// `EXTRACTED_FILTER_BEHAVIOR_UNSPECIFIED` will use the default behavior for
  /// extracted filters. For single datastore search, the default is to apply as
  /// hard filters. For multi-datastore search, the default is to apply as soft
  /// boosts.
  /// - "HARD_FILTER" : Applies all extracted filters as hard filters on the
  /// results. Results that do not pass the extracted filters will not be
  /// returned in the result set.
  /// - "SOFT_BOOST" : Applies all extracted filters as soft boosts. Results
  /// that pass the filters will be boosted up to higher ranks in the result
  /// set.
  core.String? extractedFilterBehavior;

  /// The condition under which filter extraction should occur.
  ///
  /// Server behavior defaults to `DISABLED`.
  /// Possible string values are:
  /// - "CONDITION_UNSPECIFIED" : Server behavior defaults to `DISABLED`.
  /// - "DISABLED" : Disables NL filter extraction.
  /// - "ENABLED" : Enables NL filter extraction.
  core.String? filterExtractionCondition;

  /// Field names used for location-based filtering, where geolocation filters
  /// are detected in natural language search queries.
  ///
  /// Only valid when the FilterExtractionCondition is set to `ENABLED`. If this
  /// field is set, it overrides the field names set in
  /// ServingConfig.geo_search_query_detection_field_names.
  core.List<core.String>? geoSearchQueryDetectionFieldNames;

  $SearchRequestNaturalLanguageQueryUnderstandingSpec({
    this.extractedFilterBehavior,
    this.filterExtractionCondition,
    this.geoSearchQueryDetectionFieldNames,
  });

  $SearchRequestNaturalLanguageQueryUnderstandingSpec.fromJson(core.Map json_)
    : this(
        extractedFilterBehavior:
            json_['extractedFilterBehavior'] as core.String?,
        filterExtractionCondition:
            json_['filterExtractionCondition'] as core.String?,
        geoSearchQueryDetectionFieldNames:
            (json_['geoSearchQueryDetectionFieldNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extractedFilterBehavior != null)
      'extractedFilterBehavior': extractedFilterBehavior!,
    if (filterExtractionCondition != null)
      'filterExtractionCondition': filterExtractionCondition!,
    if (geoSearchQueryDetectionFieldNames != null)
      'geoSearchQueryDetectionFieldNames': geoSearchQueryDetectionFieldNames!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SearchRequestPersonalizationSpec
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchRequestPersonalizationSpec
/// - retail:v2beta : GoogleCloudRetailV2betaSearchRequestPersonalizationSpec
class $SearchRequestPersonalizationSpec00 {
  /// Defaults to Mode.AUTO.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value. In this case, server behavior
  /// defaults to Mode.AUTO.
  /// - "AUTO" : Let CRS decide whether to use personalization based on quality
  /// of user event data.
  /// - "DISABLED" : Disable personalization.
  core.String? mode;

  $SearchRequestPersonalizationSpec00({this.mode});

  $SearchRequestPersonalizationSpec00.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestPersonalizationSpec
class $SearchRequestPersonalizationSpec01 {
  /// The personalization mode of the search request.
  ///
  /// Defaults to Mode.AUTO.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value. In this case, server behavior
  /// defaults to Mode.AUTO.
  /// - "AUTO" : Personalization is enabled if data quality requirements are
  /// met.
  /// - "DISABLED" : Disable personalization.
  core.String? mode;

  $SearchRequestPersonalizationSpec01({this.mode});

  $SearchRequestPersonalizationSpec01.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestQueryExpansionSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestQueryExpansionSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestQueryExpansionSpec
class $SearchRequestQueryExpansionSpec00 {
  /// The condition under which query expansion should occur.
  ///
  /// Default to Condition.DISABLED.
  /// Possible string values are:
  /// - "CONDITION_UNSPECIFIED" : Unspecified query expansion condition. In this
  /// case, server behavior defaults to Condition.DISABLED.
  /// - "DISABLED" : Disabled query expansion. Only the exact search query is
  /// used, even if SearchResponse.total_size is zero.
  /// - "AUTO" : Automatic query expansion built by the Search API.
  core.String? condition;

  /// Whether to pin unexpanded results.
  ///
  /// If this field is set to true, unexpanded products are always at the top of
  /// the search results, followed by the expanded results.
  core.bool? pinUnexpandedResults;

  $SearchRequestQueryExpansionSpec00({
    this.condition,
    this.pinUnexpandedResults,
  });

  $SearchRequestQueryExpansionSpec00.fromJson(core.Map json_)
    : this(
        condition: json_['condition'] as core.String?,
        pinUnexpandedResults: json_['pinUnexpandedResults'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (condition != null) 'condition': condition!,
    if (pinUnexpandedResults != null)
      'pinUnexpandedResults': pinUnexpandedResults!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SearchRequestQueryExpansionSpec
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchRequestQueryExpansionSpec
/// - retail:v2beta : GoogleCloudRetailV2betaSearchRequestQueryExpansionSpec
class $SearchRequestQueryExpansionSpec01 {
  /// The condition under which query expansion should occur.
  ///
  /// Default to Condition.DISABLED.
  /// Possible string values are:
  /// - "CONDITION_UNSPECIFIED" : Unspecified query expansion condition. In this
  /// case, server behavior defaults to Condition.DISABLED.
  /// - "DISABLED" : Disabled query expansion. Only the exact search query is
  /// used, even if SearchResponse.total_size is zero.
  /// - "AUTO" : Automatic query expansion built by Google Retail Search.
  core.String? condition;

  /// Whether to pin unexpanded results.
  ///
  /// The default value is false. If this field is set to true, unexpanded
  /// products are always at the top of the search results, followed by the
  /// expanded results.
  core.bool? pinUnexpandedResults;

  $SearchRequestQueryExpansionSpec01({
    this.condition,
    this.pinUnexpandedResults,
  });

  $SearchRequestQueryExpansionSpec01.fromJson(core.Map json_)
    : this(
        condition: json_['condition'] as core.String?,
        pinUnexpandedResults: json_['pinUnexpandedResults'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (condition != null) 'condition': condition!,
    if (pinUnexpandedResults != null)
      'pinUnexpandedResults': pinUnexpandedResults!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestRelevanceScoreSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestRelevanceScoreSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestRelevanceScoreSpec
class $SearchRequestRelevanceScoreSpec {
  /// Whether to return the relevance score for search results.
  ///
  /// The higher the score, the more relevant the document is to the query.
  ///
  /// Optional.
  core.bool? returnRelevanceScore;

  $SearchRequestRelevanceScoreSpec({this.returnRelevanceScore});

  $SearchRequestRelevanceScoreSpec.fromJson(core.Map json_)
    : this(returnRelevanceScore: json_['returnRelevanceScore'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (returnRelevanceScore != null)
      'returnRelevanceScore': returnRelevanceScore!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestSearchAsYouTypeSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestSearchAsYouTypeSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestSearchAsYouTypeSpec
class $SearchRequestSearchAsYouTypeSpec {
  /// The condition under which search as you type should occur.
  ///
  /// Default to Condition.DISABLED.
  /// Possible string values are:
  /// - "CONDITION_UNSPECIFIED" : Server behavior defaults to
  /// Condition.DISABLED.
  /// - "DISABLED" : Disables Search As You Type.
  /// - "ENABLED" : Enables Search As You Type.
  /// - "AUTO" : Automatic switching between search-as-you-type and standard
  /// search modes, ideal for single-API implementations (e.g., debouncing).
  core.String? condition;

  $SearchRequestSearchAsYouTypeSpec({this.condition});

  $SearchRequestSearchAsYouTypeSpec.fromJson(core.Map json_)
    : this(condition: json_['condition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (condition != null) 'condition': condition!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestSessionSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestSessionSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestSessionSpec
class $SearchRequestSessionSpec {
  /// If set, the search result gets stored to the "turn" specified by this
  /// query ID.
  ///
  /// Example: Let's say the session looks like this: session { name:
  /// ".../sessions/xxx" turns { query { text: "What is foo?" query_id:
  /// ".../questions/yyy" } answer: "Foo is ..." } turns { query { text: "How
  /// about bar then?" query_id: ".../questions/zzz" } } } The user can call
  /// /search API with a request like this: session: ".../sessions/xxx"
  /// session_spec { query_id: ".../questions/zzz" } Then, the API stores the
  /// search result, associated with the last turn. The stored search result can
  /// be used by a subsequent /answer API call (with the session ID and the
  /// query ID specified). Also, it is possible to call /search and /answer in
  /// parallel with the same session ID & query ID.
  core.String? queryId;

  /// The number of top search results to persist.
  ///
  /// The persisted search results can be used for the subsequent /answer api
  /// call. This field is similar to the `summary_result_count` field in
  /// SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count. At most
  /// 10 results for documents mode, or 50 for chunks mode.
  core.int? searchResultPersistenceCount;

  $SearchRequestSessionSpec({this.queryId, this.searchResultPersistenceCount});

  $SearchRequestSessionSpec.fromJson(core.Map json_)
    : this(
        queryId: json_['queryId'] as core.String?,
        searchResultPersistenceCount:
            json_['searchResultPersistenceCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryId != null) 'queryId': queryId!,
    if (searchResultPersistenceCount != null)
      'searchResultPersistenceCount': searchResultPersistenceCount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchRequestSpellCorrectionSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestSpellCorrectionSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestSpellCorrectionSpec
class $SearchRequestSpellCorrectionSpec00 {
  /// The mode under which spell correction replaces the original search query.
  ///
  /// Defaults to Mode.AUTO.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Unspecified spell correction mode. In this case,
  /// server behavior defaults to Mode.AUTO.
  /// - "SUGGESTION_ONLY" : Search API tries to find a spelling suggestion. If a
  /// suggestion is found, it is put in the SearchResponse.corrected_query. The
  /// spelling suggestion won't be used as the search query.
  /// - "AUTO" : Automatic spell correction built by the Search API. Search will
  /// be based on the corrected query if found.
  core.String? mode;

  $SearchRequestSpellCorrectionSpec00({this.mode});

  $SearchRequestSpellCorrectionSpec00.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SearchRequestSpellCorrectionSpec
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchRequestSpellCorrectionSpec
/// - retail:v2beta : GoogleCloudRetailV2betaSearchRequestSpellCorrectionSpec
class $SearchRequestSpellCorrectionSpec01 {
  /// The mode under which spell correction should take effect to replace the
  /// original search query.
  ///
  /// Default to Mode.AUTO.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Unspecified spell correction mode. In this case,
  /// server behavior defaults to Mode.AUTO.
  /// - "SUGGESTION_ONLY" : Google Retail Search will try to find a spell
  /// suggestion if there is any and put in the SearchResponse.corrected_query.
  /// The spell suggestion will not be used as the search query.
  /// - "AUTO" : Automatic spell correction built by Google Retail Search.
  /// Search will be based on the corrected query if found.
  core.String? mode;

  $SearchRequestSpellCorrectionSpec01({this.mode});

  $SearchRequestSpellCorrectionSpec01.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseGeoSearchDebugInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseGeoSearchDebugInfo
class $SearchResponseGeoSearchDebugInfo {
  /// The error produced.
  core.String? errorMessage;

  /// The address from which forward geocoding ingestion produced issues.
  core.String? originalAddressQuery;

  $SearchResponseGeoSearchDebugInfo({
    this.errorMessage,
    this.originalAddressQuery,
  });

  $SearchResponseGeoSearchDebugInfo.fromJson(core.Map json_)
    : this(
        errorMessage: json_['errorMessage'] as core.String?,
        originalAddressQuery: json_['originalAddressQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (originalAddressQuery != null)
      'originalAddressQuery': originalAddressQuery!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResultRefinementAttribute
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseGuidedSearchResultRefinementAttribute
class $SearchResponseGuidedSearchResultRefinementAttribute {
  /// Attribute key used to refine the results.
  ///
  /// For example, `"movie_type"`.
  core.String? attributeKey;

  /// Attribute value used to refine the results.
  ///
  /// For example, `"drama"`.
  core.String? attributeValue;

  $SearchResponseGuidedSearchResultRefinementAttribute({
    this.attributeKey,
    this.attributeValue,
  });

  $SearchResponseGuidedSearchResultRefinementAttribute.fromJson(core.Map json_)
    : this(
        attributeKey: json_['attributeKey'] as core.String?,
        attributeValue: json_['attributeValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeKey != null) 'attributeKey': attributeKey!,
    if (attributeValue != null) 'attributeValue': attributeValue!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint
class $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint {
  /// The reference address that was inferred from the input query.
  ///
  /// The proximity of the reference address to the geolocation field will be
  /// used to filter the results.
  core.String? address;

  /// The name of the geolocation field as defined in the schema.
  core.String? fieldName;

  /// The latitude of the geolocation inferred from the input query.
  core.double? latitude;

  /// The longitude of the geolocation inferred from the input query.
  core.double? longitude;

  /// The radius in meters around the address.
  ///
  /// The record is returned if the location of the geolocation field is within
  /// the radius.
  core.double? radiusInMeters;

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint({
    this.address,
    this.fieldName,
    this.latitude,
    this.longitude,
    this.radiusInMeters,
  });

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint.fromJson(
    core.Map json_,
  ) : this(
        address: json_['address'] as core.String?,
        fieldName: json_['fieldName'] as core.String?,
        latitude: (json_['latitude'] as core.num?)?.toDouble(),
        longitude: (json_['longitude'] as core.num?)?.toDouble(),
        radiusInMeters: (json_['radiusInMeters'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (latitude != null) 'latitude': latitude!,
    if (longitude != null) 'longitude': longitude!,
    if (radiusInMeters != null) 'radiusInMeters': radiusInMeters!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint
class $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint {
  /// The comparison operation performed between the field value and the value
  /// specified in the constraint.
  /// Possible string values are:
  /// - "COMPARISON_UNSPECIFIED" : Undefined comparison operator.
  /// - "EQUALS" : Denotes equality `=` operator.
  /// - "LESS_THAN_EQUALS" : Denotes less than or equal to `<=` operator.
  /// - "LESS_THAN" : Denotes less than `<` operator.
  /// - "GREATER_THAN_EQUALS" : Denotes greater than or equal to `>=` operator.
  /// - "GREATER_THAN" : Denotes greater than `>` operator.
  core.String? comparison;

  /// Name of the numerical field as defined in the schema.
  core.String? fieldName;

  /// Identifies the keywords within the search query that match a filter.
  core.String? querySegment;

  /// The value specified in the numerical constraint.
  core.double? value;

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint({
    this.comparison,
    this.fieldName,
    this.querySegment,
    this.value,
  });

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint.fromJson(
    core.Map json_,
  ) : this(
        comparison: json_['comparison'] as core.String?,
        fieldName: json_['fieldName'] as core.String?,
        querySegment: json_['querySegment'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (comparison != null) 'comparison': comparison!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (querySegment != null) 'querySegment': querySegment!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint
class $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint {
  /// Name of the string field as defined in the schema.
  core.String? fieldName;

  /// Identifies the keywords within the search query that match a filter.
  core.String? querySegment;

  /// Values of the string field.
  ///
  /// The record will only be returned if the field value matches one of the
  /// values specified here.
  core.List<core.String>? values;

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint({
    this.fieldName,
    this.querySegment,
    this.values,
  });

  $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint.fromJson(
    core.Map json_,
  ) : this(
        fieldName: json_['fieldName'] as core.String?,
        querySegment: json_['querySegment'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldName != null) 'fieldName': fieldName!,
    if (querySegment != null) 'querySegment': querySegment!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchResponseQueryExpansionInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseQueryExpansionInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseQueryExpansionInfo
/// - retail:v2 : GoogleCloudRetailV2SearchResponseQueryExpansionInfo
/// - retail:v2alpha : GoogleCloudRetailV2alphaSearchResponseQueryExpansionInfo
/// - retail:v2beta : GoogleCloudRetailV2betaSearchResponseQueryExpansionInfo
class $SearchResponseQueryExpansionInfo {
  /// Bool describing whether query expansion has occurred.
  core.bool? expandedQuery;

  /// Number of pinned results.
  ///
  /// This field will only be set when expansion happens and
  /// SearchRequest.QueryExpansionSpec.pin_unexpanded_results is set to true.
  core.String? pinnedResultCount;

  $SearchResponseQueryExpansionInfo({
    this.expandedQuery,
    this.pinnedResultCount,
  });

  $SearchResponseQueryExpansionInfo.fromJson(core.Map json_)
    : this(
        expandedQuery: json_['expandedQuery'] as core.bool?,
        pinnedResultCount: json_['pinnedResultCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expandedQuery != null) 'expandedQuery': expandedQuery!,
    if (pinnedResultCount != null) 'pinnedResultCount': pinnedResultCount!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchResponseSessionInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseSessionInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseSessionInfo
class $SearchResponseSessionInfo {
  /// Name of the session.
  ///
  /// If the auto-session mode is used (when SearchRequest.session ends with
  /// "-"), this field holds the newly generated session name.
  core.String? name;

  /// Query ID that corresponds to this search API call.
  ///
  /// One session can have multiple turns, each with a unique query ID. By
  /// specifying the session name and this query ID in the Answer API call, the
  /// answer generation happens in the context of the search results from this
  /// search call.
  core.String? queryId;

  $SearchResponseSessionInfo({this.name, this.queryId});

  $SearchResponseSessionInfo.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        queryId: json_['queryId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (queryId != null) 'queryId': queryId!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachmentBlob
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseSummaryBlobAttachmentBlob
class $SearchResponseSummaryBlobAttachmentBlob {
  /// Raw bytes.
  ///
  /// Output only.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The media type (MIME type) of the generated data.
  ///
  /// Output only.
  core.String? mimeType;

  $SearchResponseSummaryBlobAttachmentBlob({this.data, this.mimeType});

  $SearchResponseSummaryBlobAttachmentBlob.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        mimeType: json_['mimeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (mimeType != null) 'mimeType': mimeType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchResponseSummaryCitationSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseSummaryCitationSource
class $SearchResponseSummaryCitationSource {
  /// Document reference index from SummaryWithMetadata.references.
  ///
  /// It is 0-indexed and the value will be zero if the reference_index is not
  /// set explicitly.
  core.String? referenceIndex;

  $SearchResponseSummaryCitationSource({this.referenceIndex});

  $SearchResponseSummaryCitationSource.fromJson(core.Map json_)
    : this(referenceIndex: json_['referenceIndex'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (referenceIndex != null) 'referenceIndex': referenceIndex!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReferenceChunkContent
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseSummaryReferenceChunkContent
class $SearchResponseSummaryReferenceChunkContent {
  /// Stores indexes of blobattachments linked to this chunk.
  ///
  /// Output only.
  core.List<core.String>? blobAttachmentIndexes;

  /// Chunk textual content.
  core.String? content;

  /// Page identifier.
  core.String? pageIdentifier;

  $SearchResponseSummaryReferenceChunkContent({
    this.blobAttachmentIndexes,
    this.content,
    this.pageIdentifier,
  });

  $SearchResponseSummaryReferenceChunkContent.fromJson(core.Map json_)
    : this(
        blobAttachmentIndexes:
            (json_['blobAttachmentIndexes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        content: json_['content'] as core.String?,
        pageIdentifier: json_['pageIdentifier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobAttachmentIndexes != null)
      'blobAttachmentIndexes': blobAttachmentIndexes!,
    if (content != null) 'content': content!,
    if (pageIdentifier != null) 'pageIdentifier': pageIdentifier!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SearchResponseSummarySafetyAttributes
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySafetyAttributes
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchResponseSummarySafetyAttributes
class $SearchResponseSummarySafetyAttributes {
  /// The display names of Safety Attribute categories associated with the
  /// generated content.
  ///
  /// Order matches the Scores.
  core.List<core.String>? categories;

  /// The confidence scores of the each category, higher value means higher
  /// confidence.
  ///
  /// Order matches the Categories.
  core.List<core.double>? scores;

  $SearchResponseSummarySafetyAttributes({this.categories, this.scores});

  $SearchResponseSummarySafetyAttributes.fromJson(core.Map json_)
    : this(
        categories:
            (json_['categories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        scores:
            (json_['scores'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categories != null) 'categories': categories!,
    if (scores != null) 'scores': scores!,
  };
}

/// Used by:
///
/// - dataform:v1beta1 : DirectorySearchResult
/// - dataform:v1beta1 : FileSearchResult
class $SearchResult {
  /// File system path relative to the workspace root.
  core.String? path;

  $SearchResult({this.path});

  $SearchResult.fromJson(core.Map json_)
    : this(path: json_['path'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
  };
}

/// Used by:
///
/// - container:v1 : SecondaryBootDisk
/// - container:v1beta1 : SecondaryBootDisk
class $SecondaryBootDisk {
  /// Fully-qualified resource ID for an existing disk image.
  core.String? diskImage;

  /// Disk mode (container image cache, etc.)
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : MODE_UNSPECIFIED is when mode is not set.
  /// - "CONTAINER_IMAGE_CACHE" : CONTAINER_IMAGE_CACHE is for using the
  /// secondary boot disk as a container image cache.
  core.String? mode;

  $SecondaryBootDisk({this.diskImage, this.mode});

  $SecondaryBootDisk.fromJson(core.Map json_)
    : this(
        diskImage: json_['diskImage'] as core.String?,
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskImage != null) 'diskImage': diskImage!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - alloydb:v1 : SecondaryConfig
/// - alloydb:v1alpha : SecondaryConfig
/// - alloydb:v1beta : SecondaryConfig
class $SecondaryConfig {
  /// The name of the primary cluster name with the format: *
  /// projects/{project}/locations/{region}/clusters/{cluster_id}
  core.String? primaryClusterName;

  $SecondaryConfig({this.primaryClusterName});

  $SecondaryConfig.fromJson(core.Map json_)
    : this(primaryClusterName: json_['primaryClusterName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (primaryClusterName != null) 'primaryClusterName': primaryClusterName!,
  };
}

/// Used by:
///
/// - metastore:v1 : Secret
/// - metastore:v1alpha : Secret
/// - metastore:v1beta : Secret
class $Secret00 {
  /// The relative resource name of a Secret Manager secret version, in the
  /// following
  /// form:projects/{project_number}/secrets/{secret_id}/versions/{version_id}.
  ///
  /// Optional.
  core.String? cloudSecret;

  $Secret00({this.cloudSecret});

  $Secret00.fromJson(core.Map json_)
    : this(cloudSecret: json_['cloudSecret'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cloudSecret != null) 'cloudSecret': cloudSecret!,
  };
}

/// Used by:
///
/// - connectors:v1 : Secret
/// - integrations:v1 : GoogleCloudConnectorsV1Secret
class $Secret01 {
  /// The resource name of the secret version in the format, format as:
  /// `projects / * /secrets / * /versions / * `.
  ///
  /// Optional.
  core.String? secretVersion;

  $Secret01({this.secretVersion});

  $Secret01.fromJson(core.Map json_)
    : this(secretVersion: json_['secretVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (secretVersion != null) 'secretVersion': secretVersion!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : SecretEnvVar
/// - cloudfunctions:v2alpha : SecretEnvVar
/// - cloudfunctions:v2beta : SecretEnvVar
class $SecretEnvVar {
  /// Name of the environment variable.
  core.String? key;

  /// Project identifier (preferably project number but can also be the project
  /// ID) of the project that contains the secret.
  ///
  /// If not set, it is assumed that the secret is in the same project as the
  /// function.
  core.String? projectId;

  /// Name of the secret in secret manager (not the full resource name).
  core.String? secret;

  /// Version of the secret (version number or the string 'latest').
  ///
  /// It is recommended to use a numeric version for secret environment
  /// variables as any updates to the secret value is not reflected until new
  /// instances start.
  core.String? version;

  $SecretEnvVar({this.key, this.projectId, this.secret, this.version});

  $SecretEnvVar.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        secret: json_['secret'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (projectId != null) 'projectId': projectId!,
    if (secret != null) 'secret': secret!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - secretmanager:v1 : SecretPayload
/// - secretmanager:v1beta2 : SecretPayload
class $SecretPayload {
  /// The secret data.
  ///
  /// Must be no larger than 64KiB.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// If specified, SecretManagerService will verify the integrity of the
  /// received data on SecretManagerService.AddSecretVersion calls using the
  /// crc32c checksum and store it to include in future
  /// SecretManagerService.AccessSecretVersion responses.
  ///
  /// If a checksum is not provided in the SecretManagerService.AddSecretVersion
  /// request, the SecretManagerService will generate and store one for you. The
  /// CRC32C value is encoded as a Int64 for compatibility, and can be safely
  /// downconverted to uint32 in languages that support this type.
  /// https://cloud.google.com/apis/design/design_patterns#integer_types
  ///
  /// Optional.
  core.String? dataCrc32c;

  $SecretPayload({this.data, this.dataCrc32c});

  $SecretPayload.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        dataCrc32c: json_['dataCrc32c'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (dataCrc32c != null) 'dataCrc32c': dataCrc32c!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SecretRef
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SecretRef
class $SecretRef {
  /// The name of the secret in Cloud Secret Manager.
  ///
  /// Format: {secret_name}.
  ///
  /// Required.
  core.String? secret;

  /// The Cloud Secret Manager secret version.
  ///
  /// Can be 'latest' for the latest version, an integer for a specific version,
  /// or a version alias.
  core.String? version;

  $SecretRef({this.secret, this.version});

  $SecretRef.fromJson(core.Map json_)
    : this(
        secret: json_['secret'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (secret != null) 'secret': secret!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : SecretStatus
/// - containeranalysis:v1alpha1 : SecretStatus
/// - ondemandscanning:v1 : SecretStatus
/// - ondemandscanning:v1beta1 : SecretStatus
class $SecretStatus {
  /// Optional message about the status code.
  ///
  /// Optional.
  core.String? message;

  /// The status of the secret.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "STATUS_UNSPECIFIED" : Unspecified
  /// - "UNKNOWN" : The status of the secret is unknown.
  /// - "VALID" : The secret is valid.
  /// - "INVALID" : The secret is invalid.
  core.String? status;

  /// The time the secret status was last updated.
  ///
  /// Optional.
  core.String? updateTime;

  $SecretStatus({this.message, this.status, this.updateTime});

  $SecretStatus.fromJson(core.Map json_)
    : this(
        message: json_['message'] as core.String?,
        status: json_['status'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (message != null) 'message': message!,
    if (status != null) 'status': status!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : SecretVersion
/// - cloudfunctions:v2alpha : SecretVersion
/// - cloudfunctions:v2beta : SecretVersion
class $SecretVersion {
  /// Relative path of the file under the mount path where the secret value for
  /// this version will be fetched and made available.
  ///
  /// For example, setting the mount_path as '/etc/secrets' and path as
  /// `secret_foo` would mount the secret value file at
  /// `/etc/secrets/secret_foo`.
  core.String? path;

  /// Version of the secret (version number or the string 'latest').
  ///
  /// It is preferable to use `latest` version with secret volumes as secret
  /// value changes are reflected immediately.
  core.String? version;

  $SecretVersion({this.path, this.version});

  $SecretVersion.fromJson(core.Map json_)
    : this(
        path: json_['path'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (path != null) 'path': path!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - secretmanager:v1 : DestroySecretVersionRequest
/// - secretmanager:v1 : DisableSecretVersionRequest
/// - secretmanager:v1 : EnableSecretVersionRequest
/// - secretmanager:v1beta2 : DestroySecretVersionRequest
/// - secretmanager:v1beta2 : DisableSecretVersionRequest
/// - secretmanager:v1beta2 : EnableSecretVersionRequest
class $SecretVersionRequest {
  /// Etag of the SecretVersion.
  ///
  /// The request succeeds if it matches the etag of the currently stored secret
  /// version object. If the etag is omitted, the request succeeds.
  ///
  /// Optional.
  core.String? etag;

  $SecretVersionRequest({this.etag});

  $SecretVersionRequest.fromJson(core.Map json_)
    : this(etag: json_['etag'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig
/// - compute:beta : SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig
class $SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig {
  core.double? confidenceThreshold;
  core.int? expirationSec;
  core.double? impactedBaselineThreshold;
  core.double? loadThreshold;

  $SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig({
    this.confidenceThreshold,
    this.expirationSec,
    this.impactedBaselineThreshold,
    this.loadThreshold,
  });

  $SecurityPolicyAdaptiveProtectionConfigAutoDeployConfig.fromJson(
    core.Map json_,
  ) : this(
        confidenceThreshold:
            (json_['confidenceThreshold'] as core.num?)?.toDouble(),
        expirationSec: json_['expirationSec'] as core.int?,
        impactedBaselineThreshold:
            (json_['impactedBaselineThreshold'] as core.num?)?.toDouble(),
        loadThreshold: (json_['loadThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidenceThreshold != null)
      'confidenceThreshold': confidenceThreshold!,
    if (expirationSec != null) 'expirationSec': expirationSec!,
    if (impactedBaselineThreshold != null)
      'impactedBaselineThreshold': impactedBaselineThreshold!,
    if (loadThreshold != null) 'loadThreshold': loadThreshold!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig
/// - compute:beta : SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig
/// - compute:v1 : SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig
class $SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig {
  /// If enabled, traffic matching each unique value for the specified type
  /// constitutes a separate traffic unit.
  ///
  /// It can only be set to true if `value` is empty.
  core.bool? enableEachUniqueValue;

  /// Type of this configuration.
  /// Possible string values are:
  /// - "HTTP_HEADER_HOST"
  /// - "HTTP_PATH"
  /// - "UNSPECIFIED_TYPE"
  core.String? type;

  /// Requests that match this value constitute a granular traffic unit.
  core.String? value;

  $SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig({
    this.enableEachUniqueValue,
    this.type,
    this.value,
  });

  $SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig.fromJson(
    core.Map json_,
  ) : this(
        enableEachUniqueValue: json_['enableEachUniqueValue'] as core.bool?,
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableEachUniqueValue != null)
      'enableEachUniqueValue': enableEachUniqueValue!,
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyAdvancedOptionsConfigJsonCustomConfig
/// - compute:beta : SecurityPolicyAdvancedOptionsConfigJsonCustomConfig
/// - compute:v1 : SecurityPolicyAdvancedOptionsConfigJsonCustomConfig
class $SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
  /// A list of custom Content-Type header values to apply the JSON parsing.
  ///
  /// As per RFC 1341, a Content-Type header value has the following format:
  /// Content-Type := type "/" subtype *\[";" parameter\] When configuring a
  /// custom Content-Type header value, only the type/subtype needs to be
  /// specified, and the parameters should be excluded.
  core.List<core.String>? contentTypes;

  $SecurityPolicyAdvancedOptionsConfigJsonCustomConfig({this.contentTypes});

  $SecurityPolicyAdvancedOptionsConfigJsonCustomConfig.fromJson(core.Map json_)
    : this(
        contentTypes:
            (json_['contentTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentTypes != null) 'contentTypes': contentTypes!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyAssociation
/// - compute:beta : SecurityPolicyAssociation
class $SecurityPolicyAssociation {
  /// The resource that the security policy is attached to.
  core.String? attachmentId;

  /// The display name of the security policy of the association.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? displayName;

  /// A list of folders to exclude from the security policy.
  core.List<core.String>? excludedFolders;

  /// A list of projects to exclude from the security policy.
  core.List<core.String>? excludedProjects;

  /// The name for an association.
  core.String? name;

  /// The security policy ID of the association.
  ///
  /// Output only.
  core.String? securityPolicyId;

  /// The short name of the security policy of the association.
  ///
  /// Output only.
  core.String? shortName;

  $SecurityPolicyAssociation({
    this.attachmentId,
    this.displayName,
    this.excludedFolders,
    this.excludedProjects,
    this.name,
    this.securityPolicyId,
    this.shortName,
  });

  $SecurityPolicyAssociation.fromJson(core.Map json_)
    : this(
        attachmentId: json_['attachmentId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        excludedFolders:
            (json_['excludedFolders'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludedProjects:
            (json_['excludedProjects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        securityPolicyId: json_['securityPolicyId'] as core.String?,
        shortName: json_['shortName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachmentId != null) 'attachmentId': attachmentId!,
    if (displayName != null) 'displayName': displayName!,
    if (excludedFolders != null) 'excludedFolders': excludedFolders!,
    if (excludedProjects != null) 'excludedProjects': excludedProjects!,
    if (name != null) 'name': name!,
    if (securityPolicyId != null) 'securityPolicyId': securityPolicyId!,
    if (shortName != null) 'shortName': shortName!,
  };
}

/// Used by:
///
/// - compute:beta : SecurityPolicyDdosProtectionConfig
/// - compute:v1 : SecurityPolicyDdosProtectionConfig
class $SecurityPolicyDdosProtectionConfig {
  ///
  /// Possible string values are:
  /// - "ADVANCED"
  /// - "ADVANCED_PREVIEW"
  /// - "STANDARD"
  core.String? ddosProtection;

  $SecurityPolicyDdosProtectionConfig({this.ddosProtection});

  $SecurityPolicyDdosProtectionConfig.fromJson(core.Map json_)
    : this(ddosProtection: json_['ddosProtection'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ddosProtection != null) 'ddosProtection': ddosProtection!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRecaptchaOptionsConfig
/// - compute:beta : SecurityPolicyRecaptchaOptionsConfig
/// - compute:v1 : SecurityPolicyRecaptchaOptionsConfig
class $SecurityPolicyRecaptchaOptionsConfig {
  /// An optional field to supply a reCAPTCHA site key to be used for all the
  /// rules using the redirect action with the type of GOOGLE_RECAPTCHA under
  /// the security policy.
  ///
  /// The specified site key needs to be created from the reCAPTCHA API. The
  /// user is responsible for the validity of the specified site key. If not
  /// specified, a Google-managed site key is used. This field is only supported
  /// in Global Security Policies of type CLOUD_ARMOR.
  core.String? redirectSiteKey;

  $SecurityPolicyRecaptchaOptionsConfig({this.redirectSiteKey});

  $SecurityPolicyRecaptchaOptionsConfig.fromJson(core.Map json_)
    : this(redirectSiteKey: json_['redirectSiteKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (redirectSiteKey != null) 'redirectSiteKey': redirectSiteKey!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyReference
/// - compute:beta : SecurityPolicyReference
/// - compute:v1 : SecurityPolicyReference
class $SecurityPolicyReference {
  core.String? securityPolicy;

  $SecurityPolicyReference({this.securityPolicy});

  $SecurityPolicyReference.fromJson(core.Map json_)
    : this(securityPolicy: json_['securityPolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleHttpHeaderActionHttpHeaderOption
/// - compute:beta : SecurityPolicyRuleHttpHeaderActionHttpHeaderOption
/// - compute:v1 : SecurityPolicyRuleHttpHeaderActionHttpHeaderOption
class $SecurityPolicyRuleHttpHeaderActionHttpHeaderOption {
  /// The name of the header to set.
  core.String? headerName;

  /// The value to set the named header to.
  core.String? headerValue;

  $SecurityPolicyRuleHttpHeaderActionHttpHeaderOption({
    this.headerName,
    this.headerValue,
  });

  $SecurityPolicyRuleHttpHeaderActionHttpHeaderOption.fromJson(core.Map json_)
    : this(
        headerName: json_['headerName'] as core.String?,
        headerValue: json_['headerValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (headerName != null) 'headerName': headerName!,
    if (headerValue != null) 'headerValue': headerValue!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions
/// - compute:beta : SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions
/// - compute:v1 : SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions
class $SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions {
  /// A list of site keys to be used during the validation of reCAPTCHA
  /// action-tokens.
  ///
  /// The provided site keys need to be created from reCAPTCHA API under the
  /// same project where the security policy is created.
  core.List<core.String>? actionTokenSiteKeys;

  /// A list of site keys to be used during the validation of reCAPTCHA
  /// session-tokens.
  ///
  /// The provided site keys need to be created from reCAPTCHA API under the
  /// same project where the security policy is created.
  core.List<core.String>? sessionTokenSiteKeys;

  $SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions({
    this.actionTokenSiteKeys,
    this.sessionTokenSiteKeys,
  });

  $SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions.fromJson(core.Map json_)
    : this(
        actionTokenSiteKeys:
            (json_['actionTokenSiteKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sessionTokenSiteKeys:
            (json_['sessionTokenSiteKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actionTokenSiteKeys != null)
      'actionTokenSiteKeys': actionTokenSiteKeys!,
    if (sessionTokenSiteKeys != null)
      'sessionTokenSiteKeys': sessionTokenSiteKeys!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch
/// - compute:beta : SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch
/// - compute:v1 : SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch
class $SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch {
  /// Name of the user-defined field, as given in the definition.
  core.String? name;

  /// Matching values of the field.
  ///
  /// Each element can be a 32-bit unsigned decimal or hexadecimal (starting
  /// with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
  core.List<core.String>? values;

  $SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch({
    this.name,
    this.values,
  });

  $SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch.fromJson(
    core.Map json_,
  ) : this(
        name: json_['name'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams
/// - compute:beta : SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams
/// - compute:v1 : SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams
class $SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams {
  /// The match operator for the field.
  /// Possible string values are:
  /// - "CONTAINS" : The operator matches if the field value contains the
  /// specified value.
  /// - "ENDS_WITH" : The operator matches if the field value ends with the
  /// specified value.
  /// - "EQUALS" : The operator matches if the field value equals the specified
  /// value.
  /// - "EQUALS_ANY" : The operator matches if the field value is any value.
  /// - "STARTS_WITH" : The operator matches if the field value starts with the
  /// specified value.
  core.String? op;

  /// The value of the field.
  core.String? val;

  $SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams({
    this.op,
    this.val,
  });

  $SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams.fromJson(
    core.Map json_,
  ) : this(op: json_['op'] as core.String?, val: json_['val'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (op != null) 'op': op!,
    if (val != null) 'val': val!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig
/// - compute:beta : SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig
class $SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
  /// Rate limit key name applicable only for the following key types:
  /// HTTP_HEADER -- Name of the HTTP header whose value is taken as the key
  /// value.
  ///
  /// HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key
  /// value.
  core.String? enforceOnKeyName;

  /// Determines the key to enforce the rate_limit_threshold on.
  ///
  /// Possible values are: - ALL: A single rate limit threshold is applied to
  /// all the requests matching this rule. This is the default value if
  /// "enforceOnKeyConfigs" is not configured. - IP: The source IP address of
  /// the request is the key. Each IP has this limit enforced separately. -
  /// HTTP_HEADER: The value of the HTTP header whose name is configured under
  /// "enforceOnKeyName". The key value is truncated to the first 128 bytes of
  /// the header value. If no such header is present in the request, the key
  /// type defaults to ALL. - XFF_IP: The first IP address (i.e. the originating
  /// client IP address) specified in the list of IPs under X-Forwarded-For HTTP
  /// header. If no such header is present or the value is not a valid IP, the
  /// key defaults to the source IP address of the request i.e. key type IP. -
  /// HTTP_COOKIE: The value of the HTTP cookie whose name is configured under
  /// "enforceOnKeyName". The key value is truncated to the first 128 bytes of
  /// the cookie value. If no such cookie is present in the request, the key
  /// type defaults to ALL. - HTTP_PATH: The URL path of the HTTP request. The
  /// key value is truncated to the first 128 bytes. - SNI: Server name
  /// indication in the TLS session of the HTTPS request. The key value is
  /// truncated to the first 128 bytes. The key type defaults to ALL on a HTTP
  /// session. - REGION_CODE: The country/region from which the request
  /// originates. - TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client
  /// connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type
  /// defaults to ALL. - USER_IP: The IP address of the originating client,
  /// which is resolved based on "userIpRequestHeaders" configured with the
  /// security policy. If there is no "userIpRequestHeaders" configuration or an
  /// IP address cannot be resolved from it, the key type defaults to IP. -
  /// TLS_JA4_FINGERPRINT: JA4 TLS/SSL fingerprint if the client connects using
  /// HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL.
  /// Possible string values are:
  /// - "ALL"
  /// - "ALL_IPS"
  /// - "HTTP_COOKIE"
  /// - "HTTP_HEADER"
  /// - "HTTP_PATH"
  /// - "IP"
  /// - "REGION_CODE"
  /// - "SNI"
  /// - "TLS_JA3_FINGERPRINT"
  /// - "TLS_JA4_FINGERPRINT"
  /// - "USER_IP"
  /// - "XFF_IP"
  core.String? enforceOnKeyType;

  $SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig({
    this.enforceOnKeyName,
    this.enforceOnKeyType,
  });

  $SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig.fromJson(core.Map json_)
    : this(
        enforceOnKeyName: json_['enforceOnKeyName'] as core.String?,
        enforceOnKeyType: json_['enforceOnKeyType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enforceOnKeyName != null) 'enforceOnKeyName': enforceOnKeyName!,
    if (enforceOnKeyType != null) 'enforceOnKeyType': enforceOnKeyType!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleRateLimitOptionsThreshold
/// - compute:beta : SecurityPolicyRuleRateLimitOptionsThreshold
/// - compute:v1 : SecurityPolicyRuleRateLimitOptionsThreshold
class $SecurityPolicyRuleRateLimitOptionsThreshold {
  /// Number of HTTP(S) requests for calculating the threshold.
  core.int? count;

  /// Interval over which the threshold is computed.
  core.int? intervalSec;

  $SecurityPolicyRuleRateLimitOptionsThreshold({this.count, this.intervalSec});

  $SecurityPolicyRuleRateLimitOptionsThreshold.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.int?,
        intervalSec: json_['intervalSec'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (intervalSec != null) 'intervalSec': intervalSec!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleRedirectOptions
/// - compute:beta : SecurityPolicyRuleRedirectOptions
/// - compute:v1 : SecurityPolicyRuleRedirectOptions
class $SecurityPolicyRuleRedirectOptions {
  /// Target for the redirect action.
  ///
  /// This is required if the type is EXTERNAL_302 and cannot be specified for
  /// GOOGLE_RECAPTCHA.
  core.String? target;

  /// Type of the redirect action.
  ///
  /// Possible values are: - GOOGLE_RECAPTCHA: redirect to reCAPTCHA for manual
  /// challenge assessment. - EXTERNAL_302: redirect to a different URL via a
  /// 302 response.
  /// Possible string values are:
  /// - "EXTERNAL_302"
  /// - "GOOGLE_RECAPTCHA"
  core.String? type;

  $SecurityPolicyRuleRedirectOptions({this.target, this.type});

  $SecurityPolicyRuleRedirectOptions.fromJson(core.Map json_)
    : this(
        target: json_['target'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (target != null) 'target': target!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyUserDefinedField
/// - compute:beta : SecurityPolicyUserDefinedField
/// - compute:v1 : SecurityPolicyUserDefinedField
class $SecurityPolicyUserDefinedField {
  /// The base relative to which 'offset' is measured.
  ///
  /// Possible values are: - IPV4: Points to the beginning of the IPv4 header. -
  /// IPV6: Points to the beginning of the IPv6 header. - TCP: Points to the
  /// beginning of the TCP header, skipping over any IPv4 options or IPv6
  /// extension headers. Not present for non-first fragments. - UDP: Points to
  /// the beginning of the UDP header, skipping over any IPv4 options or IPv6
  /// extension headers. Not present for non-first fragments. required
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "TCP"
  /// - "UDP"
  core.String? base;

  /// If specified, apply this mask (bitwise AND) to the field to ignore bits
  /// before matching.
  ///
  /// Encoded as a hexadecimal number (starting with "0x"). The last byte of the
  /// field (in network byte order) corresponds to the least significant byte of
  /// the mask.
  core.String? mask;

  /// The name of this field.
  ///
  /// Must be unique within the policy.
  core.String? name;

  /// Offset of the first byte of the field (in network byte order) relative to
  /// 'base'.
  core.int? offset;

  /// Size of the field in bytes.
  ///
  /// Valid values: 1-4.
  core.int? size;

  $SecurityPolicyUserDefinedField({
    this.base,
    this.mask,
    this.name,
    this.offset,
    this.size,
  });

  $SecurityPolicyUserDefinedField.fromJson(core.Map json_)
    : this(
        base: json_['base'] as core.String?,
        mask: json_['mask'] as core.String?,
        name: json_['name'] as core.String?,
        offset: json_['offset'] as core.int?,
        size: json_['size'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (base != null) 'base': base!,
    if (mask != null) 'mask': mask!,
    if (name != null) 'name': name!,
    if (offset != null) 'offset': offset!,
    if (size != null) 'size': size!,
  };
}

/// Used by:
///
/// - container:v1 : SecurityPostureConfig
/// - container:v1beta1 : SecurityPostureConfig
/// - gkehub:v1 : SecurityPostureConfig
/// - gkehub:v1alpha : SecurityPostureConfig
/// - gkehub:v1beta : SecurityPostureConfig
class $SecurityPostureConfig {
  /// Sets which mode to use for Security Posture features.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Default value not specified.
  /// - "DISABLED" : Disables Security Posture features on the cluster.
  /// - "BASIC" : Applies Security Posture features on the cluster.
  /// - "ENTERPRISE" : Applies the Security Posture off cluster Enterprise level
  /// features.
  core.String? mode;

  /// Sets which mode to use for vulnerability scanning.
  /// Possible string values are:
  /// - "VULNERABILITY_MODE_UNSPECIFIED" : Default value not specified.
  /// - "VULNERABILITY_DISABLED" : Disables vulnerability scanning on the
  /// cluster.
  /// - "VULNERABILITY_BASIC" : Applies basic vulnerability scanning on the
  /// cluster.
  /// - "VULNERABILITY_ENTERPRISE" : Applies the Security Posture's
  /// vulnerability on cluster Enterprise level features.
  core.String? vulnerabilityMode;

  $SecurityPostureConfig({this.mode, this.vulnerabilityMode});

  $SecurityPostureConfig.fromJson(core.Map json_)
    : this(
        mode: json_['mode'] as core.String?,
        vulnerabilityMode: json_['vulnerabilityMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
    if (vulnerabilityMode != null) 'vulnerabilityMode': vulnerabilityMode!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : SecurityProfileGroup
/// - networksecurity:v1beta1 : SecurityProfileGroup
class $SecurityProfileGroup {
  /// Resource creation timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// Reference to a SecurityProfile with the CustomIntercept configuration.
  ///
  /// Optional.
  core.String? customInterceptProfile;

  /// Reference to a SecurityProfile with the CustomMirroring configuration.
  ///
  /// Optional.
  core.String? customMirroringProfile;

  /// Identifier used by the data-path.
  ///
  /// Unique within {container, location}.
  ///
  /// Output only.
  core.String? dataPathId;

  /// An optional description of the profile group.
  ///
  /// Max length 2048 characters.
  ///
  /// Optional.
  core.String? description;

  /// This checksum is computed by the server based on the value of other
  /// fields, and may be sent on update and delete requests to ensure the client
  /// has an up-to-date value before proceeding.
  ///
  /// Output only.
  core.String? etag;

  /// Labels as key value pairs.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the SecurityProfileGroup resource. It matches pattern
  /// `projects|organizations / *
  /// /locations/{location}/securityProfileGroups/{security_profile_group}`.
  ///
  /// Immutable.
  core.String? name;

  /// Reference to a SecurityProfile with the ThreatPrevention configuration.
  ///
  /// Optional.
  core.String? threatPreventionProfile;

  /// Last resource update timestamp.
  ///
  /// Output only.
  core.String? updateTime;

  $SecurityProfileGroup({
    this.createTime,
    this.customInterceptProfile,
    this.customMirroringProfile,
    this.dataPathId,
    this.description,
    this.etag,
    this.labels,
    this.name,
    this.threatPreventionProfile,
    this.updateTime,
  });

  $SecurityProfileGroup.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        customInterceptProfile: json_['customInterceptProfile'] as core.String?,
        customMirroringProfile: json_['customMirroringProfile'] as core.String?,
        dataPathId: json_['dataPathId'] as core.String?,
        description: json_['description'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        threatPreventionProfile:
            json_['threatPreventionProfile'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (customInterceptProfile != null)
      'customInterceptProfile': customInterceptProfile!,
    if (customMirroringProfile != null)
      'customMirroringProfile': customMirroringProfile!,
    if (dataPathId != null) 'dataPathId': dataPathId!,
    if (description != null) 'description': description!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (threatPreventionProfile != null)
      'threatPreventionProfile': threatPreventionProfile!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SecuritySettingsAudioExportSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SecuritySettingsAudioExportSettings
class $SecuritySettingsAudioExportSettings {
  /// Filename pattern for exported audio.
  core.String? audioExportPattern;

  /// File format for exported audio file.
  ///
  /// Currently only in telephony recordings.
  /// Possible string values are:
  /// - "AUDIO_FORMAT_UNSPECIFIED" : Unspecified. Do not use.
  /// - "MULAW" : G.711 mu-law PCM with 8kHz sample rate.
  /// - "MP3" : MP3 file format.
  /// - "OGG" : OGG Vorbis.
  core.String? audioFormat;

  /// Enable audio redaction if it is true.
  ///
  /// Note that this only redacts end-user audio data; Synthesised audio from
  /// the virtual agent is not redacted.
  core.bool? enableAudioRedaction;

  /// Cloud Storage bucket to export audio record to.
  ///
  /// Setting this field would grant the Storage Object Creator role to the
  /// Dialogflow Service Agent. API caller that tries to modify this field
  /// should have the permission of storage.buckets.setIamPolicy.
  core.String? gcsBucket;

  /// Whether to store TTS audio.
  ///
  /// By default, TTS audio from the virtual agent is not exported.
  core.bool? storeTtsAudio;

  $SecuritySettingsAudioExportSettings({
    this.audioExportPattern,
    this.audioFormat,
    this.enableAudioRedaction,
    this.gcsBucket,
    this.storeTtsAudio,
  });

  $SecuritySettingsAudioExportSettings.fromJson(core.Map json_)
    : this(
        audioExportPattern: json_['audioExportPattern'] as core.String?,
        audioFormat: json_['audioFormat'] as core.String?,
        enableAudioRedaction: json_['enableAudioRedaction'] as core.bool?,
        gcsBucket: json_['gcsBucket'] as core.String?,
        storeTtsAudio: json_['storeTtsAudio'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioExportPattern != null) 'audioExportPattern': audioExportPattern!,
    if (audioFormat != null) 'audioFormat': audioFormat!,
    if (enableAudioRedaction != null)
      'enableAudioRedaction': enableAudioRedaction!,
    if (gcsBucket != null) 'gcsBucket': gcsBucket!,
    if (storeTtsAudio != null) 'storeTtsAudio': storeTtsAudio!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SecuritySettingsInsightsExportSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SecuritySettingsInsightsExportSettings
class $SecuritySettingsInsightsExportSettings {
  /// If enabled, we will automatically exports conversations to Insights and
  /// Insights runs its analyzers.
  core.bool? enableInsightsExport;

  $SecuritySettingsInsightsExportSettings({this.enableInsightsExport});

  $SecuritySettingsInsightsExportSettings.fromJson(core.Map json_)
    : this(enableInsightsExport: json_['enableInsightsExport'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableInsightsExport != null)
      'enableInsightsExport': enableInsightsExport!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Segment
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Segment
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1Segment
class $Segment00 {
  /// End index in the given Part, measured in bytes.
  ///
  /// Offset from the start of the Part, exclusive, starting at zero.
  ///
  /// Output only.
  core.int? endIndex;

  /// The index of a Part object within its parent Content object.
  ///
  /// Output only.
  core.int? partIndex;

  /// Start index in the given Part, measured in bytes.
  ///
  /// Offset from the start of the Part, inclusive, starting at zero.
  ///
  /// Output only.
  core.int? startIndex;

  /// The text corresponding to the segment from the response.
  ///
  /// Output only.
  core.String? text;

  $Segment00({this.endIndex, this.partIndex, this.startIndex, this.text});

  $Segment00.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.int?,
        partIndex: json_['partIndex'] as core.int?,
        startIndex: json_['startIndex'] as core.int?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (partIndex != null) 'partIndex': partIndex!,
    if (startIndex != null) 'startIndex': startIndex!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - healthcare:v1 : Segment
/// - healthcare:v1beta1 : Segment
class $Segment01 {
  /// A mapping from the positional location to the value.
  ///
  /// The key string uses zero-based indexes separated by dots to identify
  /// Fields, components and sub-components. A bracket notation is also used to
  /// identify different instances of a repeated field. Regex for key:
  /// (\d+)(\[\d+\])?(.\d+)?(.\d+)? Examples of (key, value) pairs: * (0.1,
  /// "hemoglobin") denotes that the first component of Field 0 has the value
  /// "hemoglobin". * (1.1.2, "CBC") denotes that the second sub-component of
  /// the first component of Field 1 has the value "CBC". * (1\[0\].1, "HbA1c")
  /// denotes that the first component of the first Instance of Field 1, which
  /// is repeated, has the value "HbA1c".
  core.Map<core.String, core.String>? fields;

  /// A string that indicates the type of segment.
  ///
  /// For example, EVN or PID.
  core.String? segmentId;

  /// Set ID for segments that can be in a set.
  ///
  /// This can be empty if it's missing or isn't applicable.
  core.String? setId;

  $Segment01({this.fields, this.segmentId, this.setId});

  $Segment01.fromJson(core.Map json_)
    : this(
        fields: (json_['fields'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        segmentId: json_['segmentId'] as core.String?,
        setId: json_['setId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fields != null) 'fields': fields!,
    if (segmentId != null) 'segmentId': segmentId!,
    if (setId != null) 'setId': setId!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SelectedObjects
/// - sqladmin:v1beta4 : SelectedObjects
class $SelectedObjects {
  /// The name of the database to migrate.
  ///
  /// Required.
  core.String? database;

  $SelectedObjects({this.database});

  $SelectedObjects.fromJson(core.Map json_)
    : this(database: json_['database'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (database != null) 'database': database!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : SemanticVersion
/// - trafficdirector:v3 : SemanticVersion
class $SemanticVersion {
  core.int? majorNumber;
  core.int? minorNumber;
  core.int? patch;

  $SemanticVersion({this.majorNumber, this.minorNumber, this.patch});

  $SemanticVersion.fromJson(core.Map json_)
    : this(
        majorNumber: json_['majorNumber'] as core.int?,
        minorNumber: json_['minorNumber'] as core.int?,
        patch: json_['patch'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (majorNumber != null) 'majorNumber': majorNumber!,
    if (minorNumber != null) 'minorNumber': minorNumber!,
    if (patch != null) 'patch': patch!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SensitiveCategoryAssignedTargetingOptionDetails
/// - displayvideo:v3 : SensitiveCategoryAssignedTargetingOptionDetails
/// - displayvideo:v4 : SensitiveCategoryAssignedTargetingOptionDetails
class $SensitiveCategoryAssignedTargetingOptionDetails {
  /// An enum for the DV360 Sensitive category content classified to be
  /// EXCLUDED.
  ///
  /// Required.
  /// Possible string values are:
  /// - "SENSITIVE_CATEGORY_UNSPECIFIED" : This enum is only a placeholder and
  /// doesn't specify a DV360 sensitive category.
  /// - "SENSITIVE_CATEGORY_ADULT" : Adult or pornographic text, image, or video
  /// content.
  /// - "SENSITIVE_CATEGORY_DEROGATORY" : Content that may be construed as
  /// biased against individuals, groups, or organizations based on criteria
  /// such as race, religion, disability, sex, age, veteran status, sexual
  /// orientation, gender identity, or political affiliation. May also indicate
  /// discussion of such content, for instance, in an academic or journalistic
  /// context.
  /// - "SENSITIVE_CATEGORY_DOWNLOADS_SHARING" : Content related to audio,
  /// video, or software downloads.
  /// - "SENSITIVE_CATEGORY_WEAPONS" : Contains content related to personal
  /// weapons, including knives, guns, small firearms, and ammunition. Selecting
  /// either "weapons" or "sensitive social issues" will result in selecting
  /// both.
  /// - "SENSITIVE_CATEGORY_GAMBLING" : Contains content related to betting or
  /// wagering in a real-world or online setting.
  /// - "SENSITIVE_CATEGORY_VIOLENCE" : Content which may be considered
  /// graphically violent, gory, gruesome, or shocking, such as street fighting
  /// videos, accident photos, descriptions of torture, etc.
  /// - "SENSITIVE_CATEGORY_SUGGESTIVE" : Adult content, as well as suggestive
  /// content that's not explicitly pornographic. This category includes all
  /// pages categorized as adult.
  /// - "SENSITIVE_CATEGORY_PROFANITY" : Prominent use of words considered
  /// indecent, such as curse words and sexual slang. Pages with only very
  /// occasional usage, such as news sites that might include such words in a
  /// quotation, are not included.
  /// - "SENSITIVE_CATEGORY_ALCOHOL" : Contains content related to alcoholic
  /// beverages, alcohol brands, recipes, etc.
  /// - "SENSITIVE_CATEGORY_DRUGS" : Contains content related to the
  /// recreational use of legal or illegal drugs, as well as to drug
  /// paraphernalia or cultivation.
  /// - "SENSITIVE_CATEGORY_TOBACCO" : Contains content related to tobacco and
  /// tobacco accessories, including lighters, humidors, ashtrays, etc.
  /// - "SENSITIVE_CATEGORY_POLITICS" : Political news and media, including
  /// discussions of social, governmental, and public policy.
  /// - "SENSITIVE_CATEGORY_RELIGION" : Content related to religious thought or
  /// beliefs.
  /// - "SENSITIVE_CATEGORY_TRAGEDY" : Content related to death, disasters,
  /// accidents, war, etc.
  /// - "SENSITIVE_CATEGORY_TRANSPORTATION_ACCIDENTS" : Content related to motor
  /// vehicle, aviation or other transportation accidents.
  /// - "SENSITIVE_CATEGORY_SENSITIVE_SOCIAL_ISSUES" : Issues that evoke strong,
  /// opposing views and spark debate. These include issues that are
  /// controversial in most countries and markets (such as abortion), as well as
  /// those that are controversial in specific countries and markets (such as
  /// immigration reform in the United States).
  /// - "SENSITIVE_CATEGORY_SHOCKING" : Content which may be considered shocking
  /// or disturbing, such as violent news stories, stunts, or toilet humor.
  /// - "SENSITIVE_CATEGORY_EMBEDDED_VIDEO" : YouTube videos embedded on
  /// websites outside of YouTube.com.
  /// - "SENSITIVE_CATEGORY_LIVE_STREAMING_VIDEO" : Video of live events
  /// streamed over the internet.
  core.String? excludedSensitiveCategory;

  $SensitiveCategoryAssignedTargetingOptionDetails({
    this.excludedSensitiveCategory,
  });

  $SensitiveCategoryAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        excludedSensitiveCategory:
            json_['excludedSensitiveCategory'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedSensitiveCategory != null)
      'excludedSensitiveCategory': excludedSensitiveCategory!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SensitiveCategoryTargetingOptionDetails
/// - displayvideo:v3 : SensitiveCategoryTargetingOptionDetails
/// - displayvideo:v4 : SensitiveCategoryTargetingOptionDetails
class $SensitiveCategoryTargetingOptionDetails {
  /// An enum for the DV360 Sensitive category content classifier.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SENSITIVE_CATEGORY_UNSPECIFIED" : This enum is only a placeholder and
  /// doesn't specify a DV360 sensitive category.
  /// - "SENSITIVE_CATEGORY_ADULT" : Adult or pornographic text, image, or video
  /// content.
  /// - "SENSITIVE_CATEGORY_DEROGATORY" : Content that may be construed as
  /// biased against individuals, groups, or organizations based on criteria
  /// such as race, religion, disability, sex, age, veteran status, sexual
  /// orientation, gender identity, or political affiliation. May also indicate
  /// discussion of such content, for instance, in an academic or journalistic
  /// context.
  /// - "SENSITIVE_CATEGORY_DOWNLOADS_SHARING" : Content related to audio,
  /// video, or software downloads.
  /// - "SENSITIVE_CATEGORY_WEAPONS" : Contains content related to personal
  /// weapons, including knives, guns, small firearms, and ammunition. Selecting
  /// either "weapons" or "sensitive social issues" will result in selecting
  /// both.
  /// - "SENSITIVE_CATEGORY_GAMBLING" : Contains content related to betting or
  /// wagering in a real-world or online setting.
  /// - "SENSITIVE_CATEGORY_VIOLENCE" : Content which may be considered
  /// graphically violent, gory, gruesome, or shocking, such as street fighting
  /// videos, accident photos, descriptions of torture, etc.
  /// - "SENSITIVE_CATEGORY_SUGGESTIVE" : Adult content, as well as suggestive
  /// content that's not explicitly pornographic. This category includes all
  /// pages categorized as adult.
  /// - "SENSITIVE_CATEGORY_PROFANITY" : Prominent use of words considered
  /// indecent, such as curse words and sexual slang. Pages with only very
  /// occasional usage, such as news sites that might include such words in a
  /// quotation, are not included.
  /// - "SENSITIVE_CATEGORY_ALCOHOL" : Contains content related to alcoholic
  /// beverages, alcohol brands, recipes, etc.
  /// - "SENSITIVE_CATEGORY_DRUGS" : Contains content related to the
  /// recreational use of legal or illegal drugs, as well as to drug
  /// paraphernalia or cultivation.
  /// - "SENSITIVE_CATEGORY_TOBACCO" : Contains content related to tobacco and
  /// tobacco accessories, including lighters, humidors, ashtrays, etc.
  /// - "SENSITIVE_CATEGORY_POLITICS" : Political news and media, including
  /// discussions of social, governmental, and public policy.
  /// - "SENSITIVE_CATEGORY_RELIGION" : Content related to religious thought or
  /// beliefs.
  /// - "SENSITIVE_CATEGORY_TRAGEDY" : Content related to death, disasters,
  /// accidents, war, etc.
  /// - "SENSITIVE_CATEGORY_TRANSPORTATION_ACCIDENTS" : Content related to motor
  /// vehicle, aviation or other transportation accidents.
  /// - "SENSITIVE_CATEGORY_SENSITIVE_SOCIAL_ISSUES" : Issues that evoke strong,
  /// opposing views and spark debate. These include issues that are
  /// controversial in most countries and markets (such as abortion), as well as
  /// those that are controversial in specific countries and markets (such as
  /// immigration reform in the United States).
  /// - "SENSITIVE_CATEGORY_SHOCKING" : Content which may be considered shocking
  /// or disturbing, such as violent news stories, stunts, or toilet humor.
  /// - "SENSITIVE_CATEGORY_EMBEDDED_VIDEO" : YouTube videos embedded on
  /// websites outside of YouTube.com.
  /// - "SENSITIVE_CATEGORY_LIVE_STREAMING_VIDEO" : Video of live events
  /// streamed over the internet.
  core.String? sensitiveCategory;

  $SensitiveCategoryTargetingOptionDetails({this.sensitiveCategory});

  $SensitiveCategoryTargetingOptionDetails.fromJson(core.Map json_)
    : this(sensitiveCategory: json_['sensitiveCategory'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sensitiveCategory != null) 'sensitiveCategory': sensitiveCategory!,
  };
}

/// Used by:
///
/// - language:v1beta2 : Sentiment
/// - language:v2 : Sentiment
class $Sentiment {
  /// A non-negative number in the \[0, +inf\] range, which represents the
  /// absolute magnitude of sentiment regardless of score (positive or
  /// negative).
  core.double? magnitude;

  /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
  /// sentiment).
  core.double? score;

  $Sentiment({this.magnitude, this.score});

  $Sentiment.fromJson(core.Map json_)
    : this(
        magnitude: (json_['magnitude'] as core.num?)?.toDouble(),
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (magnitude != null) 'magnitude': magnitude!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SentimentAnalysisRequestConfig
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SentimentAnalysisRequestConfig
class $SentimentAnalysisRequestConfig {
  /// Instructs the service to perform sentiment analysis on `query_text`.
  ///
  /// If not provided, sentiment analysis is not performed on `query_text`.
  core.bool? analyzeQueryTextSentiment;

  $SentimentAnalysisRequestConfig({this.analyzeQueryTextSentiment});

  $SentimentAnalysisRequestConfig.fromJson(core.Map json_)
    : this(
        analyzeQueryTextSentiment:
            json_['analyzeQueryTextSentiment'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (analyzeQueryTextSentiment != null)
      'analyzeQueryTextSentiment': analyzeQueryTextSentiment!,
  };
}

/// Used by:
///
/// - compute:alpha : SerialPortOutput
/// - compute:beta : SerialPortOutput
/// - compute:v1 : SerialPortOutput
class $SerialPortOutput {
  /// The contents of the console output.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#serialPortOutput for serial port output.
  ///
  /// Output only.
  core.String? kind;

  /// The position of the next byte of content, regardless of whether the
  /// content exists, following the output returned in the `contents` property.
  ///
  /// Use this value in the next request as the start parameter.
  ///
  /// Output only.
  core.String? next;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The starting byte position of the output that was returned.
  ///
  /// This should match the start parameter sent with the request. If the serial
  /// console output exceeds the size of the buffer (1 MB), older output is
  /// overwritten by newer content. The output start value will indicate the
  /// byte position of the output that was returned, which might be different
  /// than the `start` value that was specified in the request.
  core.String? start;

  $SerialPortOutput({
    this.contents,
    this.kind,
    this.next,
    this.selfLink,
    this.start,
  });

  $SerialPortOutput.fromJson(core.Map json_)
    : this(
        contents: json_['contents'] as core.String?,
        kind: json_['kind'] as core.String?,
        next: json_['next'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        start: json_['start'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (kind != null) 'kind': kind!,
    if (next != null) 'next': next!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (start != null) 'start': start!,
  };
}

/// Used by:
///
/// - healthcare:v1 : SeriesMetrics
/// - healthcare:v1beta1 : SeriesMetrics
class $SeriesMetrics {
  /// Total blob storage bytes for all instances in the series.
  core.String? blobStorageSizeBytes;

  /// Number of instances in the series.
  core.String? instanceCount;

  /// The series resource path.
  ///
  /// For example,
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}/dicomWeb/studies/{study_uid}/series/{series_uid}`.
  core.String? series;

  /// Total structured storage bytes for all instances in the series.
  core.String? structuredStorageSizeBytes;

  $SeriesMetrics({
    this.blobStorageSizeBytes,
    this.instanceCount,
    this.series,
    this.structuredStorageSizeBytes,
  });

  $SeriesMetrics.fromJson(core.Map json_)
    : this(
        blobStorageSizeBytes: json_['blobStorageSizeBytes'] as core.String?,
        instanceCount: json_['instanceCount'] as core.String?,
        series: json_['series'] as core.String?,
        structuredStorageSizeBytes:
            json_['structuredStorageSizeBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobStorageSizeBytes != null)
      'blobStorageSizeBytes': blobStorageSizeBytes!,
    if (instanceCount != null) 'instanceCount': instanceCount!,
    if (series != null) 'series': series!,
    if (structuredStorageSizeBytes != null)
      'structuredStorageSizeBytes': structuredStorageSizeBytes!,
  };
}

/// Used by:
///
/// - compute:alpha : ServerBinding
/// - compute:beta : ServerBinding
/// - compute:v1 : ServerBinding
class $ServerBinding {
  ///
  /// Possible string values are:
  /// - "RESTART_NODE_ON_ANY_SERVER" : Node may associate with any physical
  /// server over its lifetime.
  /// - "RESTART_NODE_ON_MINIMAL_SERVERS" : Node may associate with minimal
  /// physical servers over its lifetime.
  /// - "SERVER_BINDING_TYPE_UNSPECIFIED"
  core.String? type;

  $ServerBinding({this.type});

  $ServerBinding.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : ServerlessExternalConnectionInfo
/// - networkmanagement:v1beta1 : ServerlessExternalConnectionInfo
class $ServerlessExternalConnectionInfo {
  /// Selected starting IP address, from the Google dynamic address pool.
  core.String? selectedIpAddress;

  $ServerlessExternalConnectionInfo({this.selectedIpAddress});

  $ServerlessExternalConnectionInfo.fromJson(core.Map json_)
    : this(selectedIpAddress: json_['selectedIpAddress'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (selectedIpAddress != null) 'selectedIpAddress': selectedIpAddress!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : ServerlessNegInfo
/// - networkmanagement:v1beta1 : ServerlessNegInfo
class $ServerlessNegInfo {
  /// URI of the serverless network endpoint group.
  core.String? negUri;

  $ServerlessNegInfo({this.negUri});

  $ServerlessNegInfo.fromJson(core.Map json_)
    : this(negUri: json_['negUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (negUri != null) 'negUri': negUri!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : Service
/// - firebasedataconnect:v1beta : Service
class $Service {
  /// Stores small amounts of arbitrary data.
  ///
  /// Optional.
  core.Map<core.String, core.String>? annotations;

  /// Create time stamp.
  ///
  /// Output only.
  core.String? createTime;

  /// Mutable human-readable name.
  ///
  /// 63 character limit.
  ///
  /// Optional.
  core.String? displayName;

  /// This checksum is computed by the server based on the value of other
  /// fields, and may be sent on update and delete requests to ensure the client
  /// has an up-to-date value before proceeding.
  ///
  /// \[AIP-154\](https://google.aip.dev/154)
  ///
  /// Output only.
  core.String? etag;

  /// Labels as key value pairs.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The relative resource name of the Firebase Data Connect service, in the
  /// format: ``` projects/{project}/locations/{location}/services/{service} ```
  /// Note that the service ID is specific to Firebase Data Connect and does not
  /// correspond to any of the instance IDs of the underlying data source
  /// connections.
  core.String? name;

  /// A field that if true, indicates that the system is working update the
  /// service.
  ///
  /// Output only.
  core.bool? reconciling;

  /// System-assigned, unique identifier.
  ///
  /// Output only.
  core.String? uid;

  /// Update time stamp.
  ///
  /// Output only.
  core.String? updateTime;

  $Service({
    this.annotations,
    this.createTime,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.reconciling,
    this.uid,
    this.updateTime,
  });

  $Service.fromJson(core.Map json_)
    : this(
        annotations: (json_['annotations']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        reconciling: json_['reconciling'] as core.bool?,
        uid: json_['uid'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (reconciling != null) 'reconciling': reconciling!,
    if (uid != null) 'uid': uid!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : ServiceAccount
/// - deploymentmanager:v2beta : ServiceAccount
class $ServiceAccount00 {
  /// The IAM service account email address like
  /// test@myproject.iam.gserviceaccount.com
  core.String? email;

  $ServiceAccount00({this.email});

  $ServiceAccount00.fromJson(core.Map json_)
    : this(email: json_['email'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
  };
}

/// Used by:
///
/// - tpu:v2 : ServiceAccount
/// - tpu:v2alpha1 : ServiceAccount
class $ServiceAccount01 {
  /// Email address of the service account.
  ///
  /// If empty, default Compute service account will be used.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  ///
  /// If empty, access to all Cloud APIs will be allowed.
  core.List<core.String>? scope;

  $ServiceAccount01({this.email, this.scope});

  $ServiceAccount01.fromJson(core.Map json_)
    : this(
        email: json_['email'] as core.String?,
        scope:
            (json_['scope'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ServiceAccount
/// - vmmigration:v1alpha1 : ServiceAccount
class $ServiceAccount02 {
  /// The email address of the service account.
  ///
  /// Required.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  ///
  /// Optional.
  core.List<core.String>? scopes;

  $ServiceAccount02({this.email, this.scopes});

  $ServiceAccount02.fromJson(core.Map json_)
    : this(
        email: json_['email'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
    if (scopes != null) 'scopes': scopes!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ServiceAccountSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ServiceAccountSpec
class $ServiceAccountSpec {
  /// If true, custom user-managed service account is enforced to run any
  /// workloads (for example, Vertex Jobs) on the resource.
  ///
  /// Otherwise, uses the
  /// [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  ///
  /// Required.
  core.bool? enableCustomServiceAccount;

  /// Required when all below conditions are met *
  /// `enable_custom_service_account` is true; * any runtime is specified via
  /// `ResourceRuntimeSpec` on creation time, for example, Ray The users must
  /// have `iam.serviceAccounts.actAs` permission on this service account and
  /// then the specified runtime containers will run as it.
  ///
  /// Do not set this field if you want to submit jobs using custom service
  /// account to this PersistentResource after creation, but only specify the
  /// `service_account` inside the job.
  ///
  /// Optional.
  core.String? serviceAccount;

  $ServiceAccountSpec({this.enableCustomServiceAccount, this.serviceAccount});

  $ServiceAccountSpec.fromJson(core.Map json_)
    : this(
        enableCustomServiceAccount:
            json_['enableCustomServiceAccount'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableCustomServiceAccount != null)
      'enableCustomServiceAccount': enableCustomServiceAccount!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// Used by:
///
/// - compute:beta : ServiceAttachmentConnectedEndpoint
/// - compute:v1 : ServiceAttachmentConnectedEndpoint
class $ServiceAttachmentConnectedEndpoint {
  /// The url of the consumer network.
  core.String? consumerNetwork;

  /// The url of a connected endpoint.
  core.String? endpoint;

  /// The number of consumer Network Connectivity Center spokes that the
  /// connected Private Service Connect endpoint has propagated to.
  core.int? propagatedConnectionCount;

  /// The PSC connection id of the connected endpoint.
  core.String? pscConnectionId;

  /// The status of a connected endpoint to this service attachment.
  /// Possible string values are:
  /// - "ACCEPTED" : The connection has been accepted by the producer.
  /// - "CLOSED" : The connection has been closed by the producer.
  /// - "NEEDS_ATTENTION" : The connection has been accepted by the producer,
  /// but the producer needs to take further action before the forwarding rule
  /// can serve traffic.
  /// - "PENDING" : The connection is pending acceptance by the producer.
  /// - "REJECTED" : The consumer is still connected but not using the
  /// connection.
  /// - "STATUS_UNSPECIFIED"
  core.String? status;

  $ServiceAttachmentConnectedEndpoint({
    this.consumerNetwork,
    this.endpoint,
    this.propagatedConnectionCount,
    this.pscConnectionId,
    this.status,
  });

  $ServiceAttachmentConnectedEndpoint.fromJson(core.Map json_)
    : this(
        consumerNetwork: json_['consumerNetwork'] as core.String?,
        endpoint: json_['endpoint'] as core.String?,
        propagatedConnectionCount:
            json_['propagatedConnectionCount'] as core.int?,
        pscConnectionId: json_['pscConnectionId'] as core.String?,
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumerNetwork != null) 'consumerNetwork': consumerNetwork!,
    if (endpoint != null) 'endpoint': endpoint!,
    if (propagatedConnectionCount != null)
      'propagatedConnectionCount': propagatedConnectionCount!,
    if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:alpha : ServiceAttachmentConsumerProjectLimit
/// - compute:beta : ServiceAttachmentConsumerProjectLimit
/// - compute:v1 : ServiceAttachmentConsumerProjectLimit
class $ServiceAttachmentConsumerProjectLimit {
  /// The value of the limit to set.
  ///
  /// For endpoint_url, the limit should be no more than 1.
  core.int? connectionLimit;

  /// The network URL for the network to set the limit for.
  core.String? networkUrl;

  /// The project id or number for the project to set the limit for.
  core.String? projectIdOrNum;

  $ServiceAttachmentConsumerProjectLimit({
    this.connectionLimit,
    this.networkUrl,
    this.projectIdOrNum,
  });

  $ServiceAttachmentConsumerProjectLimit.fromJson(core.Map json_)
    : this(
        connectionLimit: json_['connectionLimit'] as core.int?,
        networkUrl: json_['networkUrl'] as core.String?,
        projectIdOrNum: json_['projectIdOrNum'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectionLimit != null) 'connectionLimit': connectionLimit!,
    if (networkUrl != null) 'networkUrl': networkUrl!,
    if (projectIdOrNum != null) 'projectIdOrNum': projectIdOrNum!,
  };
}

/// Used by:
///
/// - compute:alpha : ServiceAttachmentTunnelingConfig
/// - compute:beta : ServiceAttachmentTunnelingConfig
class $ServiceAttachmentTunnelingConfig {
  /// Specify the encapsulation protocol and what metadata to include in
  /// incoming encapsulated packet headers.
  /// Possible string values are:
  /// - "GENEVE_SECURITY_V1" : Use GENEVE encapsulation protocol and include the
  /// SECURITY_V1 set of GENEVE headers.
  /// - "UNSPECIFIED_ENCAPSULATION_PROFILE"
  core.String? encapsulationProfile;

  /// How this Service Attachment will treat traffic sent to the tunnel_ip,
  /// destined for the consumer network.
  /// Possible string values are:
  /// - "PACKET_INJECTION" : Traffic sent to this service attachment will be
  /// reinjected into the consumer network.
  /// - "STANDARD_ROUTING" : Response traffic, after de-encapsulation, will be
  /// returned to the client.
  /// - "UNSPECIFIED_ROUTING_MODE"
  core.String? routingMode;

  $ServiceAttachmentTunnelingConfig({
    this.encapsulationProfile,
    this.routingMode,
  });

  $ServiceAttachmentTunnelingConfig.fromJson(core.Map json_)
    : this(
        encapsulationProfile: json_['encapsulationProfile'] as core.String?,
        routingMode: json_['routingMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encapsulationProfile != null)
      'encapsulationProfile': encapsulationProfile!,
    if (routingMode != null) 'routingMode': routingMode!,
  };
}

/// Used by:
///
/// - networkservices:v1 : ServiceBinding
/// - networkservices:v1beta1 : ServiceBinding
class $ServiceBinding {
  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A free-text description of the resource.
  ///
  /// Max length 1024 characters.
  ///
  /// Optional.
  core.String? description;

  /// Set of label tags associated with the ServiceBinding resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the ServiceBinding resource. It matches pattern `projects / *
  /// /locations / * /serviceBindings/`.
  core.String? name;

  /// The full Service Directory Service name of the format `projects / *
  /// /locations / * /namespaces / * /services / * `.
  ///
  /// This field is for Service Directory integration which will be deprecated
  /// soon.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? service;

  /// The unique identifier of the Service Directory Service against which the
  /// ServiceBinding resource is validated.
  ///
  /// This is populated when the Service Binding resource is used in another
  /// resource (like Backend Service). This is of the UUID4 format. This field
  /// is for Service Directory integration which will be deprecated soon.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? serviceId;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $ServiceBinding({
    this.createTime,
    this.description,
    this.labels,
    this.name,
    this.service,
    this.serviceId,
    this.updateTime,
  });

  $ServiceBinding.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        service: json_['service'] as core.String?,
        serviceId: json_['serviceId'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (service != null) 'service': service!,
    if (serviceId != null) 'serviceId': serviceId!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - cloudbuild:v2 : GoogleDevtoolsCloudbuildV2ServiceDirectoryConfig
/// - developerconnect:v1 : ServiceDirectoryConfig
class $ServiceDirectoryConfig {
  /// The Service Directory service name.
  ///
  /// Format:
  /// projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
  ///
  /// Required.
  core.String? service;

  $ServiceDirectoryConfig({this.service});

  $ServiceDirectoryConfig.fromJson(core.Map json_)
    : this(service: json_['service'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - container:v1 : ServiceExternalIPsConfig
/// - container:v1beta1 : ServiceExternalIPsConfig
class $ServiceExternalIPsConfig {
  /// Whether Services with ExternalIPs field are allowed or not.
  core.bool? enabled;

  $ServiceExternalIPsConfig({this.enabled});

  $ServiceExternalIPsConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - tpu:v2 : ServiceIdentity
/// - tpu:v2alpha1 : ServiceIdentity
class $ServiceIdentity {
  /// The email address of the service identity.
  core.String? email;

  $ServiceIdentity({this.email});

  $ServiceIdentity.fromJson(core.Map json_)
    : this(email: json_['email'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
  };
}

/// Used by:
///
/// - networkservices:v1 : ServiceLbPolicyAutoCapacityDrain
/// - networkservices:v1beta1 : ServiceLbPolicyAutoCapacityDrain
class $ServiceLbPolicyAutoCapacityDrain {
  /// If set to 'True', an unhealthy IG/NEG will be set as drained.
  ///
  /// - An IG/NEG is considered unhealthy if less than 25% of the
  /// instances/endpoints in the IG/NEG are healthy. - This option will never
  /// result in draining more than 50% of the configured IGs/NEGs for the
  /// Backend Service.
  ///
  /// Optional.
  core.bool? enable;

  $ServiceLbPolicyAutoCapacityDrain({this.enable});

  $ServiceLbPolicyAutoCapacityDrain.fromJson(core.Map json_)
    : this(enable: json_['enable'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
  };
}

/// Used by:
///
/// - networkservices:v1 : ServiceLbPolicyFailoverConfig
/// - networkservices:v1beta1 : ServiceLbPolicyFailoverConfig
class $ServiceLbPolicyFailoverConfig {
  /// The percentage threshold that a load balancer will begin to send traffic
  /// to failover backends.
  ///
  /// If the percentage of endpoints in a MIG/NEG is smaller than this value,
  /// traffic would be sent to failover backends if possible. This field should
  /// be set to a value between 1 and 99. The default value is 50 for Global
  /// external HTTP(S) load balancer (classic) and Proxyless service mesh, and
  /// 70 for others.
  ///
  /// Optional.
  core.int? failoverHealthThreshold;

  $ServiceLbPolicyFailoverConfig({this.failoverHealthThreshold});

  $ServiceLbPolicyFailoverConfig.fromJson(core.Map json_)
    : this(
        failoverHealthThreshold: json_['failoverHealthThreshold'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (failoverHealthThreshold != null)
      'failoverHealthThreshold': failoverHealthThreshold!,
  };
}

/// Used by:
///
/// - networkservices:v1 : ServiceLbPolicyIsolationConfig
/// - networkservices:v1beta1 : ServiceLbPolicyIsolationConfig
class $ServiceLbPolicyIsolationConfig {
  /// The isolation granularity of the load balancer.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ISOLATION_GRANULARITY_UNSPECIFIED" : No isolation is configured for the
  /// backend service. Traffic can overflow based on the load balancing
  /// algorithm.
  /// - "REGION" : Traffic for this service will be isolated at the cloud region
  /// level.
  core.String? isolationGranularity;

  /// The isolation mode of the load balancer.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ISOLATION_MODE_UNSPECIFIED" : No isolation mode is configured for the
  /// backend service.
  /// - "NEAREST" : Traffic will be sent to the nearest region.
  /// - "STRICT" : Traffic will fail if no serving backends are available in the
  /// same region as the load balancer.
  core.String? isolationMode;

  $ServiceLbPolicyIsolationConfig({
    this.isolationGranularity,
    this.isolationMode,
  });

  $ServiceLbPolicyIsolationConfig.fromJson(core.Map json_)
    : this(
        isolationGranularity: json_['isolationGranularity'] as core.String?,
        isolationMode: json_['isolationMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isolationGranularity != null)
      'isolationGranularity': isolationGranularity!,
    if (isolationMode != null) 'isolationMode': isolationMode!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ServiceMeshCondition
/// - gkehub:v1alpha : ServiceMeshCondition
/// - gkehub:v1beta : ServiceMeshCondition
/// - gkehub:v2 : ServiceMeshCondition
/// - gkehub:v2alpha : ServiceMeshCondition
/// - gkehub:v2beta : ServiceMeshCondition
class $ServiceMeshCondition {
  /// Unique identifier of the condition which describes the condition
  /// recognizable to the user.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Default Unspecified code
  /// - "MESH_IAM_PERMISSION_DENIED" : Mesh IAM permission denied error code
  /// - "MESH_IAM_CROSS_PROJECT_PERMISSION_DENIED" : Permission denied error
  /// code for cross-project
  /// - "CNI_CONFIG_UNSUPPORTED" : CNI config unsupported error code
  /// - "GKE_SANDBOX_UNSUPPORTED" : GKE sandbox unsupported error code
  /// - "NODEPOOL_WORKLOAD_IDENTITY_FEDERATION_REQUIRED" : Nodepool workload
  /// identity federation required error code
  /// - "CNI_INSTALLATION_FAILED" : CNI installation failed error code
  /// - "CNI_POD_UNSCHEDULABLE" : CNI pod unschedulable error code
  /// - "CLUSTER_HAS_ZERO_NODES" : Cluster has zero node code
  /// - "CANONICAL_SERVICE_ERROR" : Failure to reconcile CanonicalServices
  /// - "UNSUPPORTED_MULTIPLE_CONTROL_PLANES" : Multiple control planes
  /// unsupported error code
  /// - "VPCSC_GA_SUPPORTED" : VPC-SC GA is supported for this control plane.
  /// - "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT" : User is using deprecated
  /// ControlPlaneManagement and they have not yet set Management.
  /// - "DEPRECATED_SPEC_CONTROL_PLANE_MANAGEMENT_SAFE" : User is using
  /// deprecated ControlPlaneManagement and they have already set Management.
  /// - "CONFIG_APPLY_INTERNAL_ERROR" : Configuration (Istio/k8s resources)
  /// failed to apply due to internal error.
  /// - "CONFIG_VALIDATION_ERROR" : Configuration failed to be applied due to
  /// being invalid.
  /// - "CONFIG_VALIDATION_WARNING" : Encountered configuration(s) with possible
  /// unintended behavior or invalid configuration. These configs may not have
  /// been applied.
  /// - "QUOTA_EXCEEDED_BACKEND_SERVICES" : BackendService quota exceeded error
  /// code.
  /// - "QUOTA_EXCEEDED_HEALTH_CHECKS" : HealthCheck quota exceeded error code.
  /// - "QUOTA_EXCEEDED_HTTP_ROUTES" : HTTPRoute quota exceeded error code.
  /// - "QUOTA_EXCEEDED_TCP_ROUTES" : TCPRoute quota exceeded error code.
  /// - "QUOTA_EXCEEDED_TLS_ROUTES" : TLS routes quota exceeded error code.
  /// - "QUOTA_EXCEEDED_TRAFFIC_POLICIES" : TrafficPolicy quota exceeded error
  /// code.
  /// - "QUOTA_EXCEEDED_ENDPOINT_POLICIES" : EndpointPolicy quota exceeded error
  /// code.
  /// - "QUOTA_EXCEEDED_GATEWAYS" : Gateway quota exceeded error code.
  /// - "QUOTA_EXCEEDED_MESHES" : Mesh quota exceeded error code.
  /// - "QUOTA_EXCEEDED_SERVER_TLS_POLICIES" : ServerTLSPolicy quota exceeded
  /// error code.
  /// - "QUOTA_EXCEEDED_CLIENT_TLS_POLICIES" : ClientTLSPolicy quota exceeded
  /// error code.
  /// - "QUOTA_EXCEEDED_SERVICE_LB_POLICIES" : ServiceLBPolicy quota exceeded
  /// error code.
  /// - "QUOTA_EXCEEDED_HTTP_FILTERS" : HTTPFilter quota exceeded error code.
  /// - "QUOTA_EXCEEDED_TCP_FILTERS" : TCPFilter quota exceeded error code.
  /// - "QUOTA_EXCEEDED_NETWORK_ENDPOINT_GROUPS" : NetworkEndpointGroup quota
  /// exceeded error code.
  /// - "LEGACY_MC_SECRETS" : Legacy istio secrets found for multicluster error
  /// code
  /// - "WORKLOAD_IDENTITY_REQUIRED" : Workload identity required error code
  /// - "NON_STANDARD_BINARY_USAGE" : Non-standard binary usage error code
  /// - "UNSUPPORTED_GATEWAY_CLASS" : Unsupported gateway class error code
  /// - "MANAGED_CNI_NOT_ENABLED" : Managed CNI not enabled error code
  /// - "MODERNIZATION_SCHEDULED" : Modernization is scheduled for a cluster.
  /// - "MODERNIZATION_IN_PROGRESS" : Modernization is in progress for a
  /// cluster.
  /// - "MODERNIZATION_COMPLETED" : Modernization is completed for a cluster.
  /// - "MODERNIZATION_ABORTED" : Modernization is aborted for a cluster.
  /// - "MODERNIZATION_WILL_BE_SCHEDULED" : Modernization will be scheduled for
  /// a fleet.
  core.String? code;

  /// A short summary about the issue.
  core.String? details;

  /// Links contains actionable information.
  core.String? documentationLink;

  /// Severity level of the condition.
  /// Possible string values are:
  /// - "SEVERITY_UNSPECIFIED" : Unspecified severity
  /// - "ERROR" : Indicates an issue that prevents the mesh from operating
  /// correctly
  /// - "WARNING" : Indicates a setting is likely wrong, but the mesh is still
  /// able to operate
  /// - "INFO" : An informational message, not requiring any action
  core.String? severity;

  $ServiceMeshCondition({
    this.code,
    this.details,
    this.documentationLink,
    this.severity,
  });

  $ServiceMeshCondition.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        details: json_['details'] as core.String?,
        documentationLink: json_['documentationLink'] as core.String?,
        severity: json_['severity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (details != null) 'details': details!,
    if (documentationLink != null) 'documentationLink': documentationLink!,
    if (severity != null) 'severity': severity!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ServiceMeshMembershipSpec
/// - gkehub:v1beta : ServiceMeshMembershipSpec
class $ServiceMeshMembershipSpec {
  /// Specifies the API that will be used for configuring the mesh workloads.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CONFIG_API_UNSPECIFIED" : Unspecified
  /// - "CONFIG_API_ISTIO" : Use the Istio API for configuration.
  /// - "CONFIG_API_GATEWAY" : Use the K8s Gateway API for configuration.
  core.String? configApi;

  /// Deprecated: use `management` instead Enables automatic control plane
  /// management.
  /// Possible string values are:
  /// - "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED" : Unspecified
  /// - "AUTOMATIC" : Google should provision a control plane revision and make
  /// it available in the cluster. Google will enroll this revision in a release
  /// channel and keep it up to date. The control plane revision may be a
  /// managed service, or a managed install.
  /// - "MANUAL" : User will manually configure the control plane (e.g. via CLI,
  /// or via the ControlPlaneRevision KRM API)
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? controlPlane;

  /// Enables automatic Service Mesh management.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MANAGEMENT_UNSPECIFIED" : Unspecified
  /// - "MANAGEMENT_AUTOMATIC" : Google should manage my Service Mesh for the
  /// cluster.
  /// - "MANAGEMENT_MANUAL" : User will manually configure their service mesh
  /// components.
  /// - "MANAGEMENT_NOT_INSTALLED" : Google should remove any managed Service
  /// Mesh components from this cluster and deprovision any resources.
  core.String? management;

  $ServiceMeshMembershipSpec({
    this.configApi,
    this.controlPlane,
    this.management,
  });

  $ServiceMeshMembershipSpec.fromJson(core.Map json_)
    : this(
        configApi: json_['configApi'] as core.String?,
        controlPlane: json_['controlPlane'] as core.String?,
        management: json_['management'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configApi != null) 'configApi': configApi!,
    if (controlPlane != null) 'controlPlane': controlPlane!,
    if (management != null) 'management': management!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ServiceMeshStatusDetails
/// - gkehub:v1alpha : ServiceMeshStatusDetails
/// - gkehub:v1beta : ServiceMeshStatusDetails
/// - gkehub:v2 : ServiceMeshStatusDetails
/// - gkehub:v2alpha : ServiceMeshStatusDetails
/// - gkehub:v2beta : ServiceMeshStatusDetails
class $ServiceMeshStatusDetails {
  /// A machine-readable code that further describes a broad status.
  core.String? code;

  /// Human-readable explanation of code.
  core.String? details;

  $ServiceMeshStatusDetails({this.code, this.details});

  $ServiceMeshStatusDetails.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        details: json_['details'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (details != null) 'details': details!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : ServiceMeshType
/// - gkehub:v2 : ServiceMeshType
/// - gkehub:v2alpha : ServiceMeshType
/// - gkehub:v2beta : ServiceMeshType
class $ServiceMeshType {
  /// A 7 character code matching `^IST[0-9]{4}$` or `^ASM[0-9]{4}$`, intended
  /// to uniquely identify the message type.
  ///
  /// (e.g. "IST0001" is mapped to the "InternalError" message type.)
  core.String? code;

  /// A human-readable name for the message type.
  ///
  /// e.g. "InternalError", "PodMissingProxy". This should be the same for all
  /// messages of the same type. (This corresponds to the `name` field in
  /// open-source Istio.)
  core.String? displayName;

  $ServiceMeshType({this.code, this.displayName});

  $ServiceMeshType.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        displayName: json_['displayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - apphub:v1 : ServiceProjectAttachment
/// - apphub:v1alpha : ServiceProjectAttachment
class $ServiceProjectAttachment {
  /// Create time.
  ///
  /// Output only.
  core.String? createTime;

  /// Identifier.
  ///
  /// The resource name of a ServiceProjectAttachment. Format:
  /// `"projects/{host-project-id}/locations/global/serviceProjectAttachments/{service-project-id}."`
  core.String? name;

  /// Service project name in the format: `"projects/abc"` or `"projects/123"`.
  ///
  /// As input, project name with either project id or number are accepted. As
  /// output, this field will contain project number.
  ///
  /// Required. Immutable.
  core.String? serviceProject;

  /// ServiceProjectAttachment state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state.
  /// - "CREATING" : The ServiceProjectAttachment is being created.
  /// - "ACTIVE" : The ServiceProjectAttachment is ready. This means Services
  /// and Workloads under the corresponding ServiceProjectAttachment is ready
  /// for registration.
  /// - "DELETING" : The ServiceProjectAttachment is being deleted.
  core.String? state;

  /// A globally unique identifier (in UUID4 format) for the
  /// `ServiceProjectAttachment`.
  ///
  /// Output only.
  core.String? uid;

  $ServiceProjectAttachment({
    this.createTime,
    this.name,
    this.serviceProject,
    this.state,
    this.uid,
  });

  $ServiceProjectAttachment.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        serviceProject: json_['serviceProject'] as core.String?,
        state: json_['state'] as core.String?,
        uid: json_['uid'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (serviceProject != null) 'serviceProject': serviceProject!,
    if (state != null) 'state': state!,
    if (uid != null) 'uid': uid!,
  };
}

/// Used by:
///
/// - apphub:v1 : ServiceProperties
/// - apphub:v1alpha : ServiceProperties
class $ServiceProperties {
  /// The service project identifier that the underlying cloud resource resides
  /// in.
  ///
  /// Output only.
  core.String? gcpProject;

  /// The location that the underlying resource resides in, for example,
  /// us-west1.
  ///
  /// Output only.
  core.String? location;

  /// The location that the underlying resource resides in if it is zonal, for
  /// example, us-west1-a).
  ///
  /// Output only.
  core.String? zone;

  $ServiceProperties({this.gcpProject, this.location, this.zone});

  $ServiceProperties.fromJson(core.Map json_)
    : this(
        gcpProject: json_['gcpProject'] as core.String?,
        location: json_['location'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcpProject != null) 'gcpProject': gcpProject!,
    if (location != null) 'location': location!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ServingConfigMediaConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaServingConfigMediaConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaServingConfigMediaConfig
class $ServingConfigMediaConfig {
  /// Specifies the content freshness used for recommendation result.
  ///
  /// Contents will be demoted if contents were published for more than content
  /// freshness cutoff days.
  core.int? contentFreshnessCutoffDays;

  /// Specifies the content watched percentage threshold for demotion.
  ///
  /// Threshold value must be between \[0, 1.0\] inclusive.
  core.double? contentWatchedPercentageThreshold;

  /// Specifies the content watched minutes threshold for demotion.
  core.double? contentWatchedSecondsThreshold;

  /// Specifies the number of days to look back for demoting watched content.
  ///
  /// If set to zero or unset, defaults to the maximum of 365 days.
  ///
  /// Optional.
  core.int? demoteContentWatchedPastDays;

  /// Specifies the event type used for demoting recommendation result.
  ///
  /// Currently supported values: * `view-item`: Item viewed. * `media-play`:
  /// Start/resume watching a video, playing a song, etc. * `media-complete`:
  /// Finished or stopped midway through a video, song, etc. If unset, watch
  /// history demotion will not be applied. Content freshness demotion will
  /// still be applied.
  core.String? demotionEventType;

  $ServingConfigMediaConfig({
    this.contentFreshnessCutoffDays,
    this.contentWatchedPercentageThreshold,
    this.contentWatchedSecondsThreshold,
    this.demoteContentWatchedPastDays,
    this.demotionEventType,
  });

  $ServingConfigMediaConfig.fromJson(core.Map json_)
    : this(
        contentFreshnessCutoffDays:
            json_['contentFreshnessCutoffDays'] as core.int?,
        contentWatchedPercentageThreshold:
            (json_['contentWatchedPercentageThreshold'] as core.num?)
                ?.toDouble(),
        contentWatchedSecondsThreshold:
            (json_['contentWatchedSecondsThreshold'] as core.num?)?.toDouble(),
        demoteContentWatchedPastDays:
            json_['demoteContentWatchedPastDays'] as core.int?,
        demotionEventType: json_['demotionEventType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentFreshnessCutoffDays != null)
      'contentFreshnessCutoffDays': contentFreshnessCutoffDays!,
    if (contentWatchedPercentageThreshold != null)
      'contentWatchedPercentageThreshold': contentWatchedPercentageThreshold!,
    if (contentWatchedSecondsThreshold != null)
      'contentWatchedSecondsThreshold': contentWatchedSecondsThreshold!,
    if (demoteContentWatchedPastDays != null)
      'demoteContentWatchedPastDays': demoteContentWatchedPastDays!,
    if (demotionEventType != null) 'demotionEventType': demotionEventType!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SessionPositionAssignedTargetingOptionDetails
/// - displayvideo:v3 : SessionPositionAssignedTargetingOptionDetails
/// - displayvideo:v4 : SessionPositionAssignedTargetingOptionDetails
class $SessionPositionAssignedTargetingOptionDetails {
  /// The position where the ad will show in a session.
  /// Possible string values are:
  /// - "SESSION_POSITION_UNSPECIFIED" : This is a placeholder, does not
  /// indicate any positions.
  /// - "SESSION_POSITION_FIRST_IMPRESSION" : The first impression of the
  /// session.
  core.String? sessionPosition;

  $SessionPositionAssignedTargetingOptionDetails({this.sessionPosition});

  $SessionPositionAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(sessionPosition: json_['sessionPosition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sessionPosition != null) 'sessionPosition': sessionPosition!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : SetAutoscalerLinkOperationMetadata
/// - deploymentmanager:v2 : SetAutoscalerLinkOperationMetadata
/// - deploymentmanager:v2beta : SetAutoscalerLinkOperationMetadata
class $SetAutoscalerLinkOperationMetadata {
  /// List of zonal IGM IDs part of the RMIG.
  core.List<core.String>? zonalIgmIds;

  $SetAutoscalerLinkOperationMetadata({this.zonalIgmIds});

  $SetAutoscalerLinkOperationMetadata.fromJson(core.Map json_)
    : this(
        zonalIgmIds:
            (json_['zonalIgmIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (zonalIgmIds != null) 'zonalIgmIds': zonalIgmIds!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSetDedicatedCrawlRateRequest
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSetDedicatedCrawlRateRequest
class $SetDedicatedCrawlRateRequest {
  /// The crawl QPS set by the user.
  ///
  /// It is not guaranteed that Vertex crawl bot will crawl at this QPS. If the
  /// crawl rate is too high, the real QPS may be lower than the value set by
  /// the user to avoid overloading the user's website.
  ///
  /// Optional.
  core.int? crawlRate;

  /// The scope of the crawl rate that the user wants to config.
  ///
  /// Currently, only domain and host name are supported. A domain name example:
  /// `example.com`. A host name example: `www.example.com`. Please do not
  /// include `/` in the domain or host name.
  ///
  /// Required.
  core.String? crawlRateScope;

  /// Whether it's the crawl rate of user-triggered or auto-refresh.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CRAWL_TYPE_UNSPECIFIED" : The crawl type is unspecified.
  /// - "USER_TRIGGERED" : The crawl type is user-triggered.
  /// - "AUTO_REFRESH" : The crawl type is auto-refresh.
  core.String? crawlType;

  /// Whether the rate is explicitly set by users, or set by vertex AI.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : The mode is unspecified. If the user does not
  /// specify the mode, default to AUTOMATIC.
  /// - "AUTOMATIC" : Vertex AI automatically splits crawl_rate into
  /// user-triggered and auto-refresh. Users don't need to specify
  /// SetDedicatedCrawlRateRequest.CrawlType if the mode is AUTOMATIC.
  /// - "EXPLICIT" : Users explicitly set user-triggered or auto-refresh crawl
  /// rate.
  core.String? mode;

  $SetDedicatedCrawlRateRequest({
    this.crawlRate,
    this.crawlRateScope,
    this.crawlType,
    this.mode,
  });

  $SetDedicatedCrawlRateRequest.fromJson(core.Map json_)
    : this(
        crawlRate: json_['crawlRate'] as core.int?,
        crawlRateScope: json_['crawlRateScope'] as core.String?,
        crawlType: json_['crawlType'] as core.String?,
        mode: json_['mode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (crawlRate != null) 'crawlRate': crawlRate!,
    if (crawlRateScope != null) 'crawlRateScope': crawlRateScope!,
    if (crawlType != null) 'crawlType': crawlType!,
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2SetDefaultBranchRequest
/// - retail:v2alpha : GoogleCloudRetailV2alphaSetDefaultBranchRequest
/// - retail:v2beta : GoogleCloudRetailV2betaSetDefaultBranchRequest
class $SetDefaultBranchRequest {
  /// The final component of the resource name of a branch.
  ///
  /// This field must be one of "0", "1" or "2". Otherwise, an INVALID_ARGUMENT
  /// error is returned. If there are no sufficient active products in the
  /// targeted branch and force is not set, a FAILED_PRECONDITION error is
  /// returned.
  core.String? branchId;

  /// If set to true, it permits switching to a branch with branch_id even if it
  /// has no sufficient active products.
  core.bool? force;

  /// Some note on this request, this can be retrieved by
  /// CatalogService.GetDefaultBranch before next valid default branch set
  /// occurs.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 1,000
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
  core.String? note;

  $SetDefaultBranchRequest({this.branchId, this.force, this.note});

  $SetDefaultBranchRequest.fromJson(core.Map json_)
    : this(
        branchId: json_['branchId'] as core.String?,
        force: json_['force'] as core.bool?,
        note: json_['note'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (branchId != null) 'branchId': branchId!,
    if (force != null) 'force': force!,
    if (note != null) 'note': note!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1SetDefaultProcessorVersionRequest
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3SetDefaultProcessorVersionRequest
class $SetDefaultProcessorVersionRequest {
  /// The resource name of child ProcessorVersion to use as default.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{version}`
  ///
  /// Required.
  core.String? defaultProcessorVersion;

  $SetDefaultProcessorVersionRequest({this.defaultProcessorVersion});

  $SetDefaultProcessorVersionRequest.fromJson(core.Map json_)
    : this(
        defaultProcessorVersion:
            json_['defaultProcessorVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultProcessorVersion != null)
      'defaultProcessorVersion': defaultProcessorVersion!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionSetLabelsRequest
/// - compute:alpha : ZoneSetLabelsRequest
/// - compute:beta : RegionSetLabelsRequest
/// - compute:beta : ZoneSetLabelsRequest
/// - compute:v1 : RegionSetLabelsRequest
/// - compute:v1 : ZoneSetLabelsRequest
class $SetLabelsRequest00 {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  $SetLabelsRequest00({this.labelFingerprint, this.labels});

  $SetLabelsRequest00.fromJson(core.Map json_)
    : this(
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
  };
}

/// Used by:
///
/// - container:v1 : SetLabelsRequest
/// - container:v1beta1 : SetLabelsRequest
class $SetLabelsRequest01 {
  /// The name of the cluster.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Kubernetes Engine and changes
  /// after every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash when updating or changing labels. Make a
  /// `get()` request to the resource to get the latest fingerprint.
  ///
  /// Required.
  core.String? labelFingerprint;

  /// The name (project, location, cluster name) of the cluster to set labels.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The labels to set for that cluster.
  ///
  /// Required.
  core.Map<core.String, core.String>? resourceLabels;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetLabelsRequest01({
    this.clusterId,
    this.labelFingerprint,
    this.name,
    this.projectId,
    this.resourceLabels,
    this.zone,
  });

  $SetLabelsRequest01.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        resourceLabels: (json_['resourceLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (resourceLabels != null) 'resourceLabels': resourceLabels!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : SetLegacyAbacRequest
/// - container:v1beta1 : SetLegacyAbacRequest
class $SetLegacyAbacRequest {
  /// The name of the cluster to update.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// Whether ABAC authorization will be enabled in the cluster.
  ///
  /// Required.
  core.bool? enabled;

  /// The name (project, location, cluster name) of the cluster to set legacy
  /// abac.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetLegacyAbacRequest({
    this.clusterId,
    this.enabled,
    this.name,
    this.projectId,
    this.zone,
  });

  $SetLegacyAbacRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        enabled: json_['enabled'] as core.bool?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (enabled != null) 'enabled': enabled!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : SetLocationsRequest
/// - container:v1beta1 : SetLocationsRequest
class $SetLocationsRequest {
  /// The name of the cluster to upgrade.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The desired list of Google Compute Engine
  /// [zones](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster's nodes should be located.
  ///
  /// Changing the locations a cluster is in will result in nodes being either
  /// created or removed from the cluster, depending on whether locations are
  /// being added or removed. This list must always include the cluster's
  /// primary zone.
  ///
  /// Required.
  core.List<core.String>? locations;

  /// The name (project, location, cluster) of the cluster to set locations.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetLocationsRequest({
    this.clusterId,
    this.locations,
    this.name,
    this.projectId,
    this.zone,
  });

  $SetLocationsRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        locations:
            (json_['locations'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (locations != null) 'locations': locations!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : SetLoggingServiceRequest
/// - container:v1beta1 : SetLoggingServiceRequest
class $SetLoggingServiceRequest {
  /// The name of the cluster to upgrade.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The logging service the cluster should use to write logs.
  ///
  /// Currently available options: * `logging.googleapis.com/kubernetes` - The
  /// Cloud Logging service with a Kubernetes-native resource model *
  /// `logging.googleapis.com` - The legacy Cloud Logging service (no longer
  /// available as of GKE 1.15). * `none` - no logs will be exported from the
  /// cluster. If left as an empty string,`logging.googleapis.com/kubernetes`
  /// will be used for GKE 1.14+ or `logging.googleapis.com` for earlier
  /// versions.
  ///
  /// Required.
  core.String? loggingService;

  /// The name (project, location, cluster) of the cluster to set logging.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetLoggingServiceRequest({
    this.clusterId,
    this.loggingService,
    this.name,
    this.projectId,
    this.zone,
  });

  $SetLoggingServiceRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        loggingService: json_['loggingService'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (loggingService != null) 'loggingService': loggingService!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : SetMonitoringServiceRequest
/// - container:v1beta1 : SetMonitoringServiceRequest
class $SetMonitoringServiceRequest {
  /// The name of the cluster to upgrade.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The monitoring service the cluster should use to write metrics.
  ///
  /// Currently available options: * `monitoring.googleapis.com/kubernetes` -
  /// The Cloud Monitoring service with a Kubernetes-native resource model *
  /// `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
  /// longer available as of GKE 1.15). * `none` - No metrics will be exported
  /// from the cluster. If left as an empty
  /// string,`monitoring.googleapis.com/kubernetes` will be used for GKE 1.14+
  /// or `monitoring.googleapis.com` for earlier versions.
  ///
  /// Required.
  core.String? monitoringService;

  /// The name (project, location, cluster) of the cluster to set monitoring.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetMonitoringServiceRequest({
    this.clusterId,
    this.monitoringService,
    this.name,
    this.projectId,
    this.zone,
  });

  $SetMonitoringServiceRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        monitoringService: json_['monitoringService'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (monitoringService != null) 'monitoringService': monitoringService!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - container:v1 : SetNodePoolSizeRequest
/// - container:v1beta1 : SetNodePoolSizeRequest
class $SetNodePoolSizeRequest {
  /// The name of the cluster to update.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The name (project, location, cluster, node pool id) of the node pool to
  /// set size.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / *
  /// /nodePools / * `.
  core.String? name;

  /// The desired node count for the pool.
  ///
  /// Required.
  core.int? nodeCount;

  /// The name of the node pool to update.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? nodePoolId;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $SetNodePoolSizeRequest({
    this.clusterId,
    this.name,
    this.nodeCount,
    this.nodePoolId,
    this.projectId,
    this.zone,
  });

  $SetNodePoolSizeRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        name: json_['name'] as core.String?,
        nodeCount: json_['nodeCount'] as core.int?,
        nodePoolId: json_['nodePoolId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (name != null) 'name': name!,
    if (nodeCount != null) 'nodeCount': nodeCount!,
    if (nodePoolId != null) 'nodePoolId': nodePoolId!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : Setting
/// - cloudidentity:v1beta1 : Setting
class $Setting {
  /// The type of the Setting.
  ///
  /// .
  ///
  /// Required. Immutable.
  core.String? type;

  /// The value of the Setting.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? value;

  $Setting({this.type, this.value});

  $Setting.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        value:
            json_.containsKey('value')
                ? json_['value'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - content:v2.1 : AccountImageImprovementsSettings
/// - merchantapi:accounts_v1beta : ImageImprovementsAccountLevelSettings
class $Settings {
  /// Enables automatic image improvements.
  core.bool? allowAutomaticImageImprovements;

  $Settings({this.allowAutomaticImageImprovements});

  $Settings.fromJson(core.Map json_)
    : this(
        allowAutomaticImageImprovements:
            json_['allowAutomaticImageImprovements'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowAutomaticImageImprovements != null)
      'allowAutomaticImageImprovements': allowAutomaticImageImprovements!,
  };
}

/// Used by:
///
/// - compute:alpha : DiskSettingsAccessLocationAccessLocationPreference
/// - compute:alpha : SnapshotSettingsAccessLocationAccessLocationPreference
/// - compute:beta : SnapshotSettingsAccessLocationAccessLocationPreference
class $SettingsAccessLocationAccessLocationPreference {
  /// Accessible region name
  core.String? region;

  $SettingsAccessLocationAccessLocationPreference({this.region});

  $SettingsAccessLocationAccessLocationPreference.fromJson(core.Map json_)
    : this(region: json_['region'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : SetupFunctionUpgradeConfigRequest
/// - cloudfunctions:v2alpha : SetupFunctionUpgradeConfigRequest
/// - cloudfunctions:v2beta : SetupFunctionUpgradeConfigRequest
class $SetupFunctionUpgradeConfigRequest {
  /// The trigger's service account.
  ///
  /// The service account must have permission to invoke Cloud Run services, the
  /// permission is `run.routes.invoke`. If empty, defaults to the Compute
  /// Engine default service account:
  /// `{project_number}-compute@developer.gserviceaccount.com`.
  ///
  /// Optional.
  core.String? triggerServiceAccount;

  $SetupFunctionUpgradeConfigRequest({this.triggerServiceAccount});

  $SetupFunctionUpgradeConfigRequest.fromJson(core.Map json_)
    : this(
        triggerServiceAccount: json_['triggerServiceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (triggerServiceAccount != null)
      'triggerServiceAccount': triggerServiceAccount!,
  };
}

/// Used by:
///
/// - tagmanager:v1 : SetupTag
/// - tagmanager:v2 : SetupTag
class $SetupTag {
  /// If true, fire the main tag if and only if the setup tag fires
  /// successfully.
  ///
  /// If false, fire the main tag regardless of setup tag firing status.
  core.bool? stopOnSetupFailure;

  /// The name of the setup tag.
  core.String? tagName;

  $SetupTag({this.stopOnSetupFailure, this.tagName});

  $SetupTag.fromJson(core.Map json_)
    : this(
        stopOnSetupFailure: json_['stopOnSetupFailure'] as core.bool?,
        tagName: json_['tagName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (stopOnSetupFailure != null) 'stopOnSetupFailure': stopOnSetupFailure!,
    if (tagName != null) 'tagName': tagName!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : SeverityOverride
/// - networksecurity:v1beta1 : SeverityOverride
class $SeverityOverride {
  /// Threat action override.
  ///
  /// Required.
  /// Possible string values are:
  /// - "THREAT_ACTION_UNSPECIFIED" : Threat action not specified.
  /// - "DEFAULT_ACTION" : The default action (as specified by the vendor) is
  /// taken.
  /// - "ALLOW" : The packet matching this rule will be allowed to transmit.
  /// - "ALERT" : The packet matching this rule will be allowed to transmit, but
  /// a threat_log entry will be sent to the consumer project.
  /// - "DENY" : The packet matching this rule will be dropped, and a threat_log
  /// entry will be sent to the consumer project.
  core.String? action;

  /// Severity level to match.
  ///
  /// Required.
  /// Possible string values are:
  /// - "SEVERITY_UNSPECIFIED" : Severity level not specified.
  /// - "INFORMATIONAL" : Suspicious events that do not pose an immediate
  /// threat, but that are reported to call attention to deeper problems that
  /// could possibly exist.
  /// - "LOW" : Warning-level threats that have very little impact on an
  /// organization's infrastructure. They usually require local or physical
  /// system access and may often result in victim privacy issues and
  /// information leakage.
  /// - "MEDIUM" : Minor threats in which impact is minimized, that do not
  /// compromise the target or exploits that require an attacker to reside on
  /// the same local network as the victim, affect only non-standard
  /// configurations or obscure applications, or provide very limited access.
  /// - "HIGH" : Threats that have the ability to become critical but have
  /// mitigating factors; for example, they may be difficult to exploit, do not
  /// result in elevated privileges, or do not have a large victim pool.
  /// - "CRITICAL" : Serious threats, such as those that affect default
  /// installations of widely deployed software, result in root compromise of
  /// servers, and the exploit code is widely available to attackers. The
  /// attacker usually does not need any special authentication credentials or
  /// knowledge about the individual victims and the target does not need to be
  /// manipulated into performing any special functions.
  core.String? severity;

  $SeverityOverride({this.action, this.severity});

  $SeverityOverride.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        severity: json_['severity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (severity != null) 'severity': severity!,
  };
}

/// Used by:
///
/// - compute:alpha : ShareSettingsProjectConfig
/// - compute:beta : ShareSettingsProjectConfig
/// - compute:v1 : ShareSettingsProjectConfig
class $ShareSettingsProjectConfig {
  /// The project ID, should be same as the key of this project config in the
  /// parent map.
  core.String? projectId;

  $ShareSettingsProjectConfig({this.projectId});

  $ShareSettingsProjectConfig.fromJson(core.Map json_)
    : this(projectId: json_['projectId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyResourcePackageResourceAPT
/// - osconfig:v1 : OSPolicyResourcePackageResourceGooGet
/// - osconfig:v1 : OSPolicyResourcePackageResourceYUM
/// - osconfig:v1 : OSPolicyResourcePackageResourceZypper
/// - osconfig:v1alpha : OSPolicyResourcePackageResourceAPT
/// - osconfig:v1alpha : OSPolicyResourcePackageResourceGooGet
/// - osconfig:v1alpha : OSPolicyResourcePackageResourceYUM
/// - osconfig:v1alpha : OSPolicyResourcePackageResourceZypper
/// - osconfig:v2 : OSPolicyResourcePackageResourceAPT
/// - osconfig:v2 : OSPolicyResourcePackageResourceGooGet
/// - osconfig:v2 : OSPolicyResourcePackageResourceYUM
/// - osconfig:v2 : OSPolicyResourcePackageResourceZypper
/// - osconfig:v2beta : OSPolicyResourcePackageResourceAPT
/// - osconfig:v2beta : OSPolicyResourcePackageResourceGooGet
/// - osconfig:v2beta : OSPolicyResourcePackageResourceYUM
/// - osconfig:v2beta : OSPolicyResourcePackageResourceZypper
class $Shared00 {
  /// Package name.
  ///
  /// Required.
  core.String? name;

  $Shared00({this.name});

  $Shared00.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - gkehub:v1 : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v1 : PolicyControllerMonitoringConfig
/// - gkehub:v1alpha : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v1alpha : PolicyControllerMonitoringConfig
/// - gkehub:v1beta : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v1beta : PolicyControllerMonitoringConfig
/// - gkehub:v2 : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v2 : PolicyControllerMonitoringConfig
/// - gkehub:v2alpha : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v2alpha : PolicyControllerMonitoringConfig
/// - gkehub:v2beta : ConfigManagementPolicyControllerMonitoring
/// - gkehub:v2beta : PolicyControllerMonitoringConfig
class $Shared01 {
  /// Specifies the list of backends Policy Controller will export to.
  ///
  /// An empty list would effectively disable metrics export.
  core.List<core.String>? backends;

  $Shared01({this.backends});

  $Shared01.fromJson(core.Map json_)
    : this(
        backends:
            (json_['backends'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backends != null) 'backends': backends!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : BuilderConfig
/// - containeranalysis:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder
/// - containeranalysis:v1 : SlsaBuilder
/// - containeranalysis:v1alpha1 : BuilderConfig
/// - ondemandscanning:v1 : BuilderConfig
/// - ondemandscanning:v1 : GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder
/// - ondemandscanning:v1 : SlsaBuilder
/// - ondemandscanning:v1beta1 : BuilderConfig
/// - ondemandscanning:v1beta1 : GrafeasV1SlsaProvenanceZeroTwoSlsaBuilder
/// - ondemandscanning:v1beta1 : SlsaBuilder
/// - youtube:v3 : AbuseType
class $Shared02 {
  core.String? id;

  $Shared02({this.id});

  $Shared02.fromJson(core.Map json_) : this(id: json_['id'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {if (id != null) 'id': id!};
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagManagedDbConfigEnterprise
/// - androidpublisher:v3 : ArchiveSubscriptionRequest
/// - bigtableadmin:v2 : GoogleBigtableAdminV2TypeStringEncodingUtf8Raw
/// - cloudchannel:v1 : GoogleCloudChannelV1RepricingConfigChannelPartnerGranularity
/// - domains:v1 : ExportRegistrationRequest
/// - domains:v1alpha2 : ExportRegistrationRequest
/// - domains:v1beta1 : ExportRegistrationRequest
/// - driveactivity:v2 : File
/// - run:v2 : Proto2BridgeMessageSet
class $Shared03 {
  $Shared03();

  $Shared03.fromJson(
    // ignore: avoid_unused_constructor_parameters
    core.Map json_,
  );

  core.Map<core.String, core.dynamic> toJson() => {};
}

/// Used by:
///
/// - osconfig:v1 : OSPolicyAssignmentInstanceFilterInventory
/// - osconfig:v1 : OSPolicyInventoryFilter
/// - osconfig:v1alpha : OSPolicyAssignmentInstanceFilterInventory
/// - osconfig:v1alpha : OSPolicyInventoryFilter
/// - osconfig:v2 : OSPolicyAssignmentInstanceFilterInventory
/// - osconfig:v2 : OSPolicyInventoryFilter
/// - osconfig:v2beta : OSPolicyAssignmentInstanceFilterInventory
/// - osconfig:v2beta : OSPolicyInventoryFilter
class $Shared04 {
  /// The OS short name
  ///
  /// Required.
  core.String? osShortName;

  /// The OS version Prefix matches are supported if asterisk(*) is provided as
  /// the last character.
  ///
  /// For example, to match all versions with a major version of `7`, specify
  /// the following value for this field `7.*` An empty string matches all OS
  /// versions.
  core.String? osVersion;

  $Shared04({this.osShortName, this.osVersion});

  $Shared04.fromJson(core.Map json_)
    : this(
        osShortName: json_['osShortName'] as core.String?,
        osVersion: json_['osVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (osShortName != null) 'osShortName': osShortName!,
    if (osVersion != null) 'osVersion': osVersion!,
  };
}

/// Used by:
///
/// - compute:alpha : InstancesSetServiceAccountRequest
/// - compute:alpha : ServiceAccount
/// - compute:beta : InstancesSetServiceAccountRequest
/// - compute:beta : ServiceAccount
/// - compute:v1 : InstancesSetServiceAccountRequest
/// - compute:v1 : ServiceAccount
class $Shared05 {
  /// Email address of the service account.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String>? scopes;

  $Shared05({this.email, this.scopes});

  $Shared05.fromJson(core.Map json_)
    : this(
        email: json_['email'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
    if (scopes != null) 'scopes': scopes!,
  };
}

/// Used by:
///
/// - beyondcorp:v1 : GoogleCloudBeyondcorpAppconnectorsV1AppConnectorPrincipalInfoServiceAccount
/// - beyondcorp:v1alpha : GoogleCloudBeyondcorpAppconnectorsV1alphaAppConnectorPrincipalInfoServiceAccount
/// - beyondcorp:v1alpha : ServiceAccount
/// - compute:alpha : ProjectsSetDefaultServiceAccountRequest
class $Shared06 {
  /// Email address of the service account.
  core.String? email;

  $Shared06({this.email});

  $Shared06.fromJson(core.Map json_)
    : this(email: json_['email'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (email != null) 'email': email!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : DeploymentOccurrence
/// - containeranalysis:v1beta1 : Deployment
/// - ondemandscanning:v1 : DeploymentOccurrence
/// - ondemandscanning:v1beta1 : DeploymentOccurrence
class $Shared07 {
  /// Address of the runtime element hosting this deployment.
  core.String? address;

  /// Configuration used to create this deployment.
  core.String? config;

  /// Beginning of the lifetime of this deployment.
  ///
  /// Required.
  core.String? deployTime;

  /// Platform hosting this deployment.
  /// Possible string values are:
  /// - "PLATFORM_UNSPECIFIED" : Unknown.
  /// - "GKE" : Google Container Engine.
  /// - "FLEX" : Google App Engine: Flexible Environment.
  /// - "CUSTOM" : Custom user-defined platform.
  core.String? platform;

  /// Resource URI for the artifact being deployed taken from the deployable
  /// field with the same name.
  ///
  /// Output only.
  core.List<core.String>? resourceUri;

  /// End of the lifetime of this deployment.
  core.String? undeployTime;

  /// Identity of the user that triggered this deployment.
  core.String? userEmail;

  $Shared07({
    this.address,
    this.config,
    this.deployTime,
    this.platform,
    this.resourceUri,
    this.undeployTime,
    this.userEmail,
  });

  $Shared07.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        config: json_['config'] as core.String?,
        deployTime: json_['deployTime'] as core.String?,
        platform: json_['platform'] as core.String?,
        resourceUri:
            (json_['resourceUri'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        undeployTime: json_['undeployTime'] as core.String?,
        userEmail: json_['userEmail'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (config != null) 'config': config!,
    if (deployTime != null) 'deployTime': deployTime!,
    if (platform != null) 'platform': platform!,
    if (resourceUri != null) 'resourceUri': resourceUri!,
    if (undeployTime != null) 'undeployTime': undeployTime!,
    if (userEmail != null) 'userEmail': userEmail!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2Sentiment
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1Sentiment
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SentimentAnalysisResult
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SentimentAnalysisResult
class $Shared08 {
  /// A non-negative number in the \[0, +inf) range, which represents the
  /// absolute magnitude of sentiment, regardless of score (positive or
  /// negative).
  core.double? magnitude;

  /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
  /// sentiment).
  core.double? score;

  $Shared08({this.magnitude, this.score});

  $Shared08.fromJson(core.Map json_)
    : this(
        magnitude: (json_['magnitude'] as core.num?)?.toDouble(),
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (magnitude != null) 'magnitude': magnitude!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagQueryRanking
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RagRetrievalConfigHybridSearch
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1RagRetrievalConfigHybridSearch
class $Shared09 {
  /// Alpha value controls the weight between dense and sparse vector search
  /// results.
  ///
  /// The range is \[0, 1\], while 0 means sparse vector search only and 1 means
  /// dense vector search only. The default value is 0.5 which balances sparse
  /// and dense vector search equally.
  ///
  /// Optional.
  core.double? alpha;

  $Shared09({this.alpha});

  $Shared09.fromJson(core.Map json_)
    : this(alpha: (json_['alpha'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (alpha != null) 'alpha': alpha!,
  };
}

/// Used by:
///
/// - compute:alpha : ManagedInstanceInstanceFlexibilityOverride
/// - compute:alpha : ManagedInstancePropertiesFromFlexibilityPolicy
/// - compute:beta : ManagedInstancePropertiesFromFlexibilityPolicy
class $Shared10 {
  /// The machine type to be used for this instance.
  core.String? machineType;

  /// The provisioning model to be used for this instance.
  /// Possible string values are:
  /// - "FLEX_START" : Instance is provisioned using the Flex Start provisioning
  /// model and has a limited runtime.
  /// - "RESERVATION_BOUND" : Bound to the lifecycle of the reservation in which
  /// it is provisioned.
  /// - "SPOT" : Heavily discounted, no guaranteed runtime.
  /// - "STANDARD" : Standard provisioning with user controlled runtime, no
  /// discounts.
  core.String? provisioningModel;

  $Shared10({this.machineType, this.provisioningModel});

  $Shared10.fromJson(core.Map json_)
    : this(
        machineType: json_['machineType'] as core.String?,
        provisioningModel: json_['provisioningModel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineType != null) 'machineType': machineType!,
    if (provisioningModel != null) 'provisioningModel': provisioningModel!,
  };
}

/// Used by:
///
/// - compute:alpha : SecurityPolicyRuleMatcherConfigDestinationPort
/// - compute:alpha : SecurityPolicyRuleMatcherConfigLayer4Config
/// - compute:beta : SecurityPolicyRuleMatcherConfigLayer4Config
class $Shared11 {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp), or the IP protocol number.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? ipProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for UDP or TCP protocol. Each entry must be
  /// either an integer or a range. If not specified, this rule applies to
  /// connections through any port. Example inputs include: \["22"\],
  /// \["80","443"\], and \["12345-12349"\]. This field may only be specified
  /// when versioned_expr is set to FIREWALL.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? ports;

  $Shared11({this.ipProtocol, this.ports});

  $Shared11.fromJson(core.Map json_)
    : this(
        ipProtocol: json_['ipProtocol'] as core.String?,
        ports:
            (json_['ports'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipProtocol != null) 'ipProtocol': ipProtocol!,
    if (ports != null) 'ports': ports!,
  };
}

/// Used by:
///
/// - admin:reports_v1 : FieldValueTextListValue
/// - contentwarehouse:v1 : GoogleCloudContentwarehouseV1TextArray
class $Shared12 {
  /// List of text values.
  core.List<core.String>? values;

  $Shared12({this.values});

  $Shared12.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - apigee:v1 : GoogleCloudApigeeV1AccessGet
/// - integrations:v1 : EnterpriseCrmEventbusProtoToken
class $Shared13 {
  core.String? name;
  core.String? value;

  $Shared13({this.name, this.value});

  $Shared13.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - cloudsearch:v1 : DoubleValues
/// - integrations:v1 : EnterpriseCrmEventbusProtoDoubleArray
class $Shared14 {
  core.List<core.double>? values;

  $Shared14({this.values});

  $Shared14.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - cloudsearch:v1 : IntegerValues
/// - integrations:v1 : EnterpriseCrmEventbusProtoIntArray
class $Shared15 {
  core.List<core.String>? values;

  $Shared15({this.values});

  $Shared15.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1ExportIssueModelRequestGcsDestination
/// - contactcenterinsights:v1 : GoogleCloudContactcenterinsightsV1ImportIssueModelRequestGcsSource
class $Shared16 {
  /// Format: `gs:///`
  ///
  /// Required.
  core.String? objectUri;

  $Shared16({this.objectUri});

  $Shared16.fromJson(core.Map json_)
    : this(objectUri: json_['objectUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectUri != null) 'objectUri': objectUri!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : DeploymentNote
/// - containeranalysis:v1beta1 : Deployable
class $Shared17 {
  /// Resource URI for the artifact being deployed.
  ///
  /// Required.
  core.List<core.String>? resourceUri;

  $Shared17({this.resourceUri});

  $Shared17.fromJson(core.Map json_)
    : this(
        resourceUri:
            (json_['resourceUri'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceUri != null) 'resourceUri': resourceUri!,
  };
}

/// Used by:
///
/// - containeranalysis:v1beta1 : ByProducts
/// - containeranalysis:v1beta1 : Environment
class $Shared18 {
  core.Map<core.String, core.String>? customValues;

  $Shared18({this.customValues});

  $Shared18.fromJson(core.Map json_)
    : this(
        customValues: (json_['customValues']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customValues != null) 'customValues': customValues!,
  };
}

/// Used by:
///
/// - content:v2.1 : Price
/// - content:v2.1 : PriceAmount
class $Shared19 {
  /// The currency of the price.
  core.String? currency;

  /// The price represented as a number.
  core.String? value;

  $Shared19({this.currency, this.value});

  $Shared19.fromJson(core.Map json_)
    : this(
        currency: json_['currency'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currency != null) 'currency': currency!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dataform:v1beta1 : ReadRepositoryFileResponse
/// - dataform:v1beta1 : WriteFile
class $Shared20 {
  /// The file's contents.
  core.String? contents;
  core.List<core.int> get contentsAsBytes => convert.base64.decode(contents!);

  set contentsAsBytes(core.List<core.int> bytes_) {
    contents = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Shared20({this.contents});

  $Shared20.fromJson(core.Map json_)
    : this(contents: json_['contents'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
  };
}

/// Used by:
///
/// - osconfig:v1beta : SoftwareRecipeStepInstallDpkg
/// - osconfig:v1beta : SoftwareRecipeStepInstallRpm
class $Shared21 {
  /// The id of the relevant artifact in the recipe.
  ///
  /// Required.
  core.String? artifactId;

  $Shared21({this.artifactId});

  $Shared21.fromJson(core.Map json_)
    : this(artifactId: json_['artifactId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactId != null) 'artifactId': artifactId!,
  };
}

/// Used by:
///
/// - vmwareengine:v1 : Nsx
/// - vmwareengine:v1 : Vcenter
class $Shared22 {
  /// Fully qualified domain name of the appliance.
  core.String? fqdn;

  /// Internal IP address of the appliance.
  core.String? internalIp;

  /// The state of the appliance.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified appliance state. This is the default
  /// value.
  /// - "ACTIVE" : The appliance is operational and can be used.
  /// - "CREATING" : The appliance is being deployed.
  core.String? state;

  /// Version of the appliance.
  core.String? version;

  $Shared22({this.fqdn, this.internalIp, this.state, this.version});

  $Shared22.fromJson(core.Map json_)
    : this(
        fqdn: json_['fqdn'] as core.String?,
        internalIp: json_['internalIp'] as core.String?,
        state: json_['state'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fqdn != null) 'fqdn': fqdn!,
    if (internalIp != null) 'internalIp': internalIp!,
    if (state != null) 'state': state!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - workloadmanager:v1 : Product
/// - workloadmanager:v1 : SapDiscoveryWorkloadPropertiesProductVersion
class $Shared23 {
  /// Name of the product.
  ///
  /// Optional.
  core.String? name;

  /// Version of the product.
  ///
  /// Optional.
  core.String? version;

  $Shared23({this.name, this.version});

  $Shared23.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - compute:alpha : ShieldedInstanceConfig
/// - compute:beta : ShieldedInstanceConfig
/// - compute:v1 : ShieldedInstanceConfig
class $ShieldedInstanceConfig00 {
  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enabled by default.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Disabled by default.
  core.bool? enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  ///
  /// Enabled by default.
  core.bool? enableVtpm;

  $ShieldedInstanceConfig00({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
    this.enableVtpm,
  });

  $ShieldedInstanceConfig00.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
        enableVtpm: json_['enableVtpm'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
    if (enableVtpm != null) 'enableVtpm': enableVtpm!,
  };
}

/// Used by:
///
/// - container:v1 : ShieldedInstanceConfig
/// - container:v1beta1 : ShieldedInstanceConfig
class $ShieldedInstanceConfig01 {
  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enables monitoring and attestation of the boot integrity of the instance.
  /// The attestation is performed against the integrity policy baseline. This
  /// baseline is initially derived from the implicitly trusted boot image when
  /// the instance is created.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  core.bool? enableSecureBoot;

  $ShieldedInstanceConfig01({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
  });

  $ShieldedInstanceConfig01.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
  };
}

/// Used by:
///
/// - notebooks:v1 : RuntimeShieldedInstanceConfig
/// - notebooks:v1 : ShieldedInstanceConfig
class $ShieldedInstanceConfig02 {
  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enables monitoring and attestation of the boot integrity of the instance.
  /// The attestation is performed against the integrity policy baseline. This
  /// baseline is initially derived from the implicitly trusted boot image when
  /// the instance is created. Enabled by default.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails. Disabled by default.
  core.bool? enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  ///
  /// Enabled by default.
  core.bool? enableVtpm;

  $ShieldedInstanceConfig02({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
    this.enableVtpm,
  });

  $ShieldedInstanceConfig02.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
        enableVtpm: json_['enableVtpm'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
    if (enableVtpm != null) 'enableVtpm': enableVtpm!,
  };
}

/// Used by:
///
/// - tpu:v2 : ShieldedInstanceConfig
/// - tpu:v2alpha1 : ShieldedInstanceConfig
class $ShieldedInstanceConfig03 {
  /// Defines whether the instance has Secure Boot enabled.
  core.bool? enableSecureBoot;

  $ShieldedInstanceConfig03({this.enableSecureBoot});

  $ShieldedInstanceConfig03.fromJson(core.Map json_)
    : this(enableSecureBoot: json_['enableSecureBoot'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : ShieldedInstanceConfig
/// - vmmigration:v1alpha1 : ShieldedInstanceConfig
class $ShieldedInstanceConfig04 {
  /// Defines whether the instance created by the machine image has integrity
  /// monitoring enabled.
  ///
  /// This can be set to true only if the image boot option is EFI, and vTPM is
  /// enabled.
  ///
  /// Optional.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance created by the machine image has vTPM
  /// enabled.
  ///
  /// This can be set to true only if the image boot option is EFI.
  ///
  /// Optional.
  core.bool? enableVtpm;

  /// Defines whether the instance created by the machine image has Secure Boot
  /// enabled.
  ///
  /// This can be set to true only if the image boot option is EFI.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SECURE_BOOT_UNSPECIFIED" : No explicit value is selected. Will use the
  /// configuration of the source (if exists, otherwise the default will be
  /// false).
  /// - "TRUE" : Use secure boot. This can be set to true only if the image boot
  /// option is EFI.
  /// - "FALSE" : Do not use secure boot.
  core.String? secureBoot;

  $ShieldedInstanceConfig04({
    this.enableIntegrityMonitoring,
    this.enableVtpm,
    this.secureBoot,
  });

  $ShieldedInstanceConfig04.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableVtpm: json_['enableVtpm'] as core.bool?,
        secureBoot: json_['secureBoot'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableVtpm != null) 'enableVtpm': enableVtpm!,
    if (secureBoot != null) 'secureBoot': secureBoot!,
  };
}

/// Used by:
///
/// - container:v1 : ShieldedNodes
/// - container:v1beta1 : ShieldedNodes
class $ShieldedNodes {
  /// Whether Shielded Nodes features are enabled on all nodes in this cluster.
  core.bool? enabled;

  $ShieldedNodes({this.enabled});

  $ShieldedNodes.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ShieldedVmConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ShieldedVmConfig
class $ShieldedVmConfig00 {
  /// Defines whether the instance has
  /// [Secure Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
  /// enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  core.bool? enableSecureBoot;

  $ShieldedVmConfig00({this.enableSecureBoot});

  $ShieldedVmConfig00.fromJson(core.Map json_)
    : this(enableSecureBoot: json_['enableSecureBoot'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
  };
}

/// Used by:
///
/// - compute:alpha : ShieldedVmConfig
/// - compute:beta : ShieldedVmConfig
class $ShieldedVmConfig01 {
  /// Defines whether the instance has integrity monitoring enabled.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  core.bool? enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  core.bool? enableVtpm;

  $ShieldedVmConfig01({
    this.enableIntegrityMonitoring,
    this.enableSecureBoot,
    this.enableVtpm,
  });

  $ShieldedVmConfig01.fromJson(core.Map json_)
    : this(
        enableIntegrityMonitoring:
            json_['enableIntegrityMonitoring'] as core.bool?,
        enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
        enableVtpm: json_['enableVtpm'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableIntegrityMonitoring != null)
      'enableIntegrityMonitoring': enableIntegrityMonitoring!,
    if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
    if (enableVtpm != null) 'enableVtpm': enableVtpm!,
  };
}

/// Used by:
///
/// - content:v2.1 : ProductShippingDimension
/// - merchantapi:products_v1beta : ShippingDimension
class $ShippingDimension {
  /// The unit of value.
  core.String? unit;

  /// The dimension of the product used to calculate the shipping cost of the
  /// item.
  core.double? value;

  $ShippingDimension({this.unit, this.value});

  $ShippingDimension.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - content:v2.1 : AccountShippingImprovements
/// - merchantapi:accounts_v1beta : AutomaticShippingImprovements
class $ShippingImprovements {
  /// Enables automatic shipping improvements.
  core.bool? allowShippingImprovements;

  $ShippingImprovements({this.allowShippingImprovements});

  $ShippingImprovements.fromJson(core.Map json_)
    : this(
        allowShippingImprovements:
            json_['allowShippingImprovements'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowShippingImprovements != null)
      'allowShippingImprovements': allowShippingImprovements!,
  };
}

/// Used by:
///
/// - content:v2.1 : ProductShippingWeight
/// - merchantapi:products_v1beta : ShippingWeight
class $ShippingWeight {
  /// The unit of value.
  core.String? unit;

  /// The weight of the product used to calculate the shipping cost of the item.
  core.double? value;

  $ShippingWeight({this.unit, this.value});

  $ShippingWeight.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_ShotChangeDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_ShotChangeDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_ShotChangeDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_ShotChangeDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_ShotChangeDetectionConfig
class $ShotChangeDetectionConfig {
  /// Model to use for shot change detection.
  ///
  /// Supported values: "builtin/stable" (the default if unset),
  /// "builtin/latest", and "builtin/legacy".
  core.String? model;

  $ShotChangeDetectionConfig({this.model});

  $ShotChangeDetectionConfig.fromJson(core.Map json_)
    : this(model: json_['model'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - dataproc:v1 : ShufflePushReadMetrics
/// - dataproc:v1 : StageShufflePushReadMetrics
class $ShufflePushReadMetrics {
  core.String? corruptMergedBlockChunks;
  core.String? localMergedBlocksFetched;
  core.String? localMergedBytesRead;
  core.String? localMergedChunksFetched;
  core.String? mergedFetchFallbackCount;
  core.String? remoteMergedBlocksFetched;
  core.String? remoteMergedBytesRead;
  core.String? remoteMergedChunksFetched;
  core.String? remoteMergedReqsDuration;

  $ShufflePushReadMetrics({
    this.corruptMergedBlockChunks,
    this.localMergedBlocksFetched,
    this.localMergedBytesRead,
    this.localMergedChunksFetched,
    this.mergedFetchFallbackCount,
    this.remoteMergedBlocksFetched,
    this.remoteMergedBytesRead,
    this.remoteMergedChunksFetched,
    this.remoteMergedReqsDuration,
  });

  $ShufflePushReadMetrics.fromJson(core.Map json_)
    : this(
        corruptMergedBlockChunks:
            json_['corruptMergedBlockChunks'] as core.String?,
        localMergedBlocksFetched:
            json_['localMergedBlocksFetched'] as core.String?,
        localMergedBytesRead: json_['localMergedBytesRead'] as core.String?,
        localMergedChunksFetched:
            json_['localMergedChunksFetched'] as core.String?,
        mergedFetchFallbackCount:
            json_['mergedFetchFallbackCount'] as core.String?,
        remoteMergedBlocksFetched:
            json_['remoteMergedBlocksFetched'] as core.String?,
        remoteMergedBytesRead: json_['remoteMergedBytesRead'] as core.String?,
        remoteMergedChunksFetched:
            json_['remoteMergedChunksFetched'] as core.String?,
        remoteMergedReqsDuration:
            json_['remoteMergedReqsDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (corruptMergedBlockChunks != null)
      'corruptMergedBlockChunks': corruptMergedBlockChunks!,
    if (localMergedBlocksFetched != null)
      'localMergedBlocksFetched': localMergedBlocksFetched!,
    if (localMergedBytesRead != null)
      'localMergedBytesRead': localMergedBytesRead!,
    if (localMergedChunksFetched != null)
      'localMergedChunksFetched': localMergedChunksFetched!,
    if (mergedFetchFallbackCount != null)
      'mergedFetchFallbackCount': mergedFetchFallbackCount!,
    if (remoteMergedBlocksFetched != null)
      'remoteMergedBlocksFetched': remoteMergedBlocksFetched!,
    if (remoteMergedBytesRead != null)
      'remoteMergedBytesRead': remoteMergedBytesRead!,
    if (remoteMergedChunksFetched != null)
      'remoteMergedChunksFetched': remoteMergedChunksFetched!,
    if (remoteMergedReqsDuration != null)
      'remoteMergedReqsDuration': remoteMergedReqsDuration!,
  };
}

/// Used by:
///
/// - dataproc:v1 : ShuffleWriteMetrics
/// - dataproc:v1 : StageShuffleWriteMetrics
class $ShuffleWriteMetrics {
  core.String? bytesWritten;
  core.String? recordsWritten;
  core.String? writeTimeNanos;

  $ShuffleWriteMetrics({
    this.bytesWritten,
    this.recordsWritten,
    this.writeTimeNanos,
  });

  $ShuffleWriteMetrics.fromJson(core.Map json_)
    : this(
        bytesWritten: json_['bytesWritten'] as core.String?,
        recordsWritten: json_['recordsWritten'] as core.String?,
        writeTimeNanos: json_['writeTimeNanos'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bytesWritten != null) 'bytesWritten': bytesWritten!,
    if (recordsWritten != null) 'recordsWritten': recordsWritten!,
    if (writeTimeNanos != null) 'writeTimeNanos': writeTimeNanos!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : SignInBehavior
/// - cloudidentity:v1beta1 : SignInBehavior
class $SignInBehavior {
  /// When to redirect sign-ins to the IdP.
  /// Possible string values are:
  /// - "REDIRECT_CONDITION_UNSPECIFIED" : Default and means "always"
  /// - "NEVER" : Sign-in flows where the user is prompted for their identity
  /// will not redirect to the IdP (so the user will most likely be prompted by
  /// Google for a password), but special flows like IdP-initiated SAML and
  /// sign-in following automatic redirection to the IdP by domain-specific
  /// service URLs will accept the IdP's assertion of the user's identity.
  core.String? redirectCondition;

  $SignInBehavior({this.redirectCondition});

  $SignInBehavior.fromJson(core.Map json_)
    : this(redirectCondition: json_['redirectCondition'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (redirectCondition != null) 'redirectCondition': redirectCondition!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : GoogleCloudOsloginControlplaneRegionalV1alphaSignSshPublicKeyRequest
/// - oslogin:v1beta : GoogleCloudOsloginControlplaneRegionalV1betaSignSshPublicKeyRequest
class $SignSshPublicKeyRequest00 {
  /// The App Engine instance to sign the SSH public key for.
  ///
  /// Expected format:
  /// apps/{app}/services/{service}/versions/{version}/instances/{instance}
  core.String? appEngineInstance;

  /// The Compute instance to sign the SSH public key for.
  ///
  /// Expected format:
  /// projects/{project}/zones/{zone}/instances/{numeric_instance_id}
  core.String? computeInstance;

  /// The service account for the instance.
  ///
  /// If the instance in question does not have a service account, this field
  /// should be left empty. If the wrong service account is provided, this
  /// operation will return a signed certificate that will not be accepted by
  /// the VM.
  ///
  /// Optional.
  core.String? serviceAccount;

  /// The SSH public key to sign.
  ///
  /// Required.
  core.String? sshPublicKey;

  $SignSshPublicKeyRequest00({
    this.appEngineInstance,
    this.computeInstance,
    this.serviceAccount,
    this.sshPublicKey,
  });

  $SignSshPublicKeyRequest00.fromJson(core.Map json_)
    : this(
        appEngineInstance: json_['appEngineInstance'] as core.String?,
        computeInstance: json_['computeInstance'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        sshPublicKey: json_['sshPublicKey'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appEngineInstance != null) 'appEngineInstance': appEngineInstance!,
    if (computeInstance != null) 'computeInstance': computeInstance!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (sshPublicKey != null) 'sshPublicKey': sshPublicKey!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : SignSshPublicKeyRequest
/// - oslogin:v1beta : SignSshPublicKeyRequest
class $SignSshPublicKeyRequest01 {
  /// The SSH public key to sign.
  ///
  /// Required.
  core.String? sshPublicKey;

  $SignSshPublicKeyRequest01({this.sshPublicKey});

  $SignSshPublicKeyRequest01.fromJson(core.Map json_)
    : this(sshPublicKey: json_['sshPublicKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sshPublicKey != null) 'sshPublicKey': sshPublicKey!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : GoogleCloudOsloginControlplaneRegionalV1alphaSignSshPublicKeyResponse
/// - oslogin:v1alpha : SignSshPublicKeyResponse
/// - oslogin:v1beta : GoogleCloudOsloginControlplaneRegionalV1betaSignSshPublicKeyResponse
/// - oslogin:v1beta : SignSshPublicKeyResponse
class $SignSshPublicKeyResponse {
  /// The signed SSH public key to use in the SSH handshake.
  core.String? signedSshPublicKey;

  $SignSshPublicKeyResponse({this.signedSshPublicKey});

  $SignSshPublicKeyResponse.fromJson(core.Map json_)
    : this(signedSshPublicKey: json_['signedSshPublicKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (signedSshPublicKey != null) 'signedSshPublicKey': signedSshPublicKey!,
  };
}

/// Used by:
///
/// - binaryauthorization:v1 : Signature
/// - binaryauthorization:v1beta1 : Signature
/// - containeranalysis:v1 : Signature
/// - containeranalysis:v1beta1 : Signature
/// - ondemandscanning:v1 : Signature
/// - ondemandscanning:v1beta1 : Signature
class $Signature {
  /// The identifier for the public key that verifies this signature.
  ///
  /// * The `public_key_id` is required. * The `public_key_id` SHOULD be an
  /// RFC3986 conformant URI. * When possible, the `public_key_id` SHOULD be an
  /// immutable reference, such as a cryptographic digest. Examples of valid
  /// `public_key_id`s: OpenPGP V4 public key fingerprint: *
  /// "openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA" See
  /// https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr for more
  /// details on this scheme. RFC6920 digest-named SubjectPublicKeyInfo (digest
  /// of the DER serialization): *
  /// "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU" *
  /// "nih:///sha-256;703f68f42aba2c6de30f488a5ea122fef76324679c9bf89791ba95a1271589a5"
  core.String? publicKeyId;

  /// The content of the signature, an opaque bytestring.
  ///
  /// The payload that this signature verifies MUST be unambiguously provided
  /// with the Signature during verification. A wrapper message might provide
  /// the payload explicitly. Alternatively, a message might have a canonical
  /// serialization that can always be unambiguously computed to derive the
  /// payload.
  core.String? signature;
  core.List<core.int> get signatureAsBytes => convert.base64.decode(signature!);

  set signatureAsBytes(core.List<core.int> bytes_) {
    signature = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  $Signature({this.publicKeyId, this.signature});

  $Signature.fromJson(core.Map json_)
    : this(
        publicKeyId: json_['publicKeyId'] as core.String?,
        signature: json_['signature'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (publicKeyId != null) 'publicKeyId': publicKeyId!,
    if (signature != null) 'signature': signature!,
  };
}

/// Used by:
///
/// - compute:alpha : SignedUrlKey
/// - compute:beta : SignedUrlKey
/// - compute:v1 : SignedUrlKey
class $SignedUrlKey {
  /// Name of the key.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? keyName;

  /// 128-bit key value used for signing the URL.
  ///
  /// The key value must be a valid RFC 4648 Section 5 base64url encoded string.
  core.String? keyValue;

  $SignedUrlKey({this.keyName, this.keyValue});

  $SignedUrlKey.fromJson(core.Map json_)
    : this(
        keyName: json_['keyName'] as core.String?,
        keyValue: json_['keyValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (keyName != null) 'keyName': keyName!,
    if (keyValue != null) 'keyValue': keyValue!,
  };
}

/// Used by:
///
/// - netapp:v1 : SimpleExportPolicyRule
/// - netapp:v1beta1 : SimpleExportPolicyRule
class $SimpleExportPolicyRule {
  /// Access type (ReadWrite, ReadOnly, None)
  /// Possible string values are:
  /// - "ACCESS_TYPE_UNSPECIFIED" : Unspecified Access Type
  /// - "READ_ONLY" : Read Only
  /// - "READ_WRITE" : Read Write
  /// - "READ_NONE" : None
  core.String? accessType;

  /// Comma separated list of allowed clients IP addresses
  core.String? allowedClients;

  /// Whether Unix root access will be granted.
  core.String? hasRootAccess;

  /// If enabled (true) the rule defines a read only access for clients matching
  /// the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'authentication' kerberos security
  /// mode.
  core.bool? kerberos5ReadOnly;

  /// If enabled (true) the rule defines read and write access for clients
  /// matching the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'authentication' kerberos security
  /// mode. The 'kerberos5ReadOnly' value be ignored if this is enabled.
  core.bool? kerberos5ReadWrite;

  /// If enabled (true) the rule defines a read only access for clients matching
  /// the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'integrity' kerberos security mode.
  core.bool? kerberos5iReadOnly;

  /// If enabled (true) the rule defines read and write access for clients
  /// matching the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'integrity' kerberos security mode.
  /// The 'kerberos5iReadOnly' value be ignored if this is enabled.
  core.bool? kerberos5iReadWrite;

  /// If enabled (true) the rule defines a read only access for clients matching
  /// the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'privacy' kerberos security mode.
  core.bool? kerberos5pReadOnly;

  /// If enabled (true) the rule defines read and write access for clients
  /// matching the 'allowedClients' specification.
  ///
  /// It enables nfs clients to mount using 'privacy' kerberos security mode.
  /// The 'kerberos5pReadOnly' value be ignored if this is enabled.
  core.bool? kerberos5pReadWrite;

  /// NFS V3 protocol.
  core.bool? nfsv3;

  /// NFS V4 protocol.
  core.bool? nfsv4;

  $SimpleExportPolicyRule({
    this.accessType,
    this.allowedClients,
    this.hasRootAccess,
    this.kerberos5ReadOnly,
    this.kerberos5ReadWrite,
    this.kerberos5iReadOnly,
    this.kerberos5iReadWrite,
    this.kerberos5pReadOnly,
    this.kerberos5pReadWrite,
    this.nfsv3,
    this.nfsv4,
  });

  $SimpleExportPolicyRule.fromJson(core.Map json_)
    : this(
        accessType: json_['accessType'] as core.String?,
        allowedClients: json_['allowedClients'] as core.String?,
        hasRootAccess: json_['hasRootAccess'] as core.String?,
        kerberos5ReadOnly: json_['kerberos5ReadOnly'] as core.bool?,
        kerberos5ReadWrite: json_['kerberos5ReadWrite'] as core.bool?,
        kerberos5iReadOnly: json_['kerberos5iReadOnly'] as core.bool?,
        kerberos5iReadWrite: json_['kerberos5iReadWrite'] as core.bool?,
        kerberos5pReadOnly: json_['kerberos5pReadOnly'] as core.bool?,
        kerberos5pReadWrite: json_['kerberos5pReadWrite'] as core.bool?,
        nfsv3: json_['nfsv3'] as core.bool?,
        nfsv4: json_['nfsv4'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessType != null) 'accessType': accessType!,
    if (allowedClients != null) 'allowedClients': allowedClients!,
    if (hasRootAccess != null) 'hasRootAccess': hasRootAccess!,
    if (kerberos5ReadOnly != null) 'kerberos5ReadOnly': kerberos5ReadOnly!,
    if (kerberos5ReadWrite != null) 'kerberos5ReadWrite': kerberos5ReadWrite!,
    if (kerberos5iReadOnly != null) 'kerberos5iReadOnly': kerberos5iReadOnly!,
    if (kerberos5iReadWrite != null)
      'kerberos5iReadWrite': kerberos5iReadWrite!,
    if (kerberos5pReadOnly != null) 'kerberos5pReadOnly': kerberos5pReadOnly!,
    if (kerberos5pReadWrite != null)
      'kerberos5pReadWrite': kerberos5pReadWrite!,
    if (nfsv3 != null) 'nfsv3': nfsv3!,
    if (nfsv4 != null) 'nfsv4': nfsv4!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SingleRegionKey
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSingleRegionKey
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSingleRegionKey
class $SingleRegionKey {
  /// Single-regional kms key resource name which will be used to encrypt
  /// resources
  /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
  ///
  /// Required.
  core.String? kmsKey;

  $SingleRegionKey({this.kmsKey});

  $SingleRegionKey.fromJson(core.Map json_)
    : this(kmsKey: json_['kmsKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kmsKey != null) 'kmsKey': kmsKey!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : Site
/// - displayvideo:v3 : Site
/// - displayvideo:v4 : Site
class $Site00 {
  /// The resource name of the site.
  ///
  /// Output only.
  core.String? name;

  /// The app ID or URL of the site.
  ///
  /// Must be UTF-8 encoded with a maximum length of 240 bytes.
  ///
  /// Required.
  core.String? urlOrAppId;

  $Site00({this.name, this.urlOrAppId});

  $Site00.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        urlOrAppId: json_['urlOrAppId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (urlOrAppId != null) 'urlOrAppId': urlOrAppId!,
  };
}

/// Used by:
///
/// - adsenseplatform:v1 : Site
/// - adsenseplatform:v1alpha : Site
class $Site01 {
  /// Domain/sub-domain of the site.
  ///
  /// Must be a valid domain complying with
  /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt) and formatted as punycode
  /// [RFC 3492](https://www.ietf.org/rfc/rfc3492.txt) in case the domain
  /// contains unicode characters.
  core.String? domain;

  /// Resource name of a site.
  ///
  /// Format: platforms/{platform}/accounts/{account}/sites/{site}
  ///
  /// Output only.
  core.String? name;

  /// State of a site.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State unspecified.
  /// - "REQUIRES_REVIEW" : Either: - The site hasn't been checked yet. - The
  /// site is inactive and needs another review before it can show ads again.
  /// Learn how to
  /// [request a review for an inactive site](https://support.google.com/adsense/answer/9393996).
  /// - "GETTING_READY" : Google is running some checks on the site. This
  /// usually takes a few days, but in some cases it can take two to four weeks.
  /// - "READY" : The site is ready to show ads. Learn how to
  /// [set up ads on the site](https://support.google.com/adsense/answer/7037624).
  /// - "NEEDS_ATTENTION" : Publisher needs to fix some issues before the site
  /// is ready to show ads. Learn what to do
  /// [if a new site isn't ready](https://support.google.com/adsense/answer/9061852).
  core.String? state;

  $Site01({this.domain, this.name, this.state});

  $Site01.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SiteSearchEngine
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSiteSearchEngine
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSiteSearchEngine
class $SiteSearchEngine {
  /// The fully qualified resource name of the site search engine.
  ///
  /// Format: `projects / * /locations / * /dataStores / * /siteSearchEngine`
  core.String? name;

  $SiteSearchEngine({this.name});

  $SiteSearchEngine.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SiteVerificationInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSiteVerificationInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSiteVerificationInfo
class $SiteVerificationInfo {
  /// Site verification state indicating the ownership and validity.
  /// Possible string values are:
  /// - "SITE_VERIFICATION_STATE_UNSPECIFIED" : Defaults to VERIFIED.
  /// - "VERIFIED" : Site ownership verified.
  /// - "UNVERIFIED" : Site ownership pending verification or verification
  /// failed.
  /// - "EXEMPTED" : Site exempt from verification, e.g., a public website that
  /// opens to all.
  core.String? siteVerificationState;

  /// Latest site verification time.
  core.String? verifyTime;

  $SiteVerificationInfo({this.siteVerificationState, this.verifyTime});

  $SiteVerificationInfo.fromJson(core.Map json_)
    : this(
        siteVerificationState: json_['siteVerificationState'] as core.String?,
        verifyTime: json_['verifyTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (siteVerificationState != null)
      'siteVerificationState': siteVerificationState!,
    if (verifyTime != null) 'verifyTime': verifyTime!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1Sitemap
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSitemap
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSitemap
class $Sitemap {
  /// The sitemap's creation time.
  ///
  /// Output only.
  core.String? createTime;

  /// The fully qualified resource name of the sitemap.
  ///
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine/sitemaps / * ` The `sitemap_id` suffix is
  /// system-generated.
  ///
  /// Output only.
  core.String? name;

  /// Public URI for the sitemap, e.g. `www.example.com/sitemap.xml`.
  core.String? uri;

  $Sitemap({this.createTime, this.name, this.uri});

  $Sitemap.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - dfareporting:v3.5 : Size
/// - dfareporting:v4 : Size
class $Size {
  /// Height of this size.
  ///
  /// Acceptable values are 0 to 32767, inclusive.
  core.int? height;

  /// IAB standard size.
  ///
  /// This is a read-only, auto-generated field.
  core.bool? iab;

  /// ID of this size.
  ///
  /// This is a read-only, auto-generated field.
  core.String? id;

  /// Identifies what kind of resource this is.
  ///
  /// Value: the fixed string "dfareporting#size".
  core.String? kind;

  /// Width of this size.
  ///
  /// Acceptable values are 0 to 32767, inclusive.
  core.int? width;

  $Size({this.height, this.iab, this.id, this.kind, this.width});

  $Size.fromJson(core.Map json_)
    : this(
        height: json_['height'] as core.int?,
        iab: json_['iab'] as core.bool?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (height != null) 'height': height!,
    if (iab != null) 'iab': iab!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (width != null) 'width': width!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : Sku
/// - cloudcontrolspartner:v1beta : Sku
class $Sku {
  /// Display name of the product identified by the SKU.
  ///
  /// A partner may want to show partner branded names for their offerings such
  /// as local sovereign cloud solutions.
  core.String? displayName;

  /// Argentum product SKU, that is associated with the partner offerings to
  /// customers used by Syntro for billing purposes.
  ///
  /// SKUs can represent resold Google products or support services.
  core.String? id;

  $Sku({this.displayName, this.id});

  $Sku.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SlackSourceSlackChannelsSlackChannel
class $SlackSourceSlackChannelsSlackChannel {
  /// The Slack channel ID.
  ///
  /// Required.
  core.String? channelId;

  /// The ending timestamp for messages to import.
  ///
  /// Optional.
  core.String? endTime;

  /// The starting timestamp for messages to import.
  ///
  /// Optional.
  core.String? startTime;

  $SlackSourceSlackChannelsSlackChannel({
    this.channelId,
    this.endTime,
    this.startTime,
  });

  $SlackSourceSlackChannelsSlackChannel.fromJson(core.Map json_)
    : this(
        channelId: json_['channelId'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (channelId != null) 'channelId': channelId!,
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : SlsaRecipe
/// - containeranalysis:v1alpha1 : SlsaRecipe
/// - ondemandscanning:v1 : SlsaRecipe
/// - ondemandscanning:v1beta1 : SlsaRecipe
class $SlsaRecipe {
  /// Collection of all external inputs that influenced the build on top of
  /// recipe.definedInMaterial and recipe.entryPoint.
  ///
  /// For example, if the recipe type were "make", then this might be the flags
  /// passed to make aside from the target, which is captured in
  /// recipe.entryPoint. Depending on the recipe Type, the structure may be
  /// different.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? arguments;

  /// Index in materials containing the recipe steps that are not implied by
  /// recipe.type.
  ///
  /// For example, if the recipe type were "make", then this would point to the
  /// source containing the Makefile, not the make program itself. Set to -1 if
  /// the recipe doesn't come from a material, as zero is default unset value
  /// for int64.
  core.String? definedInMaterial;

  /// String identifying the entry point into the build.
  ///
  /// This is often a path to a configuration file and/or a target label within
  /// that file. The syntax and meaning are defined by recipe.type. For example,
  /// if the recipe type were "make", then this would reference the directory in
  /// which to run make as well as which target to use.
  core.String? entryPoint;

  /// Any other builder-controlled inputs necessary for correctly evaluating the
  /// recipe.
  ///
  /// Usually only needed for reproducing the build but not evaluated as part of
  /// policy. Depending on the recipe Type, the structure may be different.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? environment;

  /// URI indicating what type of recipe was performed.
  ///
  /// It determines the meaning of recipe.entryPoint, recipe.arguments,
  /// recipe.environment, and materials.
  core.String? type;

  $SlsaRecipe({
    this.arguments,
    this.definedInMaterial,
    this.entryPoint,
    this.environment,
    this.type,
  });

  $SlsaRecipe.fromJson(core.Map json_)
    : this(
        arguments:
            json_.containsKey('arguments')
                ? json_['arguments'] as core.Map<core.String, core.dynamic>
                : null,
        definedInMaterial: json_['definedInMaterial'] as core.String?,
        entryPoint: json_['entryPoint'] as core.String?,
        environment:
            json_.containsKey('environment')
                ? json_['environment'] as core.Map<core.String, core.dynamic>
                : null,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (arguments != null) 'arguments': arguments!,
    if (definedInMaterial != null) 'definedInMaterial': definedInMaterial!,
    if (entryPoint != null) 'entryPoint': entryPoint!,
    if (environment != null) 'environment': environment!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SmartReplyAnswer
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SmartReplyAnswer
class $SmartReplyAnswer {
  /// The name of answer record, in the format of
  /// "projects//locations//answerRecords/"
  core.String? answerRecord;

  /// Smart reply confidence.
  ///
  /// The system's confidence score that this reply is a good match for this
  /// conversation, as a value from 0.0 (completely uncertain) to 1.0
  /// (completely certain).
  core.double? confidence;

  /// The content of the reply.
  core.String? reply;

  $SmartReplyAnswer({this.answerRecord, this.confidence, this.reply});

  $SmartReplyAnswer.fromJson(core.Map json_)
    : this(
        answerRecord: json_['answerRecord'] as core.String?,
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        reply: json_['reply'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerRecord != null) 'answerRecord': answerRecord!,
    if (confidence != null) 'confidence': confidence!,
    if (reply != null) 'reply': reply!,
  };
}

/// Used by:
///
/// - file:v1 : Snapshot
/// - file:v1beta1 : Snapshot
class $Snapshot00 {
  /// The time when the snapshot was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of the snapshot with 2048 characters or less.
  ///
  /// Requests with longer descriptions will be rejected.
  core.String? description;

  /// The amount of bytes needed to allocate a full copy of the snapshot content
  ///
  /// Output only.
  core.String? filesystemUsedBytes;

  /// Resource labels to represent user provided metadata.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the snapshot, in the format
  /// `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`.
  ///
  /// Output only.
  core.String? name;

  /// The snapshot state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State not set.
  /// - "CREATING" : Snapshot is being created.
  /// - "READY" : Snapshot is available for use.
  /// - "DELETING" : Snapshot is being deleted.
  core.String? state;

  /// Input only.
  ///
  /// Immutable. Tag key-value pairs bound to this resource. Each key must be a
  /// namespaced name and each value a short name. Example:
  /// "123456789012/environment" : "production", "123456789013/costCenter" :
  /// "marketing" See the documentation for more information: - Namespaced name:
  /// https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_key
  /// - Short name:
  /// https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing#retrieving_tag_value
  ///
  /// Optional.
  core.Map<core.String, core.String>? tags;

  $Snapshot00({
    this.createTime,
    this.description,
    this.filesystemUsedBytes,
    this.labels,
    this.name,
    this.state,
    this.tags,
  });

  $Snapshot00.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        filesystemUsedBytes: json_['filesystemUsedBytes'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        tags: (json_['tags'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (filesystemUsedBytes != null)
      'filesystemUsedBytes': filesystemUsedBytes!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (tags != null) 'tags': tags!,
  };
}

/// Used by:
///
/// - netapp:v1 : Snapshot
/// - netapp:v1beta1 : Snapshot
class $Snapshot01 {
  /// The time when the snapshot was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of the snapshot with 2048 characters or less.
  ///
  /// Requests with longer descriptions will be rejected.
  core.String? description;

  /// Resource labels to represent user provided metadata.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// The resource name of the snapshot. Format:
  /// `projects/{project_id}/locations/{location}/volumes/{volume_id}/snapshots/{snapshot_id}`.
  core.String? name;

  /// The snapshot state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Snapshot State
  /// - "READY" : Snapshot State is Ready
  /// - "CREATING" : Snapshot State is Creating
  /// - "DELETING" : Snapshot State is Deleting
  /// - "UPDATING" : Snapshot State is Updating
  /// - "DISABLED" : Snapshot State is Disabled
  /// - "ERROR" : Snapshot State is Error
  core.String? state;

  /// State details of the storage pool
  ///
  /// Output only.
  core.String? stateDetails;

  /// Current storage usage for the snapshot in bytes.
  ///
  /// Output only.
  core.double? usedBytes;

  $Snapshot01({
    this.createTime,
    this.description,
    this.labels,
    this.name,
    this.state,
    this.stateDetails,
    this.usedBytes,
  });

  $Snapshot01.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        stateDetails: json_['stateDetails'] as core.String?,
        usedBytes: (json_['usedBytes'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (stateDetails != null) 'stateDetails': stateDetails!,
    if (usedBytes != null) 'usedBytes': usedBytes!,
  };
}

/// Used by:
///
/// - compute:alpha : InstantSnapshotGroupSourceInfo
/// - compute:alpha : SnapshotGroupSourceInfo
class $SnapshotGroupSourceInfo {
  core.String? consistencyGroup;
  core.String? consistencyGroupId;

  $SnapshotGroupSourceInfo({this.consistencyGroup, this.consistencyGroupId});

  $SnapshotGroupSourceInfo.fromJson(core.Map json_)
    : this(
        consistencyGroup: json_['consistencyGroup'] as core.String?,
        consistencyGroupId: json_['consistencyGroupId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consistencyGroup != null) 'consistencyGroup': consistencyGroup!,
    if (consistencyGroupId != null) 'consistencyGroupId': consistencyGroupId!,
  };
}

/// Used by:
///
/// - compute:alpha : SnapshotSettingsStorageLocationSettingsStorageLocationPreference
/// - compute:beta : SnapshotSettingsStorageLocationSettingsStorageLocationPreference
/// - compute:v1 : SnapshotSettingsStorageLocationSettingsStorageLocationPreference
class $SnapshotSettingsStorageLocationSettingsStorageLocationPreference {
  /// Name of the location.
  ///
  /// It should be one of the Cloud Storage buckets. Only one location can be
  /// specified.
  core.String? name;

  $SnapshotSettingsStorageLocationSettingsStorageLocationPreference({
    this.name,
  });

  $SnapshotSettingsStorageLocationSettingsStorageLocationPreference.fromJson(
    core.Map json_,
  ) : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : SoleTenantNodeType
/// - migrationcenter:v1alpha1 : SoleTenantNodeType
class $SoleTenantNodeType {
  /// Name of the Sole Tenant node.
  ///
  /// Consult https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes
  core.String? nodeName;

  $SoleTenantNodeType({this.nodeName});

  $SoleTenantNodeType.fromJson(core.Map json_)
    : this(nodeName: json_['nodeName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (nodeName != null) 'nodeName': nodeName!,
  };
}

/// Used by:
///
/// - translate:v3 : GcsInputSource
/// - translate:v3 : GcsSource
/// - translate:v3beta1 : GcsSource
class $Source00 {
  /// Source data URI.
  ///
  /// For example, `gs://my_bucket/my_object`.
  ///
  /// Required.
  core.String? inputUri;

  $Source00({this.inputUri});

  $Source00.fromJson(core.Map json_)
    : this(inputUri: json_['inputUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputUri != null) 'inputUri': inputUri!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : Source
/// - networksecurity:v1beta1 : Source
class $Source01 {
  /// List of CIDR ranges to match based on source IP address.
  ///
  /// At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR
  /// (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone
  /// should be avoided. The IP addresses of any load balancers or proxies
  /// should be considered untrusted.
  ///
  /// Optional.
  core.List<core.String>? ipBlocks;

  /// List of peer identities to match for authorization.
  ///
  /// At least one principal should match. Each peer can be an exact match, or a
  /// prefix match (example, "namespace / * ") or a suffix match (example, " * /
  /// service-account") or a presence match "*". Authorization based on the
  /// principal name without certificate validation (configured by
  /// ServerTlsPolicy resource) is considered insecure.
  ///
  /// Optional.
  core.List<core.String>? principals;

  $Source01({this.ipBlocks, this.principals});

  $Source01.fromJson(core.Map json_)
    : this(
        ipBlocks:
            (json_['ipBlocks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        principals:
            (json_['principals'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipBlocks != null) 'ipBlocks': ipBlocks!,
    if (principals != null) 'principals': principals!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : SourceContext
/// - serviceusage:v1 : SourceContext
/// - serviceusage:v1beta1 : SourceContext
class $SourceContext {
  /// The path-qualified name of the .proto file that contained the associated
  /// protobuf element.
  ///
  /// For example: `"google/protobuf/source_context.proto"`.
  core.String? fileName;

  $SourceContext({this.fileName});

  $SourceContext.fromJson(core.Map json_)
    : this(fileName: json_['fileName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fileName != null) 'fileName': fileName!,
  };
}

/// Used by:
///
/// - firebasedataconnect:v1 : SourceLocation
/// - firebasedataconnect:v1beta : SourceLocation
class $SourceLocation {
  /// Column number starting at 1.
  core.int? column;

  /// Line number starting at 1.
  core.int? line;

  $SourceLocation({this.column, this.line});

  $SourceLocation.fromJson(core.Map json_)
    : this(
        column: json_['column'] as core.int?,
        line: json_['line'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (column != null) 'column': column!,
    if (line != null) 'line': line!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SpannerSource
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSpannerSource
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSpannerSource
class $SpannerSource {
  /// The database ID of the source Spanner table.
  ///
  /// Required.
  core.String? databaseId;

  /// Whether to apply data boost on Spanner export.
  ///
  /// Enabling this option will incur additional cost. More info can be found
  /// [here](https://cloud.google.com/spanner/docs/databoost/databoost-overview#billing_and_quotas).
  core.bool? enableDataBoost;

  /// The instance ID of the source Spanner table.
  ///
  /// Required.
  core.String? instanceId;

  /// The project ID that contains the Spanner source.
  ///
  /// Has a length limit of 128 characters. If not specified, inherits the
  /// project ID from the parent request.
  core.String? projectId;

  /// The table name of the Spanner database that needs to be imported.
  ///
  /// Required.
  core.String? tableId;

  $SpannerSource({
    this.databaseId,
    this.enableDataBoost,
    this.instanceId,
    this.projectId,
    this.tableId,
  });

  $SpannerSource.fromJson(core.Map json_)
    : this(
        databaseId: json_['databaseId'] as core.String?,
        enableDataBoost: json_['enableDataBoost'] as core.bool?,
        instanceId: json_['instanceId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseId != null) 'databaseId': databaseId!,
    if (enableDataBoost != null) 'enableDataBoost': enableDataBoost!,
    if (instanceId != null) 'instanceId': instanceId!,
    if (projectId != null) 'projectId': projectId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// Used by:
///
/// - speech:v1 : SpeakerDiarizationConfig
/// - speech:v1p1beta1 : SpeakerDiarizationConfig
class $SpeakerDiarizationConfig {
  /// If 'true', enables speaker detection for each recognized word in the top
  /// alternative of the recognition result using a speaker_label provided in
  /// the WordInfo.
  core.bool? enableSpeakerDiarization;

  /// Maximum number of speakers in the conversation.
  ///
  /// This range gives you more flexibility by allowing the system to
  /// automatically determine the correct number of speakers. If not set, the
  /// default value is 6.
  core.int? maxSpeakerCount;

  /// Minimum number of speakers in the conversation.
  ///
  /// This range gives you more flexibility by allowing the system to
  /// automatically determine the correct number of speakers. If not set, the
  /// default value is 2.
  core.int? minSpeakerCount;

  /// Unused.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? speakerTag;

  $SpeakerDiarizationConfig({
    this.enableSpeakerDiarization,
    this.maxSpeakerCount,
    this.minSpeakerCount,
    this.speakerTag,
  });

  $SpeakerDiarizationConfig.fromJson(core.Map json_)
    : this(
        enableSpeakerDiarization:
            json_['enableSpeakerDiarization'] as core.bool?,
        maxSpeakerCount: json_['maxSpeakerCount'] as core.int?,
        minSpeakerCount: json_['minSpeakerCount'] as core.int?,
        speakerTag: json_['speakerTag'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableSpeakerDiarization != null)
      'enableSpeakerDiarization': enableSpeakerDiarization!,
    if (maxSpeakerCount != null) 'maxSpeakerCount': maxSpeakerCount!,
    if (minSpeakerCount != null) 'minSpeakerCount': minSpeakerCount!,
    if (speakerTag != null) 'speakerTag': speakerTag!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1CoherenceSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1FluencySpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1FulfillmentSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1GroundednessSpec
/// - aiplatform:v1 : GoogleCloudAiplatformV1SafetySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1CoherenceSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FluencySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1FulfillmentSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1GroundednessSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SafetySpec
class $Spec00 {
  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $Spec00({this.version});

  $Spec00.fromJson(core.Map json_)
    : this(version: json_['version'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : CloudBuildMembershipSpec
/// - gkehub:v1beta : MembershipSpec
/// - gkehub:v2 : CloudBuildSpec
/// - gkehub:v2alpha : CloudBuildSpec
/// - gkehub:v2beta : CloudBuildSpec
class $Spec01 {
  /// Whether it is allowed to run the privileged builds on the cluster or not.
  /// Possible string values are:
  /// - "SECURITY_POLICY_UNSPECIFIED" : Unspecified policy
  /// - "NON_PRIVILEGED" : Privileged build pods are disallowed
  /// - "PRIVILEGED" : Privileged build pods are allowed
  core.String? securityPolicy;

  /// Version of the cloud build software on the cluster.
  core.String? version;

  $Spec01({this.securityPolicy, this.version});

  $Spec01.fromJson(core.Map json_)
    : this(
        securityPolicy: json_['securityPolicy'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecMultimodalSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecMultiModalSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaAnswerQueryRequestAnswerGenerationSpecMultimodalSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSearchRequestContentSearchSpecSummarySpecMultiModalSpec
class $Spec02 {
  /// Source of image returned in the answer.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IMAGE_SOURCE_UNSPECIFIED" : Unspecified image source (multimodal
  /// feature is disabled by default).
  /// - "ALL_AVAILABLE_SOURCES" : Behavior when service determines the pick from
  /// all available sources.
  /// - "CORPUS_IMAGE_ONLY" : Includes image from corpus in the answer.
  /// - "FIGURE_GENERATION_ONLY" : Triggers figure generation in the answer.
  core.String? imageSource;

  $Spec02({this.imageSource});

  $Spec02.fromJson(core.Map json_)
    : this(imageSource: json_['imageSource'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageSource != null) 'imageSource': imageSource!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : ServiceMeshMembershipSpec
/// - gkehub:v2 : ServiceMeshSpec
/// - gkehub:v2alpha : ServiceMeshSpec
/// - gkehub:v2beta : ServiceMeshSpec
class $Spec03 {
  /// Specifies the API that will be used for configuring the mesh workloads.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CONFIG_API_UNSPECIFIED" : Unspecified
  /// - "CONFIG_API_ISTIO" : Use the Istio API for configuration.
  /// - "CONFIG_API_GATEWAY" : Use the K8s Gateway API for configuration.
  core.String? configApi;

  /// Deprecated: use `management` instead Enables automatic control plane
  /// management.
  /// Possible string values are:
  /// - "CONTROL_PLANE_MANAGEMENT_UNSPECIFIED" : Unspecified
  /// - "AUTOMATIC" : Google should provision a control plane revision and make
  /// it available in the cluster. Google will enroll this revision in a release
  /// channel and keep it up to date. The control plane revision may be a
  /// managed service, or a managed install.
  /// - "MANUAL" : User will manually configure the control plane (e.g. via CLI,
  /// or via the ControlPlaneRevision KRM API)
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? controlPlane;

  /// Determines which release channel to use for default injection and service
  /// mesh APIs.
  /// Possible string values are:
  /// - "CHANNEL_UNSPECIFIED" : Unspecified
  /// - "RAPID" : RAPID channel is offered on an early access basis for
  /// customers who want to test new releases.
  /// - "REGULAR" : REGULAR channel is intended for production users who want to
  /// take advantage of new features.
  /// - "STABLE" : STABLE channel includes versions that are known to be stable
  /// and reliable in production.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? defaultChannel;

  /// Enables automatic Service Mesh management.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MANAGEMENT_UNSPECIFIED" : Unspecified
  /// - "MANAGEMENT_AUTOMATIC" : Google should manage my Service Mesh for the
  /// cluster.
  /// - "MANAGEMENT_MANUAL" : User will manually configure their service mesh
  /// components.
  /// - "MANAGEMENT_NOT_INSTALLED" : Google should remove any managed Service
  /// Mesh components from this cluster and deprovision any resources.
  core.String? management;

  $Spec03({
    this.configApi,
    this.controlPlane,
    this.defaultChannel,
    this.management,
  });

  $Spec03.fromJson(core.Map json_)
    : this(
        configApi: json_['configApi'] as core.String?,
        controlPlane: json_['controlPlane'] as core.String?,
        defaultChannel: json_['defaultChannel'] as core.String?,
        management: json_['management'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configApi != null) 'configApi': configApi!,
    if (controlPlane != null) 'controlPlane': controlPlane!,
    if (defaultChannel != null) 'defaultChannel': defaultChannel!,
    if (management != null) 'management': management!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SearchKnowledgeRequestSearchConfigBoostSpecsBoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SearchKnowledgeRequestSearchConfigBoostSpecsBoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3BoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1BoostSpecConditionBoostSpecBoostControlSpecControlPoint
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1ControlBoostActionInterpolationBoostSpecControlPoint
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpecControlPoint
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaControlBoostActionInterpolationBoostSpecControlPoint
class $SpecControlPoint {
  /// Can be one of: 1.
  ///
  /// The numerical field value. 2. The duration spec for freshness: The value
  /// must be formatted as an XSD `dayTimeDuration` value (a restricted subset
  /// of an ISO 8601 duration value). The pattern for this is: `nDnM]`.
  ///
  /// Optional.
  core.String? attributeValue;

  /// The value between -1 to 1 by which to boost the score if the
  /// attribute_value evaluates to the value specified above.
  ///
  /// Optional.
  core.double? boostAmount;

  $SpecControlPoint({this.attributeValue, this.boostAmount});

  $SpecControlPoint.fromJson(core.Map json_)
    : this(
        attributeValue: json_['attributeValue'] as core.String?,
        boostAmount: (json_['boostAmount'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeValue != null) 'attributeValue': attributeValue!,
    if (boostAmount != null) 'boostAmount': boostAmount!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SpecialistPool
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SpecialistPool
class $SpecialistPool {
  /// The user-defined name of the SpecialistPool.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. This field should be unique on project-level.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the SpecialistPool.
  ///
  /// Required.
  core.String? name;

  /// The resource name of the pending data labeling jobs.
  ///
  /// Output only.
  core.List<core.String>? pendingDataLabelingJobs;

  /// The email addresses of the managers in the SpecialistPool.
  core.List<core.String>? specialistManagerEmails;

  /// The number of managers in this SpecialistPool.
  ///
  /// Output only.
  core.int? specialistManagersCount;

  /// The email addresses of workers in the SpecialistPool.
  core.List<core.String>? specialistWorkerEmails;

  $SpecialistPool({
    this.displayName,
    this.name,
    this.pendingDataLabelingJobs,
    this.specialistManagerEmails,
    this.specialistManagersCount,
    this.specialistWorkerEmails,
  });

  $SpecialistPool.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
        pendingDataLabelingJobs:
            (json_['pendingDataLabelingJobs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        specialistManagerEmails:
            (json_['specialistManagerEmails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        specialistManagersCount: json_['specialistManagersCount'] as core.int?,
        specialistWorkerEmails:
            (json_['specialistWorkerEmails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
    if (pendingDataLabelingJobs != null)
      'pendingDataLabelingJobs': pendingDataLabelingJobs!,
    if (specialistManagerEmails != null)
      'specialistManagerEmails': specialistManagerEmails!,
    if (specialistManagersCount != null)
      'specialistManagersCount': specialistManagersCount!,
    if (specialistWorkerEmails != null)
      'specialistWorkerEmails': specialistWorkerEmails!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecDraftModelSpeculation
class $SpeculativeDecodingSpecDraftModelSpeculation {
  /// The resource name of the draft model.
  ///
  /// Required.
  core.String? draftModel;

  $SpeculativeDecodingSpecDraftModelSpeculation({this.draftModel});

  $SpeculativeDecodingSpecDraftModelSpeculation.fromJson(core.Map json_)
    : this(draftModel: json_['draftModel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (draftModel != null) 'draftModel': draftModel!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecNgramSpeculation
class $SpeculativeDecodingSpecNgramSpeculation {
  /// The number of last N input tokens used as ngram to search/match against
  /// the previous prompt sequence.
  ///
  /// This is equal to the N in N-Gram. The default value is 3 if not specified.
  core.int? ngramSize;

  $SpeculativeDecodingSpecNgramSpeculation({this.ngramSize});

  $SpeculativeDecodingSpecNgramSpeculation.fromJson(core.Map json_)
    : this(ngramSize: json_['ngramSize'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ngramSize != null) 'ngramSize': ngramSize!,
  };
}

/// Used by:
///
/// - speech:v1 : SpeechAdaptationInfo
/// - speech:v1p1beta1 : SpeechAdaptationInfo
class $SpeechAdaptationInfo {
  /// Whether there was a timeout when applying speech adaptation.
  ///
  /// If true, adaptation had no effect in the response transcript.
  core.bool? adaptationTimeout;

  /// If set, returns a message specifying which part of the speech adaptation
  /// request timed out.
  core.String? timeoutMessage;

  $SpeechAdaptationInfo({this.adaptationTimeout, this.timeoutMessage});

  $SpeechAdaptationInfo.fromJson(core.Map json_)
    : this(
        adaptationTimeout: json_['adaptationTimeout'] as core.bool?,
        timeoutMessage: json_['timeoutMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adaptationTimeout != null) 'adaptationTimeout': adaptationTimeout!,
    if (timeoutMessage != null) 'timeoutMessage': timeoutMessage!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_SpeechContext
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_SpeechContext
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_SpeechContext
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_SpeechContext
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_SpeechContext
class $SpeechContext00 {
  /// A list of strings containing words and phrases "hints" so that the speech
  /// recognition is more likely to recognize them.
  ///
  /// This can be used to improve the accuracy for specific words and phrases,
  /// for example, if specific commands are typically spoken by the user. This
  /// can also be used to add additional words to the vocabulary of the
  /// recognizer. See
  /// [usage limits](https://cloud.google.com/speech/limits#content).
  ///
  /// Optional.
  core.List<core.String>? phrases;

  $SpeechContext00({this.phrases});

  $SpeechContext00.fromJson(core.Map json_)
    : this(
        phrases:
            (json_['phrases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (phrases != null) 'phrases': phrases!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SpeechContext
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SpeechContext
class $SpeechContext01 {
  /// Boost for this context compared to other contexts: * If the boost is
  /// positive, Dialogflow will increase the probability that the phrases in
  /// this context are recognized over similar sounding phrases.
  ///
  /// * If the boost is unspecified or non-positive, Dialogflow will not apply
  /// any boost. Dialogflow recommends that you use boosts in the range (0, 20\]
  /// and that you find a value that fits your use case with binary search.
  ///
  /// Optional.
  core.double? boost;

  /// A list of strings containing words and phrases that the speech recognizer
  /// should recognize with higher likelihood.
  ///
  /// This list can be used to: * improve accuracy for words and phrases you
  /// expect the user to say, e.g. typical commands for your Dialogflow agent *
  /// add additional words to the speech recognizer vocabulary * ... See the
  /// [Cloud Speech documentation](https://cloud.google.com/speech-to-text/quotas)
  /// for usage limits.
  ///
  /// Optional.
  core.List<core.String>? phrases;

  $SpeechContext01({this.boost, this.phrases});

  $SpeechContext01.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        phrases:
            (json_['phrases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (phrases != null) 'phrases': phrases!,
  };
}

/// Used by:
///
/// - speech:v1 : SpeechContext
/// - speech:v1p1beta1 : SpeechContext
class $SpeechContext02 {
  /// Hint Boost.
  ///
  /// Positive value will increase the probability that a specific phrase will
  /// be recognized over other similar sounding phrases. The higher the boost,
  /// the higher the chance of false positive recognition as well. Negative
  /// boost values would correspond to anti-biasing. Anti-biasing is not
  /// enabled, so negative boost will simply be ignored. Though `boost` can
  /// accept a wide range of positive values, most use cases are best served
  /// with values between 0 and 20. We recommend using a binary search approach
  /// to finding the optimal value for your use case.
  core.double? boost;

  /// A list of strings containing words and phrases "hints" so that the speech
  /// recognition is more likely to recognize them.
  ///
  /// This can be used to improve the accuracy for specific words and phrases,
  /// for example, if specific commands are typically spoken by the user. This
  /// can also be used to add additional words to the vocabulary of the
  /// recognizer. See
  /// [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
  /// List items can also be set to classes for groups of words that represent
  /// common concepts that occur in natural language. For example, rather than
  /// providing phrase hints for every month of the year, using the $MONTH class
  /// improves the likelihood of correctly transcribing audio that includes
  /// months.
  core.List<core.String>? phrases;

  $SpeechContext02({this.boost, this.phrases});

  $SpeechContext02.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        phrases:
            (json_['phrases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (phrases != null) 'phrases': phrases!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3SpeechToTextSettings
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1SpeechToTextSettings
class $SpeechToTextSettings {
  /// Whether to use speech adaptation for speech recognition.
  core.bool? enableSpeechAdaptation;

  $SpeechToTextSettings({this.enableSpeechAdaptation});

  $SpeechToTextSettings.fromJson(core.Map json_)
    : this(
        enableSpeechAdaptation: json_['enableSpeechAdaptation'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableSpeechAdaptation != null)
      'enableSpeechAdaptation': enableSpeechAdaptation!,
  };
}

/// Used by:
///
/// - jobs:v3 : SpellingCorrection
/// - jobs:v3p1beta1 : SpellingCorrection
class $SpellingCorrection {
  /// Indicates if the query was corrected by the spell checker.
  core.bool? corrected;

  /// Correction output consisting of the corrected keyword string.
  core.String? correctedText;

  $SpellingCorrection({this.corrected, this.correctedText});

  $SpellingCorrection.fromJson(core.Map json_)
    : this(
        corrected: json_['corrected'] as core.bool?,
        correctedText: json_['correctedText'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (corrected != null) 'corrected': corrected!,
    if (correctedText != null) 'correctedText': correctedText!,
  };
}

/// Used by:
///
/// - datamigration:v1 : SqlAclEntry
/// - datamigration:v1beta1 : SqlAclEntry
class $SqlAclEntry {
  /// The time when this access control entry expires in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example:
  /// `2012-11-15T16:19:00.094Z`.
  core.String? expireTime;

  /// A label to identify this entry.
  core.String? label;

  /// Input only.
  ///
  /// The time-to-leave of this access control entry.
  core.String? ttl;

  /// The allowlisted value for the access control list.
  core.String? value;

  $SqlAclEntry({this.expireTime, this.label, this.ttl, this.value});

  $SqlAclEntry.fromJson(core.Map json_)
    : this(
        expireTime: json_['expireTime'] as core.String?,
        label: json_['label'] as core.String?,
        ttl: json_['ttl'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expireTime != null) 'expireTime': expireTime!,
    if (label != null) 'label': label!,
    if (ttl != null) 'ttl': ttl!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlActiveDirectoryConfig
/// - sqladmin:v1beta4 : SqlActiveDirectoryConfig
class $SqlActiveDirectoryConfig {
  /// The name of the domain (e.g., mydomain.com).
  core.String? domain;

  /// This is always sql#activeDirectoryConfig.
  core.String? kind;

  $SqlActiveDirectoryConfig({this.domain, this.kind});

  $SqlActiveDirectoryConfig.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - alloydb:v1 : SqlExportOptions
/// - alloydb:v1alpha : SqlExportOptions
/// - alloydb:v1beta : SqlExportOptions
class $SqlExportOptions {
  /// If true, output commands to DROP all the dumped database objects prior to
  /// outputting the commands for creating them.
  ///
  /// Optional.
  core.bool? cleanTargetObjects;

  /// If true, use DROP ...
  ///
  /// IF EXISTS commands to check for the object's existence before dropping it
  /// in clean_target_objects mode.
  ///
  /// Optional.
  core.bool? ifExistTargetObjects;

  /// If true, only export the schema.
  ///
  /// Optional.
  core.bool? schemaOnly;

  /// Tables to export from.
  ///
  /// Optional.
  core.List<core.String>? tables;

  $SqlExportOptions({
    this.cleanTargetObjects,
    this.ifExistTargetObjects,
    this.schemaOnly,
    this.tables,
  });

  $SqlExportOptions.fromJson(core.Map json_)
    : this(
        cleanTargetObjects: json_['cleanTargetObjects'] as core.bool?,
        ifExistTargetObjects: json_['ifExistTargetObjects'] as core.bool?,
        schemaOnly: json_['schemaOnly'] as core.bool?,
        tables:
            (json_['tables'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cleanTargetObjects != null) 'cleanTargetObjects': cleanTargetObjects!,
    if (ifExistTargetObjects != null)
      'ifExistTargetObjects': ifExistTargetObjects!,
    if (schemaOnly != null) 'schemaOnly': schemaOnly!,
    if (tables != null) 'tables': tables!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlInstancesGetDiskShrinkConfigResponse
/// - sqladmin:v1beta4 : SqlInstancesGetDiskShrinkConfigResponse
class $SqlInstancesGetDiskShrinkConfigResponse {
  /// This is always `sql#getDiskShrinkConfig`.
  core.String? kind;

  /// Additional message to customers.
  core.String? message;

  /// The minimum size to which a disk can be shrunk in GigaBytes.
  core.String? minimalTargetSizeGb;

  $SqlInstancesGetDiskShrinkConfigResponse({
    this.kind,
    this.message,
    this.minimalTargetSizeGb,
  });

  $SqlInstancesGetDiskShrinkConfigResponse.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        message: json_['message'] as core.String?,
        minimalTargetSizeGb: json_['minimalTargetSizeGb'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (message != null) 'message': message!,
    if (minimalTargetSizeGb != null)
      'minimalTargetSizeGb': minimalTargetSizeGb!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlInstancesGetLatestRecoveryTimeResponse
/// - sqladmin:v1beta4 : SqlInstancesGetLatestRecoveryTimeResponse
class $SqlInstancesGetLatestRecoveryTimeResponse {
  /// This is always `sql#getLatestRecoveryTime`.
  core.String? kind;

  /// Timestamp, identifies the latest recovery time of the source instance.
  core.String? latestRecoveryTime;

  $SqlInstancesGetLatestRecoveryTimeResponse({
    this.kind,
    this.latestRecoveryTime,
  });

  $SqlInstancesGetLatestRecoveryTimeResponse.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        latestRecoveryTime: json_['latestRecoveryTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (latestRecoveryTime != null) 'latestRecoveryTime': latestRecoveryTime!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlOutOfDiskReport
/// - sqladmin:v1beta4 : SqlOutOfDiskReport
class $SqlOutOfDiskReport {
  /// The minimum recommended increase size in GigaBytes This field is consumed
  /// by the frontend * Writers: * the proactive database wellness job for OOD.
  ///
  /// * Readers:
  core.int? sqlMinRecommendedIncreaseSizeGb;

  /// This field represents the state generated by the proactive database
  /// wellness job for OutOfDisk issues.
  ///
  /// * Writers: * the proactive database wellness job for OOD. * Readers: * the
  /// proactive database wellness job
  /// Possible string values are:
  /// - "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" : Unspecified state
  /// - "NORMAL" : The instance has plenty space on data disk
  /// - "SOFT_SHUTDOWN" : Data disk is almost used up. It is shutdown to prevent
  /// data corruption.
  core.String? sqlOutOfDiskState;

  $SqlOutOfDiskReport({
    this.sqlMinRecommendedIncreaseSizeGb,
    this.sqlOutOfDiskState,
  });

  $SqlOutOfDiskReport.fromJson(core.Map json_)
    : this(
        sqlMinRecommendedIncreaseSizeGb:
            json_['sqlMinRecommendedIncreaseSizeGb'] as core.int?,
        sqlOutOfDiskState: json_['sqlOutOfDiskState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sqlMinRecommendedIncreaseSizeGb != null)
      'sqlMinRecommendedIncreaseSizeGb': sqlMinRecommendedIncreaseSizeGb!,
    if (sqlOutOfDiskState != null) 'sqlOutOfDiskState': sqlOutOfDiskState!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : MySqlProperty
/// - migrationcenter:v1 : PostgreSqlProperty
/// - migrationcenter:v1alpha1 : MySqlProperty
/// - migrationcenter:v1alpha1 : PostgreSqlProperty
class $SqlProperty {
  /// The property is enabled.
  ///
  /// Required.
  core.bool? enabled;

  /// The property numeric value.
  ///
  /// Required.
  core.String? numericValue;

  /// The property name.
  ///
  /// Required.
  core.String? property;

  $SqlProperty({this.enabled, this.numericValue, this.property});

  $SqlProperty.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        numericValue: json_['numericValue'] as core.String?,
        property: json_['property'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (numericValue != null) 'numericValue': numericValue!,
    if (property != null) 'property': property!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlScheduledMaintenance
/// - sqladmin:v1beta4 : SqlScheduledMaintenance
class $SqlScheduledMaintenance {
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? canDefer;

  /// If the scheduled maintenance can be rescheduled.
  core.bool? canReschedule;

  /// Maintenance cannot be rescheduled to start beyond this deadline.
  core.String? scheduleDeadlineTime;

  /// The start time of any upcoming scheduled maintenance for this instance.
  core.String? startTime;

  $SqlScheduledMaintenance({
    this.canDefer,
    this.canReschedule,
    this.scheduleDeadlineTime,
    this.startTime,
  });

  $SqlScheduledMaintenance.fromJson(core.Map json_)
    : this(
        canDefer: json_['canDefer'] as core.bool?,
        canReschedule: json_['canReschedule'] as core.bool?,
        scheduleDeadlineTime: json_['scheduleDeadlineTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canDefer != null) 'canDefer': canDefer!,
    if (canReschedule != null) 'canReschedule': canReschedule!,
    if (scheduleDeadlineTime != null)
      'scheduleDeadlineTime': scheduleDeadlineTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlServerAuditConfig
/// - sqladmin:v1beta4 : SqlServerAuditConfig
class $SqlServerAuditConfig {
  /// The name of the destination bucket (e.g., gs://mybucket).
  core.String? bucket;

  /// This is always sql#sqlServerAuditConfig
  core.String? kind;

  /// How long to keep generated audit files.
  core.String? retentionInterval;

  /// How often to upload generated audit files.
  core.String? uploadInterval;

  $SqlServerAuditConfig({
    this.bucket,
    this.kind,
    this.retentionInterval,
    this.uploadInterval,
  });

  $SqlServerAuditConfig.fromJson(core.Map json_)
    : this(
        bucket: json_['bucket'] as core.String?,
        kind: json_['kind'] as core.String?,
        retentionInterval: json_['retentionInterval'] as core.String?,
        uploadInterval: json_['uploadInterval'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
    if (kind != null) 'kind': kind!,
    if (retentionInterval != null) 'retentionInterval': retentionInterval!,
    if (uploadInterval != null) 'uploadInterval': uploadInterval!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlServerDatabaseDetails
/// - sqladmin:v1beta4 : SqlServerDatabaseDetails
class $SqlServerDatabaseDetails {
  /// The version of SQL Server with which the database is to be made compatible
  core.int? compatibilityLevel;

  /// The recovery model of a SQL Server database
  core.String? recoveryModel;

  $SqlServerDatabaseDetails({this.compatibilityLevel, this.recoveryModel});

  $SqlServerDatabaseDetails.fromJson(core.Map json_)
    : this(
        compatibilityLevel: json_['compatibilityLevel'] as core.int?,
        recoveryModel: json_['recoveryModel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (compatibilityLevel != null) 'compatibilityLevel': compatibilityLevel!,
    if (recoveryModel != null) 'recoveryModel': recoveryModel!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : SqlServerFeature
/// - migrationcenter:v1alpha1 : SqlServerFeature
class $SqlServerFeature {
  /// Field enabled is set when a feature is used on the source deployment.
  ///
  /// Required.
  core.bool? enabled;

  /// The feature name.
  ///
  /// Required.
  core.String? featureName;

  $SqlServerFeature({this.enabled, this.featureName});

  $SqlServerFeature.fromJson(core.Map json_)
    : this(
        enabled: json_['enabled'] as core.bool?,
        featureName: json_['featureName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
    if (featureName != null) 'featureName': featureName!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : SqlServerSchemaDetails
/// - migrationcenter:v1alpha1 : SqlServerSchemaDetails
class $SqlServerSchemaDetails {
  /// SqlServer number of CLR objects.
  ///
  /// Optional.
  core.int? clrObjectCount;

  $SqlServerSchemaDetails({this.clrObjectCount});

  $SqlServerSchemaDetails.fromJson(core.Map json_)
    : this(clrObjectCount: json_['clrObjectCount'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (clrObjectCount != null) 'clrObjectCount': clrObjectCount!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : SqlServerServerFlag
/// - migrationcenter:v1alpha1 : SqlServerServerFlag
class $SqlServerServerFlag {
  /// The server flag name.
  ///
  /// Required.
  core.String? serverFlagName;

  /// The server flag value set by the user.
  ///
  /// Required.
  core.String? value;

  /// The server flag actual value.
  ///
  /// If `value_in_use` is different from `value` it means that either the
  /// configuration change was not applied or it is an expected behavior. See
  /// SQL Server documentation for more details.
  ///
  /// Required.
  core.String? valueInUse;

  $SqlServerServerFlag({this.serverFlagName, this.value, this.valueInUse});

  $SqlServerServerFlag.fromJson(core.Map json_)
    : this(
        serverFlagName: json_['serverFlagName'] as core.String?,
        value: json_['value'] as core.String?,
        valueInUse: json_['valueInUse'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serverFlagName != null) 'serverFlagName': serverFlagName!,
    if (value != null) 'value': value!,
    if (valueInUse != null) 'valueInUse': valueInUse!,
  };
}

/// Used by:
///
/// - migrationcenter:v1 : SqlServerTraceFlag
/// - migrationcenter:v1alpha1 : SqlServerTraceFlag
class $SqlServerTraceFlag {
  /// The trace flag scope.
  ///
  /// Required.
  /// Possible string values are:
  /// - "SCOPE_UNSPECIFIED" : Unspecified.
  /// - "OFF" : Off.
  /// - "GLOBAL" : Global.
  /// - "SESSION" : Session.
  core.String? scope;

  /// The trace flag name.
  ///
  /// Required.
  core.String? traceFlagName;

  $SqlServerTraceFlag({this.scope, this.traceFlagName});

  $SqlServerTraceFlag.fromJson(core.Map json_)
    : this(
        scope: json_['scope'] as core.String?,
        traceFlagName: json_['traceFlagName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
    if (traceFlagName != null) 'traceFlagName': traceFlagName!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlServerUserDetails
/// - sqladmin:v1beta4 : SqlServerUserDetails
class $SqlServerUserDetails {
  /// If the user has been disabled
  core.bool? disabled;

  /// The server roles for this user
  core.List<core.String>? serverRoles;

  $SqlServerUserDetails({this.disabled, this.serverRoles});

  $SqlServerUserDetails.fromJson(core.Map json_)
    : this(
        disabled: json_['disabled'] as core.bool?,
        serverRoles:
            (json_['serverRoles'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
    if (serverRoles != null) 'serverRoles': serverRoles!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlSubOperationType
/// - sqladmin:v1beta4 : SqlSubOperationType
class $SqlSubOperationType {
  /// The type of maintenance to be performed on the instance.
  /// Possible string values are:
  /// - "SQL_MAINTENANCE_TYPE_UNSPECIFIED" : Maintenance type is unspecified.
  /// - "INSTANCE_MAINTENANCE" : Indicates that a standalone instance is
  /// undergoing maintenance. The instance can be either a primary instance or a
  /// replica.
  /// - "REPLICA_INCLUDED_MAINTENANCE" : Indicates that the primary instance and
  /// all of its replicas, including cascading replicas, are undergoing
  /// maintenance. Maintenance is performed on groups of replicas first,
  /// followed by the primary instance.
  /// - "INSTANCE_SELF_SERVICE_MAINTENANCE" : Indicates that the standalone
  /// instance is undergoing maintenance, initiated by self-service. The
  /// instance can be either a primary instance or a replica.
  /// - "REPLICA_INCLUDED_SELF_SERVICE_MAINTENANCE" : Indicates that the primary
  /// instance and all of its replicas are undergoing maintenance, initiated by
  /// self-service. Maintenance is performed on groups of replicas first,
  /// followed by the primary instance.
  core.String? maintenanceType;

  $SqlSubOperationType({this.maintenanceType});

  $SqlSubOperationType.fromJson(core.Map json_)
    : this(maintenanceType: json_['maintenanceType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maintenanceType != null) 'maintenanceType': maintenanceType!,
  };
}

/// Used by:
///
/// - oslogin:v1 : SshPublicKey
/// - oslogin:v1alpha : SshPublicKey
/// - oslogin:v1beta : SshPublicKey
class $SshPublicKey {
  /// An expiration time in microseconds since epoch.
  core.String? expirationTimeUsec;

  /// The SHA-256 fingerprint of the SSH public key.
  ///
  /// Output only.
  core.String? fingerprint;

  /// Public key text in SSH format, defined by
  /// [RFC4253](https://www.ietf.org/rfc/rfc4253.txt) section 6.6.
  ///
  /// Required.
  core.String? key;

  /// The canonical resource name.
  ///
  /// Output only.
  core.String? name;

  $SshPublicKey({
    this.expirationTimeUsec,
    this.fingerprint,
    this.key,
    this.name,
  });

  $SshPublicKey.fromJson(core.Map json_)
    : this(
        expirationTimeUsec: json_['expirationTimeUsec'] as core.String?,
        fingerprint: json_['fingerprint'] as core.String?,
        key: json_['key'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expirationTimeUsec != null) 'expirationTimeUsec': expirationTimeUsec!,
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (key != null) 'key': key!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - datamigration:v1 : SshScript
/// - datamigration:v1beta1 : SshScript
class $SshScript {
  /// The ssh configuration script.
  core.String? script;

  $SshScript({this.script});

  $SshScript.fromJson(core.Map json_)
    : this(script: json_['script'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (script != null) 'script': script!,
  };
}

/// Used by:
///
/// - compute:alpha : SslCertificateManagedSslCertificate
/// - compute:beta : SslCertificateManagedSslCertificate
/// - compute:v1 : SslCertificateManagedSslCertificate
class $SslCertificateManagedSslCertificate {
  /// Detailed statuses of the domains specified for managed certificate
  /// resource.
  ///
  /// Output only.
  core.Map<core.String, core.String>? domainStatus;

  /// The domains for which a managed SSL certificate will be generated.
  ///
  /// Each Google-managed SSL certificate supports up to the \[maximum number of
  /// domains per Google-managed SSL
  /// certificate\](/load-balancing/docs/quotas#ssl_certificates).
  core.List<core.String>? domains;

  /// Status of the managed certificate resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE" : The certificate management is working, and a certificate has
  /// been provisioned.
  /// - "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
  /// - "PROVISIONING" : The certificate management is working. GCP will attempt
  /// to provision the first certificate.
  /// - "PROVISIONING_FAILED" : Certificate provisioning failed due to an issue
  /// with the DNS or load balancing configuration. For details of which domain
  /// failed, consult domain_status field.
  /// - "PROVISIONING_FAILED_PERMANENTLY" : Certificate provisioning failed due
  /// to an issue with the DNS or load balancing configuration. It won't be
  /// retried. To try again delete and create a new managed SslCertificate
  /// resource. For details of which domain failed, consult domain_status field.
  /// - "RENEWAL_FAILED" : Renewal of the certificate has failed due to an issue
  /// with the DNS or load balancing configuration. The existing cert is still
  /// serving; however, it will expire shortly. To provision a renewed
  /// certificate, delete and create a new managed SslCertificate resource. For
  /// details on which domain failed, consult domain_status field.
  core.String? status;

  $SslCertificateManagedSslCertificate({
    this.domainStatus,
    this.domains,
    this.status,
  });

  $SslCertificateManagedSslCertificate.fromJson(core.Map json_)
    : this(
        domainStatus: (json_['domainStatus']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        domains:
            (json_['domains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        status: json_['status'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domainStatus != null) 'domainStatus': domainStatus!,
    if (domains != null) 'domains': domains!,
    if (status != null) 'status': status!,
  };
}

/// Used by:
///
/// - compute:alpha : SslCertificateSelfManagedSslCertificate
/// - compute:beta : SslCertificateSelfManagedSslCertificate
/// - compute:v1 : SslCertificateSelfManagedSslCertificate
class $SslCertificateSelfManagedSslCertificate {
  /// A local certificate file.
  ///
  /// The certificate must be in PEM format. The certificate chain must be no
  /// greater than 5 certs long. The chain must include at least one
  /// intermediate cert.
  core.String? certificate;

  /// A write-only private key in PEM format.
  ///
  /// Only insert requests will include this field.
  core.String? privateKey;

  $SslCertificateSelfManagedSslCertificate({this.certificate, this.privateKey});

  $SslCertificateSelfManagedSslCertificate.fromJson(core.Map json_)
    : this(
        certificate: json_['certificate'] as core.String?,
        privateKey: json_['privateKey'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificate != null) 'certificate': certificate!,
    if (privateKey != null) 'privateKey': privateKey!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SslCertsCreateEphemeralRequest
/// - sqladmin:v1beta4 : SslCertsCreateEphemeralRequest
class $SslCertsCreateEphemeralRequest {
  /// Access token to include in the signed certificate.
  core.String? accessToken;

  /// PEM encoded public key to include in the signed certificate.
  core.String? publicKey;

  $SslCertsCreateEphemeralRequest({this.accessToken, this.publicKey});

  $SslCertsCreateEphemeralRequest.fromJson(core.Map json_)
    : this(
        accessToken: json_['access_token'] as core.String?,
        publicKey: json_['public_key'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'access_token': accessToken!,
    if (publicKey != null) 'public_key': publicKey!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SslCertsInsertRequest
/// - sqladmin:v1beta4 : SslCertsInsertRequest
class $SslCertsInsertRequest {
  /// User supplied name.
  ///
  /// Must be a distinct name from the other certificates for this instance.
  core.String? commonName;

  $SslCertsInsertRequest({this.commonName});

  $SslCertsInsertRequest.fromJson(core.Map json_)
    : this(commonName: json_['commonName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (commonName != null) 'commonName': commonName!,
  };
}

/// Used by:
///
/// - alloydb:v1 : SslConfig
/// - alloydb:v1alpha : SslConfig
/// - alloydb:v1beta : SslConfig
class $SslConfig {
  /// Certificate Authority (CA) source.
  ///
  /// Only CA_SOURCE_MANAGED is supported currently, and is the default value.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "CA_SOURCE_UNSPECIFIED" : Certificate Authority (CA) source not
  /// specified. Defaults to CA_SOURCE_MANAGED.
  /// - "CA_SOURCE_MANAGED" : Certificate Authority (CA) managed by the AlloyDB
  /// Cluster.
  core.String? caSource;

  /// SSL mode.
  ///
  /// Specifies client-server SSL/TLS connection behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SSL_MODE_UNSPECIFIED" : SSL mode is not specified. Defaults to
  /// ENCRYPTED_ONLY.
  /// - "SSL_MODE_ALLOW" : SSL connections are optional. CA verification not
  /// enforced.
  /// - "SSL_MODE_REQUIRE" : SSL connections are required. CA verification not
  /// enforced. Clients may use locally self-signed certificates (default psql
  /// client behavior).
  /// - "SSL_MODE_VERIFY_CA" : SSL connections are required. CA verification
  /// enforced. Clients must have certificates signed by a Cluster CA, for
  /// example, using GenerateClientCertificate.
  /// - "ALLOW_UNENCRYPTED_AND_ENCRYPTED" : SSL connections are optional. CA
  /// verification not enforced.
  /// - "ENCRYPTED_ONLY" : SSL connections are required. CA verification not
  /// enforced.
  core.String? sslMode;

  $SslConfig({this.caSource, this.sslMode});

  $SslConfig.fromJson(core.Map json_)
    : this(
        caSource: json_['caSource'] as core.String?,
        sslMode: json_['sslMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caSource != null) 'caSource': caSource!,
    if (sslMode != null) 'sslMode': sslMode!,
  };
}

/// Used by:
///
/// - compute:alpha : SslPoliciesListAvailableFeaturesResponse
/// - compute:beta : SslPoliciesListAvailableFeaturesResponse
/// - compute:v1 : SslPoliciesListAvailableFeaturesResponse
class $SslPoliciesListAvailableFeaturesResponse {
  core.List<core.String>? features;

  $SslPoliciesListAvailableFeaturesResponse({this.features});

  $SslPoliciesListAvailableFeaturesResponse.fromJson(core.Map json_)
    : this(
        features:
            (json_['features'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (features != null) 'features': features!,
  };
}

/// Used by:
///
/// - compute:beta : SslPolicy
/// - compute:v1 : SslPolicy
class $SslPolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// A list of features enabled when the selected profile is CUSTOM.
  ///
  /// The method returns the set of features that can be specified in this list.
  /// This field must be empty if the profile is not CUSTOM.
  core.List<core.String>? customFeatures;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of features enabled in the SSL policy.
  ///
  /// Output only.
  core.List<core.String>? enabledFeatures;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a SslPolicy.
  /// An up-to-date fingerprint must be provided in order to update the
  /// SslPolicy, otherwise the request will fail with error 412 conditionNotMet.
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// SslPolicy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#sslPolicyfor SSL policies.
  ///
  /// Output only.
  core.String? kind;

  /// The minimum version of SSL protocol that can be used by the clients to
  /// establish a connection with the load balancer.
  ///
  /// This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
  /// Possible string values are:
  /// - "TLS_1_0" : TLS 1.0
  /// - "TLS_1_1" : TLS 1.1
  /// - "TLS_1_2" : TLS 1.2
  core.String? minTlsVersion;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Profile specifies the set of SSL features that can be used by the load
  /// balancer when negotiating SSL with clients.
  ///
  /// This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using
  /// CUSTOM, the set of SSL features to enable must be specified in the
  /// customFeatures field.
  /// Possible string values are:
  /// - "COMPATIBLE" : Compatible profile. Allows the broadset set of clients,
  /// even those which support only out-of-date SSL features to negotiate with
  /// the load balancer.
  /// - "CUSTOM" : Custom profile. Allow only the set of allowed SSL features
  /// specified in the customFeatures field.
  /// - "MODERN" : Modern profile. Supports a wide set of SSL features, allowing
  /// modern clients to negotiate SSL with the load balancer.
  /// - "RESTRICTED" : Restricted profile. Supports a reduced set of SSL
  /// features, intended to meet stricter compliance requirements.
  core.String? profile;

  /// URL of the region where the regional SSL policy resides.
  ///
  /// This field is not applicable to global SSL policies.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If potential misconfigurations are detected for this SSL policy, this
  /// field will be populated with warning messages.
  ///
  /// Output only.
  core.List<SslPolicyWarnings>? warnings;

  $SslPolicy({
    this.creationTimestamp,
    this.customFeatures,
    this.description,
    this.enabledFeatures,
    this.fingerprint,
    this.id,
    this.kind,
    this.minTlsVersion,
    this.name,
    this.profile,
    this.region,
    this.selfLink,
    this.warnings,
  });

  $SslPolicy.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        customFeatures:
            (json_['customFeatures'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        description: json_['description'] as core.String?,
        enabledFeatures:
            (json_['enabledFeatures'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        fingerprint: json_['fingerprint'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        minTlsVersion: json_['minTlsVersion'] as core.String?,
        name: json_['name'] as core.String?,
        profile: json_['profile'] as core.String?,
        region: json_['region'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        warnings:
            (json_['warnings'] as core.List?)
                ?.map(
                  (value) => SslPolicyWarnings.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (customFeatures != null) 'customFeatures': customFeatures!,
    if (description != null) 'description': description!,
    if (enabledFeatures != null) 'enabledFeatures': enabledFeatures!,
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (minTlsVersion != null) 'minTlsVersion': minTlsVersion!,
    if (name != null) 'name': name!,
    if (profile != null) 'profile': profile!,
    if (region != null) 'region': region!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (warnings != null) 'warnings': warnings!,
  };
}

/// Used by:
///
/// - compute:alpha : SslPolicyReference
/// - compute:beta : SslPolicyReference
/// - compute:v1 : SslPolicyReference
class $SslPolicyReference {
  /// URL of the SSL policy resource.
  ///
  /// Set this to empty string to clear any existing SSL policy associated with
  /// the target proxy resource.
  core.String? sslPolicy;

  $SslPolicyReference({this.sslPolicy});

  $SslPolicyReference.fromJson(core.Map json_)
    : this(sslPolicy: json_['sslPolicy'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sslPolicy != null) 'sslPolicy': sslPolicy!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SqlInstancesAcquireSsrsLeaseResponse
/// - sqladmin:v1 : SqlInstancesReleaseSsrsLeaseResponse
/// - sqladmin:v1beta4 : SqlInstancesAcquireSsrsLeaseResponse
class $SsrsLeaseResponse {
  /// The unique identifier for this operation.
  core.String? operationId;

  $SsrsLeaseResponse({this.operationId});

  $SsrsLeaseResponse.fromJson(core.Map json_)
    : this(operationId: json_['operationId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (operationId != null) 'operationId': operationId!,
  };
}

/// Used by:
///
/// - cloudtasks:v2 : StackdriverLoggingConfig
/// - cloudtasks:v2beta3 : StackdriverLoggingConfig
class $StackdriverLoggingConfig {
  /// Specifies the fraction of operations to write to
  /// [Stackdriver Logging](https://cloud.google.com/logging/docs/).
  ///
  /// This field may contain any value between 0.0 and 1.0, inclusive. 0.0 is
  /// the default and means that no operations are logged.
  core.double? samplingRatio;

  $StackdriverLoggingConfig({this.samplingRatio});

  $StackdriverLoggingConfig.fromJson(core.Map json_)
    : this(samplingRatio: (json_['samplingRatio'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (samplingRatio != null) 'samplingRatio': samplingRatio!,
  };
}

/// Used by:
///
/// - container:v1 : StandardRolloutPolicy
/// - container:v1beta1 : StandardRolloutPolicy
class $StandardRolloutPolicy {
  /// Number of blue nodes to drain in a batch.
  core.int? batchNodeCount;

  /// Percentage of the blue pool nodes to drain in a batch.
  ///
  /// The range of this field should be (0.0, 1.0\].
  core.double? batchPercentage;

  /// Soak time after each batch gets drained.
  ///
  /// Default to zero.
  core.String? batchSoakDuration;

  $StandardRolloutPolicy({
    this.batchNodeCount,
    this.batchPercentage,
    this.batchSoakDuration,
  });

  $StandardRolloutPolicy.fromJson(core.Map json_)
    : this(
        batchNodeCount: json_['batchNodeCount'] as core.int?,
        batchPercentage: (json_['batchPercentage'] as core.num?)?.toDouble(),
        batchSoakDuration: json_['batchSoakDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchNodeCount != null) 'batchNodeCount': batchNodeCount!,
    if (batchPercentage != null) 'batchPercentage': batchPercentage!,
    if (batchSoakDuration != null) 'batchSoakDuration': batchSoakDuration!,
  };
}

/// Used by:
///
/// - appengine:v1 : StandardSchedulerSettings
/// - appengine:v1beta : StandardSchedulerSettings
class $StandardSchedulerSettings {
  /// Maximum number of instances to run for this version.
  ///
  /// Set to 2147483647 to disable max_instances configuration.
  core.int? maxInstances;

  /// Minimum number of instances to run for this version.
  ///
  /// Set to zero to disable min_instances configuration.
  core.int? minInstances;

  /// Target CPU utilization ratio to maintain when scaling.
  core.double? targetCpuUtilization;

  /// Target throughput utilization ratio to maintain when scaling
  core.double? targetThroughputUtilization;

  $StandardSchedulerSettings({
    this.maxInstances,
    this.minInstances,
    this.targetCpuUtilization,
    this.targetThroughputUtilization,
  });

  $StandardSchedulerSettings.fromJson(core.Map json_)
    : this(
        maxInstances: json_['maxInstances'] as core.int?,
        minInstances: json_['minInstances'] as core.int?,
        targetCpuUtilization:
            (json_['targetCpuUtilization'] as core.num?)?.toDouble(),
        targetThroughputUtilization:
            (json_['targetThroughputUtilization'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxInstances != null) 'maxInstances': maxInstances!,
    if (minInstances != null) 'minInstances': minInstances!,
    if (targetCpuUtilization != null)
      'targetCpuUtilization': targetCpuUtilization!,
    if (targetThroughputUtilization != null)
      'targetThroughputUtilization': targetThroughputUtilization!,
  };
}

/// Used by:
///
/// - container:v1 : StartIPRotationRequest
/// - container:v1beta1 : StartIPRotationRequest
class $StartIPRotationRequest {
  /// The name of the cluster.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The name (project, location, cluster name) of the cluster to start IP
  /// rotation.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// Whether to rotate credentials during IP rotation.
  core.bool? rotateCredentials;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $StartIPRotationRequest({
    this.clusterId,
    this.name,
    this.projectId,
    this.rotateCredentials,
    this.zone,
  });

  $StartIPRotationRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        rotateCredentials: json_['rotateCredentials'] as core.bool?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (rotateCredentials != null) 'rotateCredentials': rotateCredentials!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - workstations:v1 : StartWorkstationRequest
/// - workstations:v1beta : StartWorkstationRequest
class $StartWorkstationRequest {
  /// If set, the workstation starts using the boost configuration with the
  /// specified ID.
  ///
  /// Optional.
  core.String? boostConfig;

  /// If set, the request will be rejected if the latest version of the
  /// workstation on the server does not have this ETag.
  ///
  /// Optional.
  core.String? etag;

  /// If set, validate the request and preview the review, but do not actually
  /// apply it.
  ///
  /// Optional.
  core.bool? validateOnly;

  $StartWorkstationRequest({this.boostConfig, this.etag, this.validateOnly});

  $StartWorkstationRequest.fromJson(core.Map json_)
    : this(
        boostConfig: json_['boostConfig'] as core.String?,
        etag: json_['etag'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostConfig != null) 'boostConfig': boostConfig!,
    if (etag != null) 'etag': etag!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - gkehub:v1alpha : MeteringMembershipState
/// - gkehub:v1beta : MeteringMembershipState
/// - gkehub:v2 : MeteringState
/// - gkehub:v2alpha : MeteringState
/// - gkehub:v2beta : MeteringState
class $State00 {
  /// The time stamp of the most recent measurement of the number of vCPUs in
  /// the cluster.
  core.String? lastMeasurementTime;

  /// The vCPUs capacity in the cluster according to the most recent measurement
  /// (1/1000 precision).
  core.double? preciseLastMeasuredClusterVcpuCapacity;

  $State00({
    this.lastMeasurementTime,
    this.preciseLastMeasuredClusterVcpuCapacity,
  });

  $State00.fromJson(core.Map json_)
    : this(
        lastMeasurementTime: json_['lastMeasurementTime'] as core.String?,
        preciseLastMeasuredClusterVcpuCapacity:
            (json_['preciseLastMeasuredClusterVcpuCapacity'] as core.num?)
                ?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastMeasurementTime != null)
      'lastMeasurementTime': lastMeasurementTime!,
    if (preciseLastMeasuredClusterVcpuCapacity != null)
      'preciseLastMeasuredClusterVcpuCapacity':
          preciseLastMeasuredClusterVcpuCapacity!,
  };
}

/// Used by:
///
/// - gkehub:v2 : State
/// - gkehub:v2alpha : State
/// - gkehub:v2beta : State
class $State01 {
  /// The high-level, machine-readable status of this MembershipFeature.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Unknown or not set.
  /// - "OK" : The MembershipFeature is operating normally.
  /// - "WARNING" : The MembershipFeature has encountered an issue, and is
  /// operating in a degraded state. The MembershipFeature may need intervention
  /// to return to normal operation. See the description and any associated
  /// MembershipFeature-specific details for more information.
  /// - "ERROR" : The MembershipFeature is not operating or is in a severely
  /// degraded state. The MembershipFeature may need intervention to return to
  /// normal operation. See the description and any associated
  /// MembershipFeature-specific details for more information.
  core.String? code;

  /// A human-readable description of the current status.
  core.String? description;

  /// The time this status and any related Feature-specific details were
  /// updated.
  core.String? updateTime;

  $State01({this.code, this.description, this.updateTime});

  $State01.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        description: json_['description'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (description != null) 'description': description!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - workflowexecutions:v1 : StateError
/// - workflows:v1 : StateError
class $StateError {
  /// Provides specifics about the error.
  core.String? details;

  /// The type of this state error.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : No type specified.
  /// - "KMS_ERROR" : Caused by an issue with KMS.
  core.String? type;

  $StateError({this.details, this.type});

  $StateError.fromJson(core.Map json_)
    : this(
        details: json_['details'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (details != null) 'details': details!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : GoogleCloudFunctionsV2StateMessage
/// - cloudfunctions:v2alpha : GoogleCloudFunctionsV2alphaStateMessage
/// - cloudfunctions:v2beta : GoogleCloudFunctionsV2betaStateMessage
class $StateMessage {
  /// The message.
  core.String? message;

  /// Severity of the state message.
  /// Possible string values are:
  /// - "SEVERITY_UNSPECIFIED" : Not specified. Invalid severity.
  /// - "ERROR" : ERROR-level severity.
  /// - "WARNING" : WARNING-level severity.
  /// - "INFO" : INFO-level severity.
  core.String? severity;

  /// One-word CamelCase type of the state message.
  core.String? type;

  $StateMessage({this.message, this.severity, this.type});

  $StateMessage.fromJson(core.Map json_)
    : this(
        message: json_['message'] as core.String?,
        severity: json_['severity'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (message != null) 'message': message!,
    if (severity != null) 'severity': severity!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - container:v1 : StatefulHAConfig
/// - container:v1beta1 : StatefulHAConfig
class $StatefulHAConfig {
  /// Whether the Stateful HA add-on is enabled for this cluster.
  core.bool? enabled;

  $StatefulHAConfig({this.enabled});

  $StatefulHAConfig.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - compute:alpha : StatefulPolicyPreservedStateDiskDevice
/// - compute:beta : StatefulPolicyPreservedStateDiskDevice
/// - compute:v1 : StatefulPolicyPreservedStateDiskDevice
class $StatefulPolicyPreservedStateDiskDevice {
  /// These stateful disks will never be deleted during autohealing, update or
  /// VM instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole
  /// group is deleted. Note: disks attached in READ_ONLY mode cannot be
  /// auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  $StatefulPolicyPreservedStateDiskDevice({this.autoDelete});

  $StatefulPolicyPreservedStateDiskDevice.fromJson(core.Map json_)
    : this(autoDelete: json_['autoDelete'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoDelete != null) 'autoDelete': autoDelete!,
  };
}

/// Used by:
///
/// - compute:alpha : StatefulPolicyPreservedStateNetworkIp
/// - compute:beta : StatefulPolicyPreservedStateNetworkIp
/// - compute:v1 : StatefulPolicyPreservedStateNetworkIp
class $StatefulPolicyPreservedStateNetworkIp {
  /// These stateful IPs will never be released during autohealing, update or VM
  /// instance recreate operations.
  ///
  /// This flag is used to configure if the IP reservation should be deleted
  /// after it is no longer used by the group, e.g. when the given instance or
  /// the whole group is deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  $StatefulPolicyPreservedStateNetworkIp({this.autoDelete});

  $StatefulPolicyPreservedStateNetworkIp.fromJson(core.Map json_)
    : this(autoDelete: json_['autoDelete'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoDelete != null) 'autoDelete': autoDelete!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : StaticCluster
/// - trafficdirector:v3 : StaticCluster
class $StaticCluster {
  /// The cluster config.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? cluster;

  /// The timestamp when the Cluster was last updated.
  core.String? lastUpdated;

  $StaticCluster({this.cluster, this.lastUpdated});

  $StaticCluster.fromJson(core.Map json_)
    : this(
        cluster:
            json_.containsKey('cluster')
                ? json_['cluster'] as core.Map<core.String, core.dynamic>
                : null,
        lastUpdated: json_['lastUpdated'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cluster != null) 'cluster': cluster!,
    if (lastUpdated != null) 'lastUpdated': lastUpdated!,
  };
}

/// Used by:
///
/// - appengine:v1 : StaticFilesHandler
/// - appengine:v1beta : StaticFilesHandler
class $StaticFilesHandler {
  /// Whether files should also be uploaded as code data.
  ///
  /// By default, files declared in static file handlers are uploaded as static
  /// data and are only served to end users; they cannot be read by the
  /// application. If enabled, uploads are charged against both your code and
  /// static data storage resource quotas.
  core.bool? applicationReadable;

  /// Time a static file served by this handler should be cached by web proxies
  /// and browsers.
  core.String? expiration;

  /// HTTP headers to use for all responses from these URLs.
  core.Map<core.String, core.String>? httpHeaders;

  /// MIME type used to serve all files served by this handler.Defaults to
  /// file-specific MIME types, which are derived from each file's filename
  /// extension.
  core.String? mimeType;

  /// Path to the static files matched by the URL pattern, from the application
  /// root directory.
  ///
  /// The path can refer to text matched in groupings in the URL pattern.
  core.String? path;

  /// Whether this handler should match the request if the file referenced by
  /// the handler does not exist.
  core.bool? requireMatchingFile;

  /// Regular expression that matches the file paths for all files that should
  /// be referenced by this handler.
  core.String? uploadPathRegex;

  $StaticFilesHandler({
    this.applicationReadable,
    this.expiration,
    this.httpHeaders,
    this.mimeType,
    this.path,
    this.requireMatchingFile,
    this.uploadPathRegex,
  });

  $StaticFilesHandler.fromJson(core.Map json_)
    : this(
        applicationReadable: json_['applicationReadable'] as core.bool?,
        expiration: json_['expiration'] as core.String?,
        httpHeaders: (json_['httpHeaders']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        mimeType: json_['mimeType'] as core.String?,
        path: json_['path'] as core.String?,
        requireMatchingFile: json_['requireMatchingFile'] as core.bool?,
        uploadPathRegex: json_['uploadPathRegex'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (applicationReadable != null)
      'applicationReadable': applicationReadable!,
    if (expiration != null) 'expiration': expiration!,
    if (httpHeaders != null) 'httpHeaders': httpHeaders!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (path != null) 'path': path!,
    if (requireMatchingFile != null)
      'requireMatchingFile': requireMatchingFile!,
    if (uploadPathRegex != null) 'uploadPathRegex': uploadPathRegex!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : StaticListener
/// - trafficdirector:v3 : StaticListener
class $StaticListener {
  /// The timestamp when the Listener was last successfully updated.
  core.String? lastUpdated;

  /// The listener config.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? listener;

  $StaticListener({this.lastUpdated, this.listener});

  $StaticListener.fromJson(core.Map json_)
    : this(
        lastUpdated: json_['lastUpdated'] as core.String?,
        listener:
            json_.containsKey('listener')
                ? json_['listener'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastUpdated != null) 'lastUpdated': lastUpdated!,
    if (listener != null) 'listener': listener!,
  };
}

/// Used by:
///
/// - trafficdirector:v2 : StaticRouteConfig
/// - trafficdirector:v3 : StaticRouteConfig
class $StaticRouteConfig {
  /// The timestamp when the Route was last updated.
  core.String? lastUpdated;

  /// The route config.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? routeConfig;

  $StaticRouteConfig({this.lastUpdated, this.routeConfig});

  $StaticRouteConfig.fromJson(core.Map json_)
    : this(
        lastUpdated: json_['lastUpdated'] as core.String?,
        routeConfig:
            json_.containsKey('routeConfig')
                ? json_['routeConfig'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastUpdated != null) 'lastUpdated': lastUpdated!,
    if (routeConfig != null) 'routeConfig': routeConfig!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : Status
/// - admin:directory_v1 : Status
/// - aiplatform:v1 : GoogleRpcStatus
/// - aiplatform:v1beta1 : GoogleRpcStatus
/// - alertcenter:v1beta1 : Status
/// - alloydb:v1 : Status
/// - alloydb:v1alpha : Status
/// - alloydb:v1beta : Status
/// - analyticsdata:v1beta : Status
/// - analyticshub:v1 : Status
/// - androiddeviceprovisioning:v1 : Status
/// - androidmanagement:v1 : Status
/// - apigateway:v1 : ApigatewayStatus
/// - apigateway:v1beta : ApigatewayStatus
/// - apigee:v1 : GoogleRpcStatus
/// - apigeeregistry:v1 : Status
/// - apihub:v1 : GoogleRpcStatus
/// - apikeys:v2 : Status
/// - apim:v1alpha : Status
/// - appengine:v1 : Status
/// - appengine:v1alpha : Status
/// - appengine:v1beta : Status
/// - apphub:v1 : Status
/// - apphub:v1alpha : Status
/// - artifactregistry:v1 : Status
/// - artifactregistry:v1beta1 : Status
/// - artifactregistry:v1beta2 : Status
/// - assuredworkloads:v1 : GoogleRpcStatus
/// - assuredworkloads:v1beta1 : GoogleRpcStatus
/// - backupdr:v1 : Status
/// - baremetalsolution:v2 : Status
/// - batch:v1 : Status
/// - beyondcorp:v1 : GoogleRpcStatus
/// - beyondcorp:v1alpha : GoogleRpcStatus
/// - bigquerydatatransfer:v1 : Status
/// - bigqueryreservation:v1 : Status
/// - bigtableadmin:v2 : Status
/// - blockchainnodeengine:v1 : Status
/// - certificatemanager:v1 : Status
/// - checks:v1alpha : Status
/// - chromemanagement:v1 : GoogleRpcStatus
/// - cloudasset:v1 : Status
/// - cloudasset:v1beta1 : Status
/// - cloudasset:v1p7beta1 : Status
/// - cloudbuild:v1 : Status
/// - cloudbuild:v2 : Status
/// - cloudchannel:v1 : GoogleRpcStatus
/// - clouddeploy:v1 : Status
/// - cloudfunctions:v1 : Status
/// - cloudfunctions:v2 : Status
/// - cloudfunctions:v2alpha : Status
/// - cloudfunctions:v2beta : Status
/// - cloudidentity:v1 : Status
/// - cloudidentity:v1beta1 : Status
/// - cloudkms:v1 : Status
/// - cloudresourcemanager:v1 : Status
/// - cloudresourcemanager:v2 : Status
/// - cloudresourcemanager:v2beta1 : Status
/// - cloudresourcemanager:v3 : Status
/// - cloudscheduler:v1 : Status
/// - cloudscheduler:v1beta1 : Status
/// - cloudsearch:v1 : Status
/// - cloudshell:v1 : Status
/// - cloudtasks:v2 : Status
/// - cloudtasks:v2beta2 : Status
/// - cloudtasks:v2beta3 : Status
/// - cloudtrace:v2 : Status
/// - composer:v1 : Status
/// - composer:v1beta1 : Status
/// - config:v1 : Status
/// - connectors:v1 : Status
/// - contactcenteraiplatform:v1alpha1 : Status
/// - contactcenterinsights:v1 : GoogleRpcStatus
/// - container:v1 : Status
/// - container:v1beta1 : Status
/// - containeranalysis:v1 : Status
/// - containeranalysis:v1alpha1 : Status
/// - containeranalysis:v1beta1 : Status
/// - contentwarehouse:v1 : GoogleRpcStatus
/// - datacatalog:v1 : Status
/// - dataflow:v1b3 : Status
/// - dataform:v1beta1 : Status
/// - datafusion:v1 : Status
/// - datafusion:v1beta1 : Status
/// - datalabeling:v1beta1 : GoogleRpcStatus
/// - datalineage:v1 : GoogleRpcStatus
/// - datamigration:v1 : Status
/// - datamigration:v1beta1 : Status
/// - datapipelines:v1 : GoogleRpcStatus
/// - dataplex:v1 : GoogleRpcStatus
/// - dataproc:v1 : Status
/// - datastore:v1 : Status
/// - datastore:v1beta1 : Status
/// - datastream:v1 : Status
/// - datastream:v1alpha1 : Status
/// - deploymentmanager:alpha : Status
/// - deploymentmanager:v2 : Status
/// - deploymentmanager:v2beta : Status
/// - developerconnect:v1 : Status
/// - dialogflow:v2 : GoogleRpcStatus
/// - dialogflow:v2beta1 : GoogleRpcStatus
/// - dialogflow:v3 : GoogleRpcStatus
/// - dialogflow:v3beta1 : GoogleRpcStatus
/// - discoveryengine:v1 : GoogleRpcStatus
/// - discoveryengine:v1alpha : GoogleRpcStatus
/// - discoveryengine:v1beta : GoogleRpcStatus
/// - displayvideo:v2 : Status
/// - displayvideo:v3 : Status
/// - displayvideo:v4 : Status
/// - dlp:v2 : GoogleRpcStatus
/// - documentai:v1 : GoogleRpcStatus
/// - documentai:v1beta3 : GoogleRpcStatus
/// - domains:v1 : Status
/// - domains:v1alpha2 : Status
/// - domains:v1beta1 : Status
/// - drive:v3 : Status
/// - eventarc:v1 : GoogleRpcStatus
/// - file:v1 : Status
/// - file:v1beta1 : Status
/// - firebase:v1beta1 : Status
/// - firebaseappdistribution:v1 : GoogleRpcStatus
/// - firebaseapphosting:v1 : Status
/// - firebaseapphosting:v1beta : Status
/// - firebasedataconnect:v1 : Status
/// - firebasedataconnect:v1beta : Status
/// - firebasehosting:v1 : Status
/// - firebasehosting:v1beta1 : Status
/// - firebaseml:v1 : Status
/// - firebaseml:v1beta2 : Status
/// - firestore:v1 : Status
/// - firestore:v1beta1 : Status
/// - firestore:v1beta2 : Status
/// - gkebackup:v1 : GoogleRpcStatus
/// - gkehub:v1 : GoogleRpcStatus
/// - gkehub:v1alpha : GoogleRpcStatus
/// - gkehub:v1beta : GoogleRpcStatus
/// - gkehub:v1beta1 : GoogleRpcStatus
/// - gkehub:v2 : GoogleRpcStatus
/// - gkehub:v2alpha : GoogleRpcStatus
/// - gkehub:v2beta : GoogleRpcStatus
/// - gkeonprem:v1 : Status
/// - healthcare:v1 : Status
/// - healthcare:v1beta1 : Status
/// - iam:v1 : Status
/// - iam:v2 : GoogleRpcStatus
/// - iam:v2beta : GoogleRpcStatus
/// - ids:v1 : Status
/// - jobs:v3p1beta1 : Status
/// - jobs:v4 : Status
/// - lifesciences:v2beta : Status
/// - logging:v2 : Status
/// - looker:v1 : Status
/// - managedidentities:v1 : Status
/// - managedidentities:v1alpha1 : Status
/// - managedidentities:v1beta1 : Status
/// - managedkafka:v1 : Status
/// - memcache:v1 : Status
/// - memcache:v1beta2 : Status
/// - metastore:v1 : Status
/// - metastore:v1alpha : Status
/// - metastore:v1beta : Status
/// - migrationcenter:v1 : Status
/// - migrationcenter:v1alpha1 : Status
/// - ml:v1 : GoogleRpc__Status
/// - monitoring:v1 : Status
/// - monitoring:v3 : Status
/// - netapp:v1 : Status
/// - netapp:v1beta1 : Status
/// - networkconnectivity:v1 : GoogleRpcStatus
/// - networkconnectivity:v1alpha1 : GoogleRpcStatus
/// - networkmanagement:v1 : Status
/// - networkmanagement:v1beta1 : Status
/// - networksecurity:v1 : Status
/// - networksecurity:v1beta1 : Status
/// - networkservices:v1 : Status
/// - networkservices:v1beta1 : Status
/// - notebooks:v1 : Status
/// - notebooks:v2 : Status
/// - observability:v1 : Status
/// - ondemandscanning:v1 : Status
/// - ondemandscanning:v1beta1 : Status
/// - oracledatabase:v1 : Status
/// - osconfig:v1 : Status
/// - osconfig:v1alpha : Status
/// - osconfig:v2 : Status
/// - osconfig:v2beta : Status
/// - parallelstore:v1 : Status
/// - parallelstore:v1beta : Status
/// - people:v1 : Status
/// - policysimulator:v1 : GoogleRpcStatus
/// - policysimulator:v1alpha : GoogleRpcStatus
/// - policysimulator:v1beta : GoogleRpcStatus
/// - policytroubleshooter:v1 : GoogleRpcStatus
/// - privateca:v1 : Status
/// - privateca:v1beta1 : Status
/// - prod_tt_sasportal:v1alpha1 : SasPortalStatus
/// - pubsublite:v1 : Status
/// - rapidmigrationassessment:v1 : Status
/// - recaptchaenterprise:v1 : GoogleRpcStatus
/// - recommendationengine:v1beta1 : GoogleRpcStatus
/// - redis:v1 : Status
/// - redis:v1beta1 : Status
/// - retail:v2 : GoogleRpcStatus
/// - retail:v2alpha : GoogleRpcStatus
/// - retail:v2beta : GoogleRpcStatus
/// - run:v1 : GoogleRpcStatus
/// - run:v2 : GoogleRpcStatus
/// - runtimeconfig:v1 : Status
/// - runtimeconfig:v1beta1 : Status
/// - sasportal:v1alpha1 : SasPortalStatus
/// - securesourcemanager:v1 : Status
/// - securitycenter:v1 : Status
/// - securitycenter:v1beta1 : Status
/// - securityposture:v1 : Status
/// - serviceconsumermanagement:v1 : Status
/// - serviceconsumermanagement:v1beta1 : Status
/// - servicecontrol:v1 : Status
/// - servicecontrol:v2 : Status
/// - servicemanagement:v1 : Status
/// - servicenetworking:v1 : Status
/// - servicenetworking:v1beta : Status
/// - serviceusage:v1 : Status
/// - serviceusage:v1beta1 : Status
/// - spanner:v1 : Status
/// - speech:v1 : Status
/// - speech:v1p1beta1 : Status
/// - storagebatchoperations:v1 : Status
/// - storagetransfer:v1 : Status
/// - streetviewpublish:v1 : Status
/// - texttospeech:v1 : Status
/// - texttospeech:v1beta1 : Status
/// - toolresults:v1beta3 : Status
/// - tpu:v1 : Status
/// - tpu:v1alpha1 : Status
/// - tpu:v2 : Status
/// - tpu:v2alpha1 : Status
/// - transcoder:v1 : Status
/// - translate:v3 : Status
/// - translate:v3beta1 : Status
/// - vault:v1 : Status
/// - videointelligence:v1 : GoogleRpc_Status
/// - videointelligence:v1beta2 : GoogleRpc_Status
/// - videointelligence:v1p1beta1 : GoogleRpc_Status
/// - videointelligence:v1p2beta1 : GoogleRpc_Status
/// - videointelligence:v1p3beta1 : GoogleRpc_Status
/// - vision:v1 : Status
/// - vision:v1p1beta1 : Status
/// - vision:v1p2beta1 : Status
/// - vmmigration:v1 : Status
/// - vmmigration:v1alpha1 : Status
/// - vmwareengine:v1 : Status
/// - vpcaccess:v1 : Status
/// - vpcaccess:v1beta1 : Status
/// - webrisk:v1 : GoogleRpcStatus
/// - workflows:v1 : Status
/// - workflows:v1beta : Status
/// - workloadmanager:v1 : Status
/// - workspaceevents:v1 : Status
/// - workstations:v1 : Status
/// - workstations:v1beta : Status
class $Status00 {
  /// The status code, which should be an enum value of google.rpc.Code.
  core.int? code;

  /// A list of messages that carry the error details.
  ///
  /// There is a common set of message types for APIs to use.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? details;

  /// A developer-facing error message, which should be in English.
  ///
  /// Any user-facing error message should be localized and sent in the
  /// google.rpc.Status.details field, or localized by the client.
  core.String? message;

  $Status00({this.code, this.details, this.message});

  $Status00.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.int?,
        details:
            (json_['details'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (details != null) 'details': details!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - gkehub:v1 : Status
/// - gkehub:v1alpha : Status
/// - gkehub:v1beta : Status
/// - gkehub:v2 : AppDevExperienceStatus
/// - gkehub:v2alpha : AppDevExperienceStatus
/// - gkehub:v2beta : AppDevExperienceStatus
class $Status01 {
  /// Code specifies AppDevExperienceFeature's subcomponent ready state.
  /// Possible string values are:
  /// - "CODE_UNSPECIFIED" : Not set.
  /// - "OK" : AppDevExperienceFeature's specified subcomponent is ready.
  /// - "FAILED" : AppDevExperienceFeature's specified subcomponent ready state
  /// is false. This means AppDevExperienceFeature has encountered an issue that
  /// blocks all, or a portion, of its normal operation. See the `description`
  /// for more details.
  /// - "UNKNOWN" : AppDevExperienceFeature's specified subcomponent has a
  /// pending or unknown state.
  core.String? code;

  /// Description is populated if Code is Failed, explaining why it has failed.
  core.String? description;

  $Status01({this.code, this.description});

  $Status01.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.String?,
        description: json_['description'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (description != null) 'description': description!,
  };
}

/// Used by:
///
/// - compute:alpha : Status
/// - compute:beta : Status
/// - compute:v1 : Status
class $Status02 {
  /// The status code, which should be an enum value of google.rpc.Code.
  core.int? code;

  /// A list of messages that carry the error details.
  ///
  /// There is a common set of message types for APIs to use.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? details;

  /// A developer-facing error message, which should be in English.
  ///
  /// Any user-facing error message should be localized and sent in the
  /// google.rpc.Status.details field, or localized by the client.
  core.String? message;

  $Status02({this.code, this.details, this.message});

  $Status02.fromJson(core.Map json_)
    : this(
        code: json_['code'] as core.int?,
        details:
            (json_['details'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (code != null) 'code': code!,
    if (details != null) 'details': details!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - container:v1 : StatusCondition
/// - container:v1beta1 : StatusCondition
class $StatusCondition {
  /// Canonical code of the condition.
  /// Possible string values are:
  /// - "OK" : Not an error; returned on success. HTTP Mapping: 200 OK
  /// - "CANCELLED" : The operation was cancelled, typically by the caller. HTTP
  /// Mapping: 499 Client Closed Request
  /// - "UNKNOWN" : Unknown error. For example, this error may be returned when
  /// a `Status` value received from another address space belongs to an error
  /// space that is not known in this address space. Also errors raised by APIs
  /// that do not return enough error information may be converted to this
  /// error. HTTP Mapping: 500 Internal Server Error
  /// - "INVALID_ARGUMENT" : The client specified an invalid argument. Note that
  /// this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates
  /// arguments that are problematic regardless of the state of the system
  /// (e.g., a malformed file name). HTTP Mapping: 400 Bad Request
  /// - "DEADLINE_EXCEEDED" : The deadline expired before the operation could
  /// complete. For operations that change the state of the system, this error
  /// may be returned even if the operation has completed successfully. For
  /// example, a successful response from a server could have been delayed long
  /// enough for the deadline to expire. HTTP Mapping: 504 Gateway Timeout
  /// - "NOT_FOUND" : Some requested entity (e.g., file or directory) was not
  /// found. Note to server developers: if a request is denied for an entire
  /// class of users, such as gradual feature rollout or undocumented allowlist,
  /// `NOT_FOUND` may be used. If a request is denied for some users within a
  /// class of users, such as user-based access control, `PERMISSION_DENIED`
  /// must be used. HTTP Mapping: 404 Not Found
  /// - "ALREADY_EXISTS" : The entity that a client attempted to create (e.g.,
  /// file or directory) already exists. HTTP Mapping: 409 Conflict
  /// - "PERMISSION_DENIED" : The caller does not have permission to execute the
  /// specified operation. `PERMISSION_DENIED` must not be used for rejections
  /// caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for
  /// those errors). `PERMISSION_DENIED` must not be used if the caller can not
  /// be identified (use `UNAUTHENTICATED` instead for those errors). This error
  /// code does not imply the request is valid or the requested entity exists or
  /// satisfies other pre-conditions. HTTP Mapping: 403 Forbidden
  /// - "UNAUTHENTICATED" : The request does not have valid authentication
  /// credentials for the operation. HTTP Mapping: 401 Unauthorized
  /// - "RESOURCE_EXHAUSTED" : Some resource has been exhausted, perhaps a
  /// per-user quota, or perhaps the entire file system is out of space. HTTP
  /// Mapping: 429 Too Many Requests
  /// - "FAILED_PRECONDITION" : The operation was rejected because the system is
  /// not in a state required for the operation's execution. For example, the
  /// directory to be deleted is non-empty, an rmdir operation is applied to a
  /// non-directory, etc. Service implementors can use the following guidelines
  /// to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a)
  /// Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use
  /// `ABORTED` if the client should retry at a higher level. For example, when
  /// a client-specified test-and-set fails, indicating the client should
  /// restart a read-modify-write sequence. (c) Use `FAILED_PRECONDITION` if the
  /// client should not retry until the system state has been explicitly fixed.
  /// For example, if an "rmdir" fails because the directory is non-empty,
  /// `FAILED_PRECONDITION` should be returned since the client should not retry
  /// unless the files are deleted from the directory. HTTP Mapping: 400 Bad
  /// Request
  /// - "ABORTED" : The operation was aborted, typically due to a concurrency
  /// issue such as a sequencer check failure or transaction abort. See the
  /// guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`,
  /// and `UNAVAILABLE`. HTTP Mapping: 409 Conflict
  /// - "OUT_OF_RANGE" : The operation was attempted past the valid range. E.g.,
  /// seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error
  /// indicates a problem that may be fixed if the system state changes. For
  /// example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to
  /// read at an offset that is not in the range \[0,2^32-1\], but it will
  /// generate `OUT_OF_RANGE` if asked to read from an offset past the current
  /// file size. There is a fair bit of overlap between `FAILED_PRECONDITION`
  /// and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific
  /// error) when it applies so that callers who are iterating through a space
  /// can easily look for an `OUT_OF_RANGE` error to detect when they are done.
  /// HTTP Mapping: 400 Bad Request
  /// - "UNIMPLEMENTED" : The operation is not implemented or is not
  /// supported/enabled in this service. HTTP Mapping: 501 Not Implemented
  /// - "INTERNAL" : Internal errors. This means that some invariants expected
  /// by the underlying system have been broken. This error code is reserved for
  /// serious errors. HTTP Mapping: 500 Internal Server Error
  /// - "UNAVAILABLE" : The service is currently unavailable. This is most
  /// likely a transient condition, which can be corrected by retrying with a
  /// backoff. Note that it is not always safe to retry non-idempotent
  /// operations. See the guidelines above for deciding between
  /// `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. HTTP Mapping: 503
  /// Service Unavailable
  /// - "DATA_LOSS" : Unrecoverable data loss or corruption. HTTP Mapping: 500
  /// Internal Server Error
  core.String? canonicalCode;

  /// Machine-friendly representation of the condition Deprecated.
  ///
  /// Use canonical_code instead.
  /// Possible string values are:
  /// - "UNKNOWN" : UNKNOWN indicates a generic condition.
  /// - "GCE_STOCKOUT" : GCE_STOCKOUT indicates that Google Compute Engine
  /// resources are temporarily unavailable.
  /// - "GKE_SERVICE_ACCOUNT_DELETED" : GKE_SERVICE_ACCOUNT_DELETED indicates
  /// that the user deleted their robot service account.
  /// - "GCE_QUOTA_EXCEEDED" : Google Compute Engine quota was exceeded.
  /// - "SET_BY_OPERATOR" : Cluster state was manually changed by an SRE due to
  /// a system logic error.
  /// - "CLOUD_KMS_KEY_ERROR" : Unable to perform an encrypt operation against
  /// the CloudKMS key used for etcd level encryption.
  /// - "CA_EXPIRING" : Cluster CA is expiring soon.
  /// - "NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS" : Node service account is
  /// missing permissions.
  /// - "CLOUD_KMS_KEY_DESTROYED" : Cloud KMS key version used for etcd level
  /// encryption has been destroyed. This is a permanent error.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? code;

  /// Human-friendly representation of the condition
  core.String? message;

  $StatusCondition({this.canonicalCode, this.code, this.message});

  $StatusCondition.fromJson(core.Map json_)
    : this(
        canonicalCode: json_['canonicalCode'] as core.String?,
        code: json_['code'] as core.String?,
        message: json_['message'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canonicalCode != null) 'canonicalCode': canonicalCode!,
    if (code != null) 'code': code!,
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - workflowexecutions:v1 : Step
/// - workflowexecutions:v1beta : Step
class $Step {
  /// Name of a routine within the workflow.
  core.String? routine;

  /// Name of a step within the routine.
  core.String? step;

  $Step({this.routine, this.step});

  $Step.fromJson(core.Map json_)
    : this(
        routine: json_['routine'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (routine != null) 'routine': routine!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - composer:v1 : StopAirflowCommandRequest
/// - composer:v1beta1 : StopAirflowCommandRequest
class $StopAirflowCommandRequest {
  /// The unique ID of the command execution.
  core.String? executionId;

  /// If true, the execution is terminated forcefully (SIGKILL).
  ///
  /// If false, the execution is stopped gracefully, giving it time for cleanup.
  core.bool? force;

  /// The name of the pod where the command is executed.
  core.String? pod;

  /// The namespace of the pod where the command is executed.
  core.String? podNamespace;

  $StopAirflowCommandRequest({
    this.executionId,
    this.force,
    this.pod,
    this.podNamespace,
  });

  $StopAirflowCommandRequest.fromJson(core.Map json_)
    : this(
        executionId: json_['executionId'] as core.String?,
        force: json_['force'] as core.bool?,
        pod: json_['pod'] as core.String?,
        podNamespace: json_['podNamespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (executionId != null) 'executionId': executionId!,
    if (force != null) 'force': force!,
    if (pod != null) 'pod': pod!,
    if (podNamespace != null) 'podNamespace': podNamespace!,
  };
}

/// Used by:
///
/// - composer:v1 : StopAirflowCommandResponse
/// - composer:v1beta1 : StopAirflowCommandResponse
class $StopAirflowCommandResponse {
  /// Whether the execution is still running.
  core.bool? isDone;

  /// Output message from stopping execution request.
  core.List<core.String>? output;

  $StopAirflowCommandResponse({this.isDone, this.output});

  $StopAirflowCommandResponse.fromJson(core.Map json_)
    : this(
        isDone: json_['isDone'] as core.bool?,
        output:
            (json_['output'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isDone != null) 'isDone': isDone!,
    if (output != null) 'output': output!,
  };
}

/// Used by:
///
/// - netapp:v1 : StopReplicationRequest
/// - netapp:v1beta1 : StopReplicationRequest
class $StopReplicationRequest {
  /// Indicates whether to stop replication forcefully while data transfer is in
  /// progress.
  ///
  /// Warning! if force is true, this will abort any current transfers and can
  /// lead to data loss due to partial transfer. If force is false, stop
  /// replication will fail while data transfer is in progress and you will need
  /// to retry later.
  core.bool? force;

  $StopReplicationRequest({this.force});

  $StopReplicationRequest.fromJson(core.Map json_)
    : this(force: json_['force'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (force != null) 'force': force!,
  };
}

/// Used by:
///
/// - workstations:v1 : StopWorkstationRequest
/// - workstations:v1beta : StopWorkstationRequest
class $StopWorkstationRequest {
  /// If set, the request will be rejected if the latest version of the
  /// workstation on the server does not have this ETag.
  ///
  /// Optional.
  core.String? etag;

  /// If set, validate the request and preview the review, but do not actually
  /// apply it.
  ///
  /// Optional.
  core.bool? validateOnly;

  $StopWorkstationRequest({this.etag, this.validateOnly});

  $StopWorkstationRequest.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : StorageBucketInfo
/// - networkmanagement:v1beta1 : StorageBucketInfo
class $StorageBucketInfo {
  /// Cloud Storage Bucket name.
  core.String? bucket;

  $StorageBucketInfo({this.bucket});

  $StorageBucketInfo.fromJson(core.Map json_)
    : this(bucket: json_['bucket'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
  };
}

/// Used by:
///
/// - composer:v1 : StorageConfig
/// - composer:v1beta1 : StorageConfig
class $StorageConfig {
  /// The name of the Cloud Storage bucket used by the environment.
  ///
  /// No `gs://` prefix.
  ///
  /// Optional.
  core.String? bucket;

  $StorageConfig({this.bucket});

  $StorageConfig.fromJson(core.Map json_)
    : this(bucket: json_['bucket'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
  };
}

/// Used by:
///
/// - netapp:v1 : StoragePool
/// - netapp:v1beta1 : StoragePool
class $StoragePool {
  /// Specifies the Active Directory to be used for creating a SMB volume.
  ///
  /// Optional.
  core.String? activeDirectory;

  /// True if the storage pool supports Auto Tiering enabled volumes.
  ///
  /// Default is false. Auto-tiering can be enabled after storage pool creation
  /// but it can't be disabled once enabled.
  ///
  /// Optional.
  core.bool? allowAutoTiering;

  /// Capacity in GIB of the pool
  ///
  /// Required.
  core.String? capacityGib;

  /// Create time of the storage pool
  ///
  /// Output only.
  core.String? createTime;

  /// True if using Independent Scaling of capacity and performance (Hyperdisk)
  /// By default set to false
  ///
  /// Optional.
  core.bool? customPerformanceEnabled;

  /// Description of the storage pool
  ///
  /// Optional.
  core.String? description;

  /// Flag indicating that the hot-tier threshold will be auto-increased by 10%
  /// of the hot-tier when it hits 100%.
  ///
  /// Default is true. The increment will kick in only if the new size after
  /// increment is still less than or equal to storage pool size.
  ///
  /// Optional.
  core.bool? enableHotTierAutoResize;

  /// Specifies the current pool encryption key source.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ENCRYPTION_TYPE_UNSPECIFIED" : The source of the encryption key is not
  /// specified.
  /// - "SERVICE_MANAGED" : Google managed encryption key.
  /// - "CLOUD_KMS" : Customer managed encryption key, which is stored in KMS.
  core.String? encryptionType;

  /// Used to allow SO pool to access AD or DNS server from other regions.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? globalAccessAllowed;

  /// Total hot tier capacity for the Storage Pool.
  ///
  /// It is applicable only to Flex service level. It should be less than the
  /// minimum storage pool size and cannot be more than the current storage pool
  /// size. It cannot be decreased once set.
  ///
  /// Optional.
  core.String? hotTierSizeGib;

  /// Specifies the KMS config to be used for volume encryption.
  ///
  /// Optional.
  core.String? kmsConfig;

  /// Labels as key value pairs
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Flag indicating if the pool is NFS LDAP enabled or not.
  ///
  /// Optional.
  core.bool? ldapEnabled;

  /// Identifier.
  ///
  /// Name of the storage pool
  core.String? name;

  /// VPC Network name.
  ///
  /// Format: projects/{project}/global/networks/{network}
  ///
  /// Required.
  core.String? network;

  /// This field is not implemented.
  ///
  /// The values provided in this field are ignored.
  ///
  /// Optional.
  core.String? psaRange;

  /// Specifies the replica zone for regional storagePool.
  ///
  /// Optional.
  core.String? replicaZone;

  /// Reserved for future use
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Service level of the storage pool
  ///
  /// Required.
  /// Possible string values are:
  /// - "SERVICE_LEVEL_UNSPECIFIED" : Unspecified service level.
  /// - "PREMIUM" : Premium service level.
  /// - "EXTREME" : Extreme service level.
  /// - "STANDARD" : Standard service level.
  /// - "FLEX" : Flex service level.
  core.String? serviceLevel;

  /// State of the storage pool
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Storage Pool State
  /// - "READY" : Storage Pool State is Ready
  /// - "CREATING" : Storage Pool State is Creating
  /// - "DELETING" : Storage Pool State is Deleting
  /// - "UPDATING" : Storage Pool State is Updating
  /// - "RESTORING" : Storage Pool State is Restoring
  /// - "DISABLED" : Storage Pool State is Disabled
  /// - "ERROR" : Storage Pool State is Error
  core.String? state;

  /// State details of the storage pool
  ///
  /// Output only.
  core.String? stateDetails;

  /// Custom Performance Total IOPS of the pool if not provided, it will be
  /// calculated based on the total_throughput_mibps
  ///
  /// Optional.
  core.String? totalIops;

  /// Custom Performance Total Throughput of the pool (in MiBps)
  ///
  /// Optional.
  core.String? totalThroughputMibps;

  /// Allocated size of all volumes in GIB in the storage pool
  ///
  /// Output only.
  core.String? volumeCapacityGib;

  /// Volume count of the storage pool
  ///
  /// Output only.
  core.int? volumeCount;

  /// Specifies the active zone for regional storagePool.
  ///
  /// Optional.
  core.String? zone;

  $StoragePool({
    this.activeDirectory,
    this.allowAutoTiering,
    this.capacityGib,
    this.createTime,
    this.customPerformanceEnabled,
    this.description,
    this.enableHotTierAutoResize,
    this.encryptionType,
    this.globalAccessAllowed,
    this.hotTierSizeGib,
    this.kmsConfig,
    this.labels,
    this.ldapEnabled,
    this.name,
    this.network,
    this.psaRange,
    this.replicaZone,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceLevel,
    this.state,
    this.stateDetails,
    this.totalIops,
    this.totalThroughputMibps,
    this.volumeCapacityGib,
    this.volumeCount,
    this.zone,
  });

  $StoragePool.fromJson(core.Map json_)
    : this(
        activeDirectory: json_['activeDirectory'] as core.String?,
        allowAutoTiering: json_['allowAutoTiering'] as core.bool?,
        capacityGib: json_['capacityGib'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        customPerformanceEnabled:
            json_['customPerformanceEnabled'] as core.bool?,
        description: json_['description'] as core.String?,
        enableHotTierAutoResize: json_['enableHotTierAutoResize'] as core.bool?,
        encryptionType: json_['encryptionType'] as core.String?,
        globalAccessAllowed: json_['globalAccessAllowed'] as core.bool?,
        hotTierSizeGib: json_['hotTierSizeGib'] as core.String?,
        kmsConfig: json_['kmsConfig'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        ldapEnabled: json_['ldapEnabled'] as core.bool?,
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        psaRange: json_['psaRange'] as core.String?,
        replicaZone: json_['replicaZone'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceLevel: json_['serviceLevel'] as core.String?,
        state: json_['state'] as core.String?,
        stateDetails: json_['stateDetails'] as core.String?,
        totalIops: json_['totalIops'] as core.String?,
        totalThroughputMibps: json_['totalThroughputMibps'] as core.String?,
        volumeCapacityGib: json_['volumeCapacityGib'] as core.String?,
        volumeCount: json_['volumeCount'] as core.int?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeDirectory != null) 'activeDirectory': activeDirectory!,
    if (allowAutoTiering != null) 'allowAutoTiering': allowAutoTiering!,
    if (capacityGib != null) 'capacityGib': capacityGib!,
    if (createTime != null) 'createTime': createTime!,
    if (customPerformanceEnabled != null)
      'customPerformanceEnabled': customPerformanceEnabled!,
    if (description != null) 'description': description!,
    if (enableHotTierAutoResize != null)
      'enableHotTierAutoResize': enableHotTierAutoResize!,
    if (encryptionType != null) 'encryptionType': encryptionType!,
    if (globalAccessAllowed != null)
      'globalAccessAllowed': globalAccessAllowed!,
    if (hotTierSizeGib != null) 'hotTierSizeGib': hotTierSizeGib!,
    if (kmsConfig != null) 'kmsConfig': kmsConfig!,
    if (labels != null) 'labels': labels!,
    if (ldapEnabled != null) 'ldapEnabled': ldapEnabled!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (psaRange != null) 'psaRange': psaRange!,
    if (replicaZone != null) 'replicaZone': replicaZone!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceLevel != null) 'serviceLevel': serviceLevel!,
    if (state != null) 'state': state!,
    if (stateDetails != null) 'stateDetails': stateDetails!,
    if (totalIops != null) 'totalIops': totalIops!,
    if (totalThroughputMibps != null)
      'totalThroughputMibps': totalThroughputMibps!,
    if (volumeCapacityGib != null) 'volumeCapacityGib': volumeCapacityGib!,
    if (volumeCount != null) 'volumeCount': volumeCount!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - compute:alpha : StoragePoolDisk
/// - compute:beta : StoragePoolDisk
/// - compute:v1 : StoragePoolDisk
class $StoragePoolDisk {
  /// Instances this disk is attached to.
  ///
  /// Output only.
  core.List<core.String>? attachedInstances;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The URL of the disk.
  ///
  /// Output only.
  core.String? disk;

  /// The name of the disk.
  ///
  /// Output only.
  core.String? name;

  /// The number of IOPS provisioned for the disk.
  ///
  /// Output only.
  core.String? provisionedIops;

  /// The throughput provisioned for the disk.
  ///
  /// Output only.
  core.String? provisionedThroughput;

  /// Resource policies applied to disk for automatic snapshot creations.
  ///
  /// Output only.
  core.List<core.String>? resourcePolicies;

  /// The disk size, in GB.
  ///
  /// Output only.
  core.String? sizeGb;

  /// The disk status.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING" : Disk is provisioning
  /// - "DELETING" : Disk is deleting.
  /// - "FAILED" : Disk creation failed.
  /// - "READY" : Disk is ready for use.
  /// - "RESTORING" : Source data is being copied into the disk.
  /// - "UNAVAILABLE" : Disk is currently unavailable and cannot be accessed,
  /// attached or detached.
  core.String? status;

  /// The disk type.
  ///
  /// Output only.
  core.String? type;

  /// Amount of disk space used.
  ///
  /// Output only.
  core.String? usedBytes;

  $StoragePoolDisk({
    this.attachedInstances,
    this.creationTimestamp,
    this.disk,
    this.name,
    this.provisionedIops,
    this.provisionedThroughput,
    this.resourcePolicies,
    this.sizeGb,
    this.status,
    this.type,
    this.usedBytes,
  });

  $StoragePoolDisk.fromJson(core.Map json_)
    : this(
        attachedInstances:
            (json_['attachedInstances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        disk: json_['disk'] as core.String?,
        name: json_['name'] as core.String?,
        provisionedIops: json_['provisionedIops'] as core.String?,
        provisionedThroughput: json_['provisionedThroughput'] as core.String?,
        resourcePolicies:
            (json_['resourcePolicies'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sizeGb: json_['sizeGb'] as core.String?,
        status: json_['status'] as core.String?,
        type: json_['type'] as core.String?,
        usedBytes: json_['usedBytes'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attachedInstances != null) 'attachedInstances': attachedInstances!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (disk != null) 'disk': disk!,
    if (name != null) 'name': name!,
    if (provisionedIops != null) 'provisionedIops': provisionedIops!,
    if (provisionedThroughput != null)
      'provisionedThroughput': provisionedThroughput!,
    if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
    if (status != null) 'status': status!,
    if (type != null) 'type': type!,
    if (usedBytes != null) 'usedBytes': usedBytes!,
  };
}

/// Used by:
///
/// - compute:beta : StoragePoolResourceStatus
/// - compute:v1 : StoragePoolResourceStatus
class $StoragePoolResourceStatus {
  /// Number of disks used.
  ///
  /// Output only.
  core.String? diskCount;

  /// Timestamp of the last successful resize in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastResizeTimestamp;

  /// Maximum allowed aggregate disk size in GiB.
  ///
  /// Output only.
  core.String? maxTotalProvisionedDiskCapacityGb;

  /// Space used by data stored in disks within the storage pool (in bytes).
  ///
  /// This will reflect the total number of bytes written to the disks in the
  /// pool, in contrast to the capacity of those disks.
  ///
  /// Output only.
  core.String? poolUsedCapacityBytes;

  /// Sum of all the disks' provisioned IOPS, minus some amount that is allowed
  /// per disk that is not counted towards pool's IOPS capacity.
  ///
  /// For more information, see
  /// https://cloud.google.com/compute/docs/disks/storage-pools.
  ///
  /// Output only.
  core.String? poolUsedIops;

  /// Sum of all the disks' provisioned throughput in MiB/s.
  ///
  /// Output only.
  core.String? poolUsedThroughput;

  /// Amount of data written into the pool, before it is compacted.
  ///
  /// Output only.
  core.String? poolUserWrittenBytes;

  /// Sum of all the disks' provisioned capacity (in GiB) in this storage pool.
  ///
  /// A disk's provisioned capacity is the same as its total capacity.
  ///
  /// Output only.
  core.String? totalProvisionedDiskCapacityGb;

  /// Sum of all the disks' provisioned IOPS.
  ///
  /// Output only.
  core.String? totalProvisionedDiskIops;

  /// Sum of all the disks' provisioned throughput in MiB/s, minus some amount
  /// that is allowed per disk that is not counted towards pool's throughput
  /// capacity.
  ///
  /// Output only.
  core.String? totalProvisionedDiskThroughput;

  $StoragePoolResourceStatus({
    this.diskCount,
    this.lastResizeTimestamp,
    this.maxTotalProvisionedDiskCapacityGb,
    this.poolUsedCapacityBytes,
    this.poolUsedIops,
    this.poolUsedThroughput,
    this.poolUserWrittenBytes,
    this.totalProvisionedDiskCapacityGb,
    this.totalProvisionedDiskIops,
    this.totalProvisionedDiskThroughput,
  });

  $StoragePoolResourceStatus.fromJson(core.Map json_)
    : this(
        diskCount: json_['diskCount'] as core.String?,
        lastResizeTimestamp: json_['lastResizeTimestamp'] as core.String?,
        maxTotalProvisionedDiskCapacityGb:
            json_['maxTotalProvisionedDiskCapacityGb'] as core.String?,
        poolUsedCapacityBytes: json_['poolUsedCapacityBytes'] as core.String?,
        poolUsedIops: json_['poolUsedIops'] as core.String?,
        poolUsedThroughput: json_['poolUsedThroughput'] as core.String?,
        poolUserWrittenBytes: json_['poolUserWrittenBytes'] as core.String?,
        totalProvisionedDiskCapacityGb:
            json_['totalProvisionedDiskCapacityGb'] as core.String?,
        totalProvisionedDiskIops:
            json_['totalProvisionedDiskIops'] as core.String?,
        totalProvisionedDiskThroughput:
            json_['totalProvisionedDiskThroughput'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskCount != null) 'diskCount': diskCount!,
    if (lastResizeTimestamp != null)
      'lastResizeTimestamp': lastResizeTimestamp!,
    if (maxTotalProvisionedDiskCapacityGb != null)
      'maxTotalProvisionedDiskCapacityGb': maxTotalProvisionedDiskCapacityGb!,
    if (poolUsedCapacityBytes != null)
      'poolUsedCapacityBytes': poolUsedCapacityBytes!,
    if (poolUsedIops != null) 'poolUsedIops': poolUsedIops!,
    if (poolUsedThroughput != null) 'poolUsedThroughput': poolUsedThroughput!,
    if (poolUserWrittenBytes != null)
      'poolUserWrittenBytes': poolUserWrittenBytes!,
    if (totalProvisionedDiskCapacityGb != null)
      'totalProvisionedDiskCapacityGb': totalProvisionedDiskCapacityGb!,
    if (totalProvisionedDiskIops != null)
      'totalProvisionedDiskIops': totalProvisionedDiskIops!,
    if (totalProvisionedDiskThroughput != null)
      'totalProvisionedDiskThroughput': totalProvisionedDiskThroughput!,
  };
}

/// Used by:
///
/// - cloudfunctions:v2 : StorageSource
/// - cloudfunctions:v2alpha : StorageSource
/// - cloudfunctions:v2beta : StorageSource
class $StorageSource {
  /// Google Cloud Storage bucket containing the source (see
  /// [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  core.String? bucket;

  /// Google Cloud Storage generation for the object.
  ///
  /// If the generation is omitted, the latest generation will be used.
  core.String? generation;

  /// Google Cloud Storage object containing the source.
  ///
  /// This object must be a gzipped archive file (`.tar.gz`) containing source
  /// to build.
  core.String? object;

  /// When the specified storage bucket is a 1st gen function uploard url
  /// bucket, this field should be set as the generated upload url for 1st gen
  /// deployment.
  core.String? sourceUploadUrl;

  $StorageSource({
    this.bucket,
    this.generation,
    this.object,
    this.sourceUploadUrl,
  });

  $StorageSource.fromJson(core.Map json_)
    : this(
        bucket: json_['bucket'] as core.String?,
        generation: json_['generation'] as core.String?,
        object: json_['object'] as core.String?,
        sourceUploadUrl: json_['sourceUploadUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucket != null) 'bucket': bucket!,
    if (generation != null) 'generation': generation!,
    if (object != null) 'object': object!,
    if (sourceUploadUrl != null) 'sourceUploadUrl': sourceUploadUrl!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StratifiedSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StratifiedSplit
class $StratifiedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The key provided must be for a categorical column.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  $StratifiedSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  $StratifiedSplit.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        testFraction: (json_['testFraction'] as core.num?)?.toDouble(),
        trainingFraction: (json_['trainingFraction'] as core.num?)?.toDouble(),
        validationFraction:
            (json_['validationFraction'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (testFraction != null) 'testFraction': testFraction!,
    if (trainingFraction != null) 'trainingFraction': trainingFraction!,
    if (validationFraction != null) 'validationFraction': validationFraction!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1StreamAssistRequestGenerationSpec
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaStreamAssistRequestGenerationSpec
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaStreamAssistRequestGenerationSpec
class $StreamAssistRequestGenerationSpec {
  /// The Vertex AI model_id used for the generative model.
  ///
  /// If not set, the default Assistant model will be used.
  ///
  /// Optional.
  core.String? modelId;

  $StreamAssistRequestGenerationSpec({this.modelId});

  $StreamAssistRequestGenerationSpec.fromJson(core.Map json_)
    : this(modelId: json_['modelId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelId != null) 'modelId': modelId!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1StreamAssistResponseSessionInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaStreamAssistResponseSessionInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaStreamAssistResponseSessionInfo
class $StreamAssistResponseSessionInfo {
  /// Name of the newly generated or continued session.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`.
  core.String? session;

  $StreamAssistResponseSessionInfo({this.session});

  $StreamAssistResponseSessionInfo.fromJson(core.Map json_)
    : this(session: json_['session'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (session != null) 'session': session!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StreamQueryReasoningEngineRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StreamQueryReasoningEngineRequest
class $StreamQueryReasoningEngineRequest {
  /// Class method to be used for the stream query.
  ///
  /// It is optional and defaults to "stream_query" if unspecified.
  ///
  /// Optional.
  core.String? classMethod;

  /// Input content provided by users in JSON object format.
  ///
  /// Examples include text query, function calling parameters, media bytes,
  /// etc.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? input;

  $StreamQueryReasoningEngineRequest({this.classMethod, this.input});

  $StreamQueryReasoningEngineRequest.fromJson(core.Map json_)
    : this(
        classMethod: json_['classMethod'] as core.String?,
        input:
            json_.containsKey('input')
                ? json_['input'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classMethod != null) 'classMethod': classMethod!,
    if (input != null) 'input': input!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StringArray
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StringArray
class $StringArray {
  /// A list of string values.
  core.List<core.String>? values;

  $StringArray({this.values});

  $StringArray.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - analyticsadmin:v1alpha : GoogleAnalyticsAdminV1alphaAccessStringFilter
/// - analyticsadmin:v1beta : GoogleAnalyticsAdminV1betaAccessStringFilter
/// - analyticsdata:v1beta : StringFilter
class $StringFilter {
  /// If true, the string value is case sensitive.
  core.bool? caseSensitive;

  /// The match type for this filter.
  /// Possible string values are:
  /// - "MATCH_TYPE_UNSPECIFIED" : Unspecified
  /// - "EXACT" : Exact match of the string value.
  /// - "BEGINS_WITH" : Begins with the string value.
  /// - "ENDS_WITH" : Ends with the string value.
  /// - "CONTAINS" : Contains the string value.
  /// - "FULL_REGEXP" : Full match for the regular expression with the string
  /// value.
  /// - "PARTIAL_REGEXP" : Partial match for the regular expression with the
  /// string value.
  core.String? matchType;

  /// The string value used for the matching.
  core.String? value;

  $StringFilter({this.caseSensitive, this.matchType, this.value});

  $StringFilter.fromJson(core.Map json_)
    : this(
        caseSensitive: json_['caseSensitive'] as core.bool?,
        matchType: json_['matchType'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseSensitive != null) 'caseSensitive': caseSensitive!,
    if (matchType != null) 'matchType': matchType!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2StringList
/// - retail:v2alpha : GoogleCloudRetailV2alphaStringList
/// - retail:v2beta : GoogleCloudRetailV2betaStringList
class $StringList00 {
  /// String values.
  core.List<core.String>? values;

  $StringList00({this.values});

  $StringList00.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - admob:v1 : StringList
/// - admob:v1beta : StringList
class $StringList01 {
  /// The string values.
  core.List<core.String>? values;

  $StringList01({this.values});

  $StringList01.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - alloydb:v1 : StringRestrictions
/// - alloydb:v1alpha : StringRestrictions
/// - alloydb:v1beta : StringRestrictions
class $StringRestrictions {
  /// The list of allowed values, if bounded.
  ///
  /// This field will be empty if there is a unbounded number of allowed values.
  core.List<core.String>? allowedValues;

  $StringRestrictions({this.allowedValues});

  $StringRestrictions.fromJson(core.Map json_)
    : this(
        allowedValues:
            (json_['allowedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedValues != null) 'allowedValues': allowedValues!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1OrgPolicyPolicyRuleStringValues
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1OrgPolicyPolicyRuleStringValues
/// - cloudasset:v1 : GoogleCloudAssetV1StringValues
/// - orgpolicy:v2 : GoogleCloudOrgpolicyV2PolicySpecPolicyRuleStringValues
/// - policysimulator:v1 : GoogleCloudOrgpolicyV2PolicySpecPolicyRuleStringValues
/// - policysimulator:v1beta : GoogleCloudOrgpolicyV2PolicySpecPolicyRuleStringValues
class $StringValues {
  /// List of values allowed at this resource.
  core.List<core.String>? allowedValues;

  /// List of values denied at this resource.
  core.List<core.String>? deniedValues;

  $StringValues({this.allowedValues, this.deniedValues});

  $StringValues.fromJson(core.Map json_)
    : this(
        allowedValues:
            (json_['allowedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        deniedValues:
            (json_['deniedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedValues != null) 'allowedValues': allowedValues!,
    if (deniedValues != null) 'deniedValues': deniedValues!,
  };
}

/// Used by:
///
/// - compute:alpha : StructuredEntries
/// - compute:beta : StructuredEntries
class $StructuredEntries {
  /// Map of a partner metadata that belong to the same subdomain.
  ///
  /// It accepts any value including google.protobuf.Struct.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? entries;

  $StructuredEntries({this.entries});

  $StructuredEntries.fromJson(core.Map json_)
    : this(
        entries:
            json_.containsKey('entries')
                ? json_['entries'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entries != null) 'entries': entries!,
  };
}

/// Used by:
///
/// - healthcare:v1 : StructuredStorageInfo
/// - healthcare:v1beta1 : StructuredStorageInfo
class $StructuredStorageInfo {
  /// Size in bytes of data stored in structured storage.
  core.String? sizeBytes;

  $StructuredStorageInfo({this.sizeBytes});

  $StructuredStorageInfo.fromJson(core.Map json_)
    : this(sizeBytes: json_['sizeBytes'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (sizeBytes != null) 'sizeBytes': sizeBytes!,
  };
}

/// Used by:
///
/// - healthcare:v1 : StudyMetrics
/// - healthcare:v1beta1 : StudyMetrics
class $StudyMetrics {
  /// Total blob storage bytes for all instances in the study.
  core.String? blobStorageSizeBytes;

  /// Number of instances in the study.
  core.String? instanceCount;

  /// Number of series in the study.
  core.String? seriesCount;

  /// Total structured storage bytes for all instances in the study.
  core.String? structuredStorageSizeBytes;

  /// The study resource path.
  ///
  /// For example,
  /// `projects/{project_id}/locations/{location_id}/datasets/{dataset_id}/dicomStores/{dicom_store_id}/dicomWeb/studies/{study_uid}`.
  core.String? study;

  $StudyMetrics({
    this.blobStorageSizeBytes,
    this.instanceCount,
    this.seriesCount,
    this.structuredStorageSizeBytes,
    this.study,
  });

  $StudyMetrics.fromJson(core.Map json_)
    : this(
        blobStorageSizeBytes: json_['blobStorageSizeBytes'] as core.String?,
        instanceCount: json_['instanceCount'] as core.String?,
        seriesCount: json_['seriesCount'] as core.String?,
        structuredStorageSizeBytes:
            json_['structuredStorageSizeBytes'] as core.String?,
        study: json_['study'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobStorageSizeBytes != null)
      'blobStorageSizeBytes': blobStorageSizeBytes!,
    if (instanceCount != null) 'instanceCount': instanceCount!,
    if (seriesCount != null) 'seriesCount': seriesCount!,
    if (structuredStorageSizeBytes != null)
      'structuredStorageSizeBytes': structuredStorageSizeBytes!,
    if (study != null) 'study': study!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecConvexAutomatedStoppingSpec
class $StudySpecConvexAutomatedStoppingSpec {
  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate.
  ///
  /// Leave it blank if learning rate is not in a parameter in tuning. The
  /// learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  core.String? learningRateParameterName;

  /// Steps used in predicting the final objective for early stopped trials.
  ///
  /// In general, it's set to be the same as the defined steps in training /
  /// tuning. If not defined, it will learn it from the completed trials. When
  /// use_steps is false, this field is set to the maximum elapsed seconds.
  core.String? maxStepCount;

  /// The minimal number of measurements in a Trial.
  ///
  /// Early-stopping checks will not trigger if less than
  /// min_measurement_count+1 completed trials or pending trials with less than
  /// min_measurement_count measurements. If not defined, the default value is
  /// 5.
  core.String? minMeasurementCount;

  /// Minimum number of steps for a trial to complete.
  ///
  /// Trials which do not have a measurement with step_count \> min_step_count
  /// won't be considered for early stopping. It's ok to set it to 0, and a
  /// trial can be early stopped at any stage. By default, min_step_count is set
  /// to be one-tenth of the max_step_count. When use_elapsed_duration is true,
  /// this field is set to the minimum elapsed seconds.
  core.String? minStepCount;

  /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
  /// to be early stopped using a newly trained auto-regressive model.
  ///
  /// When this flag is set to True, all stopped trials from the beginning are
  /// potentially updated in terms of their `final_measurement`. Also, note that
  /// the training logic of autoregressive models is different in this case.
  /// Enabling this option has shown better results and this may be the default
  /// option in the future.
  core.bool? updateAllStoppedTrials;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps.
  ///
  /// If use_elapsed_duration==false, the early stopping decision is made
  /// according to the predicted objective values according to the target steps.
  /// If use_elapsed_duration==true, elapsed_secs is used instead of steps.
  /// Also, in this case, the parameters max_num_steps and min_num_steps are
  /// overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
  core.bool? useElapsedDuration;

  $StudySpecConvexAutomatedStoppingSpec({
    this.learningRateParameterName,
    this.maxStepCount,
    this.minMeasurementCount,
    this.minStepCount,
    this.updateAllStoppedTrials,
    this.useElapsedDuration,
  });

  $StudySpecConvexAutomatedStoppingSpec.fromJson(core.Map json_)
    : this(
        learningRateParameterName:
            json_['learningRateParameterName'] as core.String?,
        maxStepCount: json_['maxStepCount'] as core.String?,
        minMeasurementCount: json_['minMeasurementCount'] as core.String?,
        minStepCount: json_['minStepCount'] as core.String?,
        updateAllStoppedTrials: json_['updateAllStoppedTrials'] as core.bool?,
        useElapsedDuration: json_['useElapsedDuration'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (learningRateParameterName != null)
      'learningRateParameterName': learningRateParameterName!,
    if (maxStepCount != null) 'maxStepCount': maxStepCount!,
    if (minMeasurementCount != null)
      'minMeasurementCount': minMeasurementCount!,
    if (minStepCount != null) 'minStepCount': minStepCount!,
    if (updateAllStoppedTrials != null)
      'updateAllStoppedTrials': updateAllStoppedTrials!,
    if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecDecayCurveAutomatedStoppingSpec
class $StudySpecDecayCurveAutomatedStoppingSpec {
  /// True if Measurement.elapsed_duration is used as the x-axis of each Trials
  /// Decay Curve.
  ///
  /// Otherwise, Measurement.step_count will be used as the x-axis.
  core.bool? useElapsedDuration;

  $StudySpecDecayCurveAutomatedStoppingSpec({this.useElapsedDuration});

  $StudySpecDecayCurveAutomatedStoppingSpec.fromJson(core.Map json_)
    : this(useElapsedDuration: json_['useElapsedDuration'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecMedianAutomatedStoppingSpec
class $StudySpecMedianAutomatedStoppingSpec {
  /// True if median automated stopping rule applies on
  /// Measurement.elapsed_duration.
  ///
  /// It means that elapsed_duration field of latest measurement of current
  /// Trial is used to compute median objective value for each completed Trials.
  core.bool? useElapsedDuration;

  $StudySpecMedianAutomatedStoppingSpec({this.useElapsedDuration});

  $StudySpecMedianAutomatedStoppingSpec.fromJson(core.Map json_)
    : this(useElapsedDuration: json_['useElapsedDuration'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecMetricSpecSafetyMetricConfig
class $StudySpecMetricSpecSafetyMetricConfig {
  /// Desired minimum fraction of safe trials (over total number of trials) that
  /// should be targeted by the algorithm at any time during the study (best
  /// effort).
  ///
  /// This should be between 0.0 and 1.0 and a value of 0.0 means that there is
  /// no minimum and an algorithm proceeds without targeting any specific
  /// fraction. A value of 1.0 means that the algorithm attempts to only Suggest
  /// safe Trials.
  core.double? desiredMinSafeTrialsFraction;

  /// Safety threshold (boundary value between safe and unsafe).
  ///
  /// NOTE that if you leave SafetyMetricConfig unset, a default value of 0 will
  /// be used.
  core.double? safetyThreshold;

  $StudySpecMetricSpecSafetyMetricConfig({
    this.desiredMinSafeTrialsFraction,
    this.safetyThreshold,
  });

  $StudySpecMetricSpecSafetyMetricConfig.fromJson(core.Map json_)
    : this(
        desiredMinSafeTrialsFraction:
            (json_['desiredMinSafeTrialsFraction'] as core.num?)?.toDouble(),
        safetyThreshold: (json_['safetyThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (desiredMinSafeTrialsFraction != null)
      'desiredMinSafeTrialsFraction': desiredMinSafeTrialsFraction!,
    if (safetyThreshold != null) 'safetyThreshold': safetyThreshold!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecCategoricalValueSpec
class $StudySpecParameterSpecCategoricalValueSpec {
  /// A default value for a `CATEGORICAL` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// The list of possible categories.
  ///
  /// Required.
  core.List<core.String>? values;

  $StudySpecParameterSpecCategoricalValueSpec({this.defaultValue, this.values});

  $StudySpecParameterSpecCategoricalValueSpec.fromJson(core.Map json_)
    : this(
        defaultValue: json_['defaultValue'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultValue != null) 'defaultValue': defaultValue!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
class $StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition {
  /// Matches values of the parent parameter of 'CATEGORICAL' type.
  ///
  /// All values must exist in `categorical_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  $StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition({
    this.values,
  });

  $StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition.fromJson(
    core.Map json_,
  ) : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
class $StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition {
  /// Matches values of the parent parameter of 'DISCRETE' type.
  ///
  /// All values must exist in `discrete_value_spec` of parent parameter. The
  /// Epsilon of the value matching is 1e-10.
  ///
  /// Required.
  core.List<core.double>? values;

  $StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition({
    this.values,
  });

  $StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition.fromJson(
    core.Map json_,
  ) : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
class $StudySpecParameterSpecConditionalParameterSpecIntValueCondition {
  /// Matches values of the parent parameter of 'INTEGER' type.
  ///
  /// All values must lie in `integer_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  $StudySpecParameterSpecConditionalParameterSpecIntValueCondition({
    this.values,
  });

  $StudySpecParameterSpecConditionalParameterSpecIntValueCondition.fromJson(
    core.Map json_,
  ) : this(
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecDiscreteValueSpec
class $StudySpecParameterSpecDiscreteValueSpec {
  /// A default value for a `DISCRETE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. It
  /// automatically rounds to the nearest feasible discrete point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// A list of possible values.
  ///
  /// The list should be in increasing order and at least 1e-10 apart. For
  /// instance, this parameter might have possible settings of 1.5, 2.5, and
  /// 4.0. This list should not contain more than 1,000 values.
  ///
  /// Required.
  core.List<core.double>? values;

  $StudySpecParameterSpecDiscreteValueSpec({this.defaultValue, this.values});

  $StudySpecParameterSpecDiscreteValueSpec.fromJson(core.Map json_)
    : this(
        defaultValue: (json_['defaultValue'] as core.num?)?.toDouble(),
        values:
            (json_['values'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultValue != null) 'defaultValue': defaultValue!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecDoubleValueSpec
class $StudySpecParameterSpecDoubleValueSpec {
  /// A default value for a `DOUBLE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.double? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.double? minValue;

  $StudySpecParameterSpecDoubleValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  $StudySpecParameterSpecDoubleValueSpec.fromJson(core.Map json_)
    : this(
        defaultValue: (json_['defaultValue'] as core.num?)?.toDouble(),
        maxValue: (json_['maxValue'] as core.num?)?.toDouble(),
        minValue: (json_['minValue'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultValue != null) 'defaultValue': defaultValue!,
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudySpecParameterSpecIntegerValueSpec
class $StudySpecParameterSpecIntegerValueSpec {
  /// A default value for an `INTEGER` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.String? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.String? minValue;

  $StudySpecParameterSpecIntegerValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  $StudySpecParameterSpecIntegerValueSpec.fromJson(core.Map json_)
    : this(
        defaultValue: json_['defaultValue'] as core.String?,
        maxValue: json_['maxValue'] as core.String?,
        minValue: json_['minValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultValue != null) 'defaultValue': defaultValue!,
    if (maxValue != null) 'maxValue': maxValue!,
    if (minValue != null) 'minValue': minValue!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1StudyTimeConstraint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1StudyTimeConstraint
class $StudyTimeConstraint {
  /// Compares the wallclock time to this time.
  ///
  /// Must use UTC timezone.
  core.String? endTime;

  /// Counts the wallclock time passed since the creation of this Study.
  core.String? maxDuration;

  $StudyTimeConstraint({this.endTime, this.maxDuration});

  $StudyTimeConstraint.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        maxDuration: json_['maxDuration'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (maxDuration != null) 'maxDuration': maxDuration!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SubExchangeAssignedTargetingOptionDetails
/// - displayvideo:v3 : SubExchangeAssignedTargetingOptionDetails
/// - displayvideo:v4 : SubExchangeAssignedTargetingOptionDetails
class $SubExchangeAssignedTargetingOptionDetails {
  /// The targeting_option_id of a TargetingOption of type
  /// `TARGETING_TYPE_SUB_EXCHANGE`.
  ///
  /// Required.
  core.String? targetingOptionId;

  $SubExchangeAssignedTargetingOptionDetails({this.targetingOptionId});

  $SubExchangeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(targetingOptionId: json_['targetingOptionId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : SubExchangeTargetingOptionDetails
/// - displayvideo:v3 : SubExchangeTargetingOptionDetails
/// - displayvideo:v4 : SubExchangeTargetingOptionDetails
class $SubExchangeTargetingOptionDetails {
  /// The display name of the sub-exchange.
  ///
  /// Output only.
  core.String? displayName;

  $SubExchangeTargetingOptionDetails({this.displayName});

  $SubExchangeTargetingOptionDetails.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Subject
/// - ondemandscanning:v1 : Subject
/// - ondemandscanning:v1beta1 : Subject
class $Subject {
  /// `"": ""` Algorithms can be e.g. sha256, sha512 See
  /// https://github.com/in-toto/attestation/blob/main/spec/field_types.md#DigestSet
  core.Map<core.String, core.String>? digest;
  core.String? name;

  $Subject({this.digest, this.name});

  $Subject.fromJson(core.Map json_)
    : this(
        digest: (json_['digest'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digest != null) 'digest': digest!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - vpcaccess:v1 : Subnet
/// - vpcaccess:v1beta1 : Subnet
class $Subnet {
  /// Subnet name (relative, not fully qualified).
  ///
  /// E.g. if the full subnet selfLink is
  /// https://compute.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetName}
  /// the correct input for this field would be {subnetName}
  ///
  /// Optional.
  core.String? name;

  /// Project in which the subnet exists.
  ///
  /// If not set, this project is assumed to be the project for which the
  /// connector create request was issued.
  ///
  /// Optional.
  core.String? projectId;

  $Subnet({this.name, this.projectId});

  $Subnet.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworkLogConfig
/// - compute:beta : SubnetworkLogConfig
/// - compute:v1 : SubnetworkLogConfig
class $SubnetworkLogConfig {
  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// Toggles the aggregation interval for collecting flow logs. Increasing the
  /// interval time will reduce the amount of generated flow logs for long
  /// lasting connections. Default is an interval of 5 seconds per connection.
  /// Possible string values are:
  /// - "INTERVAL_10_MIN"
  /// - "INTERVAL_15_MIN"
  /// - "INTERVAL_1_MIN"
  /// - "INTERVAL_30_SEC"
  /// - "INTERVAL_5_MIN"
  /// - "INTERVAL_5_SEC"
  core.String? aggregationInterval;

  /// Whether to enable flow logging for this subnetwork.
  ///
  /// If this field is not explicitly set, it will not appear in get listings.
  /// If not set the default behavior is determined by the org policy, if there
  /// is no org policy specified, then it will default to disabled. Flow logging
  /// isn't supported if the subnet purpose field is set to
  /// REGIONAL_MANAGED_PROXY.
  core.bool? enable;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// The filter expression is used to define which VPC flow logs should be
  /// exported to Cloud Logging.
  core.String? filterExpr;

  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// The value of the field must be in \[0, 1\]. Set the sampling rate of VPC
  /// flow logs within the subnetwork where 1.0 means all collected logs are
  /// reported and 0.0 means no logs are reported. Default is 0.5 unless
  /// otherwise specified by the org policy, which means half of all collected
  /// logs are reported.
  core.double? flowSampling;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// Configures whether all, none or a subset of metadata fields should be
  /// added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
  /// Possible string values are:
  /// - "CUSTOM_METADATA"
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled and
  /// "metadata" was set to CUSTOM_METADATA.
  core.List<core.String>? metadataFields;

  $SubnetworkLogConfig({
    this.aggregationInterval,
    this.enable,
    this.filterExpr,
    this.flowSampling,
    this.metadata,
    this.metadataFields,
  });

  $SubnetworkLogConfig.fromJson(core.Map json_)
    : this(
        aggregationInterval: json_['aggregationInterval'] as core.String?,
        enable: json_['enable'] as core.bool?,
        filterExpr: json_['filterExpr'] as core.String?,
        flowSampling: (json_['flowSampling'] as core.num?)?.toDouble(),
        metadata: json_['metadata'] as core.String?,
        metadataFields:
            (json_['metadataFields'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aggregationInterval != null)
      'aggregationInterval': aggregationInterval!,
    if (enable != null) 'enable': enable!,
    if (filterExpr != null) 'filterExpr': filterExpr!,
    if (flowSampling != null) 'flowSampling': flowSampling!,
    if (metadata != null) 'metadata': metadata!,
    if (metadataFields != null) 'metadataFields': metadataFields!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworkSecondaryRange
/// - compute:beta : SubnetworkSecondaryRange
/// - compute:v1 : SubnetworkSecondaryRange
class $SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  ///
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported. The range can be any range listed in
  /// the Valid ranges list.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  /// The URL of the reserved internal range.
  core.String? reservedInternalRange;

  $SubnetworkSecondaryRange({
    this.ipCidrRange,
    this.rangeName,
    this.reservedInternalRange,
  });

  $SubnetworkSecondaryRange.fromJson(core.Map json_)
    : this(
        ipCidrRange: json_['ipCidrRange'] as core.String?,
        rangeName: json_['rangeName'] as core.String?,
        reservedInternalRange: json_['reservedInternalRange'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
    if (rangeName != null) 'rangeName': rangeName!,
    if (reservedInternalRange != null)
      'reservedInternalRange': reservedInternalRange!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworkUtilizationDetailsIPV4Utilization
/// - compute:beta : SubnetworkUtilizationDetailsIPV4Utilization
class $SubnetworkUtilizationDetailsIPV4Utilization {
  /// Will be set for secondary range.
  ///
  /// Empty for primary IPv4 range.
  core.String? rangeName;
  core.String? totalAllocatedIp;
  core.String? totalFreeIp;

  $SubnetworkUtilizationDetailsIPV4Utilization({
    this.rangeName,
    this.totalAllocatedIp,
    this.totalFreeIp,
  });

  $SubnetworkUtilizationDetailsIPV4Utilization.fromJson(core.Map json_)
    : this(
        rangeName: json_['rangeName'] as core.String?,
        totalAllocatedIp: json_['totalAllocatedIp'] as core.String?,
        totalFreeIp: json_['totalFreeIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rangeName != null) 'rangeName': rangeName!,
    if (totalAllocatedIp != null) 'totalAllocatedIp': totalAllocatedIp!,
    if (totalFreeIp != null) 'totalFreeIp': totalFreeIp!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworksExpandIpCidrRangeRequest
/// - compute:beta : SubnetworksExpandIpCidrRangeRequest
/// - compute:v1 : SubnetworksExpandIpCidrRangeRequest
class $SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork.
  ///
  /// This range should be disjoint from other subnetworks within this network.
  /// This range can only be larger than (i.e. a superset of) the range
  /// previously defined before the update.
  core.String? ipCidrRange;

  $SubnetworksExpandIpCidrRangeRequest({this.ipCidrRange});

  $SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map json_)
    : this(ipCidrRange: json_['ipCidrRange'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworksScopedWarning
/// - compute:beta : SubnetworksScopedWarning
/// - compute:v1 : SubnetworksScopedWarning
class $SubnetworksScopedWarning {
  /// Name of the scope containing this set of Subnetworks.
  core.String? scopeName;

  /// An informational warning about unreachable scope
  SubnetworksScopedWarningWarning? warning;

  $SubnetworksScopedWarning({this.scopeName, this.warning});

  $SubnetworksScopedWarning.fromJson(core.Map json_)
    : this(
        scopeName: json_['scopeName'] as core.String?,
        warning:
            json_.containsKey('warning')
                ? SubnetworksScopedWarningWarning.fromJson(
                  json_['warning'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scopeName != null) 'scopeName': scopeName!,
    if (warning != null) 'warning': warning!,
  };
}

/// Used by:
///
/// - compute:alpha : SubnetworksSetPrivateIpGoogleAccessRequest
/// - compute:beta : SubnetworksSetPrivateIpGoogleAccessRequest
/// - compute:v1 : SubnetworksSetPrivateIpGoogleAccessRequest
class $SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool? privateIpGoogleAccess;

  $SubnetworksSetPrivateIpGoogleAccessRequest({this.privateIpGoogleAccess});

  $SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map json_)
    : this(privateIpGoogleAccess: json_['privateIpGoogleAccess'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (privateIpGoogleAccess != null)
      'privateIpGoogleAccess': privateIpGoogleAccess!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : SubscribeClientsRequest
/// - authorizedbuyersmarketplace:v1alpha : SubscribeClientsRequest
class $SubscribeClientsRequest {
  /// A list of client buyers to subscribe to the auction package, with client
  /// buyer in the format `buyers/{accountId}/clients/{clientAccountId}`.
  ///
  /// The current buyer will be subscribed to the auction package regardless of
  /// the list contents if not already.
  ///
  /// Optional.
  core.List<core.String>? clients;

  $SubscribeClientsRequest({this.clients});

  $SubscribeClientsRequest.fromJson(core.Map json_)
    : this(
        clients:
            (json_['clients'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clients != null) 'clients': clients!,
  };
}

/// Used by:
///
/// - compute:alpha : Subsetting
/// - compute:beta : Subsetting
class $Subsetting {
  ///
  /// Possible string values are:
  /// - "CONSISTENT_HASH_SUBSETTING" : Subsetting based on consistent hashing.
  /// For Traffic Director, the number of backends per backend group (the subset
  /// size) is based on the `subset_size` parameter. For Internal HTTP(S) load
  /// balancing, the number of backends per backend group (the subset size) is
  /// dynamically adjusted in two cases: - As the number of proxy instances
  /// participating in Internal HTTP(S) load balancing increases, the subset
  /// size decreases. - When the total number of backends in a network exceeds
  /// the capacity of a single proxy instance, subset sizes are reduced
  /// automatically for each service that has backend subsetting enabled.
  /// - "NONE" : No Subsetting. Clients may open connections and send traffic to
  /// all backends of this backend service. This can lead to performance issues
  /// if there is substantial imbalance in the count of clients and backends.
  core.String? policy;

  /// The number of backends per backend group assigned to each proxy instance
  /// or each service mesh client.
  ///
  /// An input parameter to the `CONSISTENT_HASH_SUBSETTING` algorithm. Can only
  /// be set if `policy` is set to `CONSISTENT_HASH_SUBSETTING`. Can only be set
  /// if load balancing scheme is `INTERNAL_MANAGED` or `INTERNAL_SELF_MANAGED`.
  /// `subset_size` is optional for Internal HTTP(S) load balancing and required
  /// for Traffic Director. If you do not provide this value, Cloud Load
  /// Balancing will calculate it dynamically to optimize the number of
  /// proxies/clients visible to each backend and vice versa. Must be greater
  /// than 0. If `subset_size` is larger than the number of backends/endpoints,
  /// then subsetting is disabled.
  core.int? subsetSize;

  $Subsetting({this.policy, this.subsetSize});

  $Subsetting.fromJson(core.Map json_)
    : this(
        policy: json_['policy'] as core.String?,
        subsetSize: json_['subsetSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (policy != null) 'policy': policy!,
    if (subsetSize != null) 'subsetSize': subsetSize!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SuggestConversationSummaryResponseSummary
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SuggestConversationSummaryResponseSummary
class $SuggestConversationSummaryResponseSummary {
  /// The name of the answer record.
  ///
  /// Format: "projects//answerRecords/"
  core.String? answerRecord;

  /// The baseline model version used to generate this summary.
  ///
  /// It is empty if a baseline model was not used to generate this summary.
  core.String? baselineModelVersion;

  /// The summary content that is concatenated into one string.
  core.String? text;

  /// The summary content that is divided into sections.
  ///
  /// The key is the section's name and the value is the section's content.
  /// There is no specific format for the key or value.
  core.Map<core.String, core.String>? textSections;

  $SuggestConversationSummaryResponseSummary({
    this.answerRecord,
    this.baselineModelVersion,
    this.text,
    this.textSections,
  });

  $SuggestConversationSummaryResponseSummary.fromJson(core.Map json_)
    : this(
        answerRecord: json_['answerRecord'] as core.String?,
        baselineModelVersion: json_['baselineModelVersion'] as core.String?,
        text: json_['text'] as core.String?,
        textSections: (json_['textSections']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerRecord != null) 'answerRecord': answerRecord!,
    if (baselineModelVersion != null)
      'baselineModelVersion': baselineModelVersion!,
    if (text != null) 'text': text!,
    if (textSections != null) 'textSections': textSections!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SuggestKnowledgeAssistRequest
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SuggestKnowledgeAssistRequest
class $SuggestKnowledgeAssistRequest {
  /// Max number of messages prior to and including latest_message to use as
  /// context when compiling the suggestion.
  ///
  /// The context size is by default 100 and at most 100.
  ///
  /// Optional.
  core.int? contextSize;

  /// The name of the latest conversation message to compile suggestions for.
  ///
  /// If empty, it will be the latest message of the conversation. Format:
  /// `projects//locations//conversations//messages/`.
  ///
  /// Optional.
  core.String? latestMessage;

  /// The previously suggested query for the given conversation.
  ///
  /// This helps identify whether the next suggestion we generate is reasonably
  /// different from the previous one. This is useful to avoid similar
  /// suggestions within the conversation.
  ///
  /// Optional.
  core.String? previousSuggestedQuery;

  $SuggestKnowledgeAssistRequest({
    this.contextSize,
    this.latestMessage,
    this.previousSuggestedQuery,
  });

  $SuggestKnowledgeAssistRequest.fromJson(core.Map json_)
    : this(
        contextSize: json_['contextSize'] as core.int?,
        latestMessage: json_['latestMessage'] as core.String?,
        previousSuggestedQuery: json_['previousSuggestedQuery'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contextSize != null) 'contextSize': contextSize!,
    if (latestMessage != null) 'latestMessage': latestMessage!,
    if (previousSuggestedQuery != null)
      'previousSuggestedQuery': previousSuggestedQuery!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1SuggestionDenyListEntry
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaSuggestionDenyListEntry
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaSuggestionDenyListEntry
class $SuggestionDenyListEntry {
  /// Phrase to block from suggestions served.
  ///
  /// Can be maximum 125 characters.
  ///
  /// Required.
  core.String? blockPhrase;

  /// The match operator to apply for this phrase.
  ///
  /// Whether to block the exact phrase, or block any suggestions containing
  /// this phrase.
  ///
  /// Required.
  /// Possible string values are:
  /// - "MATCH_OPERATOR_UNSPECIFIED" : Default value. Should not be used
  /// - "EXACT_MATCH" : If the suggestion is an exact match to the block_phrase,
  /// then block it.
  /// - "CONTAINS" : If the suggestion contains the block_phrase, then block it.
  core.String? matchOperator;

  $SuggestionDenyListEntry({this.blockPhrase, this.matchOperator});

  $SuggestionDenyListEntry.fromJson(core.Map json_)
    : this(
        blockPhrase: json_['blockPhrase'] as core.String?,
        matchOperator: json_['matchOperator'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blockPhrase != null) 'blockPhrase': blockPhrase!,
    if (matchOperator != null) 'matchOperator': matchOperator!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationHelpfulnessResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationHelpfulnessResult
class $SummarizationHelpfulnessResult {
  /// Confidence for summarization helpfulness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization helpfulness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Helpfulness score.
  ///
  /// Output only.
  core.double? score;

  $SummarizationHelpfulnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $SummarizationHelpfulnessResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationHelpfulnessSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationHelpfulnessSpec
class $SummarizationHelpfulnessSpec {
  /// Whether to use instance.reference to compute summarization helpfulness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $SummarizationHelpfulnessSpec({this.useReference, this.version});

  $SummarizationHelpfulnessSpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationQualityInstance
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationQualityInstance
class $SummarizationQualityInstance {
  /// Text to be summarized.
  ///
  /// Required.
  core.String? context;

  /// Summarization prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  $SummarizationQualityInstance({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  $SummarizationQualityInstance.fromJson(core.Map json_)
    : this(
        context: json_['context'] as core.String?,
        instruction: json_['instruction'] as core.String?,
        prediction: json_['prediction'] as core.String?,
        reference: json_['reference'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (instruction != null) 'instruction': instruction!,
    if (prediction != null) 'prediction': prediction!,
    if (reference != null) 'reference': reference!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationQualityResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationQualityResult
class $SummarizationQualityResult {
  /// Confidence for summarization quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Quality score.
  ///
  /// Output only.
  core.double? score;

  $SummarizationQualityResult({this.confidence, this.explanation, this.score});

  $SummarizationQualityResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationQualitySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationQualitySpec
class $SummarizationQualitySpec {
  /// Whether to use instance.reference to compute summarization quality.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $SummarizationQualitySpec({this.useReference, this.version});

  $SummarizationQualitySpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SummarizationSection
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SummarizationSection
class $SummarizationSection {
  /// Definition of the section, for example, "what the customer needs help with
  /// or has question about."
  ///
  /// Optional.
  core.String? definition;

  /// Name of the section, for example, "situation".
  ///
  /// Optional.
  core.String? key;

  /// Type of the summarization section.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Undefined section type, does not return anything.
  /// - "SITUATION" : What the customer needs help with or has question about.
  /// Section name: "situation".
  /// - "ACTION" : What the agent does to help the customer. Section name:
  /// "action".
  /// - "RESOLUTION" : Result of the customer service. A single word describing
  /// the result of the conversation. Section name: "resolution".
  /// - "REASON_FOR_CANCELLATION" : Reason for cancellation if the customer
  /// requests for a cancellation. "N/A" otherwise. Section name:
  /// "reason_for_cancellation".
  /// - "CUSTOMER_SATISFACTION" : "Unsatisfied" or "Satisfied" depending on the
  /// customer's feelings at the end of the conversation. Section name:
  /// "customer_satisfaction".
  /// - "ENTITIES" : Key entities extracted from the conversation, such as
  /// ticket number, order number, dollar amount, etc. Section names are
  /// prefixed by "entities/".
  /// - "CUSTOMER_DEFINED" : Customer defined sections.
  /// - "SITUATION_CONCISE" : Concise version of the situation section. This
  /// type is only available if type SITUATION is not selected.
  /// - "ACTION_CONCISE" : Concise version of the action section. This type is
  /// only available if type ACTION is not selected.
  core.String? type;

  $SummarizationSection({this.definition, this.key, this.type});

  $SummarizationSection.fromJson(core.Map json_)
    : this(
        definition: json_['definition'] as core.String?,
        key: json_['key'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (definition != null) 'definition': definition!,
    if (key != null) 'key': key!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationVerbosityResult
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationVerbosityResult
class $SummarizationVerbosityResult {
  /// Confidence for summarization verbosity score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization verbosity score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Verbosity score.
  ///
  /// Output only.
  core.double? score;

  $SummarizationVerbosityResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  $SummarizationVerbosityResult.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SummarizationVerbositySpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SummarizationVerbositySpec
class $SummarizationVerbositySpec {
  /// Whether to use instance.reference to compute summarization verbosity.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  $SummarizationVerbositySpec({this.useReference, this.version});

  $SummarizationVerbositySpec.fromJson(core.Map json_)
    : this(
        useReference: json_['useReference'] as core.bool?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (useReference != null) 'useReference': useReference!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2SummarySuggestionSummarySection
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1SummarySuggestionSummarySection
class $SummarySuggestionSummarySection {
  /// Name of the section.
  ///
  /// Required.
  core.String? section;

  /// Summary text for the section.
  ///
  /// Required.
  core.String? summary;

  $SummarySuggestionSummarySection({this.section, this.summary});

  $SummarySuggestionSummarySection.fromJson(core.Map json_)
    : this(
        section: json_['section'] as core.String?,
        summary: json_['summary'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (section != null) 'section': section!,
    if (summary != null) 'summary': summary!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistributionDatasetBucket
class $SupervisedTuningDatasetDistributionDatasetBucket {
  /// Number of values in the bucket.
  ///
  /// Output only.
  core.double? count;

  /// Left bound of the bucket.
  ///
  /// Output only.
  core.double? left;

  /// Right bound of the bucket.
  ///
  /// Output only.
  core.double? right;

  $SupervisedTuningDatasetDistributionDatasetBucket({
    this.count,
    this.left,
    this.right,
  });

  $SupervisedTuningDatasetDistributionDatasetBucket.fromJson(core.Map json_)
    : this(
        count: (json_['count'] as core.num?)?.toDouble(),
        left: (json_['left'] as core.num?)?.toDouble(),
        right: (json_['right'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (left != null) 'left': left!,
    if (right != null) 'right': right!,
  };
}

/// Used by:
///
/// - tpu:v1 : Symptom
/// - tpu:v1alpha1 : Symptom
/// - tpu:v2 : Symptom
/// - tpu:v2alpha1 : Symptom
class $Symptom {
  /// Timestamp when the Symptom is created.
  core.String? createTime;

  /// Detailed information of the current Symptom.
  core.String? details;

  /// Type of the Symptom.
  /// Possible string values are:
  /// - "SYMPTOM_TYPE_UNSPECIFIED" : Unspecified symptom.
  /// - "LOW_MEMORY" : TPU VM memory is low.
  /// - "OUT_OF_MEMORY" : TPU runtime is out of memory.
  /// - "EXECUTE_TIMED_OUT" : TPU runtime execution has timed out.
  /// - "MESH_BUILD_FAIL" : TPU runtime fails to construct a mesh that
  /// recognizes each TPU device's neighbors.
  /// - "HBM_OUT_OF_MEMORY" : TPU HBM is out of memory.
  /// - "PROJECT_ABUSE" : Abusive behaviors have been identified on the current
  /// project.
  core.String? symptomType;

  /// A string used to uniquely distinguish a worker within a TPU node.
  core.String? workerId;

  $Symptom({this.createTime, this.details, this.symptomType, this.workerId});

  $Symptom.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        details: json_['details'] as core.String?,
        symptomType: json_['symptomType'] as core.String?,
        workerId: json_['workerId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (details != null) 'details': details!,
    if (symptomType != null) 'symptomType': symptomType!,
    if (workerId != null) 'workerId': workerId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1SyncFeatureViewResponse
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1SyncFeatureViewResponse
class $SyncFeatureViewResponse {
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  core.String? featureViewSync;

  $SyncFeatureViewResponse({this.featureViewSync});

  $SyncFeatureViewResponse.fromJson(core.Map json_)
    : this(featureViewSync: json_['featureViewSync'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureViewSync != null) 'featureViewSync': featureViewSync!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : SyncFlags
/// - sqladmin:v1beta4 : SyncFlags
class $SyncFlags {
  /// The name of the flag.
  core.String? name;

  /// The value of the flag.
  ///
  /// This field must be omitted if the flag doesn't take a value.
  core.String? value;

  $SyncFlags({this.name, this.value});

  $SyncFlags.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - compute:alpha : TCPHealthCheck
/// - compute:beta : TCPHealthCheck
/// - compute:v1 : TCPHealthCheck
class $TCPHealthCheck {
  /// The TCP port number to which the health check prober sends packets.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Not supported.
  core.String? portName;

  /// Specifies how a port is selected for health checking.
  ///
  /// Can be one of the following values: USE_FIXED_PORT: Specifies a port
  /// number explicitly using the port field in the health check. Supported by
  /// backend services for passthrough load balancers and backend services for
  /// proxy load balancers. Not supported by target pools. The health check
  /// supports all backends supported by the backend service provided the
  /// backend can be health checked. For example, GCE_VM_IP network endpoint
  /// groups, GCE_VM_IP_PORT network endpoint groups, and instance group
  /// backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an
  /// indirect method of specifying the health check port by referring to the
  /// backend service. Only supported by backend services for proxy load
  /// balancers. Not supported by target pools. Not supported by backend
  /// services for passthrough load balancers. Supports all backends that can be
  /// health checked; for example, GCE_VM_IP_PORT network endpoint groups and
  /// instance group backends. For GCE_VM_IP_PORT network endpoint group
  /// backends, the health check uses the port number specified for each
  /// endpoint in the network endpoint group. For instance group backends, the
  /// health check uses the port number determined by looking up the backend
  /// service's named port in the instance group's list of named ports.
  /// Possible string values are:
  /// - "USE_FIXED_PORT" : The port number in the health check's port is used
  /// for health checking. Applies to network endpoint group and instance group
  /// backends.
  /// - "USE_NAMED_PORT" : Not supported.
  /// - "USE_SERVING_PORT" : For network endpoint group backends, the health
  /// check uses the port number specified on each endpoint in the network
  /// endpoint group. For instance group backends, the health check uses the
  /// port number specified for the backend service's named port defined in the
  /// instance group's named ports.
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Instructs the health check prober to send this exact ASCII string, up to
  /// 1024 bytes in length, after establishing the TCP connection.
  core.String? request;

  /// Creates a content-based TCP health check.
  ///
  /// In addition to establishing a TCP connection, you can configure the health
  /// check to pass only when the backend sends this exact response ASCII
  /// string, up to 1024 bytes in length. For details, see:
  /// https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
  core.String? response;

  $TCPHealthCheck({
    this.port,
    this.portName,
    this.portSpecification,
    this.proxyHeader,
    this.request,
    this.response,
  });

  $TCPHealthCheck.fromJson(core.Map json_)
    : this(
        port: json_['port'] as core.int?,
        portName: json_['portName'] as core.String?,
        portSpecification: json_['portSpecification'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        request: json_['request'] as core.String?,
        response: json_['response'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (port != null) 'port': port!,
    if (portName != null) 'portName': portName!,
    if (portSpecification != null) 'portSpecification': portSpecification!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (request != null) 'request': request!,
    if (response != null) 'response': response!,
  };
}

/// Used by:
///
/// - artifactregistry:v1 : Tag
/// - artifactregistry:v1beta1 : Tag
/// - artifactregistry:v1beta2 : Tag
class $Tag00 {
  /// The name of the tag, for example:
  /// "projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/tags/tag1".
  ///
  /// If the package part contains slashes, the slashes are escaped. The tag
  /// part can only have characters in \[a-zA-Z0-9\-._~:@\], anything else must
  /// be URL encoded.
  core.String? name;

  /// The name of the version the tag refers to, for example:
  /// `projects/p1/locations/us-central1/repositories/repo1/packages/pkg1/versions/sha256:5243811`
  /// If the package or version ID parts contain slashes, the slashes are
  /// escaped.
  core.String? version;

  $Tag00({this.name, this.version});

  $Tag00.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : Tag
/// - vmmigration:v1alpha1 : Tag
class $Tag01 {
  /// Key of tag.
  ///
  /// Required.
  core.String? key;

  /// Value of tag.
  ///
  /// Required.
  core.String? value;

  $Tag01({this.key, this.value});

  $Tag01.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - datacatalog:v1 : GoogleCloudDatacatalogV1TagFieldEnumValue
/// - datacatalog:v1beta1 : GoogleCloudDatacatalogV1beta1TagFieldEnumValue
class $TagFieldEnumValue {
  /// The display name of the enum value.
  core.String? displayName;

  $TagFieldEnumValue({this.displayName});

  $TagFieldEnumValue.fromJson(core.Map json_)
    : this(displayName: json_['displayName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - compute:alpha : Tags
/// - compute:beta : Tags
/// - compute:v1 : Tags
class $Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the tags' contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update tags. You must always provide an
  /// up-to-date fingerprint hash in order to update or change tags. To see the
  /// latest fingerprint, make get() request to the instance.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// An array of tags.
  ///
  /// Each tag must be 1-63 characters long, and comply with RFC1035.
  core.List<core.String>? items;

  $Tags({this.fingerprint, this.items});

  $Tags.fromJson(core.Map json_)
    : this(
        fingerprint: json_['fingerprint'] as core.String?,
        items:
            (json_['items'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (items != null) 'items': items!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : TargetFrequency
/// - displayvideo:v3 : TargetFrequency
/// - displayvideo:v4 : TargetFrequency
class $TargetFrequency {
  /// The target number of times, on average, the ads will be shown to the same
  /// person in the timespan dictated by time_unit and time_unit_count.
  core.String? targetCount;

  /// The unit of time in which the target frequency will be applied.
  ///
  /// The following time unit is applicable: * `TIME_UNIT_WEEKS`
  /// Possible string values are:
  /// - "TIME_UNIT_UNSPECIFIED" : Time unit value is not specified or is unknown
  /// in this version.
  /// - "TIME_UNIT_LIFETIME" : The frequency cap will be applied to the whole
  /// life time of the line item.
  /// - "TIME_UNIT_MONTHS" : The frequency cap will be applied to a number of
  /// months.
  /// - "TIME_UNIT_WEEKS" : The frequency cap will be applied to a number of
  /// weeks.
  /// - "TIME_UNIT_DAYS" : The frequency cap will be applied to a number of
  /// days.
  /// - "TIME_UNIT_HOURS" : The frequency cap will be applied to a number of
  /// hours.
  /// - "TIME_UNIT_MINUTES" : The frequency cap will be applied to a number of
  /// minutes.
  core.String? timeUnit;

  /// The number of time_unit the target frequency will last.
  ///
  /// The following restrictions apply based on the value of time_unit: *
  /// `TIME_UNIT_WEEKS` - must be 1
  core.int? timeUnitCount;

  $TargetFrequency({this.targetCount, this.timeUnit, this.timeUnitCount});

  $TargetFrequency.fromJson(core.Map json_)
    : this(
        targetCount: json_['targetCount'] as core.String?,
        timeUnit: json_['timeUnit'] as core.String?,
        timeUnitCount: json_['timeUnitCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetCount != null) 'targetCount': targetCount!,
    if (timeUnit != null) 'timeUnit': timeUnit!,
    if (timeUnitCount != null) 'timeUnitCount': timeUnitCount!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetGrpcProxy
/// - compute:beta : TargetGrpcProxy
/// - compute:v1 : TargetGrpcProxy
class $TargetGrpcProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetGrpcProxy. An up-to-date fingerprint must be provided in order to
  /// patch/update the TargetGrpcProxy; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the TargetGrpcProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> bytes_) {
    fingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetGrpcProxy for target grpc proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL with id for the resource.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  ///
  /// The protocol field in the BackendService must be set to GRPC.
  core.String? urlMap;

  /// If true, indicates that the BackendServices referenced by the urlMap may
  /// be accessed by gRPC applications without using a sidecar proxy.
  ///
  /// This will enable configuration checks on urlMap and its referenced
  /// BackendServices to not allow unsupported features. A gRPC application must
  /// use "xds:///" scheme in the target URI of the service it is connecting to.
  /// If false, indicates that the BackendServices referenced by the urlMap will
  /// be accessed by gRPC applications via a sidecar proxy. In this case, a gRPC
  /// application must not use "xds:///" scheme in the target URI of the service
  /// it is connecting to
  core.bool? validateForProxyless;

  $TargetGrpcProxy({
    this.creationTimestamp,
    this.description,
    this.fingerprint,
    this.id,
    this.kind,
    this.name,
    this.selfLink,
    this.selfLinkWithId,
    this.urlMap,
    this.validateForProxyless,
  });

  $TargetGrpcProxy.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        fingerprint: json_['fingerprint'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        selfLinkWithId: json_['selfLinkWithId'] as core.String?,
        urlMap: json_['urlMap'] as core.String?,
        validateForProxyless: json_['validateForProxyless'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (fingerprint != null) 'fingerprint': fingerprint!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
    if (urlMap != null) 'urlMap': urlMap!,
    if (validateForProxyless != null)
      'validateForProxyless': validateForProxyless!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetHttpsProxiesSetCertificateMapRequest
/// - compute:beta : TargetHttpsProxiesSetCertificateMapRequest
/// - compute:v1 : TargetHttpsProxiesSetCertificateMapRequest
class $TargetHttpsProxiesSetCertificateMapRequest {
  /// URL of the Certificate Map to associate with this TargetHttpsProxy.
  ///
  /// Accepted format is //certificatemanager.googleapis.com/projects/{project
  /// }/locations/{location}/certificateMaps/{resourceName}.
  core.String? certificateMap;

  $TargetHttpsProxiesSetCertificateMapRequest({this.certificateMap});

  $TargetHttpsProxiesSetCertificateMapRequest.fromJson(core.Map json_)
    : this(certificateMap: json_['certificateMap'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateMap != null) 'certificateMap': certificateMap!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetHttpsProxiesSetQuicOverrideRequest
/// - compute:beta : TargetHttpsProxiesSetQuicOverrideRequest
/// - compute:v1 : TargetHttpsProxiesSetQuicOverrideRequest
class $TargetHttpsProxiesSetQuicOverrideRequest {
  /// QUIC policy for the TargetHttpsProxy resource.
  /// Possible string values are:
  /// - "DISABLE" : The load balancer will not attempt to negotiate QUIC with
  /// clients.
  /// - "ENABLE" : The load balancer will attempt to negotiate QUIC with
  /// clients.
  /// - "NONE" : No overrides to the default QUIC policy. This option is
  /// implicit if no QUIC override has been specified in the request.
  core.String? quicOverride;

  $TargetHttpsProxiesSetQuicOverrideRequest({this.quicOverride});

  $TargetHttpsProxiesSetQuicOverrideRequest.fromJson(core.Map json_)
    : this(quicOverride: json_['quicOverride'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (quicOverride != null) 'quicOverride': quicOverride!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetHttpsProxiesSetSslCertificatesRequest
/// - compute:beta : TargetHttpsProxiesSetSslCertificatesRequest
/// - compute:v1 : TargetHttpsProxiesSetSslCertificatesRequest
class $TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  $TargetHttpsProxiesSetSslCertificatesRequest({this.sslCertificates});

  $TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map json_)
    : this(
        sslCertificates:
            (json_['sslCertificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sslCertificates != null) 'sslCertificates': sslCertificates!,
  };
}

/// Used by:
///
/// - compute:beta : TargetInstance
/// - compute:v1 : TargetInstance
class $TargetInstance {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance.
  ///
  /// When creating a target instance, you can provide the fully-qualified URL
  /// or a valid partial URL to the desired virtual machine. For example, the
  /// following are all valid URLs: -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// /instances/instance - projects/project/zones/zone/instances/instance -
  /// zones/zone/instances/instance
  core.String? instance;

  /// The type of the resource.
  ///
  /// Always compute#targetInstance for target instances.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Must have a value of NO_NAT.
  ///
  /// Protocol forwarding delivers packets while preserving the destination IP
  /// address of the forwarding rule referencing the target instance.
  /// Possible string values are:
  /// - "NO_NAT" : No NAT performed.
  core.String? natPolicy;

  /// The URL of the network this target instance uses to forward traffic.
  ///
  /// If not specified, the traffic will be forwarded to the network that the
  /// default network interface belongs to.
  core.String? network;

  /// The resource URL for the security policy associated with this target
  /// instance.
  ///
  /// Output only.
  core.String? securityPolicy;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL of the zone where the target instance resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  $TargetInstance({
    this.creationTimestamp,
    this.description,
    this.id,
    this.instance,
    this.kind,
    this.name,
    this.natPolicy,
    this.network,
    this.securityPolicy,
    this.selfLink,
    this.zone,
  });

  $TargetInstance.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        id: json_['id'] as core.String?,
        instance: json_['instance'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        natPolicy: json_['natPolicy'] as core.String?,
        network: json_['network'] as core.String?,
        securityPolicy: json_['securityPolicy'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (id != null) 'id': id!,
    if (instance != null) 'instance': instance!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (natPolicy != null) 'natPolicy': natPolicy!,
    if (network != null) 'network': network!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - compute:beta : TargetPool
/// - compute:v1 : TargetPool
class $TargetPool {
  /// The server-defined URL for the resource.
  ///
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between \[0, 1\]. backupPool and failoverRatio
  /// together define the fallback behavior of the primary target pool: if the
  /// ratio of the healthy instances in the primary pool is at or below
  /// failoverRatio, traffic arriving at the load-balanced IP will be directed
  /// to the backup pool. In case where failoverRatio and backupPool are not
  /// set, or all the instances in the backup pool are unhealthy, the traffic
  /// will be directed back to the primary pool in the "force" mode, where
  /// traffic will be spread to the healthy instances with the best effort, or
  /// to all instances when no instance is healthy.
  core.String? backupPool;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool).
  ///
  /// The value of the field must be in \[0, 1\]. If set, backupPool must also
  /// be set. They together define the fallback behavior of the primary target
  /// pool: if the ratio of the healthy instances in the primary pool is at or
  /// below this number, traffic arriving at the load-balanced IP will be
  /// directed to the backup pool. In case where failoverRatio is not set or all
  /// the instances in the backup pool are unhealthy, the traffic will be
  /// directed back to the primary pool in the "force" mode, where traffic will
  /// be spread to the healthy instances with the best effort, or to all
  /// instances when no instance is healthy.
  core.double? failoverRatio;

  /// The URL of the HttpHealthCheck resource.
  ///
  /// A member instance in this pool is considered healthy if and only if the
  /// health checks pass. Only legacy HttpHealthChecks are supported. Only one
  /// health check may be specified.
  core.List<core.String>? healthChecks;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool.
  ///
  /// They must live in zones contained in the same region as this pool.
  core.List<core.String>? instances;

  /// Type of the resource.
  ///
  /// Always compute#targetPool for target pools.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the target pool resides.
  ///
  /// Output only.
  core.String? region;

  /// The resource URL for the security policy associated with this target pool.
  ///
  /// Output only.
  core.String? securityPolicy;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Session affinity option, must be one of the following values: NONE:
  /// Connections from the same client IP may go to any instance in the pool.
  ///
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy. CLIENT_IP_PROTO:
  /// Connections from the same client IP with the same IP protocol will go to
  /// the same instance in the pool while that instance remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP" : 2-tuple hash on packet's source and destination IP
  /// addresses. Connections from the same source IP address to the same
  /// destination IP address will be served by the same backend VM while that VM
  /// remains healthy.
  /// - "CLIENT_IP_NO_DESTINATION" : 1-tuple hash only on packet's source IP
  /// address. Connections from the same source IP address will be served by the
  /// same backend VM while that VM remains healthy. This option can only be
  /// used for Internal TCP/UDP Load Balancing.
  /// - "CLIENT_IP_PORT_PROTO" : 5-tuple hash on packet's source and destination
  /// IP addresses, IP protocol, and source and destination ports. Connections
  /// for the same IP protocol from the same source IP address and port to the
  /// same destination IP address and port will be served by the same backend VM
  /// while that VM remains healthy. This option cannot be used for HTTP(S) load
  /// balancing.
  /// - "CLIENT_IP_PROTO" : 3-tuple hash on packet's source and destination IP
  /// addresses, and IP protocol. Connections for the same IP protocol from the
  /// same source IP address to the same destination IP address will be served
  /// by the same backend VM while that VM remains healthy. This option cannot
  /// be used for HTTP(S) load balancing.
  /// - "GENERATED_COOKIE" : Hash based on a cookie generated by the L7
  /// loadbalancer. Only valid for HTTP(S) load balancing.
  /// - "HEADER_FIELD" : The hash is based on a user specified header field.
  /// - "HTTP_COOKIE" : The hash is based on a user provided cookie.
  /// - "NONE" : No session affinity. Connections from the same client IP may go
  /// to any instance in the pool.
  /// - "STRONG_COOKIE_AFFINITY" : Strong cookie-based affinity. Connections
  /// bearing the same cookie will be served by the same backend VM while that
  /// VM remains healthy, as long as the cookie has not expired.
  core.String? sessionAffinity;

  $TargetPool({
    this.backupPool,
    this.creationTimestamp,
    this.description,
    this.failoverRatio,
    this.healthChecks,
    this.id,
    this.instances,
    this.kind,
    this.name,
    this.region,
    this.securityPolicy,
    this.selfLink,
    this.sessionAffinity,
  });

  $TargetPool.fromJson(core.Map json_)
    : this(
        backupPool: json_['backupPool'] as core.String?,
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        failoverRatio: (json_['failoverRatio'] as core.num?)?.toDouble(),
        healthChecks:
            (json_['healthChecks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
        instances:
            (json_['instances'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        region: json_['region'] as core.String?,
        securityPolicy: json_['securityPolicy'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        sessionAffinity: json_['sessionAffinity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (backupPool != null) 'backupPool': backupPool!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (failoverRatio != null) 'failoverRatio': failoverRatio!,
    if (healthChecks != null) 'healthChecks': healthChecks!,
    if (id != null) 'id': id!,
    if (instances != null) 'instances': instances!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (region != null) 'region': region!,
    if (securityPolicy != null) 'securityPolicy': securityPolicy!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : TargetProject
/// - vmmigration:v1alpha1 : TargetProject
class $TargetProject {
  /// The time this target project resource was created (not related to when the
  /// Compute Engine project it points to was created).
  ///
  /// Output only.
  core.String? createTime;

  /// The target project's description.
  core.String? description;

  /// The name of the target project.
  ///
  /// Output only.
  core.String? name;

  /// The target project ID (number) or project name.
  ///
  /// Required.
  core.String? project;

  /// The last time the target project resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $TargetProject({
    this.createTime,
    this.description,
    this.name,
    this.project,
    this.updateTime,
  });

  $TargetProject.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        project: json_['project'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (project != null) 'project': project!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetReference
/// - compute:beta : TargetReference
/// - compute:v1 : TargetReference
class $TargetReference {
  core.String? target;

  $TargetReference({this.target});

  $TargetReference.fromJson(core.Map json_)
    : this(target: json_['target'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (target != null) 'target': target!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1TargetSiteFailureReasonQuotaFailure
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReasonQuotaFailure
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaTargetSiteFailureReasonQuotaFailure
class $TargetSiteFailureReasonQuotaFailure {
  /// This number is an estimation on how much total quota this project needs to
  /// successfully complete indexing.
  core.String? totalRequiredQuota;

  $TargetSiteFailureReasonQuotaFailure({this.totalRequiredQuota});

  $TargetSiteFailureReasonQuotaFailure.fromJson(core.Map json_)
    : this(totalRequiredQuota: json_['totalRequiredQuota'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (totalRequiredQuota != null) 'totalRequiredQuota': totalRequiredQuota!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetSslProxiesSetBackendServiceRequest
/// - compute:beta : TargetSslProxiesSetBackendServiceRequest
/// - compute:v1 : TargetSslProxiesSetBackendServiceRequest
class $TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String? service;

  $TargetSslProxiesSetBackendServiceRequest({this.service});

  $TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map json_)
    : this(service: json_['service'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetSslProxiesSetCertificateMapRequest
/// - compute:beta : TargetSslProxiesSetCertificateMapRequest
/// - compute:v1 : TargetSslProxiesSetCertificateMapRequest
class $TargetSslProxiesSetCertificateMapRequest {
  /// URL of the Certificate Map to associate with this TargetSslProxy.
  ///
  /// Accepted format is //certificatemanager.googleapis.com/projects/{project
  /// }/locations/{location}/certificateMaps/{resourceName}.
  core.String? certificateMap;

  $TargetSslProxiesSetCertificateMapRequest({this.certificateMap});

  $TargetSslProxiesSetCertificateMapRequest.fromJson(core.Map json_)
    : this(certificateMap: json_['certificateMap'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateMap != null) 'certificateMap': certificateMap!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetSslProxiesSetSslCertificatesRequest
/// - compute:beta : TargetSslProxiesSetSslCertificatesRequest
/// - compute:v1 : TargetSslProxiesSetSslCertificatesRequest
class $TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  $TargetSslProxiesSetSslCertificatesRequest({this.sslCertificates});

  $TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map json_)
    : this(
        sslCertificates:
            (json_['sslCertificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sslCertificates != null) 'sslCertificates': sslCertificates!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetSslProxy
/// - compute:beta : TargetSslProxy
/// - compute:v1 : TargetSslProxy
class $TargetSslProxy {
  /// URL of a certificate map that identifies a certificate map associated with
  /// the given target proxy.
  ///
  /// This field can only be set for global target proxies. If set,
  /// sslCertificates will be ignored. Accepted format is
  /// //certificatemanager.googleapis.com/projects/{project
  /// }/locations/{location}/certificateMaps/{resourceName}.
  core.String? certificateMap;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetSslProxy for target SSL proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates. sslCertificates do not apply when the load
  /// balancing scheme is set to INTERNAL_SELF_MANAGED.
  core.List<core.String>? sslCertificates;

  /// URL of SslPolicy resource that will be associated with the TargetSslProxy
  /// resource.
  ///
  /// If not set, the TargetSslProxy resource will not have any SSL policy
  /// configured.
  core.String? sslPolicy;

  $TargetSslProxy({
    this.certificateMap,
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.proxyHeader,
    this.selfLink,
    this.service,
    this.sslCertificates,
    this.sslPolicy,
  });

  $TargetSslProxy.fromJson(core.Map json_)
    : this(
        certificateMap: json_['certificateMap'] as core.String?,
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        service: json_['service'] as core.String?,
        sslCertificates:
            (json_['sslCertificates'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sslPolicy: json_['sslPolicy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateMap != null) 'certificateMap': certificateMap!,
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (service != null) 'service': service!,
    if (sslCertificates != null) 'sslCertificates': sslCertificates!,
    if (sslPolicy != null) 'sslPolicy': sslPolicy!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetTcpProxiesSetBackendServiceRequest
/// - compute:beta : TargetTcpProxiesSetBackendServiceRequest
/// - compute:v1 : TargetTcpProxiesSetBackendServiceRequest
class $TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String? service;

  $TargetTcpProxiesSetBackendServiceRequest({this.service});

  $TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map json_)
    : this(service: json_['service'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetTcpProxy
/// - compute:beta : TargetTcpProxy
/// - compute:v1 : TargetTcpProxy
class $TargetTcpProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetTcpProxy for target TCP proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule. This is generally useful when using Traffic Director to
  /// configure Envoy as a gateway or middle proxy (in other words, not a
  /// sidecar proxy). The Envoy proxy listens for inbound requests and handles
  /// requests when it receives them. The default is false.
  core.bool? proxyBind;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// URL of the region where the regional TCP proxy resides.
  ///
  /// This field is not applicable to global TCP proxy.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  $TargetTcpProxy({
    this.creationTimestamp,
    this.description,
    this.id,
    this.kind,
    this.name,
    this.proxyBind,
    this.proxyHeader,
    this.region,
    this.selfLink,
    this.service,
  });

  $TargetTcpProxy.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        proxyBind: json_['proxyBind'] as core.bool?,
        proxyHeader: json_['proxyHeader'] as core.String?,
        region: json_['region'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        service: json_['service'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (proxyBind != null) 'proxyBind': proxyBind!,
    if (proxyHeader != null) 'proxyHeader': proxyHeader!,
    if (region != null) 'region': region!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - compute:alpha : TargetVpnGateway
/// - compute:beta : TargetVpnGateway
/// - compute:v1 : TargetVpnGateway
class $TargetVpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A list of URLs to the ForwardingRule resources.
  ///
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? forwardingRules;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this TargetVpnGateway, which
  /// is essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve a TargetVpnGateway.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> bytes_) {
    labelFingerprint = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the network to which this VPN gateway is attached.
  ///
  /// Provided by the client when the VPN gateway is created.
  core.String? network;

  /// URL of the region where the target VPN gateway resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the VPN gateway, which can be one of the following:
  /// CREATING, READY, FAILED, or DELETING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String? status;

  /// A list of URLs to VpnTunnel resources.
  ///
  /// VpnTunnels are created using the compute.vpntunnels.insert method and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? tunnels;

  $TargetVpnGateway({
    this.creationTimestamp,
    this.description,
    this.forwardingRules,
    this.id,
    this.kind,
    this.labelFingerprint,
    this.labels,
    this.name,
    this.network,
    this.region,
    this.selfLink,
    this.status,
    this.tunnels,
  });

  $TargetVpnGateway.fromJson(core.Map json_)
    : this(
        creationTimestamp: json_['creationTimestamp'] as core.String?,
        description: json_['description'] as core.String?,
        forwardingRules:
            (json_['forwardingRules'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        labelFingerprint: json_['labelFingerprint'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        region: json_['region'] as core.String?,
        selfLink: json_['selfLink'] as core.String?,
        status: json_['status'] as core.String?,
        tunnels:
            (json_['tunnels'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
    if (description != null) 'description': description!,
    if (forwardingRules != null) 'forwardingRules': forwardingRules!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (region != null) 'region': region!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (status != null) 'status': status!,
    if (tunnels != null) 'tunnels': tunnels!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : TargetingExpansionConfig
/// - displayvideo:v4 : TargetingExpansionConfig
class $TargetingExpansionConfig {
  /// Magnitude of expansion for eligible first-party user lists under this ad
  /// group.
  ///
  /// This field only applies to YouTube and Partners line item and ad group
  /// resources.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNKNOWN" : Audience expansion level is not specified or is unknown in
  /// this version.
  /// - "NO_REACH" : Audience expansion off.
  /// - "LEAST_REACH" : Conservative audience expansion.
  /// - "MID_REACH" : Moderate audience expansion.
  /// - "MOST_REACH" : Aggressive audience expansion.
  core.String? audienceExpansionLevel;

  /// Whether to exclude seed list for audience expansion.
  ///
  /// This field only applies to YouTube and Partners line item and ad group
  /// resources.
  ///
  /// Output only.
  core.bool? audienceExpansionSeedListExcluded;

  /// Whether to enable Optimized Targeting for the line item.
  ///
  /// Optimized targeting is not compatible with all bid strategies. Attempting
  /// to set this field to `true` for a line item using the BiddingStrategy
  /// field fixed_bid or one of the following combinations of BiddingStrategy
  /// fields and BiddingStrategyPerformanceGoalType will result in an error:
  /// maximize_auto_spend_bid: * `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_CIVA` *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_IVO_TEN` *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_AV_VIEWED`
  /// performance_goal_auto_bid: *
  /// `BIDDING_STRATEGY_PERFORMANCE_GOAL_TYPE_VIEWABLE_CPM`
  ///
  /// Required.
  core.bool? enableOptimizedTargeting;

  $TargetingExpansionConfig({
    this.audienceExpansionLevel,
    this.audienceExpansionSeedListExcluded,
    this.enableOptimizedTargeting,
  });

  $TargetingExpansionConfig.fromJson(core.Map json_)
    : this(
        audienceExpansionLevel: json_['audienceExpansionLevel'] as core.String?,
        audienceExpansionSeedListExcluded:
            json_['audienceExpansionSeedListExcluded'] as core.bool?,
        enableOptimizedTargeting:
            json_['enableOptimizedTargeting'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audienceExpansionLevel != null)
      'audienceExpansionLevel': audienceExpansionLevel!,
    if (audienceExpansionSeedListExcluded != null)
      'audienceExpansionSeedListExcluded': audienceExpansionSeedListExcluded!,
    if (enableOptimizedTargeting != null)
      'enableOptimizedTargeting': enableOptimizedTargeting!,
  };
}

/// Used by:
///
/// - composer:v1 : TaskLogsRetentionConfig
/// - composer:v1beta1 : TaskLogsRetentionConfig
class $TaskLogsRetentionConfig {
  /// The mode of storage for Airflow workers task logs.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TASK_LOGS_STORAGE_MODE_UNSPECIFIED" : This configuration is not
  /// specified by the user.
  /// - "CLOUD_LOGGING_AND_CLOUD_STORAGE" : Store task logs in Cloud Logging and
  /// in the environment's Cloud Storage bucket.
  /// - "CLOUD_LOGGING_ONLY" : Store task logs in Cloud Logging only.
  core.String? storageMode;

  $TaskLogsRetentionConfig({this.storageMode});

  $TaskLogsRetentionConfig.fromJson(core.Map json_)
    : this(storageMode: json_['storageMode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (storageMode != null) 'storageMode': storageMode!,
  };
}

/// Used by:
///
/// - datacatalog:v1 : GoogleCloudDatacatalogV1TaxonomyService
/// - datacatalog:v1beta1 : GoogleCloudDatacatalogV1beta1TaxonomyService
class $TaxonomyService {
  /// The service agent for the service.
  core.String? identity;

  /// The Google Cloud service name.
  /// Possible string values are:
  /// - "MANAGING_SYSTEM_UNSPECIFIED" : Default value
  /// - "MANAGING_SYSTEM_DATAPLEX" : Dataplex Universal Catalog.
  /// - "MANAGING_SYSTEM_OTHER" : Other
  core.String? name;

  $TaxonomyService({this.identity, this.name});

  $TaxonomyService.fromJson(core.Map json_)
    : this(
        identity: json_['identity'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identity != null) 'identity': identity!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - networkservices:v1 : TcpRouteRouteDestination
/// - networkservices:v1beta1 : TcpRouteRouteDestination
class $TcpRouteRouteDestination {
  /// The URL of a BackendService to route traffic to.
  ///
  /// Required.
  core.String? serviceName;

  /// Specifies the proportion of requests forwarded to the backend referenced
  /// by the serviceName field.
  ///
  /// This is computed as: - weight/Sum(weights in this destination list). For
  /// non-zero values, there may be some epsilon from the exact proportion
  /// defined here depending on the precision an implementation supports. If
  /// only one serviceName is specified and it has a weight greater than 0, 100%
  /// of the traffic is forwarded to that backend. If weights are specified for
  /// any one service name, they need to be specified for all of them. If
  /// weights are unspecified for all services, then, traffic is distributed in
  /// equal proportions to all of them.
  ///
  /// Optional.
  core.int? weight;

  $TcpRouteRouteDestination({this.serviceName, this.weight});

  $TcpRouteRouteDestination.fromJson(core.Map json_)
    : this(
        serviceName: json_['serviceName'] as core.String?,
        weight: json_['weight'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceName != null) 'serviceName': serviceName!,
    if (weight != null) 'weight': weight!,
  };
}

/// Used by:
///
/// - networkservices:v1 : TcpRouteRouteMatch
/// - networkservices:v1beta1 : TcpRouteRouteMatch
class $TcpRouteRouteMatch {
  /// Must be specified in the CIDR range format.
  ///
  /// A CIDR range consists of an IP Address and a prefix length to construct
  /// the subnet mask. By default, the prefix length is 32 (i.e. matches a
  /// single IP address). Only IPV4 addresses are supported. Examples:
  /// "10.0.0.1" - matches against this exact IP address. "10.0.0.0/8" - matches
  /// against any IP address within the 10.0.0.0 subnet and 255.255.255.0 mask.
  /// "0.0.0.0/0" - matches against any IP address'.
  ///
  /// Required.
  core.String? address;

  /// Specifies the destination port to match against.
  ///
  /// Required.
  core.String? port;

  $TcpRouteRouteMatch({this.address, this.port});

  $TcpRouteRouteMatch.fromJson(core.Map json_)
    : this(
        address: json_['address'] as core.String?,
        port: json_['port'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (address != null) 'address': address!,
    if (port != null) 'port': port!,
  };
}

/// Used by:
///
/// - tagmanager:v1 : TeardownTag
/// - tagmanager:v2 : TeardownTag
class $TeardownTag {
  /// If true, fire the teardown tag if and only if the main tag fires
  /// successfully.
  ///
  /// If false, fire the teardown tag regardless of main tag firing status.
  core.bool? stopTeardownOnFailure;

  /// The name of the teardown tag.
  core.String? tagName;

  $TeardownTag({this.stopTeardownOnFailure, this.tagName});

  $TeardownTag.fromJson(core.Map json_)
    : this(
        stopTeardownOnFailure: json_['stopTeardownOnFailure'] as core.bool?,
        tagName: json_['tagName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (stopTeardownOnFailure != null)
      'stopTeardownOnFailure': stopTeardownOnFailure!,
    if (tagName != null) 'tagName': tagName!,
  };
}

/// Used by:
///
/// - metastore:v1 : TelemetryConfig
/// - metastore:v1alpha : TelemetryConfig
/// - metastore:v1beta : TelemetryConfig
class $TelemetryConfig {
  /// The output format of the Dataproc Metastore service's logs.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LOG_FORMAT_UNSPECIFIED" : The LOG_FORMAT is not set.
  /// - "LEGACY" : Logging output uses the legacy textPayload format.
  /// - "JSON" : Logging output uses the jsonPayload format.
  core.String? logFormat;

  $TelemetryConfig({this.logFormat});

  $TelemetryConfig.fromJson(core.Map json_)
    : this(logFormat: json_['logFormat'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (logFormat != null) 'logFormat': logFormat!,
  };
}

/// Used by:
///
/// - serviceconsumermanagement:v1 : DeleteTenantProjectRequest
/// - serviceconsumermanagement:v1 : RemoveTenantProjectRequest
/// - serviceconsumermanagement:v1 : UndeleteTenantProjectRequest
class $TenantProjectRequest {
  /// Tag of the resource within the tenancy unit.
  ///
  /// Required.
  core.String? tag;

  $TenantProjectRequest({this.tag});

  $TenantProjectRequest.fromJson(core.Map json_)
    : this(tag: json_['tag'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (tag != null) 'tag': tag!,
  };
}

/// Used by:
///
/// - tpu:v1 : TensorFlowVersion
/// - tpu:v1alpha1 : TensorFlowVersion
class $TensorFlowVersion {
  /// The resource name.
  core.String? name;

  /// the tensorflow version.
  core.String? version;

  $TensorFlowVersion({this.name, this.version});

  $TensorFlowVersion.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TensorboardBlob
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TensorboardBlob
class $TensorboardBlob {
  /// The bytes of the blob is not present unless it's returned by the
  /// ReadTensorboardBlobData endpoint.
  ///
  /// Optional.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// A URI safe key uniquely identifying a blob.
  ///
  /// Can be used to locate the blob stored in the Cloud Storage bucket of the
  /// consumer project.
  ///
  /// Output only.
  core.String? id;

  $TensorboardBlob({this.data, this.id});

  $TensorboardBlob.fromJson(core.Map json_)
    : this(
        data: json_['data'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (id != null) 'id': id!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TensorboardExperiment
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TensorboardExperiment
class $TensorboardExperiment {
  /// Timestamp when this TensorboardExperiment was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardExperiment.
  core.String? description;

  /// User provided name of this TensorboardExperiment.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your
  /// TensorboardExperiment.
  ///
  /// Label keys and values cannot be longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// `aiplatform.googleapis.com/` and are immutable. The following system
  /// labels exist for each Dataset: *
  /// `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardExperiment.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Output only.
  core.String? name;

  /// Source of the TensorboardExperiment.
  ///
  /// Example: a custom training job.
  ///
  /// Immutable.
  core.String? source;

  /// Timestamp when this TensorboardExperiment was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $TensorboardExperiment({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.source,
    this.updateTime,
  });

  $TensorboardExperiment.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        source: json_['source'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (source != null) 'source': source!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TensorboardRun
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TensorboardRun
class $TensorboardRun {
  /// Timestamp when this TensorboardRun was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardRun.
  core.String? description;

  /// User provided name of this TensorboardRun.
  ///
  /// This value must be unique among all TensorboardRuns belonging to the same
  /// parent TensorboardExperiment.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your TensorboardRuns.
  ///
  /// This field will be used to filter and visualize Runs in the Tensorboard
  /// UI. For example, a Vertex AI training job can set a label
  /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
  /// within that job. An end user can set a label experiment_id=xxxxx for all
  /// the runs produced in a Jupyter notebook. These runs can be grouped by a
  /// label value and visualized together in the Tensorboard UI. Label keys and
  /// values can be no longer than 64 characters (Unicode codepoints), can only
  /// contain lowercase letters, numeric characters, underscores and dashes.
  /// International characters are allowed. No more than 64 user labels can be
  /// associated with one TensorboardRun (System labels are excluded). See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardRun.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this TensorboardRun was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  $TensorboardRun({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.updateTime,
  });

  $TensorboardRun.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TensorboardTensor
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TensorboardTensor
class $TensorboardTensor {
  /// Serialized form of
  /// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto
  ///
  /// Required.
  core.String? value;
  core.List<core.int> get valueAsBytes => convert.base64.decode(value!);

  set valueAsBytes(core.List<core.int> bytes_) {
    value = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Version number of TensorProto used to serialize value.
  ///
  /// Optional.
  core.int? versionNumber;

  $TensorboardTensor({this.value, this.versionNumber});

  $TensorboardTensor.fromJson(core.Map json_)
    : this(
        value: json_['value'] as core.String?,
        versionNumber: json_['versionNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
    if (versionNumber != null) 'versionNumber': versionNumber!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TensorboardTimeSeriesMetadata
class $TensorboardTimeSeriesMetadata {
  /// The largest blob sequence length (number of blobs) of all data points in
  /// this time series, if its ValueType is BLOB_SEQUENCE.
  ///
  /// Output only.
  core.String? maxBlobSequenceLength;

  /// Max step index of all data points within a TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxStep;

  /// Max wall clock timestamp of all data points within a
  /// TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxWallTime;

  $TensorboardTimeSeriesMetadata({
    this.maxBlobSequenceLength,
    this.maxStep,
    this.maxWallTime,
  });

  $TensorboardTimeSeriesMetadata.fromJson(core.Map json_)
    : this(
        maxBlobSequenceLength: json_['maxBlobSequenceLength'] as core.String?,
        maxStep: json_['maxStep'] as core.String?,
        maxWallTime: json_['maxWallTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxBlobSequenceLength != null)
      'maxBlobSequenceLength': maxBlobSequenceLength!,
    if (maxStep != null) 'maxStep': maxStep!,
    if (maxWallTime != null) 'maxWallTime': maxWallTime!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3TestConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1TestConfig
class $TestConfig {
  /// Flow name to start the test case with.
  ///
  /// Format: `projects//locations//agents//flows/`. Only one of `flow` and
  /// `page` should be set to indicate the starting point of the test case. If
  /// neither is set, the test case will start with start page on the default
  /// start flow.
  core.String? flow;

  /// The page to start the test case with.
  ///
  /// Format: `projects//locations//agents//flows//pages/`. Only one of `flow`
  /// and `page` should be set to indicate the starting point of the test case.
  /// If neither is set, the test case will start with start page on the default
  /// start flow.
  core.String? page;

  /// Session parameters to be compared when calculating differences.
  core.List<core.String>? trackingParameters;

  $TestConfig({this.flow, this.page, this.trackingParameters});

  $TestConfig.fromJson(core.Map json_)
    : this(
        flow: json_['flow'] as core.String?,
        page: json_['page'] as core.String?,
        trackingParameters:
            (json_['trackingParameters'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (flow != null) 'flow': flow!,
    if (page != null) 'page': page!,
    if (trackingParameters != null) 'trackingParameters': trackingParameters!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : TestIamPermissionsRequest
/// - aiplatform:v1beta1 : GoogleIamV1TestIamPermissionsRequest
/// - analyticshub:v1 : TestIamPermissionsRequest
/// - analyticshub:v1beta1 : TestIamPermissionsRequest
/// - apigateway:v1 : ApigatewayTestIamPermissionsRequest
/// - apigateway:v1beta : ApigatewayTestIamPermissionsRequest
/// - apigee:v1 : GoogleIamV1TestIamPermissionsRequest
/// - apigeeregistry:v1 : TestIamPermissionsRequest
/// - apphub:v1 : TestIamPermissionsRequest
/// - apphub:v1alpha : TestIamPermissionsRequest
/// - artifactregistry:v1 : TestIamPermissionsRequest
/// - artifactregistry:v1beta1 : TestIamPermissionsRequest
/// - artifactregistry:v1beta2 : TestIamPermissionsRequest
/// - backupdr:v1 : TestIamPermissionsRequest
/// - beyondcorp:v1 : GoogleIamV1TestIamPermissionsRequest
/// - beyondcorp:v1alpha : GoogleIamV1TestIamPermissionsRequest
/// - bigquery:v2 : TestIamPermissionsRequest
/// - bigqueryconnection:v1 : TestIamPermissionsRequest
/// - bigqueryconnection:v1beta1 : TestIamPermissionsRequest
/// - bigquerydatapolicy:v1 : TestIamPermissionsRequest
/// - bigqueryreservation:v1 : TestIamPermissionsRequest
/// - bigtableadmin:v2 : TestIamPermissionsRequest
/// - binaryauthorization:v1 : TestIamPermissionsRequest
/// - binaryauthorization:v1beta1 : TestIamPermissionsRequest
/// - cloudbilling:v1 : TestIamPermissionsRequest
/// - cloudbuild:v2 : TestIamPermissionsRequest
/// - clouddeploy:v1 : TestIamPermissionsRequest
/// - cloudfunctions:v1 : TestIamPermissionsRequest
/// - cloudfunctions:v2 : TestIamPermissionsRequest
/// - cloudfunctions:v2alpha : TestIamPermissionsRequest
/// - cloudfunctions:v2beta : TestIamPermissionsRequest
/// - cloudkms:v1 : TestIamPermissionsRequest
/// - cloudresourcemanager:v1 : TestIamPermissionsRequest
/// - cloudresourcemanager:v1beta1 : TestIamPermissionsRequest
/// - cloudresourcemanager:v2 : TestIamPermissionsRequest
/// - cloudresourcemanager:v2beta1 : TestIamPermissionsRequest
/// - cloudresourcemanager:v3 : TestIamPermissionsRequest
/// - cloudtasks:v2 : TestIamPermissionsRequest
/// - cloudtasks:v2beta2 : TestIamPermissionsRequest
/// - cloudtasks:v2beta3 : TestIamPermissionsRequest
/// - config:v1 : TestIamPermissionsRequest
/// - connectors:v1 : TestIamPermissionsRequest
/// - containeranalysis:v1 : TestIamPermissionsRequest
/// - containeranalysis:v1alpha1 : TestIamPermissionsRequest
/// - containeranalysis:v1beta1 : TestIamPermissionsRequest
/// - datacatalog:v1 : TestIamPermissionsRequest
/// - datacatalog:v1beta1 : TestIamPermissionsRequest
/// - dataform:v1beta1 : TestIamPermissionsRequest
/// - datafusion:v1 : TestIamPermissionsRequest
/// - datafusion:v1beta1 : TestIamPermissionsRequest
/// - datamigration:v1 : TestIamPermissionsRequest
/// - datamigration:v1beta1 : TestIamPermissionsRequest
/// - dns:v1 : GoogleIamV1TestIamPermissionsRequest
/// - dns:v1beta2 : GoogleIamV1TestIamPermissionsRequest
/// - domains:v1 : TestIamPermissionsRequest
/// - domains:v1alpha2 : TestIamPermissionsRequest
/// - domains:v1beta1 : TestIamPermissionsRequest
/// - eventarc:v1 : TestIamPermissionsRequest
/// - gkebackup:v1 : TestIamPermissionsRequest
/// - gkehub:v1 : TestIamPermissionsRequest
/// - gkehub:v1alpha : TestIamPermissionsRequest
/// - gkehub:v1beta : TestIamPermissionsRequest
/// - gkehub:v1beta1 : TestIamPermissionsRequest
/// - gkeonprem:v1 : TestIamPermissionsRequest
/// - healthcare:v1 : TestIamPermissionsRequest
/// - healthcare:v1beta1 : TestIamPermissionsRequest
/// - iam:v1 : TestIamPermissionsRequest
/// - iap:v1 : TestIamPermissionsRequest
/// - iap:v1beta1 : TestIamPermissionsRequest
/// - identitytoolkit:v2 : GoogleIamV1TestIamPermissionsRequest
/// - managedidentities:v1 : TestIamPermissionsRequest
/// - managedidentities:v1alpha1 : TestIamPermissionsRequest
/// - managedidentities:v1beta1 : TestIamPermissionsRequest
/// - ml:v1 : GoogleIamV1__TestIamPermissionsRequest
/// - networkconnectivity:v1 : TestIamPermissionsRequest
/// - networkconnectivity:v1alpha1 : TestIamPermissionsRequest
/// - networkmanagement:v1 : TestIamPermissionsRequest
/// - networkmanagement:v1beta1 : TestIamPermissionsRequest
/// - networksecurity:v1 : GoogleIamV1TestIamPermissionsRequest
/// - networksecurity:v1beta1 : GoogleIamV1TestIamPermissionsRequest
/// - networkservices:v1 : TestIamPermissionsRequest
/// - notebooks:v1 : TestIamPermissionsRequest
/// - notebooks:v2 : TestIamPermissionsRequest
/// - privateca:v1 : TestIamPermissionsRequest
/// - privateca:v1beta1 : TestIamPermissionsRequest
/// - pubsub:v1 : TestIamPermissionsRequest
/// - pubsub:v1beta2 : TestIamPermissionsRequest
/// - run:v1 : TestIamPermissionsRequest
/// - run:v2 : GoogleIamV1TestIamPermissionsRequest
/// - runtimeconfig:v1beta1 : TestIamPermissionsRequest
/// - secretmanager:v1 : TestIamPermissionsRequest
/// - secretmanager:v1beta1 : TestIamPermissionsRequest
/// - secretmanager:v1beta2 : TestIamPermissionsRequest
/// - securesourcemanager:v1 : TestIamPermissionsRequest
/// - securitycenter:v1 : TestIamPermissionsRequest
/// - securitycenter:v1beta1 : TestIamPermissionsRequest
/// - servicedirectory:v1 : TestIamPermissionsRequest
/// - servicedirectory:v1beta1 : TestIamPermissionsRequest
/// - servicemanagement:v1 : TestIamPermissionsRequest
/// - vmwareengine:v1 : TestIamPermissionsRequest
/// - workstations:v1 : TestIamPermissionsRequest
/// - workstations:v1beta : TestIamPermissionsRequest
class $TestIamPermissionsRequest00 {
  /// The set of permissions to check for the `resource`.
  ///
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  core.List<core.String>? permissions;

  $TestIamPermissionsRequest00({this.permissions});

  $TestIamPermissionsRequest00.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleIamV1TestIamPermissionsRequest
/// - dataproc:v1 : TestIamPermissionsRequest
/// - logging:v2 : TestIamPermissionsRequest
/// - metastore:v1 : TestIamPermissionsRequest
/// - metastore:v1alpha : TestIamPermissionsRequest
/// - metastore:v1beta : TestIamPermissionsRequest
class $TestIamPermissionsRequest01 {
  /// The set of permissions to check for the resource.
  ///
  /// Permissions with wildcards (such as * or storage.*) are not allowed. For
  /// more information see IAM Overview
  /// (https://cloud.google.com/iam/docs/overview#permissions).
  core.List<core.String>? permissions;

  $TestIamPermissionsRequest01({this.permissions});

  $TestIamPermissionsRequest01.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - dataplex:v1 : GoogleIamV1TestIamPermissionsResponse
/// - dataproc:v1 : TestIamPermissionsResponse
/// - logging:v2 : TestIamPermissionsResponse
/// - metastore:v1 : TestIamPermissionsResponse
/// - metastore:v1alpha : TestIamPermissionsResponse
/// - metastore:v1beta : TestIamPermissionsResponse
class $TestIamPermissionsResponse {
  /// A subset of TestPermissionsRequest.permissions that the caller is allowed.
  core.List<core.String>? permissions;

  $TestIamPermissionsResponse({this.permissions});

  $TestIamPermissionsResponse.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - compute:alpha : TestPermissionsRequest
/// - compute:beta : TestPermissionsRequest
/// - compute:v1 : TestPermissionsRequest
/// - deploymentmanager:alpha : TestPermissionsRequest
/// - deploymentmanager:v2 : TestPermissionsRequest
/// - deploymentmanager:v2beta : TestPermissionsRequest
class $TestPermissionsRequest {
  /// The set of permissions to check for the 'resource'.
  ///
  /// Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
  core.List<core.String>? permissions;

  $TestPermissionsRequest({this.permissions});

  $TestPermissionsRequest.fromJson(core.Map json_)
    : this(
        permissions:
            (json_['permissions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (permissions != null) 'permissions': permissions!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3TestRunDifference
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1TestRunDifference
class $TestRunDifference {
  /// A human readable description of the diff, showing the actual output vs
  /// expected output.
  core.String? description;

  /// The type of diff.
  /// Possible string values are:
  /// - "DIFF_TYPE_UNSPECIFIED" : Should never be used.
  /// - "INTENT" : The intent.
  /// - "PAGE" : The page.
  /// - "PARAMETERS" : The parameters.
  /// - "UTTERANCE" : The message utterance.
  /// - "FLOW" : The flow.
  core.String? type;

  $TestRunDifference({this.description, this.type});

  $TestRunDifference.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_TextDetectionConfig
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_TextDetectionConfig
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_TextDetectionConfig
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_TextDetectionConfig
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_TextDetectionConfig
class $TextDetectionConfig {
  /// Language hint can be specified if the language to be detected is known a
  /// priori.
  ///
  /// It can increase the accuracy of the detection. Language hint must be
  /// language code in BCP-47 format. Automatic language detection is performed
  /// if no hint is provided.
  core.List<core.String>? languageHints;

  /// Model to use for text detection.
  ///
  /// Supported values: "builtin/stable" (the default if unset) and
  /// "builtin/latest".
  core.String? model;

  $TextDetectionConfig({this.languageHints, this.model});

  $TextDetectionConfig.fromJson(core.Map json_)
    : this(
        languageHints:
            (json_['languageHints'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        model: json_['model'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageHints != null) 'languageHints': languageHints!,
    if (model != null) 'model': model!,
  };
}

/// Used by:
///
/// - vision:v1 : TextDetectionParams
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1TextDetectionParams
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1TextDetectionParams
class $TextDetectionParams {
  /// A list of advanced OCR options to further fine-tune OCR behavior.
  ///
  /// Current valid values are: - `legacy_layout`: a heuristics layout detection
  /// algorithm, which serves as an alternative to the current ML-based layout
  /// detection algorithm. Customers can choose the best suitable layout
  /// algorithm based on their situation.
  core.List<core.String>? advancedOcrOptions;

  /// By default, Cloud Vision API only includes confidence score for
  /// DOCUMENT_TEXT_DETECTION result.
  ///
  /// Set the flag to true to include confidence score for TEXT_DETECTION as
  /// well.
  core.bool? enableTextDetectionConfidenceScore;

  $TextDetectionParams({
    this.advancedOcrOptions,
    this.enableTextDetectionConfidenceScore,
  });

  $TextDetectionParams.fromJson(core.Map json_)
    : this(
        advancedOcrOptions:
            (json_['advancedOcrOptions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        enableTextDetectionConfidenceScore:
            json_['enableTextDetectionConfidenceScore'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advancedOcrOptions != null) 'advancedOcrOptions': advancedOcrOptions!,
    if (enableTextDetectionConfidenceScore != null)
      'enableTextDetectionConfidenceScore': enableTextDetectionConfidenceScore!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2TextInput
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1TextInput
class $TextInput00 {
  /// The language of this conversational query.
  ///
  /// See
  /// [Language Support](https://cloud.google.com/dialogflow/docs/reference/language)
  /// for a list of the currently supported language codes. Note that queries in
  /// the same session do not necessarily need to specify the same language.
  ///
  /// Required.
  core.String? languageCode;

  /// The UTF-8 encoded natural language text to be processed.
  ///
  /// Text length must not exceed 256 characters for virtual agent interactions.
  ///
  /// Required.
  core.String? text;

  $TextInput00({this.languageCode, this.text});

  $TextInput00.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3TextInput
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1TextInput
class $TextInput01 {
  /// The UTF-8 encoded natural language text to be processed.
  ///
  /// Required.
  core.String? text;

  $TextInput01({this.text});

  $TextInput01.fromJson(core.Map json_)
    : this(text: json_['text'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2TextLimits
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaTextLimits
class $TextLimits {
  /// Maximum length allowed for a text Field type.
  core.int? maxLength;

  /// Minimum length allowed for a text Field type.
  core.int? minLength;

  $TextLimits({this.maxLength, this.minLength});

  $TextLimits.fromJson(core.Map json_)
    : this(
        maxLength: json_['maxLength'] as core.int?,
        minLength: json_['minLength'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxLength != null) 'maxLength': maxLength!,
    if (minLength != null) 'minLength': minLength!,
  };
}

/// Used by:
///
/// - language:v1 : TextSpan
/// - language:v1beta2 : TextSpan
/// - language:v2 : TextSpan
class $TextSpan00 {
  /// The API calculates the beginning offset of the content in the original
  /// document according to the EncodingType specified in the API request.
  core.int? beginOffset;

  /// The content of the text span, which is a substring of the document.
  core.String? content;

  $TextSpan00({this.beginOffset, this.content});

  $TextSpan00.fromJson(core.Map json_)
    : this(
        beginOffset: json_['beginOffset'] as core.int?,
        content: json_['content'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (beginOffset != null) 'beginOffset': beginOffset!,
    if (content != null) 'content': content!,
  };
}

/// Used by:
///
/// - healthcare:v1 : TextSpan
/// - healthcare:v1beta1 : TextSpan
class $TextSpan01 {
  /// The unicode codepoint index of the beginning of this span.
  core.int? beginOffset;

  /// The original text contained in this span.
  core.String? content;

  $TextSpan01({this.beginOffset, this.content});

  $TextSpan01.fromJson(core.Map json_)
    : this(
        beginOffset: json_['beginOffset'] as core.int?,
        content: json_['content'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (beginOffset != null) 'beginOffset': beginOffset!,
    if (content != null) 'content': content!,
  };
}

/// Used by:
///
/// - content:v2.1 : TextWithTooltip
/// - merchantapi:issueresolution_v1beta : TextWithTooltip
class $TextWithTooltip {
  /// Value of the tooltip as a simple text.
  core.String? simpleTooltipValue;

  /// Value of the message as a simple text.
  core.String? simpleValue;

  /// The suggested type of an icon for tooltip, if a tooltip is present.
  /// Possible string values are:
  /// - "TOOLTIP_ICON_STYLE_UNSPECIFIED" : Default value. Will never be provided
  /// by the API.
  /// - "INFO" : Used when the tooltip adds additional information to the
  /// context, the 'i' can be used as an icon.
  /// - "QUESTION" : Used when the tooltip shows helpful information, the '?'
  /// can be used as an icon.
  core.String? tooltipIconStyle;

  $TextWithTooltip({
    this.simpleTooltipValue,
    this.simpleValue,
    this.tooltipIconStyle,
  });

  $TextWithTooltip.fromJson(core.Map json_)
    : this(
        simpleTooltipValue: json_['simpleTooltipValue'] as core.String?,
        simpleValue: json_['simpleValue'] as core.String?,
        tooltipIconStyle: json_['tooltipIconStyle'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (simpleTooltipValue != null) 'simpleTooltipValue': simpleTooltipValue!,
    if (simpleValue != null) 'simpleValue': simpleValue!,
    if (tooltipIconStyle != null) 'tooltipIconStyle': tooltipIconStyle!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ThirdPartyOnlyConfig
/// - displayvideo:v3 : ThirdPartyOnlyConfig
/// - displayvideo:v4 : ThirdPartyOnlyConfig
class $ThirdPartyOnlyConfig {
  /// Whether or not order ID reporting for pixels is enabled.
  ///
  /// This value cannot be changed once set to `true`.
  core.bool? pixelOrderIdReportingEnabled;

  $ThirdPartyOnlyConfig({this.pixelOrderIdReportingEnabled});

  $ThirdPartyOnlyConfig.fromJson(core.Map json_)
    : this(
        pixelOrderIdReportingEnabled:
            json_['pixelOrderIdReportingEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pixelOrderIdReportingEnabled != null)
      'pixelOrderIdReportingEnabled': pixelOrderIdReportingEnabled!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ThirdPartyUrl
/// - displayvideo:v3 : ThirdPartyUrl
/// - displayvideo:v4 : ThirdPartyUrl
class $ThirdPartyUrl {
  /// The type of interaction needs to be tracked by the tracking URL
  ///
  /// Optional.
  /// Possible string values are:
  /// - "THIRD_PARTY_URL_TYPE_UNSPECIFIED" : The type of third-party URL is
  /// unspecified or is unknown in this version.
  /// - "THIRD_PARTY_URL_TYPE_IMPRESSION" : Used to count impressions of the
  /// creative after the audio or video buffering is complete.
  /// - "THIRD_PARTY_URL_TYPE_CLICK_TRACKING" : Used to track user clicks on the
  /// audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_START" : Used to track the number of
  /// times a user starts the audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_FIRST_QUARTILE" : Used to track the
  /// number of times the audio or video plays to 25% of its length.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_MIDPOINT" : Used to track the number
  /// of times the audio or video plays to 50% of its length.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_THIRD_QUARTILE" : Used to track the
  /// number of times the audio or video plays to 75% of its length.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_COMPLETE" : Used to track the number
  /// of times the audio or video plays to the end.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_MUTE" : Used to track the number of
  /// times a user mutes the audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_PAUSE" : Used to track the number of
  /// times a user pauses the audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_REWIND" : Used to track the number of
  /// times a user replays the audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_FULLSCREEN" : Used to track the number
  /// of times a user expands the player to full-screen size.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_STOP" : Used to track the number of
  /// times a user stops the audio or video.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_CUSTOM" : Used to track the number of
  /// times a user performs a custom click, such as clicking on a video hot
  /// spot.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_SKIP" : Used to track the number of
  /// times the audio or video was skipped.
  /// - "THIRD_PARTY_URL_TYPE_AUDIO_VIDEO_PROGRESS" : Used to track the number
  /// of times the audio or video plays to an offset determined by the
  /// progress_offset.
  core.String? type;

  /// Tracking URL used to track the interaction.
  ///
  /// Provide a URL with optional path or query string, beginning with `https:`.
  /// For example, `https://www.example.com/path`
  ///
  /// Optional.
  core.String? url;

  $ThirdPartyUrl({this.type, this.url});

  $ThirdPartyUrl.fromJson(core.Map json_)
    : this(
        type: json_['type'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ThirdPartyVendorConfig
/// - displayvideo:v3 : ThirdPartyVendorConfig
/// - displayvideo:v4 : ThirdPartyVendorConfig
class $ThirdPartyVendorConfig {
  /// The ID used by the platform of the third-party vendor to identify the line
  /// item.
  core.String? placementId;

  /// The third-party measurement vendor.
  /// Possible string values are:
  /// - "THIRD_PARTY_VENDOR_UNSPECIFIED" : Unknown third-party vendor.
  /// - "THIRD_PARTY_VENDOR_MOAT" : Moat.
  /// - "THIRD_PARTY_VENDOR_DOUBLE_VERIFY" : DoubleVerify.
  /// - "THIRD_PARTY_VENDOR_INTEGRAL_AD_SCIENCE" : Integral Ad Science.
  /// - "THIRD_PARTY_VENDOR_COMSCORE" : Comscore.
  /// - "THIRD_PARTY_VENDOR_TELEMETRY" : Telemetry.
  /// - "THIRD_PARTY_VENDOR_MEETRICS" : Meetrics.
  /// - "THIRD_PARTY_VENDOR_ZEFR" : ZEFR.
  /// - "THIRD_PARTY_VENDOR_NIELSEN" : Nielsen.
  /// - "THIRD_PARTY_VENDOR_KANTAR" : Kantar.
  /// - "THIRD_PARTY_VENDOR_DYNATA" : Dynata.
  /// - "THIRD_PARTY_VENDOR_TRANSUNION" : Transunion.
  core.String? vendor;

  $ThirdPartyVendorConfig({this.placementId, this.vendor});

  $ThirdPartyVendorConfig.fromJson(core.Map json_)
    : this(
        placementId: json_['placementId'] as core.String?,
        vendor: json_['vendor'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (placementId != null) 'placementId': placementId!,
    if (vendor != null) 'vendor': vendor!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : ThreatOverride
/// - networksecurity:v1beta1 : ThreatOverride
class $ThreatOverride {
  /// Threat action override.
  ///
  /// For some threat types, only a subset of actions applies.
  ///
  /// Required.
  /// Possible string values are:
  /// - "THREAT_ACTION_UNSPECIFIED" : Threat action not specified.
  /// - "DEFAULT_ACTION" : The default action (as specified by the vendor) is
  /// taken.
  /// - "ALLOW" : The packet matching this rule will be allowed to transmit.
  /// - "ALERT" : The packet matching this rule will be allowed to transmit, but
  /// a threat_log entry will be sent to the consumer project.
  /// - "DENY" : The packet matching this rule will be dropped, and a threat_log
  /// entry will be sent to the consumer project.
  core.String? action;

  /// Vendor-specific ID of a threat to override.
  ///
  /// Required.
  core.String? threatId;

  /// Type of the threat (read only).
  ///
  /// Output only.
  /// Possible string values are:
  /// - "THREAT_TYPE_UNSPECIFIED" : Type of threat not specified.
  /// - "UNKNOWN" : Type of threat is not derivable from threat ID. An override
  /// will be created for all types. Firewall will ignore overridden signature
  /// ID's that don't exist in the specific type.
  /// - "VULNERABILITY" : Threats related to system flaws that an attacker might
  /// otherwise attempt to exploit.
  /// - "ANTIVIRUS" : Threats related to viruses and malware found in
  /// executables and file types.
  /// - "SPYWARE" : Threats related to command-and-control (C2) activity, where
  /// spyware on an infected client is collecting data without the user's
  /// consent and/or communicating with a remote attacker.
  /// - "DNS" : Threats related to DNS.
  core.String? type;

  $ThreatOverride({this.action, this.threatId, this.type});

  $ThreatOverride.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        threatId: json_['threatId'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (threatId != null) 'threatId': threatId!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ThresholdConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ThresholdConfig
class $ThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// If this threshold config is for feature distribution distance: 1. For
  /// categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  $ThresholdConfig({this.value});

  $ThresholdConfig.fromJson(core.Map json_)
    : this(value: (json_['value'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - billingbudgets:v1 : GoogleCloudBillingBudgetsV1ThresholdRule
/// - billingbudgets:v1beta1 : GoogleCloudBillingBudgetsV1beta1ThresholdRule
class $ThresholdRule {
  /// The type of basis used to determine if spend has passed the threshold.
  ///
  /// Behavior defaults to CURRENT_SPEND if not set.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "BASIS_UNSPECIFIED" : Unspecified threshold basis.
  /// - "CURRENT_SPEND" : Use current spend as the basis for comparison against
  /// the threshold.
  /// - "FORECASTED_SPEND" : Use forecasted spend for the period as the basis
  /// for comparison against the threshold. FORECASTED_SPEND can only be set
  /// when the budget's time period is a Filter.calendar_period. It cannot be
  /// set in combination with Filter.custom_period.
  core.String? spendBasis;

  /// Send an alert when this threshold is exceeded.
  ///
  /// This is a 1.0-based percentage, so 0.5 = 50%. Validation: non-negative
  /// number.
  ///
  /// Required.
  core.double? thresholdPercent;

  $ThresholdRule({this.spendBasis, this.thresholdPercent});

  $ThresholdRule.fromJson(core.Map json_)
    : this(
        spendBasis: json_['spendBasis'] as core.String?,
        thresholdPercent: (json_['thresholdPercent'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (spendBasis != null) 'spendBasis': spendBasis!,
    if (thresholdPercent != null) 'thresholdPercent': thresholdPercent!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : Tier
/// - sqladmin:v1beta4 : Tier
class $Tier {
  /// The maximum disk size of this tier in bytes.
  core.String? DiskQuota;

  /// The maximum RAM usage of this tier in bytes.
  core.String? RAM;

  /// This is always `sql#tier`.
  core.String? kind;

  /// The applicable regions for this tier.
  core.List<core.String>? region;

  /// An identifier for the machine type, for example, `db-custom-1-3840`.
  ///
  /// For related information, see \[Pricing\](/sql/pricing).
  core.String? tier;

  $Tier({this.DiskQuota, this.RAM, this.kind, this.region, this.tier});

  $Tier.fromJson(core.Map json_)
    : this(
        DiskQuota: json_['DiskQuota'] as core.String?,
        RAM: json_['RAM'] as core.String?,
        kind: json_['kind'] as core.String?,
        region:
            (json_['region'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        tier: json_['tier'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (DiskQuota != null) 'DiskQuota': DiskQuota!,
    if (RAM != null) 'RAM': RAM!,
    if (kind != null) 'kind': kind!,
    if (region != null) 'region': region!,
    if (tier != null) 'tier': tier!,
  };
}

/// Used by:
///
/// - netapp:v1 : TieringPolicy
/// - netapp:v1beta1 : TieringPolicy
class $TieringPolicy {
  /// Time in days to mark the volume's data block as cold and make it eligible
  /// for tiering, can be range from 2-183.
  ///
  /// Default is 31.
  ///
  /// Optional.
  core.int? coolingThresholdDays;

  /// Flag indicating that the hot tier bypass mode is enabled.
  ///
  /// Default is false. This is only applicable to Flex service level.
  ///
  /// Optional.
  core.bool? hotTierBypassModeEnabled;

  /// Flag indicating if the volume has tiering policy enable/pause.
  ///
  /// Default is PAUSED.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TIER_ACTION_UNSPECIFIED" : Unspecified.
  /// - "ENABLED" : When tiering is enabled, new cold data will be tiered.
  /// - "PAUSED" : When paused, tiering won't be performed on new data. Existing
  /// data stays tiered until accessed.
  core.String? tierAction;

  $TieringPolicy({
    this.coolingThresholdDays,
    this.hotTierBypassModeEnabled,
    this.tierAction,
  });

  $TieringPolicy.fromJson(core.Map json_)
    : this(
        coolingThresholdDays: json_['coolingThresholdDays'] as core.int?,
        hotTierBypassModeEnabled:
            json_['hotTierBypassModeEnabled'] as core.bool?,
        tierAction: json_['tierAction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (coolingThresholdDays != null)
      'coolingThresholdDays': coolingThresholdDays!,
    if (hotTierBypassModeEnabled != null)
      'hotTierBypassModeEnabled': hotTierBypassModeEnabled!,
    if (tierAction != null) 'tierAction': tierAction!,
  };
}

/// Used by:
///
/// - alloydb:v1 : TimeBasedRetention
/// - alloydb:v1alpha : TimeBasedRetention
/// - alloydb:v1beta : TimeBasedRetention
class $TimeBasedRetention {
  /// The retention period.
  core.String? retentionPeriod;

  $TimeBasedRetention({this.retentionPeriod});

  $TimeBasedRetention.fromJson(core.Map json_)
    : this(retentionPeriod: json_['retentionPeriod'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (retentionPeriod != null) 'retentionPeriod': retentionPeriod!,
  };
}

/// Used by:
///
/// - discoveryengine:v1alpha : GoogleMonitoringV3TimeInterval
/// - discoveryengine:v1beta : GoogleMonitoringV3TimeInterval
/// - monitoring:v3 : TimeInterval
class $TimeInterval {
  /// The end of the time interval.
  ///
  /// Required.
  core.String? endTime;

  /// The beginning of the time interval.
  ///
  /// The default value for the start time is the end time. The start time must
  /// not be later than the end time.
  ///
  /// Optional.
  core.String? startTime;

  $TimeInterval({this.endTime, this.startTime});

  $TimeInterval.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - adexchangebuyer2:v2beta1 : TimeOfDay
/// - alloydb:v1 : GoogleTypeTimeOfDay
/// - alloydb:v1alpha : GoogleTypeTimeOfDay
/// - alloydb:v1beta : GoogleTypeTimeOfDay
/// - authorizedbuyersmarketplace:v1 : TimeOfDay
/// - authorizedbuyersmarketplace:v1alpha : TimeOfDay
/// - businessprofileperformance:v1 : TimeOfDay
/// - classroom:v1 : TimeOfDay
/// - clouddeploy:v1 : TimeOfDay
/// - contactcenteraiplatform:v1alpha1 : TimeOfDay
/// - dlp:v2 : GoogleTypeTimeOfDay
/// - gkebackup:v1 : TimeOfDay
/// - jobs:v3 : TimeOfDay
/// - jobs:v3p1beta1 : TimeOfDay
/// - jobs:v4 : TimeOfDay
/// - looker:v1 : TimeOfDay
/// - memcache:v1 : TimeOfDay
/// - memcache:v1beta2 : TimeOfDay
/// - merchantapi:datasources_v1beta : TimeOfDay
/// - monitoring:v3 : TimeOfDay
/// - mybusinessbusinessinformation:v1 : TimeOfDay
/// - mybusinesslodging:v1 : TimeOfDay
/// - oracledatabase:v1 : TimeOfDay
/// - osconfig:v1 : TimeOfDay
/// - osconfig:v1beta : TimeOfDay
/// - redis:v1 : TimeOfDay
/// - redis:v1beta1 : TimeOfDay
/// - sheets:v4 : TimeOfDay
/// - storagetransfer:v1 : TimeOfDay
/// - vmwareengine:v1 : TimeOfDay
class $TimeOfDay {
  /// Hours of a day in 24 hour format.
  ///
  /// Must be greater than or equal to 0 and typically must be less than or
  /// equal to 23. An API may choose to allow the value "24:00:00" for scenarios
  /// like business closing time.
  core.int? hours;

  /// Minutes of an hour.
  ///
  /// Must be greater than or equal to 0 and less than or equal to 59.
  core.int? minutes;

  /// Fractions of seconds, in nanoseconds.
  ///
  /// Must be greater than or equal to 0 and less than or equal to 999,999,999.
  core.int? nanos;

  /// Seconds of a minute.
  ///
  /// Must be greater than or equal to 0 and typically must be less than or
  /// equal to 59. An API may allow the value 60 if it allows leap-seconds.
  core.int? seconds;

  $TimeOfDay({this.hours, this.minutes, this.nanos, this.seconds});

  $TimeOfDay.fromJson(core.Map json_)
    : this(
        hours: json_['hours'] as core.int?,
        minutes: json_['minutes'] as core.int?,
        nanos: json_['nanos'] as core.int?,
        seconds: json_['seconds'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hours != null) 'hours': hours!,
    if (minutes != null) 'minutes': minutes!,
    if (nanos != null) 'nanos': nanos!,
    if (seconds != null) 'seconds': seconds!,
  };
}

/// Used by:
///
/// - healthcare:v1 : TimePartitioning
/// - healthcare:v1beta1 : TimePartitioning
class $TimePartitioning {
  /// Number of milliseconds for which to keep the storage for a partition.
  core.String? expirationMs;

  /// Type of partitioning.
  /// Possible string values are:
  /// - "PARTITION_TYPE_UNSPECIFIED" : Default unknown time.
  /// - "HOUR" : Data partitioned by hour.
  /// - "DAY" : Data partitioned by day.
  /// - "MONTH" : Data partitioned by month.
  /// - "YEAR" : Data partitioned by year.
  core.String? type;

  $TimePartitioning({this.expirationMs, this.type});

  $TimePartitioning.fromJson(core.Map json_)
    : this(
        expirationMs: json_['expirationMs'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expirationMs != null) 'expirationMs': expirationMs!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : TimeRange
/// - displayvideo:v3 : TimeRange
/// - displayvideo:v4 : TimeRange
class $TimeRange00 {
  /// The upper bound of a time range, inclusive.
  ///
  /// Required.
  core.String? endTime;

  /// The lower bound of a time range, inclusive.
  ///
  /// Required.
  core.String? startTime;

  $TimeRange00({this.endTime, this.startTime});

  $TimeRange00.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - healthcare:v1 : TimeRange
/// - healthcare:v1beta1 : TimeRange
class $TimeRange01 {
  /// The latest consent change time, in format YYYY-MM-DDThh:mm:ss.sss+zz:zz If
  /// not specified, the system uses the time when ApplyConsents was called.
  ///
  /// Optional.
  core.String? end;

  /// The earliest consent change time, in format YYYY-MM-DDThh:mm:ss.sss+zz:zz
  /// If not specified, the system uses the FHIR store creation time.
  ///
  /// Optional.
  core.String? start;

  $TimeRange01({this.end, this.start});

  $TimeRange01.fromJson(core.Map json_)
    : this(
        end: json_['end'] as core.String?,
        start: json_['start'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (end != null) 'end': end!,
    if (start != null) 'start': start!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : TimeWindow
/// - cloudasset:v1beta1 : TimeWindow
class $TimeWindow00 {
  /// End time of the time window (inclusive).
  ///
  /// If not specified, the current timestamp is used instead.
  core.String? endTime;

  /// Start time of the time window (exclusive).
  core.String? startTime;

  $TimeWindow00({this.endTime, this.startTime});

  $TimeWindow00.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - datafusion:v1 : TimeWindow
/// - datafusion:v1beta1 : TimeWindow
class $TimeWindow01 {
  /// The end time of the time window provided in
  /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
  ///
  /// The end time should take place after the start time. Example:
  /// "2024-01-02T12:04:06-06:00"
  ///
  /// Required.
  core.String? endTime;

  /// The start time of the time window provided in
  /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
  ///
  /// Example: "2024-01-01T12:04:06-04:00"
  ///
  /// Required.
  core.String? startTime;

  $TimeWindow01({this.endTime, this.startTime});

  $TimeWindow01.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - adsense:v2 : TimeZone
/// - adsenseplatform:v1 : TimeZone
/// - adsenseplatform:v1alpha : TimeZone
/// - authorizedbuyersmarketplace:v1 : TimeZone
/// - authorizedbuyersmarketplace:v1alpha : TimeZone
/// - cloudchannel:v1 : GoogleTypeTimeZone
/// - content:v2.1 : TimeZone
/// - contentwarehouse:v1 : GoogleTypeTimeZone
/// - discoveryengine:v1alpha : GoogleTypeTimeZone
/// - documentai:v1 : GoogleTypeTimeZone
/// - documentai:v1beta3 : GoogleTypeTimeZone
/// - localservices:v1 : GoogleTypeTimeZone
/// - merchantapi:accounts_v1beta : TimeZone
/// - merchantapi:ordertracking_v1beta : TimeZone
/// - migrationcenter:v1alpha1 : TimeZone
/// - oracledatabase:v1 : TimeZone
/// - osconfig:v1 : TimeZone
/// - osconfig:v1beta : TimeZone
/// - places:v1 : GoogleTypeTimeZone
/// - playdeveloperreporting:v1alpha1 : GoogleTypeTimeZone
/// - playdeveloperreporting:v1beta1 : GoogleTypeTimeZone
class $TimeZone {
  /// IANA Time Zone Database time zone.
  ///
  /// For example "America/New_York".
  core.String? id;

  /// IANA Time Zone Database version number.
  ///
  /// For example "2019a".
  ///
  /// Optional.
  core.String? version;

  $TimeZone({this.id, this.version});

  $TimeZone.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : TimerEvent
/// - displayvideo:v3 : TimerEvent
/// - displayvideo:v4 : TimerEvent
class $TimerEvent {
  /// The name of the timer event.
  ///
  /// Required.
  core.String? name;

  /// The name used to identify this timer event in reports.
  ///
  /// Required.
  core.String? reportingName;

  $TimerEvent({this.name, this.reportingName});

  $TimerEvent.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        reportingName: json_['reportingName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (reportingName != null) 'reportingName': reportingName!,
  };
}

/// Used by:
///
/// - jobs:v3 : TimestampRange
/// - jobs:v3p1beta1 : TimestampRange
class $TimestampRange {
  /// End of the period.
  core.String? endTime;

  /// Begin of the period.
  core.String? startTime;

  $TimestampRange({this.endTime, this.startTime});

  $TimestampRange.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TimestampSplit
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TimestampSplit
class $TimestampSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The values of the key (the values in the column) must be in RFC 3339
  /// `date-time` format, where `time-offset` = `"Z"` (e.g.
  /// 1985-04-12T23:20:50.52Z). If for a piece of data the key is not present or
  /// has an invalid value, that piece is ignored by the pipeline.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  $TimestampSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  $TimestampSplit.fromJson(core.Map json_)
    : this(
        key: json_['key'] as core.String?,
        testFraction: (json_['testFraction'] as core.num?)?.toDouble(),
        trainingFraction: (json_['trainingFraction'] as core.num?)?.toDouble(),
        validationFraction:
            (json_['validationFraction'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (key != null) 'key': key!,
    if (testFraction != null) 'testFraction': testFraction!,
    if (trainingFraction != null) 'trainingFraction': trainingFraction!,
    if (validationFraction != null) 'validationFraction': validationFraction!,
  };
}

/// Used by:
///
/// - redis:v1 : TlsCertificate
/// - redis:v1beta1 : TlsCertificate
class $TlsCertificate {
  /// PEM representation.
  core.String? cert;

  /// The time when the certificate was created in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
  /// `2020-05-18T00:00:00.094Z`.
  ///
  /// Output only.
  core.String? createTime;

  /// The time when the certificate expires in
  /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example
  /// `2020-05-18T00:00:00.094Z`.
  ///
  /// Output only.
  core.String? expireTime;

  /// Serial number, as extracted from the certificate.
  core.String? serialNumber;

  /// Sha1 Fingerprint of the certificate.
  core.String? sha1Fingerprint;

  $TlsCertificate({
    this.cert,
    this.createTime,
    this.expireTime,
    this.serialNumber,
    this.sha1Fingerprint,
  });

  $TlsCertificate.fromJson(core.Map json_)
    : this(
        cert: json_['cert'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        expireTime: json_['expireTime'] as core.String?,
        serialNumber: json_['serialNumber'] as core.String?,
        sha1Fingerprint: json_['sha1Fingerprint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cert != null) 'cert': cert!,
    if (createTime != null) 'createTime': createTime!,
    if (expireTime != null) 'expireTime': expireTime!,
    if (serialNumber != null) 'serialNumber': serialNumber!,
    if (sha1Fingerprint != null) 'sha1Fingerprint': sha1Fingerprint!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : TlsInspectionPolicy
/// - networksecurity:v1beta1 : TlsInspectionPolicy
class $TlsInspectionPolicy {
  /// A CA pool resource used to issue interception certificates.
  ///
  /// The CA pool string has a relative resource path following the form
  /// "projects/{project}/locations/{location}/caPools/{ca_pool}".
  ///
  /// Required.
  core.String? caPool;

  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// List of custom TLS cipher suites selected.
  ///
  /// This field is valid only if the selected tls_feature_profile is CUSTOM.
  /// The compute.SslPoliciesService.ListAvailableFeatures method returns the
  /// set of features that can be specified in this list. Note that Secure Web
  /// Proxy does not yet honor this field.
  ///
  /// Optional.
  core.List<core.String>? customTlsFeatures;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// If FALSE (the default), use our default set of public CAs in addition to
  /// any CAs specified in trust_config.
  ///
  /// These public CAs are currently based on the Mozilla Root Program and are
  /// subject to change over time. If TRUE, do not accept our default set of
  /// public CAs. Only CAs specified in trust_config will be accepted. This
  /// defaults to FALSE (use public CAs in addition to trust_config) for
  /// backwards compatibility, but trusting public root CAs is *not recommended*
  /// unless the traffic in question is outbound to public web servers. When
  /// possible, prefer setting this to "false" and explicitly specifying trusted
  /// CAs and certificates in a TrustConfig. Note that Secure Web Proxy does not
  /// yet honor this field.
  ///
  /// Optional.
  core.bool? excludePublicCaSet;

  /// Minimum TLS version that the firewall should use when negotiating
  /// connections with both clients and servers.
  ///
  /// If this is not set, then the default value is to allow the broadest set of
  /// clients and servers (TLS 1.0 or higher). Setting this to more restrictive
  /// values may improve security, but may also prevent the firewall from
  /// connecting to some clients or servers. Note that Secure Web Proxy does not
  /// yet honor this field.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TLS_VERSION_UNSPECIFIED" : Indicates no TLS version was specified.
  /// - "TLS_1_0" : TLS 1.0
  /// - "TLS_1_1" : TLS 1.1
  /// - "TLS_1_2" : TLS 1.2
  /// - "TLS_1_3" : TLS 1.3
  core.String? minTlsVersion;

  /// Name of the resource.
  ///
  /// Name is of the form
  /// projects/{project}/locations/{location}/tlsInspectionPolicies/{tls_inspection_policy}
  /// tls_inspection_policy should match the
  /// pattern:(^\[a-z\](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
  ///
  /// Required.
  core.String? name;

  /// The selected Profile.
  ///
  /// If this is not set, then the default value is to allow the broadest set of
  /// clients and servers ("PROFILE_COMPATIBLE"). Setting this to more
  /// restrictive values may improve security, but may also prevent the TLS
  /// inspection proxy from connecting to some clients or servers. Note that
  /// Secure Web Proxy does not yet honor this field.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "PROFILE_UNSPECIFIED" : Indicates no profile was specified.
  /// - "PROFILE_COMPATIBLE" : Compatible profile. Allows the broadest set of
  /// clients, even those which support only out-of-date SSL features to
  /// negotiate with the TLS inspection proxy.
  /// - "PROFILE_MODERN" : Modern profile. Supports a wide set of SSL features,
  /// allowing modern clients to negotiate SSL with the TLS inspection proxy.
  /// - "PROFILE_RESTRICTED" : Restricted profile. Supports a reduced set of SSL
  /// features, intended to meet stricter compliance requirements.
  /// - "PROFILE_CUSTOM" : Custom profile. Allow only the set of allowed SSL
  /// features specified in the custom_features field of SslPolicy.
  core.String? tlsFeatureProfile;

  /// A TrustConfig resource used when making a connection to the TLS server.
  ///
  /// This is a relative resource path following the form
  /// "projects/{project}/locations/{location}/trustConfigs/{trust_config}".
  /// This is necessary to intercept TLS connections to servers with
  /// certificates signed by a private CA or self-signed certificates. Note that
  /// Secure Web Proxy does not yet honor this field.
  ///
  /// Optional.
  core.String? trustConfig;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $TlsInspectionPolicy({
    this.caPool,
    this.createTime,
    this.customTlsFeatures,
    this.description,
    this.excludePublicCaSet,
    this.minTlsVersion,
    this.name,
    this.tlsFeatureProfile,
    this.trustConfig,
    this.updateTime,
  });

  $TlsInspectionPolicy.fromJson(core.Map json_)
    : this(
        caPool: json_['caPool'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        customTlsFeatures:
            (json_['customTlsFeatures'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        description: json_['description'] as core.String?,
        excludePublicCaSet: json_['excludePublicCaSet'] as core.bool?,
        minTlsVersion: json_['minTlsVersion'] as core.String?,
        name: json_['name'] as core.String?,
        tlsFeatureProfile: json_['tlsFeatureProfile'] as core.String?,
        trustConfig: json_['trustConfig'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caPool != null) 'caPool': caPool!,
    if (createTime != null) 'createTime': createTime!,
    if (customTlsFeatures != null) 'customTlsFeatures': customTlsFeatures!,
    if (description != null) 'description': description!,
    if (excludePublicCaSet != null) 'excludePublicCaSet': excludePublicCaSet!,
    if (minTlsVersion != null) 'minTlsVersion': minTlsVersion!,
    if (name != null) 'name': name!,
    if (tlsFeatureProfile != null) 'tlsFeatureProfile': tlsFeatureProfile!,
    if (trustConfig != null) 'trustConfig': trustConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networkservices:v1 : TlsRouteRouteDestination
/// - networkservices:v1beta1 : TlsRouteRouteDestination
class $TlsRouteRouteDestination {
  /// The URL of a BackendService to route traffic to.
  ///
  /// Required.
  core.String? serviceName;

  /// Specifies the proportion of requests forwarded to the backend referenced
  /// by the service_name field.
  ///
  /// This is computed as: - weight/Sum(weights in destinations) Weights in all
  /// destinations does not need to sum up to 100.
  ///
  /// Optional.
  core.int? weight;

  $TlsRouteRouteDestination({this.serviceName, this.weight});

  $TlsRouteRouteDestination.fromJson(core.Map json_)
    : this(
        serviceName: json_['serviceName'] as core.String?,
        weight: json_['weight'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceName != null) 'serviceName': serviceName!,
    if (weight != null) 'weight': weight!,
  };
}

/// Used by:
///
/// - networkservices:v1 : TlsRouteRouteMatch
/// - networkservices:v1beta1 : TlsRouteRouteMatch
class $TlsRouteRouteMatch {
  /// ALPN (Application-Layer Protocol Negotiation) to match against.
  ///
  /// Examples: "http/1.1", "h2". At least one of sni_host and alpn is required.
  /// Up to 5 alpns across all matches can be set.
  ///
  /// Optional.
  core.List<core.String>? alpn;

  /// SNI (server name indicator) to match against.
  ///
  /// SNI will be matched against all wildcard domains, i.e. `www.example.com`
  /// will be first matched against `www.example.com`, then `*.example.com`,
  /// then `*.com.` Partial wildcards are not supported, and values like
  /// *w.example.com are invalid. At least one of sni_host and alpn is required.
  /// Up to 100 sni hosts across all matches can be set.
  ///
  /// Optional.
  core.List<core.String>? sniHost;

  $TlsRouteRouteMatch({this.alpn, this.sniHost});

  $TlsRouteRouteMatch.fromJson(core.Map json_)
    : this(
        alpn:
            (json_['alpn'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        sniHost:
            (json_['sniHost'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alpn != null) 'alpn': alpn!,
    if (sniHost != null) 'sniHost': sniHost!,
  };
}

/// Used by:
///
/// - androidenterprise:v1 : TokenPagination
/// - androidpublisher:v3 : TokenPagination
class $TokenPagination {
  /// Tokens to pass to the standard list field 'page_token'.
  ///
  /// Whenever available, tokens are preferred over manipulating start_index.
  core.String? nextPageToken;
  core.String? previousPageToken;

  $TokenPagination({this.nextPageToken, this.previousPageToken});

  $TokenPagination.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        previousPageToken: json_['previousPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (previousPageToken != null) 'previousPageToken': previousPageToken!,
  };
}

/// Used by:
///
/// - cloudbuild:v2 : FetchReadTokenResponse
/// - cloudbuild:v2 : FetchReadWriteTokenResponse
class $TokenResponse00 {
  /// Expiration timestamp.
  ///
  /// Can be empty if unknown or non-expiring.
  core.String? expirationTime;

  /// The token content.
  core.String? token;

  $TokenResponse00({this.expirationTime, this.token});

  $TokenResponse00.fromJson(core.Map json_)
    : this(
        expirationTime: json_['expirationTime'] as core.String?,
        token: json_['token'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expirationTime != null) 'expirationTime': expirationTime!,
    if (token != null) 'token': token!,
  };
}

/// Used by:
///
/// - developerconnect:v1 : FetchReadTokenResponse
/// - developerconnect:v1 : FetchReadWriteTokenResponse
class $TokenResponse01 {
  /// Expiration timestamp.
  ///
  /// Can be empty if unknown or non-expiring.
  core.String? expirationTime;

  /// The git_username to specify when making a git clone with the token.
  ///
  /// For example, for GitHub GitRepositoryLinks, this would be "x-access-token"
  core.String? gitUsername;

  /// The token content.
  core.String? token;

  $TokenResponse01({this.expirationTime, this.gitUsername, this.token});

  $TokenResponse01.fromJson(core.Map json_)
    : this(
        expirationTime: json_['expirationTime'] as core.String?,
        gitUsername: json_['gitUsername'] as core.String?,
        token: json_['token'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expirationTime != null) 'expirationTime': expirationTime!,
    if (gitUsername != null) 'gitUsername': gitUsername!,
    if (token != null) 'token': token!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TokensInfo
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TokensInfo
class $TokensInfo {
  /// Optional fields for the role from the corresponding Content.
  ///
  /// Optional.
  core.String? role;

  /// A list of token ids from the input.
  core.List<core.String>? tokenIds;

  /// A list of tokens from the input.
  core.List<core.String>? tokens;

  $TokensInfo({this.role, this.tokenIds, this.tokens});

  $TokensInfo.fromJson(core.Map json_)
    : this(
        role: json_['role'] as core.String?,
        tokenIds:
            (json_['tokenIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        tokens:
            (json_['tokens'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (role != null) 'role': role!,
    if (tokenIds != null) 'tokenIds': tokenIds!,
    if (tokens != null) 'tokens': tokens!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolAuthenticationApiKeyConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolAuthenticationApiKeyConfig
class $ToolAuthenticationApiKeyConfig {
  /// The API key.
  ///
  /// If the `secret_version_for_api_key` field is set, this field will be
  /// ignored.
  ///
  /// Optional.
  core.String? apiKey;

  /// The parameter name or the header name of the API key.
  ///
  /// E.g., If the API request is "https://example.com/act?X-Api-Key=",
  /// "X-Api-Key" would be the parameter name.
  ///
  /// Required.
  core.String? keyName;

  /// Key location in the request.
  ///
  /// Required.
  /// Possible string values are:
  /// - "REQUEST_LOCATION_UNSPECIFIED" : Default value. This value is unused.
  /// - "HEADER" : Represents the key in http header.
  /// - "QUERY_STRING" : Represents the key in query string.
  core.String? requestLocation;

  /// The name of the SecretManager secret version resource storing the API key.
  ///
  /// If this field is set, the `api_key` field will be ignored. Format:
  /// `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Optional.
  core.String? secretVersionForApiKey;

  $ToolAuthenticationApiKeyConfig({
    this.apiKey,
    this.keyName,
    this.requestLocation,
    this.secretVersionForApiKey,
  });

  $ToolAuthenticationApiKeyConfig.fromJson(core.Map json_)
    : this(
        apiKey: json_['apiKey'] as core.String?,
        keyName: json_['keyName'] as core.String?,
        requestLocation: json_['requestLocation'] as core.String?,
        secretVersionForApiKey: json_['secretVersionForApiKey'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKey != null) 'apiKey': apiKey!,
    if (keyName != null) 'keyName': keyName!,
    if (requestLocation != null) 'requestLocation': requestLocation!,
    if (secretVersionForApiKey != null)
      'secretVersionForApiKey': secretVersionForApiKey!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolAuthenticationBearerTokenConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolAuthenticationBearerTokenConfig
class $ToolAuthenticationBearerTokenConfig {
  /// The name of the SecretManager secret version resource storing the Bearer
  /// token.
  ///
  /// If this field is set, the `token` field will be ignored. Format:
  /// `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Optional.
  core.String? secretVersionForToken;

  /// The text token appended to the text `Bearer` to the request Authorization
  /// header.
  ///
  /// [Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref)
  /// can be used to pass the token dynamically, e.g.
  /// `$session.params.parameter-id`.
  ///
  /// Optional.
  core.String? token;

  $ToolAuthenticationBearerTokenConfig({
    this.secretVersionForToken,
    this.token,
  });

  $ToolAuthenticationBearerTokenConfig.fromJson(core.Map json_)
    : this(
        secretVersionForToken: json_['secretVersionForToken'] as core.String?,
        token: json_['token'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (secretVersionForToken != null)
      'secretVersionForToken': secretVersionForToken!,
    if (token != null) 'token': token!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolAuthenticationOAuthConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolAuthenticationOAuthConfig
class $ToolAuthenticationOAuthConfig {
  /// The client ID from the OAuth provider.
  ///
  /// Required.
  core.String? clientId;

  /// The client secret from the OAuth provider.
  ///
  /// If the `secret_version_for_client_secret` field is set, this field will be
  /// ignored.
  ///
  /// Optional.
  core.String? clientSecret;

  /// OAuth grant types.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OAUTH_GRANT_TYPE_UNSPECIFIED" : Default value. This value is unused.
  /// - "CLIENT_CREDENTIAL" : Represents the
  /// [client credential flow](https://oauth.net/2/grant-types/client-credentials).
  core.String? oauthGrantType;

  /// The OAuth scopes to grant.
  ///
  /// Optional.
  core.List<core.String>? scopes;

  /// The name of the SecretManager secret version resource storing the client
  /// secret.
  ///
  /// If this field is set, the `client_secret` field will be ignored. Format:
  /// `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Optional.
  core.String? secretVersionForClientSecret;

  /// The token endpoint in the OAuth provider to exchange for an access token.
  ///
  /// Required.
  core.String? tokenEndpoint;

  $ToolAuthenticationOAuthConfig({
    this.clientId,
    this.clientSecret,
    this.oauthGrantType,
    this.scopes,
    this.secretVersionForClientSecret,
    this.tokenEndpoint,
  });

  $ToolAuthenticationOAuthConfig.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        clientSecret: json_['clientSecret'] as core.String?,
        oauthGrantType: json_['oauthGrantType'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        secretVersionForClientSecret:
            json_['secretVersionForClientSecret'] as core.String?,
        tokenEndpoint: json_['tokenEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (oauthGrantType != null) 'oauthGrantType': oauthGrantType!,
    if (scopes != null) 'scopes': scopes!,
    if (secretVersionForClientSecret != null)
      'secretVersionForClientSecret': secretVersionForClientSecret!,
    if (tokenEndpoint != null) 'tokenEndpoint': tokenEndpoint!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolAuthenticationServiceAgentAuthConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolAuthenticationServiceAgentAuthConfig
class $ToolAuthenticationServiceAgentAuthConfig {
  /// Indicate the auth token type generated from the
  /// [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
  ///
  /// The generated token is sent in the Authorization header.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SERVICE_AGENT_AUTH_UNSPECIFIED" : Service agent auth type unspecified.
  /// Default to ID_TOKEN.
  /// - "ID_TOKEN" : Use
  /// [ID token](https://cloud.google.com/docs/authentication/token-types#id)
  /// generated from service agent. This can be used to access Cloud Function
  /// and Cloud Run after you grant Invoker role to
  /// `service-@gcp-sa-dialogflow.iam.gserviceaccount.com`.
  /// - "ACCESS_TOKEN" : Use
  /// [access token](https://cloud.google.com/docs/authentication/token-types#access)
  /// generated from service agent. This can be used to access other Google
  /// Cloud APIs after you grant required roles to
  /// `service-@gcp-sa-dialogflow.iam.gserviceaccount.com`.
  core.String? serviceAgentAuth;

  $ToolAuthenticationServiceAgentAuthConfig({this.serviceAgentAuth});

  $ToolAuthenticationServiceAgentAuthConfig.fromJson(core.Map json_)
    : this(serviceAgentAuth: json_['serviceAgentAuth'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceAgentAuth != null) 'serviceAgentAuth': serviceAgentAuth!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolCall
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolCall
class $ToolCall00 {
  /// Spec for tool input
  ///
  /// Optional.
  core.String? toolInput;

  /// Spec for tool name
  ///
  /// Required.
  core.String? toolName;

  $ToolCall00({this.toolInput, this.toolName});

  $ToolCall00.fromJson(core.Map json_)
    : this(
        toolInput: json_['toolInput'] as core.String?,
        toolName: json_['toolName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolInput != null) 'toolInput': toolInput!,
    if (toolName != null) 'toolName': toolName!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ToolCall
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ToolCall
class $ToolCall01 {
  /// The name of the tool's action associated with this call.
  ///
  /// Optional.
  core.String? action;

  /// Create time of the tool call.
  ///
  /// Output only.
  core.String? createTime;

  /// The action's input parameters.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? inputParameters;

  /// The tool associated with this call.
  ///
  /// Format: `projects//locations//tools/`.
  ///
  /// Optional.
  core.String? tool;

  $ToolCall01({this.action, this.createTime, this.inputParameters, this.tool});

  $ToolCall01.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        inputParameters:
            json_.containsKey('inputParameters')
                ? json_['inputParameters']
                    as core.Map<core.String, core.dynamic>
                : null,
        tool: json_['tool'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (createTime != null) 'createTime': createTime!,
    if (inputParameters != null) 'inputParameters': inputParameters!,
    if (tool != null) 'tool': tool!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolCall
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolCall
class $ToolCall02 {
  /// The name of the tool's action associated with this call.
  ///
  /// Required.
  core.String? action;

  /// The action's input parameters.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? inputParameters;

  /// The tool associated with this call.
  ///
  /// Format: `projects//locations//agents//tools/`.
  ///
  /// Required.
  core.String? tool;

  $ToolCall02({this.action, this.inputParameters, this.tool});

  $ToolCall02.fromJson(core.Map json_)
    : this(
        action: json_['action'] as core.String?,
        inputParameters:
            json_.containsKey('inputParameters')
                ? json_['inputParameters']
                    as core.Map<core.String, core.dynamic>
                : null,
        tool: json_['tool'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (action != null) 'action': action!,
    if (inputParameters != null) 'inputParameters': inputParameters!,
    if (tool != null) 'tool': tool!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ToolCallResultError
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ToolCallResultError
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolCallResultError
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolCallResultError
class $ToolCallResultError {
  /// The error message of the function.
  ///
  /// Optional.
  core.String? message;

  $ToolCallResultError({this.message});

  $ToolCallResultError.fromJson(core.Map json_)
    : this(message: json_['message'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (message != null) 'message': message!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolCallValidMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolCallValidMetricValue
class $ToolCallValidMetricValue {
  /// Tool call valid score.
  ///
  /// Output only.
  core.double? score;

  $ToolCallValidMetricValue({this.score});

  $ToolCallValidMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolFunctionTool
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolFunctionTool
class $ToolFunctionTool {
  /// The JSON schema is encapsulated in a google.protobuf.Struct to describe
  /// the input of the function.
  ///
  /// This input is a JSON object that contains the function's parameters as
  /// properties of the object.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? inputSchema;

  /// The JSON schema is encapsulated in a google.protobuf.Struct to describe
  /// the output of the function.
  ///
  /// This output is a JSON object that contains the function's parameters as
  /// properties of the object.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? outputSchema;

  $ToolFunctionTool({this.inputSchema, this.outputSchema});

  $ToolFunctionTool.fromJson(core.Map json_)
    : this(
        inputSchema:
            json_.containsKey('inputSchema')
                ? json_['inputSchema'] as core.Map<core.String, core.dynamic>
                : null,
        outputSchema:
            json_.containsKey('outputSchema')
                ? json_['outputSchema'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputSchema != null) 'inputSchema': inputSchema!,
    if (outputSchema != null) 'outputSchema': outputSchema!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolGoogleSearch
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolGoogleSearch
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1ToolGoogleSearch
class $ToolGoogleSearch {
  /// List of domains to be excluded from the search results.
  ///
  /// The default limit is 2000 domains. Example: \["amazon.com",
  /// "facebook.com"\].
  ///
  /// Optional.
  core.List<core.String>? excludeDomains;

  $ToolGoogleSearch({this.excludeDomains});

  $ToolGoogleSearch.fromJson(core.Map json_)
    : this(
        excludeDomains:
            (json_['excludeDomains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludeDomains != null) 'excludeDomains': excludeDomains!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolNameMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolNameMatchMetricValue
class $ToolNameMatchMetricValue {
  /// Tool name match score.
  ///
  /// Output only.
  core.double? score;

  $ToolNameMatchMetricValue({this.score});

  $ToolNameMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKVMatchMetricValue
class $ToolParameterKVMatchMetricValue {
  /// Tool parameter key value match score.
  ///
  /// Output only.
  core.double? score;

  $ToolParameterKVMatchMetricValue({this.score});

  $ToolParameterKVMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKVMatchSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKVMatchSpec
class $ToolParameterKVMatchSpec {
  /// Whether to use STRICT string match on parameter values.
  ///
  /// Optional.
  core.bool? useStrictStringMatch;

  $ToolParameterKVMatchSpec({this.useStrictStringMatch});

  $ToolParameterKVMatchSpec.fromJson(core.Map json_)
    : this(useStrictStringMatch: json_['useStrictStringMatch'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (useStrictStringMatch != null)
      'useStrictStringMatch': useStrictStringMatch!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1ToolParameterKeyMatchMetricValue
class $ToolParameterKeyMatchMetricValue {
  /// Tool parameter key match score.
  ///
  /// Output only.
  core.double? score;

  $ToolParameterKeyMatchMetricValue({this.score});

  $ToolParameterKeyMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolServiceDirectoryConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolServiceDirectoryConfig
class $ToolServiceDirectoryConfig {
  /// The name of
  /// [Service Directory](https://cloud.google.com/service-directory) service.
  ///
  /// Format: `projects//locations//namespaces//services/`. `LocationID` of the
  /// service directory must be the same as the location of the agent.
  ///
  /// Required.
  core.String? service;

  $ToolServiceDirectoryConfig({this.service});

  $ToolServiceDirectoryConfig.fromJson(core.Map json_)
    : this(service: json_['service'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3ToolTLSConfigCACert
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1ToolTLSConfigCACert
class $ToolTLSConfigCACert {
  /// The allowed custom CA certificates (in DER format) for HTTPS verification.
  ///
  /// This overrides the default SSL trust store. If this is empty or
  /// unspecified, Dialogflow will use Google's default trust store to verify
  /// certificates. N.B. Make sure the HTTPS server certificates are signed with
  /// "subject alt name". For instance a certificate can be self-signed using
  /// the following command: ``` openssl x509 -req -days 200 -in example.com.csr
  /// \ -signkey example.com.key \ -out example.com.crt \ -extfile <(printf
  /// "\nsubjectAltName='DNS:www.example.com'") ```
  ///
  /// Required.
  core.String? cert;
  core.List<core.int> get certAsBytes => convert.base64.decode(cert!);

  set certAsBytes(core.List<core.int> bytes_) {
    cert = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// The name of the allowed custom CA certificates.
  ///
  /// This can be used to disambiguate the custom CA certificates.
  ///
  /// Required.
  core.String? displayName;

  $ToolTLSConfigCACert({this.cert, this.displayName});

  $ToolTLSConfigCACert.fromJson(core.Map json_)
    : this(
        cert: json_['cert'] as core.String?,
        displayName: json_['displayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cert != null) 'cert': cert!,
    if (displayName != null) 'displayName': displayName!,
  };
}

/// Used by:
///
/// - container:v1 : TopologyManager
/// - container:v1beta1 : TopologyManager
class $TopologyManager {
  /// Configures the strategy for resource alignment.
  ///
  /// Allowed values are: * none: the default policy, and does not perform any
  /// topology alignment. * restricted: the topology manager stores the
  /// preferred NUMA node affinity for the container, and will reject the pod if
  /// the affinity if not preferred. * best-effort: the topology manager stores
  /// the preferred NUMA node affinity for the container. If the affinity is not
  /// preferred, the topology manager will admit the pod to the node anyway. *
  /// single-numa-node: the topology manager determines if the single NUMA node
  /// affinity is possible. If it is, Topology Manager will store this and the
  /// Hint Providers can then use this information when making the resource
  /// allocation decision. If, however, this is not possible then the Topology
  /// Manager will reject the pod from the node. This will result in a pod in a
  /// Terminated state with a pod admission failure. The default policy value is
  /// 'none' if unspecified. Details about each strategy can be found
  /// [here](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/#topology-manager-policies).
  core.String? policy;

  /// The Topology Manager aligns resources in following scopes: * container *
  /// pod The default scope is 'container' if unspecified.
  ///
  /// See
  /// https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/#topology-manager-scopes
  core.String? scope;

  $TopologyManager({this.policy, this.scope});

  $TopologyManager.fromJson(core.Map json_)
    : this(
        policy: json_['policy'] as core.String?,
        scope: json_['scope'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (policy != null) 'policy': policy!,
    if (scope != null) 'scope': scope!,
  };
}

/// Used by:
///
/// - apigee:v1 : GoogleCloudApigeeV1RuntimeTraceSamplingConfig
/// - apigee:v1 : GoogleCloudApigeeV1TraceSamplingConfig
class $TraceSamplingConfig {
  /// Sampler of distributed tracing.
  ///
  /// OFF is the default value.
  /// Possible string values are:
  /// - "SAMPLER_UNSPECIFIED" : Sampler unspecified.
  /// - "OFF" : OFF means distributed trace is disabled, or the sampling
  /// probability is 0.
  /// - "PROBABILITY" : PROBABILITY means traces are captured on a probability
  /// that defined by sampling_rate. The sampling rate is limited to 0 to 0.5
  /// when this is set.
  core.String? sampler;

  /// Field sampling rate.
  ///
  /// This value is only applicable when using the PROBABILITY sampler. The
  /// supported values are \> 0 and \<= 0.5.
  core.double? samplingRate;

  $TraceSamplingConfig({this.sampler, this.samplingRate});

  $TraceSamplingConfig.fromJson(core.Map json_)
    : this(
        sampler: json_['sampler'] as core.String?,
        samplingRate: (json_['samplingRate'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sampler != null) 'sampler': sampler!,
    if (samplingRate != null) 'samplingRate': samplingRate!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : TrackingFloodlightActivityConfig
/// - displayvideo:v3 : TrackingFloodlightActivityConfig
/// - displayvideo:v4 : TrackingFloodlightActivityConfig
class $TrackingFloodlightActivityConfig {
  /// The ID of the Floodlight activity.
  ///
  /// Required.
  core.String? floodlightActivityId;

  /// The number of days after an ad has been clicked in which a conversion may
  /// be counted.
  ///
  /// Must be between 0 and 90 inclusive.
  ///
  /// Required.
  core.int? postClickLookbackWindowDays;

  /// The number of days after an ad has been viewed in which a conversion may
  /// be counted.
  ///
  /// Must be between 0 and 90 inclusive.
  ///
  /// Required.
  core.int? postViewLookbackWindowDays;

  $TrackingFloodlightActivityConfig({
    this.floodlightActivityId,
    this.postClickLookbackWindowDays,
    this.postViewLookbackWindowDays,
  });

  $TrackingFloodlightActivityConfig.fromJson(core.Map json_)
    : this(
        floodlightActivityId: json_['floodlightActivityId'] as core.String?,
        postClickLookbackWindowDays:
            json_['postClickLookbackWindowDays'] as core.int?,
        postViewLookbackWindowDays:
            json_['postViewLookbackWindowDays'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (floodlightActivityId != null)
      'floodlightActivityId': floodlightActivityId!,
    if (postClickLookbackWindowDays != null)
      'postClickLookbackWindowDays': postClickLookbackWindowDays!,
    if (postViewLookbackWindowDays != null)
      'postViewLookbackWindowDays': postViewLookbackWindowDays!,
  };
}

/// Used by:
///
/// - networkservices:v1 : TrafficPortSelector
/// - networkservices:v1beta1 : TrafficPortSelector
class $TrafficPortSelector {
  /// A list of ports.
  ///
  /// Can be port numbers or port range (example, \[80-90\] specifies all ports
  /// from 80 to 90, including 80 and 90) or named ports or * to specify all
  /// ports. If the list is empty, all ports are selected.
  ///
  /// Optional.
  core.List<core.String>? ports;

  $TrafficPortSelector({this.ports});

  $TrafficPortSelector.fromJson(core.Map json_)
    : this(
        ports:
            (json_['ports'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ports != null) 'ports': ports!,
  };
}

/// Used by:
///
/// - connectors:v1 : TrafficShapingConfig
/// - integrations:v1 : GoogleCloudConnectorsV1TrafficShapingConfig
class $TrafficShapingConfig {
  /// * The duration over which the API call quota limits are calculated.
  ///
  /// This duration is used to define the time window for evaluating if the
  /// number of API calls made by a user is within the allowed quota limits. For
  /// example: - To define a quota sampled over 16 seconds, set `seconds` to 16
  /// - To define a quota sampled over 5 minutes, set `seconds` to 300 (5 * 60)
  /// - To define a quota sampled over 1 day, set `seconds` to 86400 (24 * 60 *
  /// 60) and so on. It is important to note that this duration is not the time
  /// the quota is valid for, but rather the time window over which the quota is
  /// evaluated. For example, if the quota is 100 calls per 10 seconds, then
  /// this duration field would be set to 10 seconds.
  ///
  /// Required.
  core.String? duration;

  /// Maximum number of api calls allowed.
  ///
  /// Required.
  core.String? quotaLimit;

  $TrafficShapingConfig({this.duration, this.quotaLimit});

  $TrafficShapingConfig.fromJson(core.Map json_)
    : this(
        duration: json_['duration'] as core.String?,
        quotaLimit: json_['quotaLimit'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (duration != null) 'duration': duration!,
    if (quotaLimit != null) 'quotaLimit': quotaLimit!,
  };
}

/// Used by:
///
/// - appengine:v1 : TrafficSplit
/// - appengine:v1beta : TrafficSplit
class $TrafficSplit00 {
  /// Mapping from version IDs within the service to fractional (0.000, 1\]
  /// allocations of traffic for that version.
  ///
  /// Each version can be specified only once, but some versions in the service
  /// may not have any traffic allocation. Services that have traffic allocated
  /// cannot be deleted until either the service is deleted or their traffic
  /// allocation is removed. Allocations must sum to 1. Up to two decimal place
  /// precision is supported for IP-based splits and up to three decimal places
  /// is supported for cookie-based splits.
  core.Map<core.String, core.double>? allocations;

  /// Mechanism used to determine which version a request is sent to.
  ///
  /// The traffic selection algorithm will be stable for either type until
  /// allocations are changed.
  /// Possible string values are:
  /// - "UNSPECIFIED" : Diversion method unspecified.
  /// - "COOKIE" : Diversion based on a specially named cookie, "GOOGAPPUID."
  /// The cookie must be set by the application itself or no diversion will
  /// occur.
  /// - "IP" : Diversion based on applying the modulus operation to a
  /// fingerprint of the IP address.
  /// - "RANDOM" : Diversion based on weighted random assignment. An incoming
  /// request is randomly routed to a version in the traffic split, with
  /// probability proportional to the version's traffic share.
  core.String? shardBy;

  $TrafficSplit00({this.allocations, this.shardBy});

  $TrafficSplit00.fromJson(core.Map json_)
    : this(
        allocations:
            (json_['allocations'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) =>
                  core.MapEntry(key, (value as core.num).toDouble()),
            ),
        shardBy: json_['shardBy'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allocations != null) 'allocations': allocations!,
    if (shardBy != null) 'shardBy': shardBy!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : TrafficSplit
/// - firebaseapphosting:v1beta : TrafficSplit
class $TrafficSplit01 {
  /// The build that traffic is being routed to.
  ///
  /// Required.
  core.String? build;

  /// The percentage of traffic to send to the build.
  ///
  /// Currently must be 100% or 0%.
  ///
  /// Required.
  core.int? percent;

  $TrafficSplit01({this.build, this.percent});

  $TrafficSplit01.fromJson(core.Map json_)
    : this(
        build: json_['build'] as core.String?,
        percent: json_['percent'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (build != null) 'build': build!,
    if (percent != null) 'percent': percent!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1TrainCustomModelRequestGcsTrainingInput
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequestGcsTrainingInput
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaTrainCustomModelRequestGcsTrainingInput
class $TrainCustomModelRequestGcsTrainingInput {
  /// The Cloud Storage corpus data which could be associated in train data.
  ///
  /// The data path format is `gs:///`. A newline delimited jsonl/ndjson file.
  /// For search-tuning model, each line should have the _id, title and text.
  /// Example: `{"_id": "doc1", title: "relevant doc", "text": "relevant text"}`
  core.String? corpusDataPath;

  /// The gcs query data which could be associated in train data.
  ///
  /// The data path format is `gs:///`. A newline delimited jsonl/ndjson file.
  /// For search-tuning model, each line should have the _id and text. Example:
  /// {"_id": "query1", "text": "example query"}
  core.String? queryDataPath;

  /// Cloud Storage test data.
  ///
  /// Same format as train_data_path. If not provided, a random 80/20 train/test
  /// split will be performed on train_data_path.
  core.String? testDataPath;

  /// Cloud Storage training data path whose format should be `gs:///`.
  ///
  /// The file should be in tsv format. Each line should have the doc_id and
  /// query_id and score (number). For search-tuning model, it should have the
  /// query-id corpus-id score as tsv file header. The score should be a number
  /// in `[0, inf+)`. The larger the number is, the more relevant the pair is.
  /// Example: * `query-id\tcorpus-id\tscore` * `query1\tdoc1\t1`
  core.String? trainDataPath;

  $TrainCustomModelRequestGcsTrainingInput({
    this.corpusDataPath,
    this.queryDataPath,
    this.testDataPath,
    this.trainDataPath,
  });

  $TrainCustomModelRequestGcsTrainingInput.fromJson(core.Map json_)
    : this(
        corpusDataPath: json_['corpusDataPath'] as core.String?,
        queryDataPath: json_['queryDataPath'] as core.String?,
        testDataPath: json_['testDataPath'] as core.String?,
        trainDataPath: json_['trainDataPath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (corpusDataPath != null) 'corpusDataPath': corpusDataPath!,
    if (queryDataPath != null) 'queryDataPath': queryDataPath!,
    if (testDataPath != null) 'testDataPath': testDataPath!,
    if (trainDataPath != null) 'trainDataPath': trainDataPath!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1TrainProcessorVersionRequestCustomDocumentExtractionOptions
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3TrainProcessorVersionRequestCustomDocumentExtractionOptions
class $TrainProcessorVersionRequestCustomDocumentExtractionOptions {
  /// Training method to use for CDE training.
  /// Possible string values are:
  /// - "TRAINING_METHOD_UNSPECIFIED"
  /// - "MODEL_BASED"
  /// - "TEMPLATE_BASED"
  core.String? trainingMethod;

  $TrainProcessorVersionRequestCustomDocumentExtractionOptions({
    this.trainingMethod,
  });

  $TrainProcessorVersionRequestCustomDocumentExtractionOptions.fromJson(
    core.Map json_,
  ) : this(trainingMethod: json_['trainingMethod'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (trainingMethod != null) 'trainingMethod': trainingMethod!,
  };
}

/// Used by:
///
/// - documentai:v1 : GoogleCloudDocumentaiV1TrainProcessorVersionRequestFoundationModelTuningOptions
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3TrainProcessorVersionRequestFoundationModelTuningOptions
class $TrainProcessorVersionRequestFoundationModelTuningOptions {
  /// The multiplier to apply to the recommended learning rate.
  ///
  /// Valid values are between 0.1 and 10. If not provided, recommended learning
  /// rate will be used.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  /// The number of steps to run for model tuning.
  ///
  /// Valid values are between 1 and 400. If not provided, recommended steps
  /// will be used.
  ///
  /// Optional.
  core.int? trainSteps;

  $TrainProcessorVersionRequestFoundationModelTuningOptions({
    this.learningRateMultiplier,
    this.trainSteps,
  });

  $TrainProcessorVersionRequestFoundationModelTuningOptions.fromJson(
    core.Map json_,
  ) : this(
        learningRateMultiplier:
            (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
        trainSteps: json_['trainSteps'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (learningRateMultiplier != null)
      'learningRateMultiplier': learningRateMultiplier!,
    if (trainSteps != null) 'trainSteps': trainSteps!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrainingConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrainingConfig
class $TrainingConfig {
  /// The timeout hours for the CMLE training job, expressed in milli hours i.e.
  /// 1,000 value in this field means 1 hour.
  core.String? timeoutTrainingMilliHours;

  $TrainingConfig({this.timeoutTrainingMilliHours});

  $TrainingConfig.fromJson(core.Map json_)
    : this(
        timeoutTrainingMilliHours:
            json_['timeoutTrainingMilliHours'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeoutTrainingMilliHours != null)
      'timeoutTrainingMilliHours': timeoutTrainingMilliHours!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchMetricValue
class $TrajectoryAnyOrderMatchMetricValue {
  /// TrajectoryAnyOrderMatch score.
  ///
  /// Output only.
  core.double? score;

  $TrajectoryAnyOrderMatchMetricValue({this.score});

  $TrajectoryAnyOrderMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryExactMatchMetricValue
class $TrajectoryExactMatchMetricValue {
  /// TrajectoryExactMatch score.
  ///
  /// Output only.
  core.double? score;

  $TrajectoryExactMatchMetricValue({this.score});

  $TrajectoryExactMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchMetricValue
class $TrajectoryInOrderMatchMetricValue {
  /// TrajectoryInOrderMatch score.
  ///
  /// Output only.
  core.double? score;

  $TrajectoryInOrderMatchMetricValue({this.score});

  $TrajectoryInOrderMatchMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryPrecisionMetricValue
class $TrajectoryPrecisionMetricValue {
  /// TrajectoryPrecision score.
  ///
  /// Output only.
  core.double? score;

  $TrajectoryPrecisionMetricValue({this.score});

  $TrajectoryPrecisionMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectoryRecallMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectoryRecallMetricValue
class $TrajectoryRecallMetricValue {
  /// TrajectoryRecall score.
  ///
  /// Output only.
  core.double? score;

  $TrajectoryRecallMetricValue({this.score});

  $TrajectoryRecallMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectorySingleToolUseMetricValue
class $TrajectorySingleToolUseMetricValue {
  /// TrajectorySingleToolUse score.
  ///
  /// Output only.
  core.double? score;

  $TrajectorySingleToolUseMetricValue({this.score});

  $TrajectorySingleToolUseMetricValue.fromJson(core.Map json_)
    : this(score: (json_['score'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrajectorySingleToolUseSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrajectorySingleToolUseSpec
class $TrajectorySingleToolUseSpec {
  /// Spec for tool name to be checked for in the predicted trajectory.
  ///
  /// Required.
  core.String? toolName;

  $TrajectorySingleToolUseSpec({this.toolName});

  $TrajectorySingleToolUseSpec.fromJson(core.Map json_)
    : this(toolName: json_['toolName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolName != null) 'toolName': toolName!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1TransactionInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaTransactionInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaTransactionInfo
class $TransactionInfo {
  /// All the costs associated with the products.
  ///
  /// These can be manufacturing costs, shipping expenses not borne by the end
  /// user, or any other costs, such that: * Profit = value - tax - cost
  core.double? cost;

  /// Currency code.
  ///
  /// Use three-character ISO-4217 code.
  ///
  /// Required.
  core.String? currency;

  /// The total discount(s) value applied to this transaction.
  ///
  /// This figure should be excluded from TransactionInfo.value For example, if
  /// a user paid TransactionInfo.value amount, then nominal (pre-discount)
  /// value of the transaction is the sum of TransactionInfo.value and
  /// TransactionInfo.discount_value This means that profit is calculated the
  /// same way, regardless of the discount value, and that
  /// TransactionInfo.discount_value can be larger than TransactionInfo.value: *
  /// Profit = value - tax - cost
  core.double? discountValue;

  /// All the taxes associated with the transaction.
  core.double? tax;

  /// The transaction ID with a length limit of 128 characters.
  core.String? transactionId;

  /// Total non-zero value associated with the transaction.
  ///
  /// This value may include shipping, tax, or other adjustments to the total
  /// value that you want to include.
  ///
  /// Required.
  core.double? value;

  $TransactionInfo({
    this.cost,
    this.currency,
    this.discountValue,
    this.tax,
    this.transactionId,
    this.value,
  });

  $TransactionInfo.fromJson(core.Map json_)
    : this(
        cost: (json_['cost'] as core.num?)?.toDouble(),
        currency: json_['currency'] as core.String?,
        discountValue: (json_['discountValue'] as core.num?)?.toDouble(),
        tax: (json_['tax'] as core.num?)?.toDouble(),
        transactionId: json_['transactionId'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cost != null) 'cost': cost!,
    if (currency != null) 'currency': currency!,
    if (discountValue != null) 'discountValue': discountValue!,
    if (tax != null) 'tax': tax!,
    if (transactionId != null) 'transactionId': transactionId!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - speech:v1 : TranscriptOutputConfig
/// - speech:v1p1beta1 : TranscriptOutputConfig
class $TranscriptOutputConfig {
  /// Specifies a Cloud Storage URI for the recognition results.
  ///
  /// Must be specified in the format: `gs://bucket_name/object_name`, and the
  /// bucket must already exist.
  core.String? gcsUri;

  $TranscriptOutputConfig({this.gcsUri});

  $TranscriptOutputConfig.fromJson(core.Map json_)
    : this(gcsUri: json_['gcsUri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsUri != null) 'gcsUri': gcsUri!,
  };
}

/// Used by:
///
/// - parallelstore:v1 : TransferMetadataOptions
/// - parallelstore:v1beta : TransferMetadataOptions
class $TransferMetadataOptions {
  /// The GID preservation behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "GID_UNSPECIFIED" : default is GID_NUMBER_PRESERVE.
  /// - "GID_SKIP" : Do not preserve GID during a transfer job.
  /// - "GID_NUMBER_PRESERVE" : Preserve GID that is in number format during a
  /// transfer job.
  core.String? gid;

  /// The mode preservation behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : default is MODE_PRESERVE.
  /// - "MODE_SKIP" : Do not preserve mode during a transfer job.
  /// - "MODE_PRESERVE" : Preserve mode during a transfer job.
  core.String? mode;

  /// The UID preservation behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "UID_UNSPECIFIED" : default is UID_NUMBER_PRESERVE.
  /// - "UID_SKIP" : Do not preserve UID during a transfer job.
  /// - "UID_NUMBER_PRESERVE" : Preserve UID that is in number format during a
  /// transfer job.
  core.String? uid;

  $TransferMetadataOptions({this.gid, this.mode, this.uid});

  $TransferMetadataOptions.fromJson(core.Map json_)
    : this(
        gid: json_['gid'] as core.String?,
        mode: json_['mode'] as core.String?,
        uid: json_['uid'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gid != null) 'gid': gid!,
    if (mode != null) 'mode': mode!,
    if (uid != null) 'uid': uid!,
  };
}

/// Used by:
///
/// - netapp:v1 : TransferStats
/// - netapp:v1beta1 : TransferStats
class $TransferStats {
  /// Lag duration indicates the duration by which Destination region volume
  /// content lags behind the primary region volume content.
  core.String? lagDuration;

  /// Last transfer size in bytes.
  core.String? lastTransferBytes;

  /// Time taken during last transfer.
  core.String? lastTransferDuration;

  /// Time when last transfer completed.
  core.String? lastTransferEndTime;

  /// A message describing the cause of the last transfer failure.
  core.String? lastTransferError;

  /// Cumulative time taken across all transfers for the replication
  /// relationship.
  core.String? totalTransferDuration;

  /// Cumulative bytes transferred so far for the replication relationship.
  core.String? transferBytes;

  /// Time when progress was updated last.
  core.String? updateTime;

  $TransferStats({
    this.lagDuration,
    this.lastTransferBytes,
    this.lastTransferDuration,
    this.lastTransferEndTime,
    this.lastTransferError,
    this.totalTransferDuration,
    this.transferBytes,
    this.updateTime,
  });

  $TransferStats.fromJson(core.Map json_)
    : this(
        lagDuration: json_['lagDuration'] as core.String?,
        lastTransferBytes: json_['lastTransferBytes'] as core.String?,
        lastTransferDuration: json_['lastTransferDuration'] as core.String?,
        lastTransferEndTime: json_['lastTransferEndTime'] as core.String?,
        lastTransferError: json_['lastTransferError'] as core.String?,
        totalTransferDuration: json_['totalTransferDuration'] as core.String?,
        transferBytes: json_['transferBytes'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lagDuration != null) 'lagDuration': lagDuration!,
    if (lastTransferBytes != null) 'lastTransferBytes': lastTransferBytes!,
    if (lastTransferDuration != null)
      'lastTransferDuration': lastTransferDuration!,
    if (lastTransferEndTime != null)
      'lastTransferEndTime': lastTransferEndTime!,
    if (lastTransferError != null) 'lastTransferError': lastTransferError!,
    if (totalTransferDuration != null)
      'totalTransferDuration': totalTransferDuration!,
    if (transferBytes != null) 'transferBytes': transferBytes!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : TransitiveMembershipRole
/// - cloudidentity:v1beta1 : TransitiveMembershipRole
class $TransitiveMembershipRole {
  /// TransitiveMembershipRole in string format.
  ///
  /// Currently supported TransitiveMembershipRoles: `"MEMBER"`, `"OWNER"`, and
  /// `"MANAGER"`.
  core.String? role;

  $TransitiveMembershipRole({this.role});

  $TransitiveMembershipRole.fromJson(core.Map json_)
    : this(role: json_['role'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (role != null) 'role': role!,
  };
}

/// Used by:
///
/// - alloydb:v1 : TrialMetadata
/// - alloydb:v1alpha : TrialMetadata
/// - alloydb:v1beta : TrialMetadata
class $TrialMetadata {
  /// End time of the trial cluster.
  core.String? endTime;

  /// grace end time of the cluster.
  core.String? graceEndTime;

  /// start time of the trial cluster.
  core.String? startTime;

  /// Upgrade time of trial cluster to Standard cluster.
  core.String? upgradeTime;

  $TrialMetadata({
    this.endTime,
    this.graceEndTime,
    this.startTime,
    this.upgradeTime,
  });

  $TrialMetadata.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        graceEndTime: json_['graceEndTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        upgradeTime: json_['upgradeTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (graceEndTime != null) 'graceEndTime': graceEndTime!,
    if (startTime != null) 'startTime': startTime!,
    if (upgradeTime != null) 'upgradeTime': upgradeTime!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TrialParameter
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TrialParameter
class $TrialParameter {
  /// The ID of the parameter.
  ///
  /// The parameter should be defined in StudySpec's Parameters.
  ///
  /// Output only.
  core.String? parameterId;

  /// The value of the parameter.
  ///
  /// `number_value` will be set if a parameter defined in StudySpec is in type
  /// 'INTEGER', 'DOUBLE' or 'DISCRETE'. `string_value` will be set if a
  /// parameter defined in StudySpec is in type 'CATEGORICAL'.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? value;

  $TrialParameter({this.parameterId, this.value});

  $TrialParameter.fromJson(core.Map json_)
    : this(
        parameterId: json_['parameterId'] as core.String?,
        value: json_['value'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parameterId != null) 'parameterId': parameterId!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - integrations:v1 : EnterpriseCrmFrontendsEventbusProtoTriggerConfigVariables
/// - integrations:v1 : GoogleCloudIntegrationsV1alphaTriggerConfigVariables
class $TriggerConfigVariables {
  /// List of variable names.
  ///
  /// Optional.
  core.List<core.String>? names;

  $TriggerConfigVariables({this.names});

  $TriggerConfigVariables.fromJson(core.Map json_)
    : this(
        names:
            (json_['names'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (names != null) 'names': names!,
  };
}

/// Used by:
///
/// - composer:v1 : TriggererResource
/// - composer:v1beta1 : TriggererResource
class $TriggererResource {
  /// The number of triggerers.
  ///
  /// Optional.
  core.int? count;

  /// CPU request and limit for a single Airflow triggerer replica.
  ///
  /// Optional.
  core.double? cpu;

  /// Memory (GB) request and limit for a single Airflow triggerer replica.
  ///
  /// Optional.
  core.double? memoryGb;

  $TriggererResource({this.count, this.cpu, this.memoryGb});

  $TriggererResource.fromJson(core.Map json_)
    : this(
        count: json_['count'] as core.int?,
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        memoryGb: (json_['memoryGb'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (cpu != null) 'cpu': cpu!,
    if (memoryGb != null) 'memoryGb': memoryGb!,
  };
}

/// Used by:
///
/// - cloudtrace:v2 : TruncatableString
/// - servicecontrol:v1 : TruncatableString
class $TruncatableString {
  /// The number of bytes removed from the original string.
  ///
  /// If this value is 0, then the string was not shortened.
  core.int? truncatedByteCount;

  /// The shortened string.
  ///
  /// For example, if the original string is 500 bytes long and the limit of the
  /// string is 128 bytes, then `value` contains the first 128 bytes of the
  /// 500-byte string. Truncation always happens on a UTF8 character boundary.
  /// If there are multi-byte characters in the string, then the length of the
  /// shortened string might be less than the size limit.
  core.String? value;

  $TruncatableString({this.truncatedByteCount, this.value});

  $TruncatableString.fromJson(core.Map json_)
    : this(
        truncatedByteCount: json_['truncatedByteCount'] as core.int?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (truncatedByteCount != null) 'truncatedByteCount': truncatedByteCount!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - sqladmin:v1 : TruncateLogContext
/// - sqladmin:v1beta4 : TruncateLogContext
class $TruncateLogContext {
  /// This is always `sql#truncateLogContext`.
  core.String? kind;

  /// The type of log to truncate.
  ///
  /// Valid values are `MYSQL_GENERAL_TABLE` and `MYSQL_SLOW_TABLE`.
  core.String? logType;

  $TruncateLogContext({this.kind, this.logType});

  $TruncateLogContext.fromJson(core.Map json_)
    : this(
        kind: json_['kind'] as core.String?,
        logType: json_['logType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (kind != null) 'kind': kind!,
    if (logType != null) 'logType': logType!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TunedModelCheckpoint
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TunedModelCheckpoint
class $TunedModelCheckpoint {
  /// The ID of the checkpoint.
  core.String? checkpointId;

  /// The Endpoint resource name that the checkpoint is deployed to.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  core.String? endpoint;

  /// The epoch of the checkpoint.
  core.String? epoch;

  /// The step of the checkpoint.
  core.String? step;

  $TunedModelCheckpoint({
    this.checkpointId,
    this.endpoint,
    this.epoch,
    this.step,
  });

  $TunedModelCheckpoint.fromJson(core.Map json_)
    : this(
        checkpointId: json_['checkpointId'] as core.String?,
        endpoint: json_['endpoint'] as core.String?,
        epoch: json_['epoch'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (endpoint != null) 'endpoint': endpoint!,
    if (epoch != null) 'epoch': epoch!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1TunedModelRef
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1TunedModelRef
class $TunedModelRef {
  /// Support migration from tuning job list page, from bison model to gemini
  /// model.
  core.String? pipelineJob;

  /// Support migration from model registry.
  core.String? tunedModel;

  /// Support migration from tuning job list page, from gemini-1.0-pro-002 to
  /// 1.5 and above.
  core.String? tuningJob;

  $TunedModelRef({this.pipelineJob, this.tunedModel, this.tuningJob});

  $TunedModelRef.fromJson(core.Map json_)
    : this(
        pipelineJob: json_['pipelineJob'] as core.String?,
        tunedModel: json_['tunedModel'] as core.String?,
        tuningJob: json_['tuningJob'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pipelineJob != null) 'pipelineJob': pipelineJob!,
    if (tunedModel != null) 'tunedModel': tunedModel!,
    if (tuningJob != null) 'tuningJob': tuningJob!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : Turn
/// - texttospeech:v1beta1 : Turn
class $Turn {
  /// The speaker of the turn, for example, 'O' or 'Q'.
  ///
  /// Please refer to documentation for available speakers.
  ///
  /// Required.
  core.String? speaker;

  /// The text to speak.
  ///
  /// Required.
  core.String? text;

  $Turn({this.speaker, this.text});

  $Turn.fromJson(core.Map json_)
    : this(
        speaker: json_['speaker'] as core.String?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (speaker != null) 'speaker': speaker!,
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : TypeInfoSchemaInfo
/// - deploymentmanager:v2beta : TypeInfoSchemaInfo
class $TypeInfoSchemaInfo {
  /// The properties that this composite type or base type collection accept as
  /// input, represented as a json blob, format is: JSON Schema Draft V4
  core.String? input;

  /// The properties that this composite type or base type collection exposes as
  /// output, these properties can be used for references, represented as json
  /// blob, format is: JSON Schema Draft V4
  core.String? output;

  $TypeInfoSchemaInfo({this.input, this.output});

  $TypeInfoSchemaInfo.fromJson(core.Map json_)
    : this(
        input: json_['input'] as core.String?,
        output: json_['output'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (input != null) 'input': input!,
    if (output != null) 'output': output!,
  };
}

/// Used by:
///
/// - gkehub:v1 : TypeMeta
/// - gkehub:v1alpha : TypeMeta
/// - gkehub:v1beta : TypeMeta
/// - gkehub:v1beta1 : TypeMeta
class $TypeMeta {
  /// APIVersion of the resource (e.g. v1).
  core.String? apiVersion;

  /// Kind of the resource (e.g. Deployment).
  core.String? kind;

  $TypeMeta({this.apiVersion, this.kind});

  $TypeMeta.fromJson(core.Map json_)
    : this(
        apiVersion: json_['apiVersion'] as core.String?,
        kind: json_['kind'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiVersion != null) 'apiVersion': apiVersion!,
    if (kind != null) 'kind': kind!,
  };
}

/// Used by:
///
/// - compute:alpha : Uint128
/// - compute:beta : Uint128
/// - compute:v1 : Uint128
class $Uint128 {
  core.String? high;
  core.String? low;

  $Uint128({this.high, this.low});

  $Uint128.fromJson(core.Map json_)
    : this(
        high: json_['high'] as core.String?,
        low: json_['low'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (high != null) 'high': high!,
    if (low != null) 'low': low!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1UndeployIndexRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UndeployIndexRequest
class $UndeployIndexRequest {
  /// The ID of the DeployedIndex to be undeployed from the IndexEndpoint.
  ///
  /// Required.
  core.String? deployedIndexId;

  $UndeployIndexRequest({this.deployedIndexId});

  $UndeployIndexRequest.fromJson(core.Map json_)
    : this(deployedIndexId: json_['deployedIndexId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1UndeployModelRequest
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UndeployModelRequest
class $UndeployModelRequest {
  /// The ID of the DeployedModel to be undeployed from the Endpoint.
  ///
  /// Required.
  core.String? deployedModelId;

  /// If this field is provided, then the Endpoint's traffic_split will be
  /// overwritten with it.
  ///
  /// If last DeployedModel is being undeployed from the Endpoint, the
  /// \[Endpoint.traffic_split\] will always end up empty when this call
  /// returns. A DeployedModel will be successfully undeployed only if it
  /// doesn't have any traffic assigned to it when this method executes, or if
  /// this field unassigns any traffic to it.
  core.Map<core.String, core.int>? trafficSplit;

  $UndeployModelRequest({this.deployedModelId, this.trafficSplit});

  $UndeployModelRequest.fromJson(core.Map json_)
    : this(
        deployedModelId: json_['deployedModelId'] as core.String?,
        trafficSplit: (json_['trafficSplit']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.int)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (trafficSplit != null) 'trafficSplit': trafficSplit!,
  };
}

/// Used by:
///
/// - content:v2.1 : ProductUnitPricingBaseMeasure
/// - merchantapi:products_v1beta : UnitPricingBaseMeasure
class $UnitPricingBaseMeasure {
  /// The unit of the denominator.
  core.String? unit;

  /// The denominator of the unit price.
  core.String? value;

  $UnitPricingBaseMeasure({this.unit, this.value});

  $UnitPricingBaseMeasure.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - content:v2.1 : ProductUnitPricingMeasure
/// - merchantapi:products_v1beta : UnitPricingMeasure
class $UnitPricingMeasure {
  /// The unit of the measure.
  core.String? unit;

  /// The measure of an item.
  core.double? value;

  $UnitPricingMeasure({this.unit, this.value});

  $UnitPricingMeasure.fromJson(core.Map json_)
    : this(
        unit: json_['unit'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : UniversalAdId
/// - displayvideo:v3 : UniversalAdId
/// - displayvideo:v4 : UniversalAdId
class $UniversalAdId {
  /// The unique creative identifier.
  ///
  /// Optional.
  core.String? id;

  /// The registry provides unique creative identifiers.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "UNIVERSAL_AD_REGISTRY_UNSPECIFIED" : The Universal Ad registry is
  /// unspecified or is unknown in this version.
  /// - "UNIVERSAL_AD_REGISTRY_OTHER" : Use a custom provider to provide the
  /// Universal Ad ID.
  /// - "UNIVERSAL_AD_REGISTRY_AD_ID" : Use Ad-ID to provide the Universal Ad
  /// ID.
  /// - "UNIVERSAL_AD_REGISTRY_CLEARCAST" : Use clearcast.co.uk to provide the
  /// Universal Ad ID.
  /// - "UNIVERSAL_AD_REGISTRY_DV360" : Use Display & Video 360 to provide the
  /// Universal Ad ID.
  /// - "UNIVERSAL_AD_REGISTRY_CM" : Use Campaign Manager 360 to provide the
  /// Universal Ad ID.
  core.String? registry;

  $UniversalAdId({this.id, this.registry});

  $UniversalAdId.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        registry: json_['registry'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (registry != null) 'registry': registry!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : UniversalTwoFactor
/// - oslogin:v1beta : UniversalTwoFactor
class $UniversalTwoFactor {
  /// Application ID for the U2F protocol.
  core.String? appId;

  $UniversalTwoFactor({this.appId});

  $UniversalTwoFactor.fromJson(core.Map json_)
    : this(appId: json_['appId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (appId != null) 'appId': appId!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : UnsubscribeClientsRequest
/// - authorizedbuyersmarketplace:v1alpha : UnsubscribeClientsRequest
class $UnsubscribeClientsRequest {
  /// A list of client buyers to unsubscribe from the auction package, with
  /// client buyer in the format `buyers/{accountId}/clients/{clientAccountId}`.
  ///
  /// Optional.
  core.List<core.String>? clients;

  $UnsubscribeClientsRequest({this.clients});

  $UnsubscribeClientsRequest.fromJson(core.Map json_)
    : this(
        clients:
            (json_['clients'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clients != null) 'clients': clients!,
  };
}

/// Used by:
///
/// - compute:beta : UpcomingMaintenance
/// - compute:v1 : UpcomingMaintenance
class $UpcomingMaintenance00 {
  /// Indicates if the maintenance can be customer triggered.
  core.bool? canReschedule;

  /// The latest time for the planned maintenance window to start.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? latestWindowStartTime;

  /// Indicates whether the UpcomingMaintenance will be triggered on VM
  /// shutdown.
  core.bool? maintenanceOnShutdown;

  /// The reasons for the maintenance.
  ///
  /// Only valid for vms.
  core.List<core.String>? maintenanceReasons;

  ///
  /// Possible string values are:
  /// - "ONGOING" : There is ongoing maintenance on this VM.
  /// - "PENDING" : There is pending maintenance.
  /// - "UNKNOWN" : Unknown maintenance status. Do not use this value.
  core.String? maintenanceStatus;

  /// Defines the type of maintenance.
  /// Possible string values are:
  /// - "MULTIPLE" : Multiple maintenance types in one window. This is only
  /// intended to be used for groups.
  /// - "SCHEDULED" : Scheduled maintenance (e.g. maintenance after uptime
  /// guarantee is complete).
  /// - "UNKNOWN_TYPE" : No type specified. Do not use this value.
  /// - "UNSCHEDULED" : Unscheduled maintenance (e.g. emergency maintenance
  /// during uptime guarantee).
  core.String? type;

  /// The time by which the maintenance disruption will be completed.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? windowEndTime;

  /// The current start time of the maintenance window.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? windowStartTime;

  $UpcomingMaintenance00({
    this.canReschedule,
    this.latestWindowStartTime,
    this.maintenanceOnShutdown,
    this.maintenanceReasons,
    this.maintenanceStatus,
    this.type,
    this.windowEndTime,
    this.windowStartTime,
  });

  $UpcomingMaintenance00.fromJson(core.Map json_)
    : this(
        canReschedule: json_['canReschedule'] as core.bool?,
        latestWindowStartTime: json_['latestWindowStartTime'] as core.String?,
        maintenanceOnShutdown: json_['maintenanceOnShutdown'] as core.bool?,
        maintenanceReasons:
            (json_['maintenanceReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        maintenanceStatus: json_['maintenanceStatus'] as core.String?,
        type: json_['type'] as core.String?,
        windowEndTime: json_['windowEndTime'] as core.String?,
        windowStartTime: json_['windowStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canReschedule != null) 'canReschedule': canReschedule!,
    if (latestWindowStartTime != null)
      'latestWindowStartTime': latestWindowStartTime!,
    if (maintenanceOnShutdown != null)
      'maintenanceOnShutdown': maintenanceOnShutdown!,
    if (maintenanceReasons != null) 'maintenanceReasons': maintenanceReasons!,
    if (maintenanceStatus != null) 'maintenanceStatus': maintenanceStatus!,
    if (type != null) 'type': type!,
    if (windowEndTime != null) 'windowEndTime': windowEndTime!,
    if (windowStartTime != null) 'windowStartTime': windowStartTime!,
  };
}

/// Used by:
///
/// - tpu:v2 : UpcomingMaintenance
/// - tpu:v2alpha1 : UpcomingMaintenance
class $UpcomingMaintenance01 {
  /// Indicates if the maintenance can be customer triggered.
  core.bool? canReschedule;

  /// The latest time for the planned maintenance window to start.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? latestWindowStartTime;

  /// The status of the maintenance.
  /// Possible string values are:
  /// - "UNKNOWN" : Unknown maintenance status. Do not use this value.
  /// - "PENDING" : There is pending maintenance.
  /// - "ONGOING" : There is ongoing maintenance on this VM.
  core.String? maintenanceStatus;

  /// Defines the type of maintenance.
  /// Possible string values are:
  /// - "UNKNOWN_TYPE" : No type specified. Do not use this value.
  /// - "SCHEDULED" : Scheduled maintenance (e.g. maintenance after uptime
  /// guarantee is complete).
  /// - "UNSCHEDULED" : Unscheduled maintenance (e.g. emergency maintenance
  /// during uptime guarantee).
  core.String? type;

  /// The time by which the maintenance disruption will be completed.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? windowEndTime;

  /// The current start time of the maintenance window.
  ///
  /// This timestamp value is in RFC3339 text format.
  core.String? windowStartTime;

  $UpcomingMaintenance01({
    this.canReschedule,
    this.latestWindowStartTime,
    this.maintenanceStatus,
    this.type,
    this.windowEndTime,
    this.windowStartTime,
  });

  $UpcomingMaintenance01.fromJson(core.Map json_)
    : this(
        canReschedule: json_['canReschedule'] as core.bool?,
        latestWindowStartTime: json_['latestWindowStartTime'] as core.String?,
        maintenanceStatus: json_['maintenanceStatus'] as core.String?,
        type: json_['type'] as core.String?,
        windowEndTime: json_['windowEndTime'] as core.String?,
        windowStartTime: json_['windowStartTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canReschedule != null) 'canReschedule': canReschedule!,
    if (latestWindowStartTime != null)
      'latestWindowStartTime': latestWindowStartTime!,
    if (maintenanceStatus != null) 'maintenanceStatus': maintenanceStatus!,
    if (type != null) 'type': type!,
    if (windowEndTime != null) 'windowEndTime': windowEndTime!,
    if (windowStartTime != null) 'windowStartTime': windowStartTime!,
  };
}

/// Used by:
///
/// - redis:v1 : UpdateInfo
/// - redis:v1beta1 : UpdateInfo
class $UpdateInfo {
  /// Target node type for redis cluster.
  /// Possible string values are:
  /// - "NODE_TYPE_UNSPECIFIED" : Node type unspecified
  /// - "REDIS_SHARED_CORE_NANO" : Redis shared core nano node_type.
  /// - "REDIS_HIGHMEM_MEDIUM" : Redis highmem medium node_type.
  /// - "REDIS_HIGHMEM_XLARGE" : Redis highmem xlarge node_type.
  /// - "REDIS_STANDARD_SMALL" : Redis standard small node_type.
  core.String? targetNodeType;

  /// Target number of replica nodes per shard.
  core.int? targetReplicaCount;

  /// Target number of shards for redis cluster
  core.int? targetShardCount;

  $UpdateInfo({
    this.targetNodeType,
    this.targetReplicaCount,
    this.targetShardCount,
  });

  $UpdateInfo.fromJson(core.Map json_)
    : this(
        targetNodeType: json_['targetNodeType'] as core.String?,
        targetReplicaCount: json_['targetReplicaCount'] as core.int?,
        targetShardCount: json_['targetShardCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetNodeType != null) 'targetNodeType': targetNodeType!,
    if (targetReplicaCount != null) 'targetReplicaCount': targetReplicaCount!,
    if (targetShardCount != null) 'targetShardCount': targetShardCount!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2UpdateLabelCopyModeRequest
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaUpdateLabelCopyModeRequest
class $UpdateLabelCopyModeRequest {
  /// Indicates how the applied Label, and Field values should be copied when a
  /// Drive item is copied.
  ///
  /// Required.
  /// Possible string values are:
  /// - "COPY_MODE_UNSPECIFIED" : Copy mode unspecified.
  /// - "DO_NOT_COPY" : The applied label and field values are not copied by
  /// default when the Drive item it's applied to is copied.
  /// - "ALWAYS_COPY" : The applied label and field values are always copied
  /// when the Drive item it's applied to is copied. Only admins can use this
  /// mode.
  /// - "COPY_APPLIABLE" : The applied label and field values are copied if the
  /// label is appliable by the user making the copy.
  core.String? copyMode;

  /// The BCP-47 language code to use for evaluating localized field labels.
  ///
  /// When not specified, values in the default configured language will be
  /// used.
  core.String? languageCode;

  /// Set to `true` in order to use the user's admin credentials.
  ///
  /// The server will verify the user is an admin for the Label before allowing
  /// access.
  core.bool? useAdminAccess;

  /// When specified, only certain fields belonging to the indicated view will
  /// be returned.
  /// Possible string values are:
  /// - "LABEL_VIEW_BASIC" : Implies the field mask:
  /// `name,id,revision_id,label_type,properties.*`
  /// - "LABEL_VIEW_FULL" : All possible fields.
  core.String? view;

  $UpdateLabelCopyModeRequest({
    this.copyMode,
    this.languageCode,
    this.useAdminAccess,
    this.view,
  });

  $UpdateLabelCopyModeRequest.fromJson(core.Map json_)
    : this(
        copyMode: json_['copyMode'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        useAdminAccess: json_['useAdminAccess'] as core.bool?,
        view: json_['view'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (copyMode != null) 'copyMode': copyMode!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (useAdminAccess != null) 'useAdminAccess': useAdminAccess!,
    if (view != null) 'view': view!,
  };
}

/// Used by:
///
/// - container:v1 : UpdateMasterRequest
/// - container:v1beta1 : UpdateMasterRequest
class $UpdateMasterRequest {
  /// The name of the cluster to upgrade.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? clusterId;

  /// The Kubernetes version to change the master to.
  ///
  /// Users may specify either explicit versions offered by Kubernetes Engine or
  /// version aliases, which have the following behavior: - "latest": picks the
  /// highest valid Kubernetes version - "1.X": picks the highest valid
  /// patch+gke.N patch in the 1.X version - "1.X.Y": picks the highest valid
  /// gke.N patch in the 1.X.Y version - "1.X.Y-gke.N": picks an explicit
  /// Kubernetes version - "-": picks the default Kubernetes version
  ///
  /// Required.
  core.String? masterVersion;

  /// The name (project, location, cluster) of the cluster to update.
  ///
  /// Specified in the format `projects / * /locations / * /clusters / * `.
  core.String? name;

  /// The Google Developers Console
  /// [project ID or project number](https://{$universe.dns_names.final_documentation_domain}/resource-manager/docs/creating-managing-projects).
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? projectId;

  /// The name of the Google Compute Engine
  /// [zone](https://{$universe.dns_names.final_documentation_domain}/compute/docs/zones#available)
  /// in which the cluster resides.
  ///
  /// This field has been deprecated and replaced by the name field.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? zone;

  $UpdateMasterRequest({
    this.clusterId,
    this.masterVersion,
    this.name,
    this.projectId,
    this.zone,
  });

  $UpdateMasterRequest.fromJson(core.Map json_)
    : this(
        clusterId: json_['clusterId'] as core.String?,
        masterVersion: json_['masterVersion'] as core.String?,
        name: json_['name'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clusterId != null) 'clusterId': clusterId!,
    if (masterVersion != null) 'masterVersion': masterVersion!,
    if (name != null) 'name': name!,
    if (projectId != null) 'projectId': projectId!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : UpdatePolicy
/// - alloydb:v1beta : UpdatePolicy
class $UpdatePolicy {
  /// Mode for updating the instance.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Mode is unknown.
  /// - "DEFAULT" : Least disruptive way to apply the update.
  /// - "FORCE_APPLY" : Performs a forced update when applicable. This will be
  /// fast but may incur a downtime.
  core.String? mode;

  $UpdatePolicy({this.mode});

  $UpdatePolicy.fromJson(core.Map json_)
    : this(mode: json_['mode'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : UpgradeApplianceRequest
/// - vmmigration:v1alpha1 : UpgradeApplianceRequest
class $UpgradeApplianceRequest {
  /// A request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server will know to ignore the request if it has already been completed.
  /// The server will guarantee that for at least 60 minutes after the first
  /// request. For example, consider a situation where you make an initial
  /// request and the request times out. If you make the request again with the
  /// same request ID, the server can check if original operation with the same
  /// request ID was received, and if so, will ignore the second request. This
  /// prevents clients from accidentally creating duplicate commitments. The
  /// request ID must be a valid UUID with the exception that zero UUID is not
  /// supported (00000000-0000-0000-0000-000000000000).
  core.String? requestId;

  $UpgradeApplianceRequest({this.requestId});

  $UpgradeApplianceRequest.fromJson(core.Map json_)
    : this(requestId: json_['requestId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requestId != null) 'requestId': requestId!,
  };
}

/// Used by:
///
/// - alloydb:v1alpha : UpgradeClusterRequest
/// - alloydb:v1beta : UpgradeClusterRequest
class $UpgradeClusterRequest {
  /// The current etag of the Cluster.
  ///
  /// If an etag is provided and does not match the current etag of the Cluster,
  /// upgrade will be blocked and an ABORTED error will be returned.
  ///
  /// Optional.
  core.String? etag;

  /// An optional request ID to identify requests.
  ///
  /// Specify a unique request ID so that if you must retry your request, the
  /// server ignores the request if it has already been completed. The server
  /// guarantees that for at least 60 minutes since the first request. For
  /// example, consider a situation where you make an initial request and the
  /// request times out. If you make the request again with the same request ID,
  /// the server can check if the original operation with the same request ID
  /// was received, and if so, ignores the second request. This prevents clients
  /// from accidentally creating duplicate commitments. The request ID must be a
  /// valid UUID with the exception that zero UUID is not supported
  /// (00000000-0000-0000-0000-000000000000).
  ///
  /// Optional.
  core.String? requestId;

  /// If set, performs request validation, for example, permission checks and
  /// any other type of validation, but does not actually execute the create
  /// request.
  ///
  /// Optional.
  core.bool? validateOnly;

  /// The version the cluster is going to be upgraded to.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DATABASE_VERSION_UNSPECIFIED" : This is an unknown database version.
  /// - "POSTGRES_13" : DEPRECATED - The database version is Postgres 13.
  /// - "POSTGRES_14" : The database version is Postgres 14.
  /// - "POSTGRES_15" : The database version is Postgres 15.
  /// - "POSTGRES_16" : The database version is Postgres 16.
  /// - "POSTGRES_17" : The database version is Postgres 17.
  core.String? version;

  $UpgradeClusterRequest({
    this.etag,
    this.requestId,
    this.validateOnly,
    this.version,
  });

  $UpgradeClusterRequest.fromJson(core.Map json_)
    : this(
        etag: json_['etag'] as core.String?,
        requestId: json_['requestId'] as core.String?,
        validateOnly: json_['validateOnly'] as core.bool?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (etag != null) 'etag': etag!,
    if (requestId != null) 'requestId': requestId!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - container:v1 : UpgradeDetails
/// - container:v1beta1 : UpgradeDetails
class $UpgradeDetails {
  /// The end timestamp of the upgrade.
  core.String? endTime;

  /// The version before the upgrade.
  core.String? initialVersion;

  /// The start timestamp of the upgrade.
  core.String? startTime;

  /// The start type of the upgrade.
  /// Possible string values are:
  /// - "START_TYPE_UNSPECIFIED" : Upgrade start type is unspecified.
  /// - "AUTOMATIC" : Upgrade started automatically.
  /// - "MANUAL" : Upgrade started manually.
  core.String? startType;

  /// The state of the upgrade.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNKNOWN" : Upgrade state is unknown.
  /// - "FAILED" : Upgrade has failed with an error.
  /// - "SUCCEEDED" : Upgrade has succeeded.
  /// - "CANCELED" : Upgrade has been canceled.
  /// - "RUNNING" : Upgrade is running.
  core.String? state;

  /// The version after the upgrade.
  core.String? targetVersion;

  $UpgradeDetails({
    this.endTime,
    this.initialVersion,
    this.startTime,
    this.startType,
    this.state,
    this.targetVersion,
  });

  $UpgradeDetails.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        initialVersion: json_['initialVersion'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        startType: json_['startType'] as core.String?,
        state: json_['state'] as core.String?,
        targetVersion: json_['targetVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (initialVersion != null) 'initialVersion': initialVersion!,
    if (startTime != null) 'startTime': startTime!,
    if (startType != null) 'startType': startType!,
    if (state != null) 'state': state!,
    if (targetVersion != null) 'targetVersion': targetVersion!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : UpgradeDistribution
/// - ondemandscanning:v1 : UpgradeDistribution
/// - ondemandscanning:v1beta1 : UpgradeDistribution
class $UpgradeDistribution {
  /// The operating system classification of this Upgrade, as specified by the
  /// upstream operating system upgrade feed.
  ///
  /// For Windows the classification is one of the category_ids listed at
  /// https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ff357803(v=vs.85)
  core.String? classification;

  /// Required - The specific operating system this metadata applies to.
  ///
  /// See https://cpe.mitre.org/specification/.
  core.String? cpeUri;

  /// The cve tied to this Upgrade.
  core.List<core.String>? cve;

  /// The severity as specified by the upstream operating system.
  core.String? severity;

  $UpgradeDistribution({
    this.classification,
    this.cpeUri,
    this.cve,
    this.severity,
  });

  $UpgradeDistribution.fromJson(core.Map json_)
    : this(
        classification: json_['classification'] as core.String?,
        cpeUri: json_['cpeUri'] as core.String?,
        cve:
            (json_['cve'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        severity: json_['severity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classification != null) 'classification': classification!,
    if (cpeUri != null) 'cpeUri': cpeUri!,
    if (cve != null) 'cve': cve!,
    if (severity != null) 'severity': severity!,
  };
}

/// Used by:
///
/// - memcache:v1 : GoogleCloudMemcacheV1UpgradeInstanceRequest
/// - memcache:v1beta2 : GoogleCloudMemcacheV1beta2UpgradeInstanceRequest
class $UpgradeInstanceRequest00 {
  /// Specifies the target version of memcached engine to upgrade to.
  ///
  /// Required.
  /// Possible string values are:
  /// - "MEMCACHE_VERSION_UNSPECIFIED" : Memcache version is not specified by
  /// customer
  /// - "MEMCACHE_1_5" : Memcached 1.5 version.
  /// - "MEMCACHE_1_6_15" : Memcached 1.6.15 version.
  core.String? memcacheVersion;

  $UpgradeInstanceRequest00({this.memcacheVersion});

  $UpgradeInstanceRequest00.fromJson(core.Map json_)
    : this(memcacheVersion: json_['memcacheVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (memcacheVersion != null) 'memcacheVersion': memcacheVersion!,
  };
}

/// Used by:
///
/// - redis:v1 : UpgradeInstanceRequest
/// - redis:v1beta1 : UpgradeInstanceRequest
class $UpgradeInstanceRequest01 {
  /// Specifies the target version of Redis software to upgrade to.
  ///
  /// Required.
  core.String? redisVersion;

  $UpgradeInstanceRequest01({this.redisVersion});

  $UpgradeInstanceRequest01.fromJson(core.Map json_)
    : this(redisVersion: json_['redisVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (redisVersion != null) 'redisVersion': redisVersion!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : UriTargeting
/// - authorizedbuyersmarketplace:v1alpha : UriTargeting
class $UriTargeting {
  /// A list of URLs to be excluded.
  core.List<core.String>? excludedUris;

  /// A list of URLs to be included.
  core.List<core.String>? targetedUris;

  $UriTargeting({this.excludedUris, this.targetedUris});

  $UriTargeting.fromJson(core.Map json_)
    : this(
        excludedUris:
            (json_['excludedUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetedUris:
            (json_['targetedUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedUris != null) 'excludedUris': excludedUris!,
    if (targetedUris != null) 'targetedUris': targetedUris!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : UrlAssignedTargetingOptionDetails
/// - displayvideo:v3 : UrlAssignedTargetingOptionDetails
/// - displayvideo:v4 : UrlAssignedTargetingOptionDetails
class $UrlAssignedTargetingOptionDetails {
  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// The URL, for example `example.com`.
  ///
  /// DV360 supports two levels of subdirectory targeting, for example
  /// `www.example.com/one-subdirectory-level/second-level`, and five levels of
  /// subdomain targeting, for example `five.four.three.two.one.example.com`.
  ///
  /// Required.
  core.String? url;

  $UrlAssignedTargetingOptionDetails({this.negative, this.url});

  $UrlAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        negative: json_['negative'] as core.bool?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (negative != null) 'negative': negative!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - appengine:v1 : UrlDispatchRule
/// - appengine:v1beta : UrlDispatchRule
class $UrlDispatchRule {
  /// Domain name to match against.
  ///
  /// The wildcard "*" is supported if specified before a period: "*.".Defaults
  /// to matching all domains: "*".
  core.String? domain;

  /// Pathname within the host.
  ///
  /// Must start with a "/". A single "*" can be included at the end of the
  /// path.The sum of the lengths of the domain and path may not exceed 100
  /// characters.
  core.String? path;

  /// Resource ID of a service in this application that should serve the matched
  /// request.
  ///
  /// The service must already exist. Example: default.
  core.String? service;

  $UrlDispatchRule({this.domain, this.path, this.service});

  $UrlDispatchRule.fromJson(core.Map json_)
    : this(
        domain: json_['domain'] as core.String?,
        path: json_['path'] as core.String?,
        service: json_['service'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (domain != null) 'domain': domain!,
    if (path != null) 'path': path!,
    if (service != null) 'service': service!,
  };
}

/// Used by:
///
/// - networksecurity:v1 : UrlList
/// - networksecurity:v1beta1 : UrlList
class $UrlList {
  /// Time when the security policy was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Free-text description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// Name of the resource provided by the user.
  ///
  /// Name is of the form
  /// projects/{project}/locations/{location}/urlLists/{url_list} url_list
  /// should match the pattern:(^\[a-z\](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
  ///
  /// Required.
  core.String? name;

  /// Time when the security policy was updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// FQDNs and URLs.
  ///
  /// Required.
  core.List<core.String>? values;

  $UrlList({
    this.createTime,
    this.description,
    this.name,
    this.updateTime,
    this.values,
  });

  $UrlList.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (values != null) 'values': values!,
  };
}

/// Used by:
///
/// - compute:alpha : UrlMapReference
/// - compute:beta : UrlMapReference
/// - compute:v1 : UrlMapReference
class $UrlMapReference {
  core.String? urlMap;

  $UrlMapReference({this.urlMap});

  $UrlMapReference.fromJson(core.Map json_)
    : this(urlMap: json_['urlMap'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (urlMap != null) 'urlMap': urlMap!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1UrlMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UrlMetadata
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1UrlMetadata
class $UrlMetadata {
  /// Retrieved url by the tool.
  core.String? retrievedUrl;

  /// Status of the url retrieval.
  /// Possible string values are:
  /// - "URL_RETRIEVAL_STATUS_UNSPECIFIED" : Default value. This value is
  /// unused.
  /// - "URL_RETRIEVAL_STATUS_SUCCESS" : Url retrieval is successful.
  /// - "URL_RETRIEVAL_STATUS_ERROR" : Url retrieval is failed due to error.
  core.String? urlRetrievalStatus;

  $UrlMetadata({this.retrievedUrl, this.urlRetrievalStatus});

  $UrlMetadata.fromJson(core.Map json_)
    : this(
        retrievedUrl: json_['retrievedUrl'] as core.String?,
        urlRetrievalStatus: json_['urlRetrievalStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (retrievedUrl != null) 'retrievedUrl': retrievedUrl!,
    if (urlRetrievalStatus != null) 'urlRetrievalStatus': urlRetrievalStatus!,
  };
}

/// Used by:
///
/// - compute:alpha : UrlRewrite
/// - compute:beta : UrlRewrite
/// - compute:v1 : UrlRewrite
class $UrlRewrite {
  /// Before forwarding the request to the selected service, the request's host
  /// header is replaced with contents of hostRewrite.
  ///
  /// The value must be from 1 to 255 characters.
  core.String? hostRewrite;

  /// Before forwarding the request to the selected backend service, the
  /// matching portion of the request's path is replaced by pathPrefixRewrite.
  ///
  /// The value must be from 1 to 1024 characters.
  core.String? pathPrefixRewrite;

  /// If specified, the pattern rewrites the URL path (based on the :path
  /// header) using the HTTP template syntax.
  ///
  /// A corresponding path_template_match must be specified. Any template
  /// variables must exist in the path_template_match field. - -At least one
  /// variable must be specified in the path_template_match field - You can omit
  /// variables from the rewritten URL - The * and ** operators cannot be
  /// matched unless they have a corresponding variable name - e.g. {format=*}
  /// or {var=**}. For example, a path_template_match of /static/{format=**}
  /// could be rewritten as /static/content/{format} to prefix /content to the
  /// URL. Variables can also be re-ordered in a rewrite, so that
  /// /{country}/{format}/{suffix=**} can be rewritten as
  /// /content/{format}/{country}/{suffix}. At least one non-empty
  /// routeRules\[\].matchRules\[\].path_template_match is required. Only one of
  /// path_prefix_rewrite or path_template_rewrite may be specified.
  core.String? pathTemplateRewrite;

  $UrlRewrite({
    this.hostRewrite,
    this.pathPrefixRewrite,
    this.pathTemplateRewrite,
  });

  $UrlRewrite.fromJson(core.Map json_)
    : this(
        hostRewrite: json_['hostRewrite'] as core.String?,
        pathPrefixRewrite: json_['pathPrefixRewrite'] as core.String?,
        pathTemplateRewrite: json_['pathTemplateRewrite'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hostRewrite != null) 'hostRewrite': hostRewrite!,
    if (pathPrefixRewrite != null) 'pathPrefixRewrite': pathPrefixRewrite!,
    if (pathTemplateRewrite != null)
      'pathTemplateRewrite': pathTemplateRewrite!,
  };
}

/// Used by:
///
/// - compute:alpha : UsableSubnetworkSecondaryRange
/// - compute:beta : UsableSubnetworkSecondaryRange
/// - compute:v1 : UsableSubnetworkSecondaryRange
class $UsableSubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  $UsableSubnetworkSecondaryRange({this.ipCidrRange, this.rangeName});

  $UsableSubnetworkSecondaryRange.fromJson(core.Map json_)
    : this(
        ipCidrRange: json_['ipCidrRange'] as core.String?,
        rangeName: json_['rangeName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
    if (rangeName != null) 'rangeName': rangeName!,
  };
}

/// Used by:
///
/// - compute:alpha : UsageExportLocation
/// - compute:beta : UsageExportLocation
/// - compute:v1 : UsageExportLocation
class $UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored.
  ///
  /// The Google Service Account is granted write access to this bucket. This
  /// can either be the bucket name by itself, such as example-bucket, or the
  /// bucket name with gs:// or https://storage.googleapis.com/ in front of it,
  /// such as gs://example-bucket.
  core.String? bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName.
  ///
  /// If not supplied, defaults to usage_gce. The report is stored as a CSV file
  /// named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the day of the
  /// usage according to Pacific Time. If you supply a prefix, it should conform
  /// to Cloud Storage object naming conventions.
  core.String? reportNamePrefix;

  $UsageExportLocation({this.bucketName, this.reportNamePrefix});

  $UsageExportLocation.fromJson(core.Map json_)
    : this(
        bucketName: json_['bucketName'] as core.String?,
        reportNamePrefix: json_['reportNamePrefix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucketName != null) 'bucketName': bucketName!,
    if (reportNamePrefix != null) 'reportNamePrefix': reportNamePrefix!,
  };
}

/// Used by:
///
/// - servicemanagement:v1 : UsageRule
/// - serviceusage:v1 : UsageRule
/// - serviceusage:v1beta1 : UsageRule
class $UsageRule {
  ///  Use this rule to configure unregistered calls for the service.
  ///
  /// Unregistered calls are calls that do not contain consumer project
  /// identity. (Example: calls that do not contain an API key). WARNING: By
  /// default, API methods do not allow unregistered calls, and each method call
  /// must be identified by a consumer project identity.
  core.bool? allowUnregisteredCalls;

  /// Selects the methods to which this rule applies.
  ///
  /// Use '*' to indicate all methods in all APIs. Refer to selector for syntax
  /// details.
  core.String? selector;

  /// If true, the selected method should skip service control and the control
  /// plane features, such as quota and billing, will not be available.
  ///
  /// This flag is used by Google Cloud Endpoints to bypass checks for internal
  /// methods, such as service health check methods.
  core.bool? skipServiceControl;

  $UsageRule({
    this.allowUnregisteredCalls,
    this.selector,
    this.skipServiceControl,
  });

  $UsageRule.fromJson(core.Map json_)
    : this(
        allowUnregisteredCalls: json_['allowUnregisteredCalls'] as core.bool?,
        selector: json_['selector'] as core.String?,
        skipServiceControl: json_['skipServiceControl'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowUnregisteredCalls != null)
      'allowUnregisteredCalls': allowUnregisteredCalls!,
    if (selector != null) 'selector': selector!,
    if (skipServiceControl != null) 'skipServiceControl': skipServiceControl!,
  };
}

/// Used by:
///
/// - alloydb:v1 : User
/// - alloydb:v1alpha : User
/// - alloydb:v1beta : User
class $User00 {
  /// List of database roles this user has.
  ///
  /// The database role strings are subject to the PostgreSQL naming
  /// conventions.
  ///
  /// Optional.
  core.List<core.String>? databaseRoles;

  /// Input only.
  ///
  /// If the user already exists and it has additional roles, keep them granted.
  core.bool? keepExtraRoles;

  /// Name of the resource in the form of
  /// projects/{project}/locations/{location}/cluster/{cluster}/users/{user}.
  ///
  /// Output only.
  core.String? name;

  /// Input only.
  ///
  /// Password for the user.
  core.String? password;

  /// Type of this user.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "USER_TYPE_UNSPECIFIED" : Unspecified user type.
  /// - "ALLOYDB_BUILT_IN" : The default user type that authenticates via
  /// password-based authentication.
  /// - "ALLOYDB_IAM_USER" : Database user that can authenticate via IAM-Based
  /// authentication.
  core.String? userType;

  $User00({
    this.databaseRoles,
    this.keepExtraRoles,
    this.name,
    this.password,
    this.userType,
  });

  $User00.fromJson(core.Map json_)
    : this(
        databaseRoles:
            (json_['databaseRoles'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        keepExtraRoles: json_['keepExtraRoles'] as core.bool?,
        name: json_['name'] as core.String?,
        password: json_['password'] as core.String?,
        userType: json_['userType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (databaseRoles != null) 'databaseRoles': databaseRoles!,
    if (keepExtraRoles != null) 'keepExtraRoles': keepExtraRoles!,
    if (name != null) 'name': name!,
    if (password != null) 'password': password!,
    if (userType != null) 'userType': userType!,
  };
}

/// Used by:
///
/// - blogger:v2 : User
/// - blogger:v3 : User
class $User01 {
  /// Profile summary information.
  core.String? about;

  /// The container of blogs for this user.
  UserBlogs? blogs;

  /// The timestamp of when this profile was created, in seconds since epoch.
  core.String? created;

  /// The display name.
  core.String? displayName;

  /// The identifier for this User.
  core.String? id;

  /// The kind of this entity.
  ///
  /// Always blogger#user.
  core.String? kind;

  /// This user's locale
  UserLocale? locale;

  /// The API REST URL to fetch this resource from.
  core.String? selfLink;

  /// The user's profile page.
  core.String? url;

  $User01({
    this.about,
    this.blogs,
    this.created,
    this.displayName,
    this.id,
    this.kind,
    this.locale,
    this.selfLink,
    this.url,
  });

  $User01.fromJson(core.Map json_)
    : this(
        about: json_['about'] as core.String?,
        blogs:
            json_.containsKey('blogs')
                ? UserBlogs.fromJson(
                  json_['blogs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        created: json_['created'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        id: json_['id'] as core.String?,
        kind: json_['kind'] as core.String?,
        locale:
            json_.containsKey('locale')
                ? UserLocale.fromJson(
                  json_['locale'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        selfLink: json_['selfLink'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (about != null) 'about': about!,
    if (blogs != null) 'blogs': blogs!,
    if (created != null) 'created': created!,
    if (displayName != null) 'displayName': displayName!,
    if (id != null) 'id': id!,
    if (kind != null) 'kind': kind!,
    if (locale != null) 'locale': locale!,
    if (selfLink != null) 'selfLink': selfLink!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1UserActionReference
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1UserActionReference
class $UserActionReference {
  /// For API calls that start a LabelingJob.
  ///
  /// Resource name of the LabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  core.String? dataLabelingJob;

  /// The method name of the API RPC call.
  ///
  /// For example,
  /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
  core.String? method;

  /// For API calls that return a long running operation.
  ///
  /// Resource name of the long running operation. Format:
  /// `projects/{project}/locations/{location}/operations/{operation}`
  core.String? operation;

  $UserActionReference({this.dataLabelingJob, this.method, this.operation});

  $UserActionReference.fromJson(core.Map json_)
    : this(
        dataLabelingJob: json_['dataLabelingJob'] as core.String?,
        method: json_['method'] as core.String?,
        operation: json_['operation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob!,
    if (method != null) 'method': method!,
    if (operation != null) 'operation': operation!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2UserCapabilities
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaUserCapabilities
class $UserCapabilities {
  /// Whether the user is allowed access to the label manager.
  ///
  /// Output only.
  core.bool? canAccessLabelManager;

  /// Whether the user is an administrator for the shared labels feature.
  ///
  /// Output only.
  core.bool? canAdministrateLabels;

  /// Whether the user is allowed to create new admin labels.
  ///
  /// Output only.
  core.bool? canCreateAdminLabels;

  /// Whether the user is allowed to create new shared labels.
  ///
  /// Output only.
  core.bool? canCreateSharedLabels;

  /// Resource name for the user capabilities.
  ///
  /// Output only.
  core.String? name;

  $UserCapabilities({
    this.canAccessLabelManager,
    this.canAdministrateLabels,
    this.canCreateAdminLabels,
    this.canCreateSharedLabels,
    this.name,
  });

  $UserCapabilities.fromJson(core.Map json_)
    : this(
        canAccessLabelManager: json_['canAccessLabelManager'] as core.bool?,
        canAdministrateLabels: json_['canAdministrateLabels'] as core.bool?,
        canCreateAdminLabels: json_['canCreateAdminLabels'] as core.bool?,
        canCreateSharedLabels: json_['canCreateSharedLabels'] as core.bool?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (canAccessLabelManager != null)
      'canAccessLabelManager': canAccessLabelManager!,
    if (canAdministrateLabels != null)
      'canAdministrateLabels': canAdministrateLabels!,
    if (canCreateAdminLabels != null)
      'canCreateAdminLabels': canCreateAdminLabels!,
    if (canCreateSharedLabels != null)
      'canCreateSharedLabels': canCreateSharedLabels!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1UserInfo
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaUserInfo
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaUserInfo
class $UserInfo00 {
  /// IANA time zone, e.g. Europe/Budapest.
  ///
  /// Optional.
  core.String? timeZone;

  /// User agent as included in the HTTP header.
  ///
  /// The field must be a UTF-8 encoded string with a length limit of 1,000
  /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned. This
  /// should not be set when using the client side event reporting with GTM or
  /// JavaScript tag in UserEventService.CollectUserEvent or if
  /// UserEvent.direct_user_request is set.
  core.String? userAgent;

  /// Highly recommended for logged-in users.
  ///
  /// Unique identifier for logged-in user, such as a user name. Don't set for
  /// anonymous users. Always use a hashed value for this ID. Don't set the
  /// field to the same fixed ID for different users. This mixes the event
  /// history of those users together, which results in degraded model quality.
  /// The field must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
  core.String? userId;

  $UserInfo00({this.timeZone, this.userAgent, this.userId});

  $UserInfo00.fromJson(core.Map json_)
    : this(
        timeZone: json_['timeZone'] as core.String?,
        userAgent: json_['userAgent'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeZone != null) 'timeZone': timeZone!,
    if (userAgent != null) 'userAgent': userAgent!,
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - retail:v2 : GoogleCloudRetailV2UserInfo
/// - retail:v2alpha : GoogleCloudRetailV2alphaUserInfo
/// - retail:v2beta : GoogleCloudRetailV2betaUserInfo
class $UserInfo01 {
  /// True if the request is made directly from the end user, in which case the
  /// ip_address and user_agent can be populated from the HTTP request.
  ///
  /// This flag should be set only if the API request is made directly from the
  /// end user such as a mobile app (and not if a gateway or a server is
  /// processing and pushing the user events). This should not be set when using
  /// the JavaScript tag in UserEventService.CollectUserEvent.
  core.bool? directUserRequest;

  /// The end user's IP address.
  ///
  /// This field is used to extract location information for personalization.
  /// This field must be either an IPv4 address (e.g. "104.133.9.80") or an IPv6
  /// address (e.g. "2001:0db8:85a3:0000:0000:8a2e:0370:7334"). Otherwise, an
  /// INVALID_ARGUMENT error is returned. This should not be set when: * setting
  /// SearchRequest.user_info. * using the JavaScript tag in
  /// UserEventService.CollectUserEvent or if direct_user_request is set.
  core.String? ipAddress;

  /// User agent as included in the HTTP header.
  ///
  /// The field must be a UTF-8 encoded string with a length limit of 1,000
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned. This should
  /// not be set when using the client side event reporting with GTM or
  /// JavaScript tag in UserEventService.CollectUserEvent or if
  /// direct_user_request is set.
  core.String? userAgent;

  /// Highly recommended for logged-in users.
  ///
  /// Unique identifier for logged-in user, such as a user name. Don't set for
  /// anonymous users. Always use a hashed value for this ID. Don't set the
  /// field to the same fixed ID for different users. This mixes the event
  /// history of those users together, which results in degraded model quality.
  /// The field must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
  core.String? userId;

  $UserInfo01({
    this.directUserRequest,
    this.ipAddress,
    this.userAgent,
    this.userId,
  });

  $UserInfo01.fromJson(core.Map json_)
    : this(
        directUserRequest: json_['directUserRequest'] as core.bool?,
        ipAddress: json_['ipAddress'] as core.String?,
        userAgent: json_['userAgent'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (directUserRequest != null) 'directUserRequest': directUserRequest!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (userAgent != null) 'userAgent': userAgent!,
    if (userId != null) 'userId': userId!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2UserInfo
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaUserInfo
class $UserInfo02 {
  /// The identifier for this user that can be used with the People API to get
  /// more information.
  ///
  /// For example, people/12345678.
  core.String? person;

  $UserInfo02({this.person});

  $UserInfo02.fromJson(core.Map json_)
    : this(person: json_['person'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (person != null) 'person': person!,
  };
}

/// Used by:
///
/// - cloudidentity:v1 : UserInvitation
/// - cloudidentity:v1beta1 : UserInvitation
class $UserInvitation {
  /// Number of invitation emails sent to the user.
  core.String? mailsSentCount;

  /// Shall be of the form
  /// `customers/{customer}/userinvitations/{user_email_address}`.
  core.String? name;

  /// State of the `UserInvitation`.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The default value. This value is used if the state
  /// is omitted.
  /// - "NOT_YET_SENT" : The `UserInvitation` has been created and is ready for
  /// sending as an email.
  /// - "INVITED" : The user has been invited by email.
  /// - "ACCEPTED" : The user has accepted the invitation and is part of the
  /// organization.
  /// - "DECLINED" : The user declined the invitation.
  core.String? state;

  /// Time when the `UserInvitation` was last updated.
  core.String? updateTime;

  $UserInvitation({
    this.mailsSentCount,
    this.name,
    this.state,
    this.updateTime,
  });

  $UserInvitation.fromJson(core.Map json_)
    : this(
        mailsSentCount: json_['mailsSentCount'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mailsSentCount != null) 'mailsSentCount': mailsSentCount!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1UserLicense
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaUserLicense
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaUserLicense
class $UserLicense {
  /// User created timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// User last logged in time.
  ///
  /// If the user has not logged in yet, this field will be empty.
  ///
  /// Output only.
  core.String? lastLoginTime;

  /// License assignment state of the user.
  ///
  /// If the user is assigned with a license config, the user login will be
  /// assigned with the license; If the user's license assignment state is
  /// unassigned or unspecified, no license config will be associated to the
  /// user;
  ///
  /// Output only.
  /// Possible string values are:
  /// - "LICENSE_ASSIGNMENT_STATE_UNSPECIFIED" : Default value.
  /// - "ASSIGNED" : License assigned to the user.
  /// - "UNASSIGNED" : No license assigned to the user. Deprecated, translated
  /// to NO_LICENSE.
  /// - "NO_LICENSE" : No license assigned to the user.
  /// - "NO_LICENSE_ATTEMPTED_LOGIN" : User attempted to login but no license
  /// assigned to the user. This state is only used for no user first time login
  /// attempt but cannot get license assigned. Users already logged in but
  /// cannot get license assigned will be assigned NO_LICENSE state(License
  /// could be unassigned by admin).
  /// - "BLOCKED" : User is blocked from assigning a license.
  core.String? licenseAssignmentState;

  /// The full resource name of the Subscription(LicenseConfig) assigned to the
  /// user.
  ///
  /// Optional.
  core.String? licenseConfig;

  /// User update timestamp.
  ///
  /// Output only.
  core.String? updateTime;

  /// The user principal of the User, could be email address or other prinical
  /// identifier.
  ///
  /// This field is immutable. Admin assign licenses based on the user
  /// principal.
  ///
  /// Required. Immutable.
  core.String? userPrincipal;

  /// The user profile.
  ///
  /// We user user full name(First name + Last name) as user profile.
  ///
  /// Optional.
  core.String? userProfile;

  $UserLicense({
    this.createTime,
    this.lastLoginTime,
    this.licenseAssignmentState,
    this.licenseConfig,
    this.updateTime,
    this.userPrincipal,
    this.userProfile,
  });

  $UserLicense.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        lastLoginTime: json_['lastLoginTime'] as core.String?,
        licenseAssignmentState: json_['licenseAssignmentState'] as core.String?,
        licenseConfig: json_['licenseConfig'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        userPrincipal: json_['userPrincipal'] as core.String?,
        userProfile: json_['userProfile'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (lastLoginTime != null) 'lastLoginTime': lastLoginTime!,
    if (licenseAssignmentState != null)
      'licenseAssignmentState': licenseAssignmentState!,
    if (licenseConfig != null) 'licenseConfig': licenseConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (userPrincipal != null) 'userPrincipal': userPrincipal!,
    if (userProfile != null) 'userProfile': userProfile!,
  };
}

/// Used by:
///
/// - container:v1 : UserManagedKeysConfig
/// - container:v1beta1 : UserManagedKeysConfig
class $UserManagedKeysConfig {
  /// The Certificate Authority Service caPool to use for the aggregation CA in
  /// this cluster.
  core.String? aggregationCa;

  /// The Certificate Authority Service caPool to use for the cluster CA in this
  /// cluster.
  core.String? clusterCa;

  /// The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control
  /// plane nodes.
  core.String? controlPlaneDiskEncryptionKey;

  /// Resource path of the Certificate Authority Service caPool to use for the
  /// etcd API CA in this cluster.
  core.String? etcdApiCa;

  /// Resource path of the Certificate Authority Service caPool to use for the
  /// etcd peer CA in this cluster.
  core.String? etcdPeerCa;

  /// Resource path of the Cloud KMS cryptoKey to use for encryption of internal
  /// etcd backups.
  core.String? gkeopsEtcdBackupEncryptionKey;

  /// The Cloud KMS cryptoKeyVersions to use for signing service account JWTs
  /// issued by this cluster.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
  core.List<core.String>? serviceAccountSigningKeys;

  /// The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs
  /// issued by this cluster.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
  core.List<core.String>? serviceAccountVerificationKeys;

  $UserManagedKeysConfig({
    this.aggregationCa,
    this.clusterCa,
    this.controlPlaneDiskEncryptionKey,
    this.etcdApiCa,
    this.etcdPeerCa,
    this.gkeopsEtcdBackupEncryptionKey,
    this.serviceAccountSigningKeys,
    this.serviceAccountVerificationKeys,
  });

  $UserManagedKeysConfig.fromJson(core.Map json_)
    : this(
        aggregationCa: json_['aggregationCa'] as core.String?,
        clusterCa: json_['clusterCa'] as core.String?,
        controlPlaneDiskEncryptionKey:
            json_['controlPlaneDiskEncryptionKey'] as core.String?,
        etcdApiCa: json_['etcdApiCa'] as core.String?,
        etcdPeerCa: json_['etcdPeerCa'] as core.String?,
        gkeopsEtcdBackupEncryptionKey:
            json_['gkeopsEtcdBackupEncryptionKey'] as core.String?,
        serviceAccountSigningKeys:
            (json_['serviceAccountSigningKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        serviceAccountVerificationKeys:
            (json_['serviceAccountVerificationKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aggregationCa != null) 'aggregationCa': aggregationCa!,
    if (clusterCa != null) 'clusterCa': clusterCa!,
    if (controlPlaneDiskEncryptionKey != null)
      'controlPlaneDiskEncryptionKey': controlPlaneDiskEncryptionKey!,
    if (etcdApiCa != null) 'etcdApiCa': etcdApiCa!,
    if (etcdPeerCa != null) 'etcdPeerCa': etcdPeerCa!,
    if (gkeopsEtcdBackupEncryptionKey != null)
      'gkeopsEtcdBackupEncryptionKey': gkeopsEtcdBackupEncryptionKey!,
    if (serviceAccountSigningKeys != null)
      'serviceAccountSigningKeys': serviceAccountSigningKeys!,
    if (serviceAccountVerificationKeys != null)
      'serviceAccountVerificationKeys': serviceAccountVerificationKeys!,
  };
}

/// Used by:
///
/// - firebaseapphosting:v1 : UserMetadata
/// - firebaseapphosting:v1beta : UserMetadata
class $UserMetadata {
  /// The 'name' field in a Git user's git.config.
  ///
  /// Required by Git.
  ///
  /// Output only.
  core.String? displayName;

  /// The 'email' field in a Git user's git.config, if available.
  ///
  /// Output only.
  core.String? email;

  /// The URI of an image file associated with the user's account in an external
  /// source control provider, if available.
  ///
  /// Output only.
  core.String? imageUri;

  $UserMetadata({this.displayName, this.email, this.imageUri});

  $UserMetadata.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        email: json_['email'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (email != null) 'email': email!,
    if (imageUri != null) 'imageUri': imageUri!,
  };
}

/// Used by:
///
/// - alloydb:v1 : UserPassword
/// - alloydb:v1alpha : UserPassword
/// - alloydb:v1beta : UserPassword
class $UserPassword {
  /// The initial password for the user.
  core.String? password;

  /// The database username.
  core.String? user;

  $UserPassword({this.password, this.user});

  $UserPassword.fromJson(core.Map json_)
    : this(
        password: json_['password'] as core.String?,
        user: json_['user'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
    if (user != null) 'user': user!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : UserRewardedContentAssignedTargetingOptionDetails
/// - displayvideo:v3 : UserRewardedContentAssignedTargetingOptionDetails
/// - displayvideo:v4 : UserRewardedContentAssignedTargetingOptionDetails
class $UserRewardedContentAssignedTargetingOptionDetails {
  /// The targeting_option_id field when targeting_type is
  /// `TARGETING_TYPE_USER_REWARDED_CONTENT`.
  ///
  /// Required.
  core.String? targetingOptionId;

  /// User rewarded content status for video ads.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "USER_REWARDED_CONTENT_UNSPECIFIED" : User rewarded content is not
  /// specified or is unknown in this version.
  /// - "USER_REWARDED_CONTENT_USER_REWARDED" : Represents ads where the user
  /// will see a reward after viewing.
  /// - "USER_REWARDED_CONTENT_NOT_USER_REWARDED" : Represents all other ads
  /// besides user-rewarded.
  core.String? userRewardedContent;

  $UserRewardedContentAssignedTargetingOptionDetails({
    this.targetingOptionId,
    this.userRewardedContent,
  });

  $UserRewardedContentAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        targetingOptionId: json_['targetingOptionId'] as core.String?,
        userRewardedContent: json_['userRewardedContent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (targetingOptionId != null) 'targetingOptionId': targetingOptionId!,
    if (userRewardedContent != null)
      'userRewardedContent': userRewardedContent!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : UserRewardedContentTargetingOptionDetails
/// - displayvideo:v3 : UserRewardedContentTargetingOptionDetails
/// - displayvideo:v4 : UserRewardedContentTargetingOptionDetails
class $UserRewardedContentTargetingOptionDetails {
  /// User rewarded content status for video ads.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "USER_REWARDED_CONTENT_UNSPECIFIED" : User rewarded content is not
  /// specified or is unknown in this version.
  /// - "USER_REWARDED_CONTENT_USER_REWARDED" : Represents ads where the user
  /// will see a reward after viewing.
  /// - "USER_REWARDED_CONTENT_NOT_USER_REWARDED" : Represents all other ads
  /// besides user-rewarded.
  core.String? userRewardedContent;

  $UserRewardedContentTargetingOptionDetails({this.userRewardedContent});

  $UserRewardedContentTargetingOptionDetails.fromJson(core.Map json_)
    : this(userRewardedContent: json_['userRewardedContent'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (userRewardedContent != null)
      'userRewardedContent': userRewardedContent!,
  };
}

/// Used by:
///
/// - composer:v1 : UserWorkloadsConfigMap
/// - composer:v1beta1 : UserWorkloadsConfigMap
class $UserWorkloadsConfigMap {
  /// The "data" field of Kubernetes ConfigMap, organized in key-value pairs.
  ///
  /// For details see:
  /// https://kubernetes.io/docs/concepts/configuration/configmap/ Example: {
  /// "example_key": "example_value", "another_key": "another_value" }
  ///
  /// Optional.
  core.Map<core.String, core.String>? data;

  /// Identifier.
  ///
  /// The resource name of the ConfigMap, in the form:
  /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsConfigMaps/{userWorkloadsConfigMapId}"
  core.String? name;

  $UserWorkloadsConfigMap({this.data, this.name});

  $UserWorkloadsConfigMap.fromJson(core.Map json_)
    : this(
        data: (json_['data'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - composer:v1 : UserWorkloadsSecret
/// - composer:v1beta1 : UserWorkloadsSecret
class $UserWorkloadsSecret {
  /// The "data" field of Kubernetes Secret, organized in key-value pairs, which
  /// can contain sensitive values such as a password, a token, or a key.
  ///
  /// The values for all keys have to be base64-encoded strings. For details
  /// see: https://kubernetes.io/docs/concepts/configuration/secret/ Example: {
  /// "example": "ZXhhbXBsZV92YWx1ZQ==", "another-example":
  /// "YW5vdGhlcl9leGFtcGxlX3ZhbHVl" }
  ///
  /// Optional.
  core.Map<core.String, core.String>? data;

  /// Identifier.
  ///
  /// The resource name of the Secret, in the form:
  /// "projects/{projectId}/locations/{locationId}/environments/{environmentId}/userWorkloadsSecrets/{userWorkloadsSecretId}"
  core.String? name;

  $UserWorkloadsSecret({this.data, this.name});

  $UserWorkloadsSecret.fromJson(core.Map json_)
    : this(
        data: (json_['data'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3AgentUtterance
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3UserUtterance
class $Utterance {
  /// Message content in text.
  ///
  /// Required.
  core.String? text;

  $Utterance({this.text});

  $Utterance.fromJson(core.Map json_)
    : this(text: json_['text'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (text != null) 'text': text!,
  };
}

/// Used by:
///
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountpricesV1betaAggregationInfo
/// - cloudbilling:v1beta : GoogleCloudBillingPricesV1betaAggregationInfo
class $V1betaAggregationInfo {
  /// Interval at which usage is aggregated to compute cost.
  ///
  /// Example: "MONTHLY" interval indicates that usage is aggregated every
  /// month.
  /// Possible string values are:
  /// - "INTERVAL_UNSPECIFIED" : Default unspecified value.
  /// - "INTERVAL_MONTHLY" : Usage is aggregated every month.
  /// - "INTERVAL_DAILY" : Usage is aggregated every day.
  core.String? interval;

  /// Level at which usage is aggregated to compute cost.
  ///
  /// Example: "ACCOUNT" level indicates that usage is aggregated across all
  /// projects in a single account.
  /// Possible string values are:
  /// - "LEVEL_UNSPECIFIED" : Default unspecified value.
  /// - "LEVEL_ACCOUNT" : Usage is aggregated at an account level.
  /// - "LEVEL_PROJECT" : Usage is aggregated at a project level.
  core.String? level;

  $V1betaAggregationInfo({this.interval, this.level});

  $V1betaAggregationInfo.fromJson(core.Map json_)
    : this(
        interval: json_['interval'] as core.String?,
        level: json_['level'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interval != null) 'interval': interval!,
    if (level != null) 'level': level!,
  };
}

/// Used by:
///
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskugroupskusV1betaGeoTaxonomyRegion
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskusV1betaGeoTaxonomyRegion
/// - cloudbilling:v1beta : GoogleCloudBillingSkugroupskusV1betaGeoTaxonomyRegion
class $V1betaGeoTaxonomyRegion {
  /// Description of a Google Cloud region.
  ///
  /// Example: "us-west2".
  core.String? region;

  $V1betaGeoTaxonomyRegion({this.region});

  $V1betaGeoTaxonomyRegion.fromJson(core.Map json_)
    : this(region: json_['region'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (region != null) 'region': region!,
  };
}

/// Used by:
///
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskugroupskusV1betaTaxonomyCategory
/// - cloudbilling:v1beta : GoogleCloudBillingBillingaccountskusV1betaTaxonomyCategory
/// - cloudbilling:v1beta : GoogleCloudBillingSkugroupskusV1betaTaxonomyCategory
class $V1betaTaxonomyCategory {
  /// Name of the product category.
  core.String? category;

  $V1betaTaxonomyCategory({this.category});

  $V1betaTaxonomyCategory.fromJson(core.Map json_)
    : this(category: json_['category'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
  };
}

/// Used by:
///
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitAdminV2CustomStrengthOptions
/// - identitytoolkit:v2 : GoogleCloudIdentitytoolkitV2CustomStrengthOptions
class $V2CustomStrengthOptions {
  /// The password must contain a lower case character.
  core.bool? containsLowercaseCharacter;

  /// The password must contain a non alpha numeric character.
  core.bool? containsNonAlphanumericCharacter;

  /// The password must contain a number.
  core.bool? containsNumericCharacter;

  /// The password must contain an upper case character.
  core.bool? containsUppercaseCharacter;

  /// Maximum password length.
  ///
  /// No default max length
  core.int? maxPasswordLength;

  /// Minimum password length.
  ///
  /// Range from 6 to 30
  core.int? minPasswordLength;

  $V2CustomStrengthOptions({
    this.containsLowercaseCharacter,
    this.containsNonAlphanumericCharacter,
    this.containsNumericCharacter,
    this.containsUppercaseCharacter,
    this.maxPasswordLength,
    this.minPasswordLength,
  });

  $V2CustomStrengthOptions.fromJson(core.Map json_)
    : this(
        containsLowercaseCharacter:
            json_['containsLowercaseCharacter'] as core.bool?,
        containsNonAlphanumericCharacter:
            json_['containsNonAlphanumericCharacter'] as core.bool?,
        containsNumericCharacter:
            json_['containsNumericCharacter'] as core.bool?,
        containsUppercaseCharacter:
            json_['containsUppercaseCharacter'] as core.bool?,
        maxPasswordLength: json_['maxPasswordLength'] as core.int?,
        minPasswordLength: json_['minPasswordLength'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (containsLowercaseCharacter != null)
      'containsLowercaseCharacter': containsLowercaseCharacter!,
    if (containsNonAlphanumericCharacter != null)
      'containsNonAlphanumericCharacter': containsNonAlphanumericCharacter!,
    if (containsNumericCharacter != null)
      'containsNumericCharacter': containsNumericCharacter!,
    if (containsUppercaseCharacter != null)
      'containsUppercaseCharacter': containsUppercaseCharacter!,
    if (maxPasswordLength != null) 'maxPasswordLength': maxPasswordLength!,
    if (minPasswordLength != null) 'minPasswordLength': minPasswordLength!,
  };
}

/// Used by:
///
/// - binaryauthorization:v1 : ValidateAttestationOccurrenceResponse
/// - binaryauthorization:v1beta1 : ValidateAttestationOccurrenceResponse
class $ValidateAttestationOccurrenceResponse {
  /// The reason for denial if the Attestation couldn't be validated.
  core.String? denialReason;

  /// The result of the Attestation validation.
  /// Possible string values are:
  /// - "RESULT_UNSPECIFIED" : Unspecified.
  /// - "VERIFIED" : The Attestation was able to verified by the Attestor.
  /// - "ATTESTATION_NOT_VERIFIABLE" : The Attestation was not able to verified
  /// by the Attestor.
  core.String? result;

  $ValidateAttestationOccurrenceResponse({this.denialReason, this.result});

  $ValidateAttestationOccurrenceResponse.fromJson(core.Map json_)
    : this(
        denialReason: json_['denialReason'] as core.String?,
        result: json_['result'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (denialReason != null) 'denialReason': denialReason!,
    if (result != null) 'result': result!,
  };
}

/// Used by:
///
/// - netapp:v1 : ValidateDirectoryServiceRequest
/// - netapp:v1beta1 : ValidateDirectoryServiceRequest
class $ValidateDirectoryServiceRequest {
  /// Type of directory service policy attached to the storage pool.
  /// Possible string values are:
  /// - "DIRECTORY_SERVICE_TYPE_UNSPECIFIED" : Directory service type is not
  /// specified.
  /// - "ACTIVE_DIRECTORY" : Active directory policy attached to the storage
  /// pool.
  core.String? directoryServiceType;

  $ValidateDirectoryServiceRequest({this.directoryServiceType});

  $ValidateDirectoryServiceRequest.fromJson(core.Map json_)
    : this(directoryServiceType: json_['directoryServiceType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (directoryServiceType != null)
      'directoryServiceType': directoryServiceType!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2ValidationError
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1ValidationError
class $ValidationError {
  /// The names of the entries that the error is associated with.
  ///
  /// Format: - `projects//agent`, if the error is associated with the entire
  /// agent. - `projects//agent/intents/`, if the error is associated with
  /// certain intents. - `projects//agent/intents//trainingPhrases/`, if the
  /// error is associated with certain intent training phrases. -
  /// `projects//agent/intents//parameters/`, if the error is associated with
  /// certain intent parameters. - `projects//agent/entities/`, if the error is
  /// associated with certain entities.
  core.List<core.String>? entries;

  /// The detailed error message.
  core.String? errorMessage;

  /// The severity of the error.
  /// Possible string values are:
  /// - "SEVERITY_UNSPECIFIED" : Not specified. This value should never be used.
  /// - "INFO" : The agent doesn't follow Dialogflow best practices.
  /// - "WARNING" : The agent may not behave as expected.
  /// - "ERROR" : The agent may experience partial failures.
  /// - "CRITICAL" : The agent may completely fail.
  core.String? severity;

  $ValidationError({this.entries, this.errorMessage, this.severity});

  $ValidationError.fromJson(core.Map json_)
    : this(
        entries:
            (json_['entries'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        errorMessage: json_['errorMessage'] as core.String?,
        severity: json_['severity'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entries != null) 'entries': entries!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (severity != null) 'severity': severity!,
  };
}

/// Used by:
///
/// - deploymentmanager:alpha : ValidationOptions
/// - deploymentmanager:v2beta : ValidationOptions
class $ValidationOptions {
  /// Customize how deployment manager will validate the resource against schema
  /// errors.
  /// Possible string values are:
  /// - "UNKNOWN"
  /// - "IGNORE" : Ignore schema failures.
  /// - "IGNORE_WITH_WARNINGS" : Ignore schema failures but display them as
  /// warnings.
  /// - "FAIL" : Fail the resource if the schema is not valid, this is the
  /// default behavior.
  core.String? schemaValidation;

  /// Specify what to do with extra properties when executing a request.
  /// Possible string values are:
  /// - "UNKNOWN"
  /// - "INCLUDE" : Always include even if not present on discovery doc.
  /// - "IGNORE" : Always ignore if not present on discovery doc.
  /// - "INCLUDE_WITH_WARNINGS" : Include on request, but emit a warning.
  /// - "IGNORE_WITH_WARNINGS" : Ignore properties, but emit a warning.
  /// - "FAIL" : Always fail if undeclared properties are present.
  core.String? undeclaredProperties;

  $ValidationOptions({this.schemaValidation, this.undeclaredProperties});

  $ValidationOptions.fromJson(core.Map json_)
    : this(
        schemaValidation: json_['schemaValidation'] as core.String?,
        undeclaredProperties: json_['undeclaredProperties'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (schemaValidation != null) 'schemaValidation': schemaValidation!,
    if (undeclaredProperties != null)
      'undeclaredProperties': undeclaredProperties!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1Value
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1Value
class $Value {
  /// A double value.
  core.double? doubleValue;

  /// An integer value.
  core.String? intValue;

  /// A string value.
  core.String? stringValue;

  $Value({this.doubleValue, this.intValue, this.stringValue});

  $Value.fromJson(core.Map json_)
    : this(
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        intValue: json_['intValue'] as core.String?,
        stringValue: json_['stringValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (intValue != null) 'intValue': intValue!,
    if (stringValue != null) 'stringValue': stringValue!,
  };
}

/// Used by:
///
/// - recommender:v1 : GoogleCloudRecommenderV1ValueMatcher
/// - recommender:v1beta1 : GoogleCloudRecommenderV1beta1ValueMatcher
class $ValueMatcher {
  /// To be used for full regex matching.
  ///
  /// The regular expression is using the Google RE2 syntax
  /// (https://github.com/google/re2/wiki/Syntax), so to be used with
  /// RE2::FullMatch
  core.String? matchesPattern;

  $ValueMatcher({this.matchesPattern});

  $ValueMatcher.fromJson(core.Map json_)
    : this(matchesPattern: json_['matchesPattern'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (matchesPattern != null) 'matchesPattern': matchesPattern!,
  };
}

/// Used by:
///
/// - netapp:v1 : VerifyKmsConfigResponse
/// - netapp:v1beta1 : VerifyKmsConfigResponse
class $VerifyKmsConfigResponse {
  /// Error message if config is not healthy.
  ///
  /// Output only.
  core.String? healthError;

  /// If the customer key configured correctly to the encrypt volume.
  ///
  /// Output only.
  core.bool? healthy;

  /// Instructions for the customers to provide the access to the encryption
  /// key.
  ///
  /// Output only.
  core.String? instructions;

  $VerifyKmsConfigResponse({this.healthError, this.healthy, this.instructions});

  $VerifyKmsConfigResponse.fromJson(core.Map json_)
    : this(
        healthError: json_['healthError'] as core.String?,
        healthy: json_['healthy'] as core.bool?,
        instructions: json_['instructions'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (healthError != null) 'healthError': healthError!,
    if (healthy != null) 'healthy': healthy!,
    if (instructions != null) 'instructions': instructions!,
  };
}

/// Used by:
///
/// - containeranalysis:v1 : Version
/// - ondemandscanning:v1 : Version
/// - ondemandscanning:v1beta1 : Version
class $Version00 {
  /// Used to correct mistakes in the version numbering scheme.
  core.int? epoch;

  /// Human readable version string.
  ///
  /// This string is of the form :- and is only set when kind is NORMAL.
  core.String? fullName;

  /// Whether this version is specifying part of an inclusive range.
  ///
  /// Grafeas does not have the capability to specify version ranges; instead we
  /// have fields that specify start version and end versions. At times this is
  /// insufficient - we also need to specify whether the version is included in
  /// the range or is excluded from the range. This boolean is expected to be
  /// set to true when the version is included in a range.
  core.bool? inclusive;

  /// Distinguishes between sentinel MIN/MAX versions and normal versions.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VERSION_KIND_UNSPECIFIED" : Unknown.
  /// - "NORMAL" : A standard package version.
  /// - "MINIMUM" : A special version representing negative infinity.
  /// - "MAXIMUM" : A special version representing positive infinity.
  core.String? kind;

  /// Required only when version kind is NORMAL.
  ///
  /// The main part of the version name.
  core.String? name;

  /// The iteration of the package build from the above version.
  core.String? revision;

  $Version00({
    this.epoch,
    this.fullName,
    this.inclusive,
    this.kind,
    this.name,
    this.revision,
  });

  $Version00.fromJson(core.Map json_)
    : this(
        epoch: json_['epoch'] as core.int?,
        fullName: json_['fullName'] as core.String?,
        inclusive: json_['inclusive'] as core.bool?,
        kind: json_['kind'] as core.String?,
        name: json_['name'] as core.String?,
        revision: json_['revision'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (epoch != null) 'epoch': epoch!,
    if (fullName != null) 'fullName': fullName!,
    if (inclusive != null) 'inclusive': inclusive!,
    if (kind != null) 'kind': kind!,
    if (name != null) 'name': name!,
    if (revision != null) 'revision': revision!,
  };
}

/// Used by:
///
/// - datafusion:v1 : Version
/// - datafusion:v1beta1 : Version
class $Version01 {
  /// Represents a list of available feature names for a given version.
  core.List<core.String>? availableFeatures;

  /// Whether this is currently the default version for Cloud Data Fusion
  core.bool? defaultVersion;

  /// Type represents the release availability of the version
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Version does not have availability yet
  /// - "TYPE_PREVIEW" : Version is under development and not considered stable
  /// - "TYPE_GENERAL_AVAILABILITY" : Version is available for public use
  /// - "TYPE_DEPRECATED" : Version is no longer supported.
  core.String? type;

  /// The version number of the Data Fusion instance, such as '6.0.1.0'.
  core.String? versionNumber;

  $Version01({
    this.availableFeatures,
    this.defaultVersion,
    this.type,
    this.versionNumber,
  });

  $Version01.fromJson(core.Map json_)
    : this(
        availableFeatures:
            (json_['availableFeatures'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        defaultVersion: json_['defaultVersion'] as core.bool?,
        type: json_['type'] as core.String?,
        versionNumber: json_['versionNumber'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (availableFeatures != null) 'availableFeatures': availableFeatures!,
    if (defaultVersion != null) 'defaultVersion': defaultVersion!,
    if (type != null) 'type': type!,
    if (versionNumber != null) 'versionNumber': versionNumber!,
  };
}

/// Used by:
///
/// - dialogflow:v2 : GoogleCloudDialogflowV2Version
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1Version
class $Version02 {
  /// The creation time of this version.
  ///
  /// This field is read-only, i.e., it cannot be set by create and update
  /// methods.
  ///
  /// Output only.
  core.String? createTime;

  /// The developer-provided description of this version.
  ///
  /// Optional.
  core.String? description;

  /// The unique identifier of this agent version.
  ///
  /// Supported formats: - `projects//agent/versions/` -
  /// `projects//locations//agent/versions/`
  ///
  /// Output only.
  core.String? name;

  /// The status of this version.
  ///
  /// This field is read-only and cannot be set by create and update methods.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "VERSION_STATUS_UNSPECIFIED" : Not specified. This value is not used.
  /// - "IN_PROGRESS" : Version is not ready to serve (e.g. training is in
  /// progress).
  /// - "READY" : Version is ready to serve.
  /// - "FAILED" : Version training failed.
  core.String? status;

  /// The sequential number of this version.
  ///
  /// This field is read-only which means it cannot be set by create and update
  /// methods.
  ///
  /// Output only.
  core.int? versionNumber;

  $Version02({
    this.createTime,
    this.description,
    this.name,
    this.status,
    this.versionNumber,
  });

  $Version02.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        status: json_['status'] as core.String?,
        versionNumber: json_['versionNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (status != null) 'status': status!,
    if (versionNumber != null) 'versionNumber': versionNumber!,
  };
}

/// Used by:
///
/// - healthcare:v1 : VersionSource
/// - healthcare:v1beta1 : VersionSource
class $VersionSource {
  /// The field to extract from the MSH segment.
  ///
  /// For example, "3.1" or "18\[1\].1".
  core.String? mshField;

  /// The value to match with the field.
  ///
  /// For example, "My Application Name" or "2.3".
  core.String? value;

  $VersionSource({this.mshField, this.value});

  $VersionSource.fromJson(core.Map json_)
    : this(
        mshField: json_['mshField'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mshField != null) 'mshField': mshField!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3VersionVariantsVariant
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1VersionVariantsVariant
class $VersionVariantsVariant {
  /// Whether the variant is for the control group.
  core.bool? isControlGroup;

  /// Percentage of the traffic which should be routed to this version of flow.
  ///
  /// Traffic allocation for a single flow must sum up to 1.0.
  core.double? trafficAllocation;

  /// The name of the flow version.
  ///
  /// Format: `projects//locations//agents//flows//versions/`.
  core.String? version;

  $VersionVariantsVariant({
    this.isControlGroup,
    this.trafficAllocation,
    this.version,
  });

  $VersionVariantsVariant.fromJson(core.Map json_)
    : this(
        isControlGroup: json_['isControlGroup'] as core.bool?,
        trafficAllocation:
            (json_['trafficAllocation'] as core.num?)?.toDouble(),
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isControlGroup != null) 'isControlGroup': isControlGroup!,
    if (trafficAllocation != null) 'trafficAllocation': trafficAllocation!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : VersionedPackage
/// - osconfig:v1 : InventoryVersionedPackage
/// - osconfig:v1alpha : InventoryVersionedPackage
class $VersionedPackage {
  /// The system architecture this package is intended for.
  core.String? architecture;

  /// The name of the package.
  core.String? packageName;

  /// The version of the package.
  core.String? version;

  $VersionedPackage({this.architecture, this.packageName, this.version});

  $VersionedPackage.fromJson(core.Map json_)
    : this(
        architecture: json_['architecture'] as core.String?,
        packageName: json_['packageName'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (architecture != null) 'architecture': architecture!,
    if (packageName != null) 'packageName': packageName!,
    if (version != null) 'version': version!,
  };
}

/// Used by:
///
/// - datalabeling:v1beta1 : GoogleCloudDatalabelingV1beta1Vertex
/// - vision:v1 : Vertex
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1Vertex
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1Vertex
class $Vertex00 {
  /// X coordinate.
  core.int? x;

  /// Y coordinate.
  core.int? y;

  $Vertex00({this.x, this.y});

  $Vertex00.fromJson(core.Map json_)
    : this(x: json_['x'] as core.int?, y: json_['y'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
  };
}

/// Used by:
///
/// - contentwarehouse:v1 : GoogleCloudDocumentaiV1Vertex
/// - documentai:v1 : GoogleCloudDocumentaiV1Vertex
/// - documentai:v1beta3 : GoogleCloudDocumentaiV1beta3Vertex
class $Vertex01 {
  /// X coordinate.
  core.int? x;

  /// Y coordinate (starts from the top of the image).
  core.int? y;

  $Vertex01({this.x, this.y});

  $Vertex01.fromJson(core.Map json_)
    : this(x: json_['x'] as core.int?, y: json_['y'] as core.int?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (x != null) 'x': x!,
    if (y != null) 'y': y!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1VertexAISearchDataStoreSpec
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1VertexAISearchDataStoreSpec
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1VertexAISearchDataStoreSpec
class $VertexAISearchDataStoreSpec {
  /// Full resource name of DataStore, such as Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  core.String? dataStore;

  /// Filter specification to filter documents in the data store specified by
  /// data_store field.
  ///
  /// For more information on filtering, see
  /// [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  ///
  /// Optional.
  core.String? filter;

  $VertexAISearchDataStoreSpec({this.dataStore, this.filter});

  $VertexAISearchDataStoreSpec.fromJson(core.Map json_)
    : this(
        dataStore: json_['dataStore'] as core.String?,
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (filter != null) 'filter': filter!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1VertexAiSearchConfig
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1VertexAiSearchConfig
class $VertexAiSearchConfig {
  /// Vertex AI Search Serving Config resource full name.
  ///
  /// For example,
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/servingConfigs/{serving_config}`.
  core.String? servingConfig;

  $VertexAiSearchConfig({this.servingConfig});

  $VertexAiSearchConfig.fromJson(core.Map json_)
    : this(servingConfig: json_['servingConfig'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (servingConfig != null) 'servingConfig': servingConfig!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStoreRagResource
/// - aiplatform:v1 : GoogleCloudAiplatformV1VertexRagStoreRagResource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStoreRagResource
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1VertexRagStoreRagResource
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1VertexRagStoreRagResource
class $VertexRagStoreRagResource {
  /// RagCorpora resource name.
  ///
  /// Format: `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  ///
  /// Optional.
  core.String? ragCorpus;

  /// rag_file_id.
  ///
  /// The files should be in the same rag_corpus set in rag_corpus field.
  ///
  /// Optional.
  core.List<core.String>? ragFileIds;

  $VertexRagStoreRagResource({this.ragCorpus, this.ragFileIds});

  $VertexRagStoreRagResource.fromJson(core.Map json_)
    : this(
        ragCorpus: json_['ragCorpus'] as core.String?,
        ragFileIds:
            (json_['ragFileIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragCorpus != null) 'ragCorpus': ragCorpus!,
    if (ragFileIds != null) 'ragFileIds': ragFileIds!,
  };
}

/// Used by:
///
/// - container:v1 : VerticalPodAutoscaling
/// - container:v1beta1 : VerticalPodAutoscaling
class $VerticalPodAutoscaling {
  /// Enables vertical pod autoscaling.
  core.bool? enabled;

  $VerticalPodAutoscaling({this.enabled});

  $VerticalPodAutoscaling.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : VideoAdInventoryControl
/// - displayvideo:v3 : VideoAdInventoryControl
/// - displayvideo:v4 : VideoAdInventoryControl
class $VideoAdInventoryControl {
  /// Whether ads can serve as in-feed format.
  ///
  /// Optional.
  core.bool? allowInFeed;

  /// Whether ads can serve as in-stream format.
  ///
  /// Optional.
  core.bool? allowInStream;

  /// Whether ads can serve as shorts format.
  ///
  /// Optional.
  core.bool? allowShorts;

  $VideoAdInventoryControl({
    this.allowInFeed,
    this.allowInStream,
    this.allowShorts,
  });

  $VideoAdInventoryControl.fromJson(core.Map json_)
    : this(
        allowInFeed: json_['allowInFeed'] as core.bool?,
        allowInStream: json_['allowInStream'] as core.bool?,
        allowShorts: json_['allowShorts'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowInFeed != null) 'allowInFeed': allowInFeed!,
    if (allowInStream != null) 'allowInStream': allowInStream!,
    if (allowShorts != null) 'allowShorts': allowShorts!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : VideoAdSequenceStep
/// - displayvideo:v3 : VideoAdSequenceStep
/// - displayvideo:v4 : VideoAdSequenceStep
class $VideoAdSequenceStep {
  /// The ID of the corresponding ad group of the step.
  core.String? adGroupId;

  /// The interaction on the previous step that will lead the viewer to this
  /// step.
  ///
  /// The first step does not have interaction_type.
  /// Possible string values are:
  /// - "INTERACTION_TYPE_UNSPECIFIED" : Unspecified or unknown
  /// - "INTERACTION_TYPE_PAID_VIEW" : A paid view.
  /// - "INTERACTION_TYPE_SKIP" : Skipped by the viewer.
  /// - "INTERACTION_TYPE_IMPRESSION" : A (viewed) ad impression.
  /// - "INTERACTION_TYPE_ENGAGED_IMPRESSION" : An ad impression that was not
  /// immediately skipped by the viewer, but didn't reach the billable event
  /// either.
  core.String? interactionType;

  /// The ID of the previous step.
  ///
  /// The first step does not have previous step.
  core.String? previousStepId;

  /// The ID of the step.
  core.String? stepId;

  $VideoAdSequenceStep({
    this.adGroupId,
    this.interactionType,
    this.previousStepId,
    this.stepId,
  });

  $VideoAdSequenceStep.fromJson(core.Map json_)
    : this(
        adGroupId: json_['adGroupId'] as core.String?,
        interactionType: json_['interactionType'] as core.String?,
        previousStepId: json_['previousStepId'] as core.String?,
        stepId: json_['stepId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adGroupId != null) 'adGroupId': adGroupId!,
    if (interactionType != null) 'interactionType': interactionType!,
    if (previousStepId != null) 'previousStepId': previousStepId!,
    if (stepId != null) 'stepId': stepId!,
  };
}

/// Used by:
///
/// - aiplatform:v1 : GoogleCloudAiplatformV1VideoMetadata
/// - aiplatform:v1beta1 : GoogleCloudAiplatformV1beta1VideoMetadata
/// - firebaseml:v2beta : GoogleCloudAiplatformV1beta1VideoMetadata
class $VideoMetadata {
  /// The end offset of the video.
  ///
  /// Optional.
  core.String? endOffset;

  /// The frame rate of the video sent to the model.
  ///
  /// If not specified, the default value will be 1.0. The fps range is (0.0,
  /// 24.0\].
  ///
  /// Optional.
  core.double? fps;

  /// The start offset of the video.
  ///
  /// Optional.
  core.String? startOffset;

  $VideoMetadata({this.endOffset, this.fps, this.startOffset});

  $VideoMetadata.fromJson(core.Map json_)
    : this(
        endOffset: json_['endOffset'] as core.String?,
        fps: (json_['fps'] as core.num?)?.toDouble(),
        startOffset: json_['startOffset'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endOffset != null) 'endOffset': endOffset!,
    if (fps != null) 'fps': fps!,
    if (startOffset != null) 'startOffset': startOffset!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : VideoPlayerSizeAssignedTargetingOptionDetails
/// - displayvideo:v3 : VideoPlayerSizeAssignedTargetingOptionDetails
/// - displayvideo:v4 : VideoPlayerSizeAssignedTargetingOptionDetails
class $VideoPlayerSizeAssignedTargetingOptionDetails {
  /// The video player size.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VIDEO_PLAYER_SIZE_UNSPECIFIED" : Video player size is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real video player size.
  /// - "VIDEO_PLAYER_SIZE_SMALL" : The dimensions of the video player are less
  /// than 400300 (desktop), or up to 20% of screen covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_LARGE" : The dimensions of the video player are
  /// between 400x300 and 1280x720 pixels (desktop), or 20% to 90% of the screen
  /// covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_HD" : The dimensions of the video player are 1280720
  /// or greater (desktop), or over 90% of the screen covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_UNKNOWN" : The dimensions of the video player are
  /// unknown.
  core.String? videoPlayerSize;

  $VideoPlayerSizeAssignedTargetingOptionDetails({this.videoPlayerSize});

  $VideoPlayerSizeAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(videoPlayerSize: json_['videoPlayerSize'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (videoPlayerSize != null) 'videoPlayerSize': videoPlayerSize!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : VideoPlayerSizeTargetingOptionDetails
/// - displayvideo:v3 : VideoPlayerSizeTargetingOptionDetails
/// - displayvideo:v4 : VideoPlayerSizeTargetingOptionDetails
class $VideoPlayerSizeTargetingOptionDetails {
  /// The video player size.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "VIDEO_PLAYER_SIZE_UNSPECIFIED" : Video player size is not specified in
  /// this version. This enum is a place holder for a default value and does not
  /// represent a real video player size.
  /// - "VIDEO_PLAYER_SIZE_SMALL" : The dimensions of the video player are less
  /// than 400300 (desktop), or up to 20% of screen covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_LARGE" : The dimensions of the video player are
  /// between 400x300 and 1280x720 pixels (desktop), or 20% to 90% of the screen
  /// covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_HD" : The dimensions of the video player are 1280720
  /// or greater (desktop), or over 90% of the screen covered (mobile).
  /// - "VIDEO_PLAYER_SIZE_UNKNOWN" : The dimensions of the video player are
  /// unknown.
  core.String? videoPlayerSize;

  $VideoPlayerSizeTargetingOptionDetails({this.videoPlayerSize});

  $VideoPlayerSizeTargetingOptionDetails.fromJson(core.Map json_)
    : this(videoPlayerSize: json_['videoPlayerSize'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (videoPlayerSize != null) 'videoPlayerSize': videoPlayerSize!,
  };
}

/// Used by:
///
/// - videointelligence:v1 : GoogleCloudVideointelligenceV1_VideoSegment
/// - videointelligence:v1beta2 : GoogleCloudVideointelligenceV1beta2_VideoSegment
/// - videointelligence:v1p1beta1 : GoogleCloudVideointelligenceV1p1beta1_VideoSegment
/// - videointelligence:v1p2beta1 : GoogleCloudVideointelligenceV1p2beta1_VideoSegment
/// - videointelligence:v1p3beta1 : GoogleCloudVideointelligenceV1p3beta1_VideoSegment
class $VideoSegment {
  /// Time-offset, relative to the beginning of the video, corresponding to the
  /// end of the segment (inclusive).
  core.String? endTimeOffset;

  /// Time-offset, relative to the beginning of the video, corresponding to the
  /// start of the segment (inclusive).
  core.String? startTimeOffset;

  $VideoSegment({this.endTimeOffset, this.startTimeOffset});

  $VideoSegment.fromJson(core.Map json_)
    : this(
        endTimeOffset: json_['endTimeOffset'] as core.String?,
        startTimeOffset: json_['startTimeOffset'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTimeOffset != null) 'endTimeOffset': endTimeOffset!,
    if (startTimeOffset != null) 'startTimeOffset': startTimeOffset!,
  };
}

/// Used by:
///
/// - authorizedbuyersmarketplace:v1 : VideoTargeting
/// - authorizedbuyersmarketplace:v1alpha : VideoTargeting
class $VideoTargeting {
  /// A list of video positions to be excluded.
  ///
  /// When this field is populated, the targeted_position_types field must be
  /// empty.
  core.List<core.String>? excludedPositionTypes;

  /// A list of video positions to be included.
  ///
  /// When this field is populated, the excluded_position_types field must be
  /// empty.
  core.List<core.String>? targetedPositionTypes;

  $VideoTargeting({this.excludedPositionTypes, this.targetedPositionTypes});

  $VideoTargeting.fromJson(core.Map json_)
    : this(
        excludedPositionTypes:
            (json_['excludedPositionTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        targetedPositionTypes:
            (json_['targetedPositionTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludedPositionTypes != null)
      'excludedPositionTypes': excludedPositionTypes!,
    if (targetedPositionTypes != null)
      'targetedPositionTypes': targetedPositionTypes!,
  };
}

/// Used by:
///
/// - datacatalog:v1 : GoogleCloudDatacatalogV1ViewSpec
/// - datacatalog:v1beta1 : GoogleCloudDatacatalogV1beta1ViewSpec
class $ViewSpec {
  /// The query that defines the table view.
  ///
  /// Output only.
  core.String? viewQuery;

  $ViewSpec({this.viewQuery});

  $ViewSpec.fromJson(core.Map json_)
    : this(viewQuery: json_['viewQuery'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (viewQuery != null) 'viewQuery': viewQuery!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ViewabilityAssignedTargetingOptionDetails
/// - displayvideo:v3 : ViewabilityAssignedTargetingOptionDetails
/// - displayvideo:v4 : ViewabilityAssignedTargetingOptionDetails
class $ViewabilityAssignedTargetingOptionDetails {
  /// The predicted viewability percentage.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VIEWABILITY_UNSPECIFIED" : Default value when viewability is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real viewability option.
  /// - "VIEWABILITY_10_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 10% likely to be viewable.
  /// - "VIEWABILITY_20_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 20% likely to be viewable.
  /// - "VIEWABILITY_30_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 30% likely to be viewable.
  /// - "VIEWABILITY_40_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 40% likely to be viewable.
  /// - "VIEWABILITY_50_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 50% likely to be viewable.
  /// - "VIEWABILITY_60_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 60% likely to be viewable.
  /// - "VIEWABILITY_70_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 70% likely to be viewable.
  /// - "VIEWABILITY_80_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 80% likely to be viewable.
  /// - "VIEWABILITY_90_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 90% likely to be viewable.
  core.String? viewability;

  $ViewabilityAssignedTargetingOptionDetails({this.viewability});

  $ViewabilityAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(viewability: json_['viewability'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (viewability != null) 'viewability': viewability!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : ViewabilityTargetingOptionDetails
/// - displayvideo:v3 : ViewabilityTargetingOptionDetails
/// - displayvideo:v4 : ViewabilityTargetingOptionDetails
class $ViewabilityTargetingOptionDetails {
  /// The predicted viewability percentage.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "VIEWABILITY_UNSPECIFIED" : Default value when viewability is not
  /// specified in this version. This enum is a placeholder for default value
  /// and does not represent a real viewability option.
  /// - "VIEWABILITY_10_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 10% likely to be viewable.
  /// - "VIEWABILITY_20_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 20% likely to be viewable.
  /// - "VIEWABILITY_30_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 30% likely to be viewable.
  /// - "VIEWABILITY_40_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 40% likely to be viewable.
  /// - "VIEWABILITY_50_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 50% likely to be viewable.
  /// - "VIEWABILITY_60_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 60% likely to be viewable.
  /// - "VIEWABILITY_70_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 70% likely to be viewable.
  /// - "VIEWABILITY_80_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 80% likely to be viewable.
  /// - "VIEWABILITY_90_PERCENT_OR_MORE" : Bid only on impressions that are at
  /// least 90% likely to be viewable.
  core.String? viewability;

  $ViewabilityTargetingOptionDetails({this.viewability});

  $ViewabilityTargetingOptionDetails.fromJson(core.Map json_)
    : this(viewability: json_['viewability'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (viewability != null) 'viewability': viewability!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : ViolatingResource
/// - websecurityscanner:v1alpha : ViolatingResource
/// - websecurityscanner:v1beta : ViolatingResource
class $ViolatingResource {
  /// The MIME type of this resource.
  core.String? contentType;

  /// URL of this violating resource.
  core.String? resourceUrl;

  $ViolatingResource({this.contentType, this.resourceUrl});

  $ViolatingResource.fromJson(core.Map json_)
    : this(
        contentType: json_['contentType'] as core.String?,
        resourceUrl: json_['resourceUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentType != null) 'contentType': contentType!,
    if (resourceUrl != null) 'resourceUrl': resourceUrl!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1ViolationExceptionContext
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1ViolationExceptionContext
class $ViolationExceptionContext {
  /// Timestamp when the violation was acknowledged.
  core.String? acknowledgementTime;

  /// Business justification provided towards the acknowledgement of the
  /// violation.
  core.String? comment;

  /// Name of the user (or service account) who acknowledged the violation.
  core.String? userName;

  $ViolationExceptionContext({
    this.acknowledgementTime,
    this.comment,
    this.userName,
  });

  $ViolationExceptionContext.fromJson(core.Map json_)
    : this(
        acknowledgementTime: json_['acknowledgementTime'] as core.String?,
        comment: json_['comment'] as core.String?,
        userName: json_['userName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acknowledgementTime != null)
      'acknowledgementTime': acknowledgementTime!,
    if (comment != null) 'comment': comment!,
    if (userName != null) 'userName': userName!,
  };
}

/// Used by:
///
/// - container:v1 : VirtualNIC
/// - container:v1beta1 : VirtualNIC
class $VirtualNIC {
  /// Whether gVNIC features are enabled in the node pool.
  core.bool? enabled;

  $VirtualNIC({this.enabled});

  $VirtualNIC.fromJson(core.Map json_)
    : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : VmAttachmentDetails
/// - vmmigration:v1alpha1 : VmAttachmentDetails
class $VmAttachmentDetails {
  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance.
  ///
  /// If not specified, the server chooses a default device name to apply to
  /// this disk, in the form persistent-disk-x, where x is a number assigned by
  /// Google Compute Engine. This field is only applicable for persistent disks.
  ///
  /// Optional.
  core.String? deviceName;

  $VmAttachmentDetails({this.deviceName});

  $VmAttachmentDetails.fromJson(core.Map json_)
    : this(deviceName: json_['deviceName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceName != null) 'deviceName': deviceName!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : VmCapabilities
/// - vmmigration:v1alpha1 : VmCapabilities
class $VmCapabilities {
  /// The last time OS capabilities list was updated.
  ///
  /// Output only.
  core.String? lastOsCapabilitiesUpdateTime;

  /// Unordered list.
  ///
  /// List of certain VM OS capabilities needed for some Compute Engine
  /// features.
  ///
  /// Output only.
  core.List<core.String>? osCapabilities;

  $VmCapabilities({this.lastOsCapabilitiesUpdateTime, this.osCapabilities});

  $VmCapabilities.fromJson(core.Map json_)
    : this(
        lastOsCapabilitiesUpdateTime:
            json_['lastOsCapabilitiesUpdateTime'] as core.String?,
        osCapabilities:
            (json_['osCapabilities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastOsCapabilitiesUpdateTime != null)
      'lastOsCapabilitiesUpdateTime': lastOsCapabilitiesUpdateTime!,
    if (osCapabilities != null) 'osCapabilities': osCapabilities!,
  };
}

/// Used by:
///
/// - datamigration:v1 : VmCreationConfig
/// - datamigration:v1beta1 : VmCreationConfig
class $VmCreationConfig {
  /// The subnet name the vm needs to be created in.
  core.String? subnet;

  /// VM instance machine type to create.
  ///
  /// Required.
  core.String? vmMachineType;

  /// The Google Cloud Platform zone to create the VM in.
  core.String? vmZone;

  $VmCreationConfig({this.subnet, this.vmMachineType, this.vmZone});

  $VmCreationConfig.fromJson(core.Map json_)
    : this(
        subnet: json_['subnet'] as core.String?,
        vmMachineType: json_['vmMachineType'] as core.String?,
        vmZone: json_['vmZone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (subnet != null) 'subnet': subnet!,
    if (vmMachineType != null) 'vmMachineType': vmMachineType!,
    if (vmZone != null) 'vmZone': vmZone!,
  };
}

/// Used by:
///
/// - compute:alpha : VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings
/// - compute:beta : VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings
/// - compute:v1 : VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings
class $VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings {
  /// List of all drain IP:port-range mappings assigned to this interface by
  /// this rule.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? drainNatIpPortRanges;

  /// A list of all IP:port-range mappings assigned to this interface by this
  /// rule.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? natIpPortRanges;

  /// Total number of drain ports across all NAT IPs allocated to this interface
  /// by this rule.
  ///
  /// It equals the aggregated port number in the field
  /// drain_nat_ip_port_ranges.
  core.int? numTotalDrainNatPorts;

  /// Total number of ports across all NAT IPs allocated to this interface by
  /// this rule.
  ///
  /// It equals the aggregated port number in the field nat_ip_port_ranges.
  core.int? numTotalNatPorts;

  /// Rule number of the NAT Rule.
  core.int? ruleNumber;

  $VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings({
    this.drainNatIpPortRanges,
    this.natIpPortRanges,
    this.numTotalDrainNatPorts,
    this.numTotalNatPorts,
    this.ruleNumber,
  });

  $VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings.fromJson(
    core.Map json_,
  ) : this(
        drainNatIpPortRanges:
            (json_['drainNatIpPortRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        natIpPortRanges:
            (json_['natIpPortRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        numTotalDrainNatPorts: json_['numTotalDrainNatPorts'] as core.int?,
        numTotalNatPorts: json_['numTotalNatPorts'] as core.int?,
        ruleNumber: json_['ruleNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (drainNatIpPortRanges != null)
      'drainNatIpPortRanges': drainNatIpPortRanges!,
    if (natIpPortRanges != null) 'natIpPortRanges': natIpPortRanges!,
    if (numTotalDrainNatPorts != null)
      'numTotalDrainNatPorts': numTotalDrainNatPorts!,
    if (numTotalNatPorts != null) 'numTotalNatPorts': numTotalNatPorts!,
    if (ruleNumber != null) 'ruleNumber': ruleNumber!,
  };
}

/// Used by:
///
/// - datamigration:v1 : VmSelectionConfig
/// - datamigration:v1beta1 : VmSelectionConfig
class $VmSelectionConfig {
  /// The Google Cloud Platform zone the VM is located.
  ///
  /// Required.
  core.String? vmZone;

  $VmSelectionConfig({this.vmZone});

  $VmSelectionConfig.fromJson(core.Map json_)
    : this(vmZone: json_['vmZone'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vmZone != null) 'vmZone': vmZone!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : VmwareDiskDetails
/// - vmmigration:v1alpha1 : VmwareDiskDetails
class $VmwareDiskDetails {
  /// The ordinal number of the disk.
  ///
  /// Output only.
  core.int? diskNumber;

  /// The disk label.
  ///
  /// Output only.
  core.String? label;

  /// Size in GB.
  ///
  /// Output only.
  core.String? sizeGb;

  $VmwareDiskDetails({this.diskNumber, this.label, this.sizeGb});

  $VmwareDiskDetails.fromJson(core.Map json_)
    : this(
        diskNumber: json_['diskNumber'] as core.int?,
        label: json_['label'] as core.String?,
        sizeGb: json_['sizeGb'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (diskNumber != null) 'diskNumber': diskNumber!,
    if (label != null) 'label': label!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
  };
}

/// Used by:
///
/// - vmmigration:v1 : VmwareSourceDetails
/// - vmmigration:v1alpha1 : VmwareSourceDetails
class $VmwareSourceDetails {
  /// Input only.
  ///
  /// The credentials password. This is write only and can not be read in a GET
  /// operation.
  core.String? password;

  /// The hostname of the vcenter.
  core.String? resolvedVcenterHost;

  /// The thumbprint representing the certificate for the vcenter.
  core.String? thumbprint;

  /// The credentials username.
  core.String? username;

  /// The ip address of the vcenter this Source represents.
  core.String? vcenterIp;

  $VmwareSourceDetails({
    this.password,
    this.resolvedVcenterHost,
    this.thumbprint,
    this.username,
    this.vcenterIp,
  });

  $VmwareSourceDetails.fromJson(core.Map json_)
    : this(
        password: json_['password'] as core.String?,
        resolvedVcenterHost: json_['resolvedVcenterHost'] as core.String?,
        thumbprint: json_['thumbprint'] as core.String?,
        username: json_['username'] as core.String?,
        vcenterIp: json_['vcenterIp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (password != null) 'password': password!,
    if (resolvedVcenterHost != null)
      'resolvedVcenterHost': resolvedVcenterHost!,
    if (thumbprint != null) 'thumbprint': thumbprint!,
    if (username != null) 'username': username!,
    if (vcenterIp != null) 'vcenterIp': vcenterIp!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : Voice
/// - texttospeech:v1beta1 : Voice
class $Voice {
  /// The languages that this voice supports, expressed as
  /// \[BCP-47\](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags
  /// (e.g. "en-US", "es-419", "cmn-tw").
  core.List<core.String>? languageCodes;

  /// The name of this voice.
  ///
  /// Each distinct voice has a unique name.
  core.String? name;

  /// The natural sample rate (in hertz) for this voice.
  core.int? naturalSampleRateHertz;

  /// The gender of this voice.
  /// Possible string values are:
  /// - "SSML_VOICE_GENDER_UNSPECIFIED" : An unspecified gender. In
  /// VoiceSelectionParams, this means that the client doesn't care which gender
  /// the selected voice will have. In the Voice field of ListVoicesResponse,
  /// this may mean that the voice doesn't fit any of the other categories in
  /// this enum, or that the gender of the voice isn't known.
  /// - "MALE" : A male voice.
  /// - "FEMALE" : A female voice.
  /// - "NEUTRAL" : A gender-neutral voice. This voice is not yet supported.
  core.String? ssmlGender;

  $Voice({
    this.languageCodes,
    this.name,
    this.naturalSampleRateHertz,
    this.ssmlGender,
  });

  $Voice.fromJson(core.Map json_)
    : this(
        languageCodes:
            (json_['languageCodes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        naturalSampleRateHertz: json_['naturalSampleRateHertz'] as core.int?,
        ssmlGender: json_['ssmlGender'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCodes != null) 'languageCodes': languageCodes!,
    if (name != null) 'name': name!,
    if (naturalSampleRateHertz != null)
      'naturalSampleRateHertz': naturalSampleRateHertz!,
    if (ssmlGender != null) 'ssmlGender': ssmlGender!,
  };
}

/// Used by:
///
/// - texttospeech:v1 : VoiceCloneParams
/// - texttospeech:v1beta1 : VoiceCloneParams
class $VoiceCloneParams {
  /// Created by GenerateVoiceCloningKey.
  ///
  /// Required.
  core.String? voiceCloningKey;

  $VoiceCloneParams({this.voiceCloningKey});

  $VoiceCloneParams.fromJson(core.Map json_)
    : this(voiceCloningKey: json_['voiceCloningKey'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (voiceCloningKey != null) 'voiceCloningKey': voiceCloningKey!,
  };
}

/// Used by:
///
/// - dialogflow:v2beta1 : GoogleCloudDialogflowV2beta1VoiceSelectionParams
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1VoiceSelectionParams
class $VoiceSelectionParams {
  /// The name of the voice.
  ///
  /// If not set, the service will choose a voice based on the other parameters
  /// such as language_code and ssml_gender. For the list of available voices,
  /// please refer to
  /// [Supported voices and languages](https://cloud.google.com/text-to-speech/docs/voices).
  ///
  /// Optional.
  core.String? name;

  /// The preferred gender of the voice.
  ///
  /// If not set, the service will choose a voice based on the other parameters
  /// such as language_code and name. Note that this is only a preference, not
  /// requirement. If a voice of the appropriate gender is not available, the
  /// synthesizer should substitute a voice with a different gender rather than
  /// failing the request.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SSML_VOICE_GENDER_UNSPECIFIED" : An unspecified gender, which means
  /// that the client doesn't care which gender the selected voice will have.
  /// - "SSML_VOICE_GENDER_MALE" : A male voice.
  /// - "SSML_VOICE_GENDER_FEMALE" : A female voice.
  /// - "SSML_VOICE_GENDER_NEUTRAL" : A gender-neutral voice.
  core.String? ssmlGender;

  $VoiceSelectionParams({this.name, this.ssmlGender});

  $VoiceSelectionParams.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        ssmlGender: json_['ssmlGender'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (ssmlGender != null) 'ssmlGender': ssmlGender!,
  };
}

/// Used by:
///
/// - appengine:v1 : Volume
/// - appengine:v1beta : Volume
class $Volume {
  /// Unique name for the volume.
  core.String? name;

  /// Volume size in gigabytes.
  core.double? sizeGb;

  /// Underlying volume type, e.g. 'tmpfs'.
  core.String? volumeType;

  $Volume({this.name, this.sizeGb, this.volumeType});

  $Volume.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        sizeGb: (json_['sizeGb'] as core.num?)?.toDouble(),
        volumeType: json_['volumeType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (sizeGb != null) 'sizeGb': sizeGb!,
    if (volumeType != null) 'volumeType': volumeType!,
  };
}

/// Used by:
///
/// - appengine:v1 : VpcAccessConnector
/// - appengine:v1beta : VpcAccessConnector
class $VpcAccessConnector {
  /// The egress setting for the connector, controlling what traffic is diverted
  /// through it.
  /// Possible string values are:
  /// - "EGRESS_SETTING_UNSPECIFIED"
  /// - "ALL_TRAFFIC" : Force the use of VPC Access for all egress traffic from
  /// the function.
  /// - "PRIVATE_IP_RANGES" : Use the VPC Access Connector for private IP space
  /// from RFC1918.
  core.String? egressSetting;

  /// Full Serverless VPC Access Connector name e.g.
  /// projects/my-project/locations/us-central1/connectors/c1.
  core.String? name;

  $VpcAccessConnector({this.egressSetting, this.name});

  $VpcAccessConnector.fromJson(core.Map json_)
    : this(
        egressSetting: json_['egressSetting'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (egressSetting != null) 'egressSetting': egressSetting!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : VpcAccessibleServices
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1VpcAccessibleServices
class $VpcAccessibleServices {
  /// The list of APIs usable within the Service Perimeter.
  ///
  /// Must be empty unless 'enable_restriction' is True. You can specify a list
  /// of individual services, as well as include the 'RESTRICTED-SERVICES'
  /// value, which automatically includes all of the services protected by the
  /// perimeter.
  core.List<core.String>? allowedServices;

  /// Whether to restrict API calls within the Service Perimeter to the list of
  /// APIs specified in 'allowed_services'.
  core.bool? enableRestriction;

  $VpcAccessibleServices({this.allowedServices, this.enableRestriction});

  $VpcAccessibleServices.fromJson(core.Map json_)
    : this(
        allowedServices:
            (json_['allowedServices'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        enableRestriction: json_['enableRestriction'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowedServices != null) 'allowedServices': allowedServices!,
    if (enableRestriction != null) 'enableRestriction': enableRestriction!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : VpcConnectorInfo
/// - networkmanagement:v1beta1 : VpcConnectorInfo
class $VpcConnectorInfo {
  /// Name of a VPC connector.
  core.String? displayName;

  /// Location in which the VPC connector is deployed.
  core.String? location;

  /// URI of a VPC connector.
  core.String? uri;

  $VpcConnectorInfo({this.displayName, this.location, this.uri});

  $VpcConnectorInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        location: json_['location'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (location != null) 'location': location!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - datamigration:v1 : VpcPeeringConnectivity
/// - datamigration:v1beta1 : VpcPeeringConnectivity
class $VpcPeeringConnectivity {
  /// The name of the VPC network to peer with the Cloud SQL private network.
  core.String? vpc;

  $VpcPeeringConnectivity({this.vpc});

  $VpcPeeringConnectivity.fromJson(core.Map json_)
    : this(vpc: json_['vpc'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vpc != null) 'vpc': vpc!,
  };
}

/// Used by:
///
/// - servicenetworking:v1 : DisableVpcServiceControlsRequest
/// - servicenetworking:v1 : EnableVpcServiceControlsRequest
class $VpcServiceControlsRequest {
  /// The network that the consumer is using to connect with services.
  ///
  /// Must be in the form of projects/{project}/global/networks/{network}
  /// {project} is a project number, as in '12345' {network} is network name.
  ///
  /// Required.
  core.String? consumerNetwork;

  $VpcServiceControlsRequest({this.consumerNetwork});

  $VpcServiceControlsRequest.fromJson(core.Map json_)
    : this(consumerNetwork: json_['consumerNetwork'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (consumerNetwork != null) 'consumerNetwork': consumerNetwork!,
  };
}

/// Used by:
///
/// - accesscontextmanager:v1 : VpcSubNetwork
/// - cloudasset:v1 : GoogleIdentityAccesscontextmanagerV1VpcSubNetwork
/// - cloudasset:v1beta1 : GoogleIdentityAccesscontextmanagerV1VpcSubNetwork
/// - cloudasset:v1p5beta1 : GoogleIdentityAccesscontextmanagerV1VpcSubNetwork
class $VpcSubNetwork {
  /// Network name.
  ///
  /// If the network is not part of the organization, the `compute.network.get`
  /// permission must be granted to the caller. Format:
  /// `//compute.googleapis.com/projects/{PROJECT_ID}/global/networks/{NETWORK_NAME}`
  /// Example:
  /// `//compute.googleapis.com/projects/my-project/global/networks/network-1`
  ///
  /// Required.
  core.String? network;

  /// CIDR block IP subnetwork specification.
  ///
  /// The IP address must be an IPv4 address and can be a public or private IP
  /// address. Note that for a CIDR IP address block, the specified IP address
  /// portion must be properly truncated (i.e. all the host bits must be zero)
  /// or the input is considered malformed. For example, "192.0.2.0/24" is
  /// accepted but "192.0.2.1/24" is not. If empty, all IP addresses are
  /// allowed.
  core.List<core.String>? vpcIpSubnetworks;

  $VpcSubNetwork({this.network, this.vpcIpSubnetworks});

  $VpcSubNetwork.fromJson(core.Map json_)
    : this(
        network: json_['network'] as core.String?,
        vpcIpSubnetworks:
            (json_['vpcIpSubnetworks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (network != null) 'network': network!,
    if (vpcIpSubnetworks != null) 'vpcIpSubnetworks': vpcIpSubnetworks!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : VpnGatewayInfo
/// - networkmanagement:v1beta1 : VpnGatewayInfo
class $VpnGatewayInfo {
  /// Name of a VPN gateway.
  core.String? displayName;

  /// IP address of the VPN gateway.
  core.String? ipAddress;

  /// URI of a Compute Engine network where the VPN gateway is configured.
  core.String? networkUri;

  /// Name of a Google Cloud region where this VPN gateway is configured.
  core.String? region;

  /// URI of a VPN gateway.
  core.String? uri;

  /// A VPN tunnel that is associated with this VPN gateway.
  ///
  /// There may be multiple VPN tunnels configured on a VPN gateway, and only
  /// the one relevant to the test is displayed.
  core.String? vpnTunnelUri;

  $VpnGatewayInfo({
    this.displayName,
    this.ipAddress,
    this.networkUri,
    this.region,
    this.uri,
    this.vpnTunnelUri,
  });

  $VpnGatewayInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        region: json_['region'] as core.String?,
        uri: json_['uri'] as core.String?,
        vpnTunnelUri: json_['vpnTunnelUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (region != null) 'region': region!,
    if (uri != null) 'uri': uri!,
    if (vpnTunnelUri != null) 'vpnTunnelUri': vpnTunnelUri!,
  };
}

/// Used by:
///
/// - compute:alpha : VpnGatewayStatusHighAvailabilityRequirementState
/// - compute:beta : VpnGatewayStatusHighAvailabilityRequirementState
/// - compute:v1 : VpnGatewayStatusHighAvailabilityRequirementState
class $VpnGatewayStatusHighAvailabilityRequirementState {
  /// Indicates the high availability requirement state for the VPN connection.
  ///
  /// Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
  /// Possible string values are:
  /// - "CONNECTION_REDUNDANCY_MET" : VPN tunnels are configured with adequate
  /// redundancy from Cloud VPN gateway to the peer VPN gateway. For both
  /// GCP-to-non-GCP and GCP-to-GCP connections, the adequate redundancy is a
  /// pre-requirement for users to get 99.99% availability on GCP side; please
  /// note that for any connection, end-to-end 99.99% availability is subject to
  /// proper configuration on the peer VPN gateway.
  /// - "CONNECTION_REDUNDANCY_NOT_MET" : VPN tunnels are not configured with
  /// adequate redundancy from the Cloud VPN gateway to the peer gateway
  core.String? state;

  /// Indicates the reason why the VPN connection does not meet the high
  /// availability redundancy criteria/requirement.
  ///
  /// Valid values is INCOMPLETE_TUNNELS_COVERAGE.
  /// Possible string values are:
  /// - "INCOMPLETE_TUNNELS_COVERAGE"
  core.String? unsatisfiedReason;

  $VpnGatewayStatusHighAvailabilityRequirementState({
    this.state,
    this.unsatisfiedReason,
  });

  $VpnGatewayStatusHighAvailabilityRequirementState.fromJson(core.Map json_)
    : this(
        state: json_['state'] as core.String?,
        unsatisfiedReason: json_['unsatisfiedReason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (state != null) 'state': state!,
    if (unsatisfiedReason != null) 'unsatisfiedReason': unsatisfiedReason!,
  };
}

/// Used by:
///
/// - compute:alpha : VpnGatewayStatusTunnel
/// - compute:beta : VpnGatewayStatusTunnel
/// - compute:v1 : VpnGatewayStatusTunnel
class $VpnGatewayStatusTunnel {
  /// The VPN gateway interface this VPN tunnel is associated with.
  core.int? localGatewayInterface;

  /// The peer gateway interface this VPN tunnel is connected to, the peer
  /// gateway could either be an external VPN gateway or a Google Cloud VPN
  /// gateway.
  core.int? peerGatewayInterface;

  /// URL reference to the VPN tunnel.
  core.String? tunnelUrl;

  $VpnGatewayStatusTunnel({
    this.localGatewayInterface,
    this.peerGatewayInterface,
    this.tunnelUrl,
  });

  $VpnGatewayStatusTunnel.fromJson(core.Map json_)
    : this(
        localGatewayInterface: json_['localGatewayInterface'] as core.int?,
        peerGatewayInterface: json_['peerGatewayInterface'] as core.int?,
        tunnelUrl: json_['tunnelUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (localGatewayInterface != null)
      'localGatewayInterface': localGatewayInterface!,
    if (peerGatewayInterface != null)
      'peerGatewayInterface': peerGatewayInterface!,
    if (tunnelUrl != null) 'tunnelUrl': tunnelUrl!,
  };
}

/// Used by:
///
/// - compute:alpha : VpnGatewayVpnGatewayInterface
/// - compute:beta : VpnGatewayVpnGatewayInterface
/// - compute:v1 : VpnGatewayVpnGatewayInterface
class $VpnGatewayVpnGatewayInterface {
  /// Numeric identifier for this VPN interface associated with the VPN gateway.
  ///
  /// Output only.
  core.int? id;

  /// URL of the VLAN attachment (interconnectAttachment) resource for this VPN
  /// gateway interface.
  ///
  /// When the value of this field is present, the VPN gateway is used for HA
  /// VPN over Cloud Interconnect; all egress or ingress traffic for this VPN
  /// gateway interface goes through the specified VLAN attachment resource.
  core.String? interconnectAttachment;

  /// IP address for this VPN interface associated with the VPN gateway.
  ///
  /// The IP address could be either a regional external IP address or a
  /// regional internal IP address. The two IP addresses for a VPN gateway must
  /// be all regional external or regional internal IP addresses. There cannot
  /// be a mix of regional external IP addresses and regional internal IP
  /// addresses. For HA VPN over Cloud Interconnect, the IP addresses for both
  /// interfaces could either be regional internal IP addresses or regional
  /// external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA
  /// VPN tunnels, the IP address must be a regional external IP address.
  ///
  /// Output only.
  core.String? ipAddress;

  /// IPv6 address for this VPN interface associated with the VPN gateway.
  ///
  /// The IPv6 address must be a regional external IPv6 address. The format is
  /// RFC 5952 format (e.g. 2001:db8::2d9:51:0:0).
  ///
  /// Output only.
  core.String? ipv6Address;

  $VpnGatewayVpnGatewayInterface({
    this.id,
    this.interconnectAttachment,
    this.ipAddress,
    this.ipv6Address,
  });

  $VpnGatewayVpnGatewayInterface.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.int?,
        interconnectAttachment: json_['interconnectAttachment'] as core.String?,
        ipAddress: json_['ipAddress'] as core.String?,
        ipv6Address: json_['ipv6Address'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (interconnectAttachment != null)
      'interconnectAttachment': interconnectAttachment!,
    if (ipAddress != null) 'ipAddress': ipAddress!,
    if (ipv6Address != null) 'ipv6Address': ipv6Address!,
  };
}

/// Used by:
///
/// - networkmanagement:v1 : VpnTunnelInfo
/// - networkmanagement:v1beta1 : VpnTunnelInfo
class $VpnTunnelInfo {
  /// Name of a VPN tunnel.
  core.String? displayName;

  /// URI of a Compute Engine network where the VPN tunnel is configured.
  core.String? networkUri;

  /// Name of a Google Cloud region where this VPN tunnel is configured.
  core.String? region;

  /// URI of a VPN gateway at remote end of the tunnel.
  core.String? remoteGateway;

  /// Remote VPN gateway's IP address.
  core.String? remoteGatewayIp;

  /// Type of the routing policy.
  /// Possible string values are:
  /// - "ROUTING_TYPE_UNSPECIFIED" : Unspecified type. Default value.
  /// - "ROUTE_BASED" : Route based VPN.
  /// - "POLICY_BASED" : Policy based routing.
  /// - "DYNAMIC" : Dynamic (BGP) routing.
  core.String? routingType;

  /// URI of the VPN gateway at local end of the tunnel.
  core.String? sourceGateway;

  /// Local VPN gateway's IP address.
  core.String? sourceGatewayIp;

  /// URI of a VPN tunnel.
  core.String? uri;

  $VpnTunnelInfo({
    this.displayName,
    this.networkUri,
    this.region,
    this.remoteGateway,
    this.remoteGatewayIp,
    this.routingType,
    this.sourceGateway,
    this.sourceGatewayIp,
    this.uri,
  });

  $VpnTunnelInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        networkUri: json_['networkUri'] as core.String?,
        region: json_['region'] as core.String?,
        remoteGateway: json_['remoteGateway'] as core.String?,
        remoteGatewayIp: json_['remoteGatewayIp'] as core.String?,
        routingType: json_['routingType'] as core.String?,
        sourceGateway: json_['sourceGateway'] as core.String?,
        sourceGatewayIp: json_['sourceGatewayIp'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (networkUri != null) 'networkUri': networkUri!,
    if (region != null) 'region': region!,
    if (remoteGateway != null) 'remoteGateway': remoteGateway!,
    if (remoteGatewayIp != null) 'remoteGatewayIp': remoteGatewayIp!,
    if (routingType != null) 'routingType': routingType!,
    if (sourceGateway != null) 'sourceGateway': sourceGateway!,
    if (sourceGatewayIp != null) 'sourceGatewayIp': sourceGatewayIp!,
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - compute:alpha : VpnTunnelPhase1Algorithms
/// - compute:beta : VpnTunnelPhase1Algorithms
class $VpnTunnelPhase1Algorithms {
  core.List<core.String>? dh;
  core.List<core.String>? encryption;
  core.List<core.String>? integrity;
  core.List<core.String>? prf;

  $VpnTunnelPhase1Algorithms({
    this.dh,
    this.encryption,
    this.integrity,
    this.prf,
  });

  $VpnTunnelPhase1Algorithms.fromJson(core.Map json_)
    : this(
        dh:
            (json_['dh'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        encryption:
            (json_['encryption'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        integrity:
            (json_['integrity'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        prf:
            (json_['prf'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dh != null) 'dh': dh!,
    if (encryption != null) 'encryption': encryption!,
    if (integrity != null) 'integrity': integrity!,
    if (prf != null) 'prf': prf!,
  };
}

/// Used by:
///
/// - compute:alpha : VpnTunnelPhase2Algorithms
/// - compute:beta : VpnTunnelPhase2Algorithms
class $VpnTunnelPhase2Algorithms {
  core.List<core.String>? encryption;
  core.List<core.String>? integrity;
  core.List<core.String>? pfs;

  $VpnTunnelPhase2Algorithms({this.encryption, this.integrity, this.pfs});

  $VpnTunnelPhase2Algorithms.fromJson(core.Map json_)
    : this(
        encryption:
            (json_['encryption'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        integrity:
            (json_['integrity'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pfs:
            (json_['pfs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encryption != null) 'encryption': encryption!,
    if (integrity != null) 'integrity': integrity!,
    if (pfs != null) 'pfs': pfs!,
  };
}

/// Used by:
///
/// - osconfig:v1 : VulnerabilityReportVulnerabilityDetailsReference
/// - osconfig:v1alpha : VulnerabilityReportVulnerabilityDetailsReference
class $VulnerabilityReportVulnerabilityDetailsReference {
  /// The source of the reference e.g. NVD.
  core.String? source;

  /// The url of the reference.
  core.String? url;

  $VulnerabilityReportVulnerabilityDetailsReference({this.source, this.url});

  $VulnerabilityReportVulnerabilityDetailsReference.fromJson(core.Map json_)
    : this(
        source: json_['source'] as core.String?,
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (source != null) 'source': source!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - osconfig:v1 : VulnerabilityReportVulnerabilityItem
/// - osconfig:v1alpha : VulnerabilityReportVulnerabilityItem
class $VulnerabilityReportVulnerabilityItem {
  /// Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
  ///
  /// If the vulnerability report was not updated after the VM inventory update,
  /// these values might not display in VM inventory. If there is no available
  /// fix, the field is empty. The `inventory_item` value specifies the latest
  /// `SoftwarePackage` available to the VM that fixes the vulnerability.
  core.String? availableInventoryItemId;

  /// The recommended [CPE URI](https://cpe.mitre.org/specification/) update
  /// that contains a fix for this vulnerability.
  core.String? fixedCpeUri;

  /// Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
  ///
  /// This field displays the inventory items affected by this vulnerability. If
  /// the vulnerability report was not updated after the VM inventory update,
  /// these values might not display in VM inventory. For some operating
  /// systems, this field might be empty.
  core.String? installedInventoryItemId;

  /// The upstream OS patch, packages or KB that fixes the vulnerability.
  core.String? upstreamFix;

  $VulnerabilityReportVulnerabilityItem({
    this.availableInventoryItemId,
    this.fixedCpeUri,
    this.installedInventoryItemId,
    this.upstreamFix,
  });

  $VulnerabilityReportVulnerabilityItem.fromJson(core.Map json_)
    : this(
        availableInventoryItemId:
            json_['availableInventoryItemId'] as core.String?,
        fixedCpeUri: json_['fixedCpeUri'] as core.String?,
        installedInventoryItemId:
            json_['installedInventoryItemId'] as core.String?,
        upstreamFix: json_['upstreamFix'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (availableInventoryItemId != null)
      'availableInventoryItemId': availableInventoryItemId!,
    if (fixedCpeUri != null) 'fixedCpeUri': fixedCpeUri!,
    if (installedInventoryItemId != null)
      'installedInventoryItemId': installedInventoryItemId!,
    if (upstreamFix != null) 'upstreamFix': upstreamFix!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : VulnerableParameters
/// - websecurityscanner:v1alpha : VulnerableParameters
/// - websecurityscanner:v1beta : VulnerableParameters
class $VulnerableParameters {
  /// The vulnerable parameter names.
  core.List<core.String>? parameterNames;

  $VulnerableParameters({this.parameterNames});

  $VulnerableParameters.fromJson(core.Map json_)
    : this(
        parameterNames:
            (json_['parameterNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parameterNames != null) 'parameterNames': parameterNames!,
  };
}

/// Used by:
///
/// - compute:alpha : WafExpressionSetExpression
/// - compute:beta : WafExpressionSetExpression
/// - compute:v1 : WafExpressionSetExpression
class $WafExpressionSetExpression {
  /// Expression ID should uniquely identify the origin of the expression.
  ///
  /// E.g. owasp-crs-v020901-id973337 identifies Owasp core rule set version
  /// 2.9.1 rule id 973337. The ID could be used to determine the individual
  /// attack definition that has been detected. It could also be used to exclude
  /// it from the policy in case of false positive. required
  core.String? id;

  /// The sensitivity value associated with the WAF rule ID.
  ///
  /// This corresponds to the ModSecurity paranoia level, ranging from 1 to 4. 0
  /// is reserved for opt-in only rules.
  core.int? sensitivity;

  $WafExpressionSetExpression({this.id, this.sensitivity});

  $WafExpressionSetExpression.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        sensitivity: json_['sensitivity'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (sensitivity != null) 'sensitivity': sensitivity!,
  };
}

/// Used by:
///
/// - compute:alpha : RegionWaitForReplicationCatchUpRequest
/// - compute:alpha : WaitForReplicationCatchUpRequest
class $WaitForReplicationCatchUpRequest {
  core.String? maxWaitDuration;

  $WaitForReplicationCatchUpRequest({this.maxWaitDuration});

  $WaitForReplicationCatchUpRequest.fromJson(core.Map json_)
    : this(maxWaitDuration: json_['maxWaitDuration'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxWaitDuration != null) 'maxWaitDuration': maxWaitDuration!,
  };
}

/// Used by:
///
/// - checks:v1alpha : WaitOperationRequest
/// - firebaseappdistribution:v1 : GoogleLongrunningWaitOperationRequest
/// - run:v1 : GoogleLongrunningWaitOperationRequest
/// - run:v2 : GoogleLongrunningWaitOperationRequest
/// - translate:v3 : WaitOperationRequest
/// - translate:v3beta1 : WaitOperationRequest
class $WaitOperationRequest {
  /// The maximum duration to wait before timing out.
  ///
  /// If left blank, the wait will be at most the time permitted by the
  /// underlying HTTP/RPC protocol. If RPC context deadline is also specified,
  /// the shorter one will be used.
  core.String? timeout;

  $WaitOperationRequest({this.timeout});

  $WaitOperationRequest.fromJson(core.Map json_)
    : this(timeout: json_['timeout'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeout != null) 'timeout': timeout!,
  };
}

/// Used by:
///
/// - networkservices:v1 : WasmPluginLogConfig
/// - networkservices:v1beta1 : WasmPluginLogConfig
class $WasmPluginLogConfig {
  /// Specifies whether to enable logging for activity by this plugin.
  ///
  /// Defaults to `false`.
  ///
  /// Optional.
  core.bool? enable;

  /// Non-empty default.
  ///
  /// Specifies the lowest level of the plugin logs that are exported to Cloud
  /// Logging. This setting relates to the logs generated by using logging
  /// statements in your Wasm code. This field is can be set only if logging is
  /// enabled for the plugin. If the field is not provided when logging is
  /// enabled, it is set to `INFO` by default.
  /// Possible string values are:
  /// - "LOG_LEVEL_UNSPECIFIED" : Unspecified value. Defaults to
  /// `LogLevel.INFO`.
  /// - "TRACE" : Report logs with TRACE level and above.
  /// - "DEBUG" : Report logs with DEBUG level and above.
  /// - "INFO" : Report logs with INFO level and above.
  /// - "WARN" : Report logs with WARN level and above.
  /// - "ERROR" : Report logs with ERROR level and above.
  /// - "CRITICAL" : Report logs with CRITICAL level only.
  core.String? minLogLevel;

  /// Non-empty default.
  ///
  /// Configures the sampling rate of activity logs, where `1.0` means all
  /// logged activity is reported and `0.0` means no activity is reported. A
  /// floating point value between `0.0` and `1.0` indicates that a percentage
  /// of log messages is stored. The default value when logging is enabled is
  /// `1.0`. The value of the field must be between `0` and `1` (inclusive).
  /// This field can be specified only if logging is enabled for this plugin.
  core.double? sampleRate;

  $WasmPluginLogConfig({this.enable, this.minLogLevel, this.sampleRate});

  $WasmPluginLogConfig.fromJson(core.Map json_)
    : this(
        enable: json_['enable'] as core.bool?,
        minLogLevel: json_['minLogLevel'] as core.String?,
        sampleRate: (json_['sampleRate'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
    if (minLogLevel != null) 'minLogLevel': minLogLevel!,
    if (sampleRate != null) 'sampleRate': sampleRate!,
  };
}

/// Used by:
///
/// - networkservices:v1 : WasmPluginUsedBy
/// - networkservices:v1beta1 : WasmPluginUsedBy
class $WasmPluginUsedBy {
  /// Full name of the resource https://google.aip.dev/122#full-resource-names,
  /// for example
  /// `//networkservices.googleapis.com/projects/{project}/locations/{location}/lbRouteExtensions/{extension}`
  ///
  /// Output only.
  core.String? name;

  $WasmPluginUsedBy({this.name});

  $WasmPluginUsedBy.fromJson(core.Map json_)
    : this(name: json_['name'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - networkservices:v1 : WasmPluginVersion
/// - networkservices:v1beta1 : WasmPluginVersion
class $WasmPluginVersion {
  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A human-readable description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// This field holds the digest (usually checksum) value for the plugin image.
  ///
  /// The value is calculated based on the `image_uri` field. If the `image_uri`
  /// field refers to a container image, the digest value is obtained from the
  /// container image. If the `image_uri` field refers to a generic artifact,
  /// the digest value is calculated based on the contents of the file.
  ///
  /// Output only.
  core.String? imageDigest;

  /// URI of the image containing the Wasm module, stored in Artifact Registry.
  ///
  /// The URI can refer to one of the following repository formats: * Container
  /// images: the `image_uri` must point to a container that contains a single
  /// file with the name `plugin.wasm`. When a new `WasmPluginVersion` resource
  /// is created, the digest of the image is saved in the `image_digest` field.
  /// When pulling a container image from Artifact Registry, the digest value is
  /// used instead of an image tag. * Generic artifacts: the `image_uri` must be
  /// in this format:
  /// `projects/{project}/locations/{location}/repositories/{repository}/
  /// genericArtifacts/{package}:{version}`. The specified package and version
  /// must contain a file with the name `plugin.wasm`. When a new
  /// `WasmPluginVersion` resource is created, the checksum of the contents of
  /// the file is saved in the `image_digest` field.
  ///
  /// Optional.
  core.String? imageUri;

  /// Set of labels associated with the `WasmPluginVersion` resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the `WasmPluginVersion` resource in the following format:
  /// `projects/{project}/locations/{location}/wasmPlugins/{wasm_plugin}/
  /// versions/{wasm_plugin_version}`.
  core.String? name;

  /// Configuration for the plugin.
  ///
  /// The configuration is provided to the plugin at runtime through the
  /// `ON_CONFIGURE` callback. When a new `WasmPluginVersion` resource is
  /// created, the digest of the contents is saved in the `plugin_config_digest`
  /// field.
  core.String? pluginConfigData;
  core.List<core.int> get pluginConfigDataAsBytes =>
      convert.base64.decode(pluginConfigData!);

  set pluginConfigDataAsBytes(core.List<core.int> bytes_) {
    pluginConfigData = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// This field holds the digest (usually checksum) value for the plugin
  /// configuration.
  ///
  /// The value is calculated based on the contents of `plugin_config_data`
  /// field or the image defined by the `plugin_config_uri` field.
  ///
  /// Output only.
  core.String? pluginConfigDigest;

  /// URI of the plugin configuration stored in the Artifact Registry.
  ///
  /// The configuration is provided to the plugin at runtime through the
  /// `ON_CONFIGURE` callback. The URI can refer to one of the following
  /// repository formats: * Container images: the `plugin_config_uri` must point
  /// to a container that contains a single file with the name `plugin.config`.
  /// When a new `WasmPluginVersion` resource is created, the digest of the
  /// image is saved in the `plugin_config_digest` field. When pulling a
  /// container image from Artifact Registry, the digest value is used instead
  /// of an image tag. * Generic artifacts: the `plugin_config_uri` must be in
  /// this format:
  /// `projects/{project}/locations/{location}/repositories/{repository}/
  /// genericArtifacts/{package}:{version}`. The specified package and version
  /// must contain a file with the name `plugin.config`. When a new
  /// `WasmPluginVersion` resource is created, the checksum of the contents of
  /// the file is saved in the `plugin_config_digest` field.
  core.String? pluginConfigUri;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $WasmPluginVersion({
    this.createTime,
    this.description,
    this.imageDigest,
    this.imageUri,
    this.labels,
    this.name,
    this.pluginConfigData,
    this.pluginConfigDigest,
    this.pluginConfigUri,
    this.updateTime,
  });

  $WasmPluginVersion.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        imageDigest: json_['imageDigest'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        pluginConfigData: json_['pluginConfigData'] as core.String?,
        pluginConfigDigest: json_['pluginConfigDigest'] as core.String?,
        pluginConfigUri: json_['pluginConfigUri'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (imageDigest != null) 'imageDigest': imageDigest!,
    if (imageUri != null) 'imageUri': imageUri!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (pluginConfigData != null) 'pluginConfigData': pluginConfigData!,
    if (pluginConfigDigest != null) 'pluginConfigDigest': pluginConfigDigest!,
    if (pluginConfigUri != null) 'pluginConfigUri': pluginConfigUri!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - networkservices:v1 : WasmPluginVersionDetails
/// - networkservices:v1beta1 : WasmPluginVersionDetails
class $WasmPluginVersionDetails {
  /// The timestamp when the resource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A human-readable description of the resource.
  ///
  /// Optional.
  core.String? description;

  /// This field holds the digest (usually checksum) value for the plugin image.
  ///
  /// The value is calculated based on the `image_uri` field. If the `image_uri`
  /// field refers to a container image, the digest value is obtained from the
  /// container image. If the `image_uri` field refers to a generic artifact,
  /// the digest value is calculated based on the contents of the file.
  ///
  /// Output only.
  core.String? imageDigest;

  /// URI of the image containing the Wasm module, stored in Artifact Registry.
  ///
  /// The URI can refer to one of the following repository formats: * Container
  /// images: the `image_uri` must point to a container that contains a single
  /// file with the name `plugin.wasm`. When a new `WasmPluginVersion` resource
  /// is created, the digest of the image is saved in the `image_digest` field.
  /// When pulling a container image from Artifact Registry, the digest value is
  /// used instead of an image tag. * Generic artifacts: the `image_uri` must be
  /// in this format:
  /// `projects/{project}/locations/{location}/repositories/{repository}/
  /// genericArtifacts/{package}:{version}`. The specified package and version
  /// must contain a file with the name `plugin.wasm`. When a new
  /// `WasmPluginVersion` resource is created, the checksum of the contents of
  /// the file is saved in the `image_digest` field.
  ///
  /// Optional.
  core.String? imageUri;

  /// Set of labels associated with the `WasmPluginVersion` resource.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Configuration for the plugin.
  ///
  /// The configuration is provided to the plugin at runtime through the
  /// `ON_CONFIGURE` callback. When a new `WasmPluginVersion` version is
  /// created, the digest of the contents is saved in the `plugin_config_digest`
  /// field.
  core.String? pluginConfigData;
  core.List<core.int> get pluginConfigDataAsBytes =>
      convert.base64.decode(pluginConfigData!);

  set pluginConfigDataAsBytes(core.List<core.int> bytes_) {
    pluginConfigData = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// This field holds the digest (usually checksum) value for the plugin
  /// configuration.
  ///
  /// The value is calculated based on the contents of `plugin_config_data`
  /// field or the image defined by the `plugin_config_uri` field.
  ///
  /// Output only.
  core.String? pluginConfigDigest;

  /// URI of the plugin configuration stored in the Artifact Registry.
  ///
  /// The configuration is provided to the plugin at runtime through the
  /// `ON_CONFIGURE` callback. The URI can refer to one of the following
  /// repository formats: * Container images: the `plugin_config_uri` must point
  /// to a container that contains a single file with the name `plugin.config`.
  /// When a new `WasmPluginVersion` resource is created, the digest of the
  /// image is saved in the `plugin_config_digest` field. When pulling a
  /// container image from Artifact Registry, the digest value is used instead
  /// of an image tag. * Generic artifacts: the `plugin_config_uri` must be in
  /// this format:
  /// `projects/{project}/locations/{location}/repositories/{repository}/
  /// genericArtifacts/{package}:{version}`. The specified package and version
  /// must contain a file with the name `plugin.config`. When a new
  /// `WasmPluginVersion` resource is created, the checksum of the contents of
  /// the file is saved in the `plugin_config_digest` field.
  core.String? pluginConfigUri;

  /// The timestamp when the resource was updated.
  ///
  /// Output only.
  core.String? updateTime;

  $WasmPluginVersionDetails({
    this.createTime,
    this.description,
    this.imageDigest,
    this.imageUri,
    this.labels,
    this.pluginConfigData,
    this.pluginConfigDigest,
    this.pluginConfigUri,
    this.updateTime,
  });

  $WasmPluginVersionDetails.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        imageDigest: json_['imageDigest'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        pluginConfigData: json_['pluginConfigData'] as core.String?,
        pluginConfigDigest: json_['pluginConfigDigest'] as core.String?,
        pluginConfigUri: json_['pluginConfigUri'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (imageDigest != null) 'imageDigest': imageDigest!,
    if (imageUri != null) 'imageUri': imageUri!,
    if (labels != null) 'labels': labels!,
    if (pluginConfigData != null) 'pluginConfigData': pluginConfigData!,
    if (pluginConfigDigest != null) 'pluginConfigDigest': pluginConfigDigest!,
    if (pluginConfigUri != null) 'pluginConfigUri': pluginConfigUri!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Used by:
///
/// - androidenterprise:v1 : WebAppIcon
/// - androidmanagement:v1 : WebAppIcon
class $WebAppIcon {
  /// The actual bytes of the image in a base64url encoded string (c.f. RFC4648,
  /// section 5 "Base 64 Encoding with URL and Filename Safe Alphabet").
  ///
  /// - The image type can be png or jpg. - The image should ideally be square.
  /// - The image should ideally have a size of 512x512.
  core.String? imageData;

  $WebAppIcon({this.imageData});

  $WebAppIcon.fromJson(core.Map json_)
    : this(imageData: json_['imageData'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageData != null) 'imageData': imageData!,
  };
}

/// Used by:
///
/// - oslogin:v1alpha : WebAuthn
/// - oslogin:v1beta : WebAuthn
class $WebAuthn {
  /// Relying party ID for Web Authentication.
  core.String? rpId;

  $WebAuthn({this.rpId});

  $WebAuthn.fromJson(core.Map json_)
    : this(rpId: json_['rpId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (rpId != null) 'rpId': rpId!,
  };
}

/// Used by:
///
/// - vision:v1 : WebDetectionParams
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1WebDetectionParams
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1WebDetectionParams
class $WebDetectionParams {
  /// This field has no effect on results.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? includeGeoResults;

  $WebDetectionParams({this.includeGeoResults});

  $WebDetectionParams.fromJson(core.Map json_)
    : this(includeGeoResults: json_['includeGeoResults'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeGeoResults != null) 'includeGeoResults': includeGeoResults!,
  };
}

/// Used by:
///
/// - vision:v1 : WebEntity
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1WebDetectionWebEntity
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1WebDetectionWebEntity
class $WebEntity {
  /// Canonical description of the entity, in English.
  core.String? description;

  /// Opaque entity ID.
  core.String? entityId;

  /// Overall relevancy score for the entity.
  ///
  /// Not normalized and not comparable across different image queries.
  core.double? score;

  $WebEntity({this.description, this.entityId, this.score});

  $WebEntity.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        entityId: json_['entityId'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (entityId != null) 'entityId': entityId!,
    if (score != null) 'score': score!,
  };
}

/// Used by:
///
/// - vision:v1 : WebImage
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1WebDetectionWebImage
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1WebDetectionWebImage
class $WebImage {
  /// (Deprecated) Overall relevancy score for the image.
  core.double? score;

  /// The result image URL.
  core.String? url;

  $WebImage({this.score, this.url});

  $WebImage.fromJson(core.Map json_)
    : this(
        score: (json_['score'] as core.num?)?.toDouble(),
        url: json_['url'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (score != null) 'score': score!,
    if (url != null) 'url': url!,
  };
}

/// Used by:
///
/// - vision:v1 : WebLabel
/// - vision:v1p1beta1 : GoogleCloudVisionV1p1beta1WebDetectionWebLabel
/// - vision:v1p2beta1 : GoogleCloudVisionV1p2beta1WebDetectionWebLabel
class $WebLabel {
  /// Label for extra metadata.
  core.String? label;

  /// The BCP-47 language code for `label`, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  core.String? languageCode;

  $WebLabel({this.label, this.languageCode});

  $WebLabel.fromJson(core.Map json_)
    : this(
        label: json_['label'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (label != null) 'label': label!,
    if (languageCode != null) 'languageCode': languageCode!,
  };
}

/// Used by:
///
/// - composer:v1 : WebServerConfig
/// - composer:v1beta1 : WebServerConfig
class $WebServerConfig {
  /// Machine type on which Airflow web server is running.
  ///
  /// It has to be one of: composer-n1-webserver-2, composer-n1-webserver-4 or
  /// composer-n1-webserver-8. If not specified, composer-n1-webserver-2 will be
  /// used. Value custom is returned only in response, if Airflow web server
  /// parameters were manually changed to a non-standard values.
  ///
  /// Optional.
  core.String? machineType;

  $WebServerConfig({this.machineType});

  $WebServerConfig.fromJson(core.Map json_)
    : this(machineType: json_['machineType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineType != null) 'machineType': machineType!,
  };
}

/// Used by:
///
/// - composer:v1 : WebServerResource
/// - composer:v1beta1 : WebServerResource
class $WebServerResource {
  /// CPU request and limit for Airflow web server.
  ///
  /// Optional.
  core.double? cpu;

  /// Memory (GB) request and limit for Airflow web server.
  ///
  /// Optional.
  core.double? memoryGb;

  /// Storage (GB) request and limit for Airflow web server.
  ///
  /// Optional.
  core.double? storageGb;

  $WebServerResource({this.cpu, this.memoryGb, this.storageGb});

  $WebServerResource.fromJson(core.Map json_)
    : this(
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        memoryGb: (json_['memoryGb'] as core.num?)?.toDouble(),
        storageGb: (json_['storageGb'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpu != null) 'cpu': cpu!,
    if (memoryGb != null) 'memoryGb': memoryGb!,
    if (storageGb != null) 'storageGb': storageGb!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3WebhookGenericWebServiceOAuthConfig
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1WebhookGenericWebServiceOAuthConfig
class $WebhookGenericWebServiceOAuthConfig {
  /// The client ID provided by the 3rd party platform.
  ///
  /// Required.
  core.String? clientId;

  /// The client secret provided by the 3rd party platform.
  ///
  /// Optional.
  core.String? clientSecret;

  /// The OAuth scopes to grant.
  ///
  /// Optional.
  core.List<core.String>? scopes;

  /// The name of the SecretManager secret version resource storing the client
  /// secret.
  ///
  /// If this field is set, the `client_secret` field will be ignored. Format:
  /// `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Optional.
  core.String? secretVersionForClientSecret;

  /// The token endpoint provided by the 3rd party platform to exchange an
  /// access token.
  ///
  /// Required.
  core.String? tokenEndpoint;

  $WebhookGenericWebServiceOAuthConfig({
    this.clientId,
    this.clientSecret,
    this.scopes,
    this.secretVersionForClientSecret,
    this.tokenEndpoint,
  });

  $WebhookGenericWebServiceOAuthConfig.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        clientSecret: json_['clientSecret'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        secretVersionForClientSecret:
            json_['secretVersionForClientSecret'] as core.String?,
        tokenEndpoint: json_['tokenEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (scopes != null) 'scopes': scopes!,
    if (secretVersionForClientSecret != null)
      'secretVersionForClientSecret': secretVersionForClientSecret!,
    if (tokenEndpoint != null) 'tokenEndpoint': tokenEndpoint!,
  };
}

/// Used by:
///
/// - dialogflow:v3 : GoogleCloudDialogflowCxV3WebhookGenericWebServiceSecretVersionHeaderValue
/// - dialogflow:v3beta1 : GoogleCloudDialogflowCxV3beta1WebhookGenericWebServiceSecretVersionHeaderValue
class $WebhookGenericWebServiceSecretVersionHeaderValue {
  /// The SecretManager secret version resource storing the header value.
  ///
  /// Format: `projects/{project}/secrets/{secret}/versions/{version}`
  ///
  /// Required.
  core.String? secretVersion;

  $WebhookGenericWebServiceSecretVersionHeaderValue({this.secretVersion});

  $WebhookGenericWebServiceSecretVersionHeaderValue.fromJson(core.Map json_)
    : this(secretVersion: json_['secretVersion'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (secretVersion != null) 'secretVersion': secretVersion!,
  };
}

/// Used by:
///
/// - netapp:v1 : WeeklySchedule
/// - netapp:v1beta1 : WeeklySchedule
class $WeeklySchedule00 {
  /// Set the day or days of the week to make a snapshot.
  ///
  /// Accepts a comma separated days of the week. Defaults to 'Sunday'.
  core.String? day;

  /// Set the hour to start the snapshot (0-23), defaults to midnight (0).
  core.double? hour;

  /// Set the minute of the hour to start the snapshot (0-59), defaults to the
  /// top of the hour (0).
  core.double? minute;

  /// The maximum number of Snapshots to keep for the hourly schedule
  core.double? snapshotsToKeep;

  $WeeklySchedule00({this.day, this.hour, this.minute, this.snapshotsToKeep});

  $WeeklySchedule00.fromJson(core.Map json_)
    : this(
        day: json_['day'] as core.String?,
        hour: (json_['hour'] as core.num?)?.toDouble(),
        minute: (json_['minute'] as core.num?)?.toDouble(),
        snapshotsToKeep: (json_['snapshotsToKeep'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (day != null) 'day': day!,
    if (hour != null) 'hour': hour!,
    if (minute != null) 'minute': minute!,
    if (snapshotsToKeep != null) 'snapshotsToKeep': snapshotsToKeep!,
  };
}

/// Used by:
///
/// - osconfig:v1 : WeeklySchedule
/// - osconfig:v1beta : WeeklySchedule
class $WeeklySchedule01 {
  /// Day of the week.
  ///
  /// Required.
  /// Possible string values are:
  /// - "DAY_OF_WEEK_UNSPECIFIED" : The day of the week is unspecified.
  /// - "MONDAY" : Monday
  /// - "TUESDAY" : Tuesday
  /// - "WEDNESDAY" : Wednesday
  /// - "THURSDAY" : Thursday
  /// - "FRIDAY" : Friday
  /// - "SATURDAY" : Saturday
  /// - "SUNDAY" : Sunday
  core.String? dayOfWeek;

  $WeeklySchedule01({this.dayOfWeek});

  $WeeklySchedule01.fromJson(core.Map json_)
    : this(dayOfWeek: json_['dayOfWeek'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (dayOfWeek != null) 'dayOfWeek': dayOfWeek!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : WindowsQuickFixEngineeringPackage
/// - osconfig:v1 : InventoryWindowsQuickFixEngineeringPackage
/// - osconfig:v1alpha : InventoryWindowsQuickFixEngineeringPackage
class $WindowsQuickFixEngineeringPackage {
  /// A short textual description of the QFE update.
  core.String? caption;

  /// A textual description of the QFE update.
  core.String? description;

  /// Unique identifier associated with a particular QFE update.
  core.String? hotFixId;

  /// Date that the QFE update was installed.
  ///
  /// Mapped from installed_on field.
  core.String? installTime;

  $WindowsQuickFixEngineeringPackage({
    this.caption,
    this.description,
    this.hotFixId,
    this.installTime,
  });

  $WindowsQuickFixEngineeringPackage.fromJson(core.Map json_)
    : this(
        caption: json_['caption'] as core.String?,
        description: json_['description'] as core.String?,
        hotFixId: json_['hotFixId'] as core.String?,
        installTime: json_['installTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caption != null) 'caption': caption!,
    if (description != null) 'description': description!,
    if (hotFixId != null) 'hotFixId': hotFixId!,
    if (installTime != null) 'installTime': installTime!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : WindowsUpdateCategory
/// - osconfig:v1 : InventoryWindowsUpdatePackageWindowsUpdateCategory
/// - osconfig:v1alpha : InventoryWindowsUpdatePackageWindowsUpdateCategory
class $WindowsUpdateCategory {
  /// The identifier of the windows update category.
  core.String? id;

  /// The name of the windows update category.
  core.String? name;

  $WindowsUpdateCategory({this.id, this.name});

  $WindowsUpdateCategory.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Used by:
///
/// - osconfig:v1 : WindowsUpdateSettings
/// - osconfig:v1beta : WindowsUpdateSettings
class $WindowsUpdateSettings {
  /// Only apply updates of these windows update classifications.
  ///
  /// If empty, all updates are applied.
  core.List<core.String>? classifications;

  /// List of KBs to exclude from update.
  core.List<core.String>? excludes;

  /// An exclusive list of kbs to be updated.
  ///
  /// These are the only patches that will be updated. This field must not be
  /// used with other patch configurations.
  core.List<core.String>? exclusivePatches;

  $WindowsUpdateSettings({
    this.classifications,
    this.excludes,
    this.exclusivePatches,
  });

  $WindowsUpdateSettings.fromJson(core.Map json_)
    : this(
        classifications:
            (json_['classifications'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludes:
            (json_['excludes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        exclusivePatches:
            (json_['exclusivePatches'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classifications != null) 'classifications': classifications!,
    if (excludes != null) 'excludes': excludes!,
    if (exclusivePatches != null) 'exclusivePatches': exclusivePatches!,
  };
}

/// Used by:
///
/// - compute:alpha : WireEndpoint
/// - compute:beta : WireEndpoint
class $WireEndpoint {
  core.String? interconnect;
  core.int? vlanTag;

  $WireEndpoint({this.interconnect, this.vlanTag});

  $WireEndpoint.fromJson(core.Map json_)
    : this(
        interconnect: json_['interconnect'] as core.String?,
        vlanTag: json_['vlanTag'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnect != null) 'interconnect': interconnect!,
    if (vlanTag != null) 'vlanTag': vlanTag!,
  };
}

/// Used by:
///
/// - compute:alpha : WireGroupEndpointInterconnect
/// - compute:beta : WireGroupEndpointInterconnect
class $WireGroupEndpointInterconnect {
  /// An Interconnect connection.
  ///
  /// You can specify the connection as a partial or full URL. If the connection
  /// is in a different project from the cross-site network, use a format that
  /// specifies the project. See the following examples of partial and full
  /// URLs: global/interconnects/NAME
  /// projects/PROJECT_ID/global/interconnects/NAME -
  /// https://compute.googleapis.com/compute/projects/PROJECT_ID
  /// /global/interconnects/NAME
  core.String? interconnect;

  /// To configure the wire group for VLAN mode, enter a VLAN tag, which is a
  /// number from `2` to `4093`.
  ///
  /// You can autoallocate a tag by entering `0`. To configure the wire group
  /// for port mode, enter `-1`. Review the following guidelines: - A VLAN tag
  /// must be unique for an Interconnect connection across all attachments and
  /// wire groups. - Both endpoints of a wire must use the same VLAN tag value.
  /// - Single wire and redundant type wire groups must have only one VLAN tag.
  /// - Port mode pseudowires must have a single VLAN tag with a value of `-1`
  /// for both endpoints. - Box and cross type wire groups must have two VLAN
  /// tags. The first is for the same-zone pseudowire, and the second is for the
  /// cross-zone pseudowire.
  core.List<core.int>? vlanTags;

  $WireGroupEndpointInterconnect({this.interconnect, this.vlanTags});

  $WireGroupEndpointInterconnect.fromJson(core.Map json_)
    : this(
        interconnect: json_['interconnect'] as core.String?,
        vlanTags:
            (json_['vlanTags'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interconnect != null) 'interconnect': interconnect!,
    if (vlanTags != null) 'vlanTags': vlanTags!,
  };
}

/// Used by:
///
/// - compute:alpha : WireGroupProperties
/// - compute:beta : WireGroupProperties
class $WireGroupProperties {
  /// The type of the wire group, one of the following: - WIRE: a single
  /// pseudowire over two Interconnect connections with no redundancy.
  ///
  /// - REDUNDANT: two pseudowires over four Interconnect connections, with two
  /// connections in one metro and two connections in another metro. Each
  /// redundant pair of Interconnect connections spans both edge availability
  /// domains of the metro. Each pseudowire connects Interconnect connections in
  /// matching edge availability domains of the two metros. - BOX_AND_CROSS:
  /// four pseudowires over four Interconnect connections, with two connections
  /// in one metro and two connections in another metro. Each redundant pair of
  /// Interconnect connections spans both edge availability domains of the
  /// metro. Two pseudowires connect Interconnect connections in matching edge
  /// availability domains of the two metros. Two additional pseudowires connect
  /// the non-matching edge availability domains of the two metros.
  /// Possible string values are:
  /// - "BOX_AND_CROSS" : Four pseudowires over four Interconnect connections,
  /// with two connections in one metro and two connections in another metro.
  /// Each redundant pair of Interconnect connections spans both edge
  /// availability domains of the metro. Two pseudowires connect Interconnect
  /// connections in matching edge availability domains of the two metros. Two
  /// additional pseudowires connect the non-matching edge availability domains
  /// of the two metros.
  /// - "REDUNDANT" : Two pseudowires over four Interconnect connections, with
  /// two connections in one metro and two connections in another metro. Each
  /// redundant pair of Interconnect connections spans both edge availability
  /// domains of the metro. Each pseudowire connects Interconnect connections in
  /// matching edge availability domains of the two metros.
  /// - "WIRE" : A single pseudowire over two Interconnect connections with no
  /// redundancy.
  core.String? type;

  $WireGroupProperties({this.type});

  $WireGroupProperties.fromJson(core.Map json_)
    : this(type: json_['type'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - compute:alpha : WireGroupTopologyEndpoint
/// - compute:beta : WireGroupTopologyEndpoint
class $WireGroupTopologyEndpoint {
  /// The InterconnectLocation.city (metropolitan area designator) that all
  /// interconnects are located in.
  core.String? city;

  /// Endpoint label from the wire group.
  core.String? label;

  $WireGroupTopologyEndpoint({this.city, this.label});

  $WireGroupTopologyEndpoint.fromJson(core.Map json_)
    : this(
        city: json_['city'] as core.String?,
        label: json_['label'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (city != null) 'city': city!,
    if (label != null) 'label': label!,
  };
}

/// Used by:
///
/// - speech:v1 : WordInfo
/// - speech:v1p1beta1 : WordInfo
class $WordInfo {
  /// The confidence estimate between 0.0 and 1.0.
  ///
  /// A higher number indicates an estimated greater likelihood that the
  /// recognized words are correct. This field is set only for the top
  /// alternative of a non-streaming result or, of a streaming result where
  /// `is_final=true`. This field is not guaranteed to be accurate and users
  /// should not rely on it to be always provided. The default of 0.0 is a
  /// sentinel value indicating `confidence` was not set.
  core.double? confidence;

  /// Time offset relative to the beginning of the audio, and corresponding to
  /// the end of the spoken word.
  ///
  /// This field is only set if `enable_word_time_offsets=true` and only in the
  /// top hypothesis. This is an experimental feature and the accuracy of the
  /// time offset can vary.
  core.String? endTime;

  /// A label value assigned for every unique speaker within the audio.
  ///
  /// This field specifies which speaker was detected to have spoken this word.
  /// For some models, like medical_conversation this can be actual speaker
  /// role, for example "patient" or "provider", but generally this would be a
  /// number identifying a speaker. This field is only set if
  /// enable_speaker_diarization = 'true' and only for the top alternative.
  ///
  /// Output only.
  core.String? speakerLabel;

  /// A distinct integer value is assigned for every speaker within the audio.
  ///
  /// This field specifies which one of those speakers was detected to have
  /// spoken this word. Value ranges from '1' to diarization_speaker_count.
  /// speaker_tag is set if enable_speaker_diarization = 'true' and only for the
  /// top alternative. Note: Use speaker_label instead.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? speakerTag;

  /// Time offset relative to the beginning of the audio, and corresponding to
  /// the start of the spoken word.
  ///
  /// This field is only set if `enable_word_time_offsets=true` and only in the
  /// top hypothesis. This is an experimental feature and the accuracy of the
  /// time offset can vary.
  core.String? startTime;

  /// The word corresponding to this set of information.
  core.String? word;

  $WordInfo({
    this.confidence,
    this.endTime,
    this.speakerLabel,
    this.speakerTag,
    this.startTime,
    this.word,
  });

  $WordInfo.fromJson(core.Map json_)
    : this(
        confidence: (json_['confidence'] as core.num?)?.toDouble(),
        endTime: json_['endTime'] as core.String?,
        speakerLabel: json_['speakerLabel'] as core.String?,
        speakerTag: json_['speakerTag'] as core.int?,
        startTime: json_['startTime'] as core.String?,
        word: json_['word'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidence != null) 'confidence': confidence!,
    if (endTime != null) 'endTime': endTime!,
    if (speakerLabel != null) 'speakerLabel': speakerLabel!,
    if (speakerTag != null) 'speakerTag': speakerTag!,
    if (startTime != null) 'startTime': startTime!,
    if (word != null) 'word': word!,
  };
}

/// Used by:
///
/// - composer:v1 : WorkerResource
/// - composer:v1beta1 : WorkerResource
class $WorkerResource {
  /// CPU request and limit for a single Airflow worker replica.
  ///
  /// Optional.
  core.double? cpu;

  /// Maximum number of workers for autoscaling.
  ///
  /// Optional.
  core.int? maxCount;

  /// Memory (GB) request and limit for a single Airflow worker replica.
  ///
  /// Optional.
  core.double? memoryGb;

  /// Minimum number of workers for autoscaling.
  ///
  /// Optional.
  core.int? minCount;

  /// Storage (GB) request and limit for a single Airflow worker replica.
  ///
  /// Optional.
  core.double? storageGb;

  $WorkerResource({
    this.cpu,
    this.maxCount,
    this.memoryGb,
    this.minCount,
    this.storageGb,
  });

  $WorkerResource.fromJson(core.Map json_)
    : this(
        cpu: (json_['cpu'] as core.num?)?.toDouble(),
        maxCount: json_['maxCount'] as core.int?,
        memoryGb: (json_['memoryGb'] as core.num?)?.toDouble(),
        minCount: json_['minCount'] as core.int?,
        storageGb: (json_['storageGb'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cpu != null) 'cpu': cpu!,
    if (maxCount != null) 'maxCount': maxCount!,
    if (memoryGb != null) 'memoryGb': memoryGb!,
    if (minCount != null) 'minCount': minCount!,
    if (storageGb != null) 'storageGb': storageGb!,
  };
}

/// Used by:
///
/// - gkehub:v2 : WorkloadCertificateSpec
/// - gkehub:v2alpha : WorkloadCertificateSpec
/// - gkehub:v2beta : WorkloadCertificateSpec
class $WorkloadCertificateSpec {
  /// CertificateManagement specifies workload certificate management.
  /// Possible string values are:
  /// - "CERTIFICATE_MANAGEMENT_UNSPECIFIED" : Disable workload certificate
  /// feature.
  /// - "DISABLED" : Disable workload certificate feature.
  /// - "ENABLED" : Enable workload certificate feature.
  core.String? certificateManagement;

  $WorkloadCertificateSpec({this.certificateManagement});

  $WorkloadCertificateSpec.fromJson(core.Map json_)
    : this(
        certificateManagement: json_['certificateManagement'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (certificateManagement != null)
      'certificateManagement': certificateManagement!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadComplianceStatus
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadComplianceStatus
class $WorkloadComplianceStatus {
  /// Number of current resource violations which are not acknowledged.
  core.int? acknowledgedResourceViolationCount;

  /// Number of current orgPolicy violations which are acknowledged.
  core.int? acknowledgedViolationCount;

  /// Number of current resource violations which are acknowledged.
  core.int? activeResourceViolationCount;

  /// Number of current orgPolicy violations which are not acknowledged.
  core.int? activeViolationCount;

  $WorkloadComplianceStatus({
    this.acknowledgedResourceViolationCount,
    this.acknowledgedViolationCount,
    this.activeResourceViolationCount,
    this.activeViolationCount,
  });

  $WorkloadComplianceStatus.fromJson(core.Map json_)
    : this(
        acknowledgedResourceViolationCount:
            json_['acknowledgedResourceViolationCount'] as core.int?,
        acknowledgedViolationCount:
            json_['acknowledgedViolationCount'] as core.int?,
        activeResourceViolationCount:
            json_['activeResourceViolationCount'] as core.int?,
        activeViolationCount: json_['activeViolationCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acknowledgedResourceViolationCount != null)
      'acknowledgedResourceViolationCount': acknowledgedResourceViolationCount!,
    if (acknowledgedViolationCount != null)
      'acknowledgedViolationCount': acknowledgedViolationCount!,
    if (activeResourceViolationCount != null)
      'activeResourceViolationCount': activeResourceViolationCount!,
    if (activeViolationCount != null)
      'activeViolationCount': activeViolationCount!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadEkmProvisioningResponse
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadEkmProvisioningResponse
class $WorkloadEkmProvisioningResponse {
  /// Indicates Ekm provisioning error if any.
  /// Possible string values are:
  /// - "EKM_PROVISIONING_ERROR_DOMAIN_UNSPECIFIED" : No error domain
  /// - "UNSPECIFIED_ERROR" : Error but domain is unspecified.
  /// - "GOOGLE_SERVER_ERROR" : Internal logic breaks within provisioning code.
  /// - "EXTERNAL_USER_ERROR" : Error occurred with the customer not granting
  /// permission/creating resource.
  /// - "EXTERNAL_PARTNER_ERROR" : Error occurred within the partner's
  /// provisioning cluster.
  /// - "TIMEOUT_ERROR" : Resource wasn't provisioned in the required 7 day time
  /// period
  core.String? ekmProvisioningErrorDomain;

  /// Detailed error message if Ekm provisioning fails
  /// Possible string values are:
  /// - "EKM_PROVISIONING_ERROR_MAPPING_UNSPECIFIED" : Error is unspecified.
  /// - "INVALID_SERVICE_ACCOUNT" : Service account is used is invalid.
  /// - "MISSING_METRICS_SCOPE_ADMIN_PERMISSION" : Iam permission
  /// monitoring.MetricsScopeAdmin wasn't applied.
  /// - "MISSING_EKM_CONNECTION_ADMIN_PERMISSION" : Iam permission
  /// cloudkms.ekmConnectionsAdmin wasn't applied.
  core.String? ekmProvisioningErrorMapping;

  /// Indicates Ekm enrollment Provisioning of a given workload.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EKM_PROVISIONING_STATE_UNSPECIFIED" : Default State for Ekm
  /// Provisioning
  /// - "EKM_PROVISIONING_STATE_PENDING" : Pending State for Ekm Provisioning
  /// - "EKM_PROVISIONING_STATE_FAILED" : Failed State for Ekm Provisioning
  /// - "EKM_PROVISIONING_STATE_COMPLETED" : Completed State for Ekm
  /// Provisioning
  core.String? ekmProvisioningState;

  $WorkloadEkmProvisioningResponse({
    this.ekmProvisioningErrorDomain,
    this.ekmProvisioningErrorMapping,
    this.ekmProvisioningState,
  });

  $WorkloadEkmProvisioningResponse.fromJson(core.Map json_)
    : this(
        ekmProvisioningErrorDomain:
            json_['ekmProvisioningErrorDomain'] as core.String?,
        ekmProvisioningErrorMapping:
            json_['ekmProvisioningErrorMapping'] as core.String?,
        ekmProvisioningState: json_['ekmProvisioningState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ekmProvisioningErrorDomain != null)
      'ekmProvisioningErrorDomain': ekmProvisioningErrorDomain!,
    if (ekmProvisioningErrorMapping != null)
      'ekmProvisioningErrorMapping': ekmProvisioningErrorMapping!,
    if (ekmProvisioningState != null)
      'ekmProvisioningState': ekmProvisioningState!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadKMSSettings
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadKMSSettings
class $WorkloadKMSSettings {
  /// Input only.
  ///
  /// Immutable. The time at which the Key Management Service will automatically
  /// create a new version of the crypto key and mark it as the primary.
  ///
  /// Required.
  core.String? nextRotationTime;

  /// Input only.
  ///
  /// Immutable. \[next_rotation_time\] will be advanced by this period when the
  /// Key Management Service automatically rotates a key. Must be at least 24
  /// hours and at most 876,000 hours.
  ///
  /// Required.
  core.String? rotationPeriod;

  $WorkloadKMSSettings({this.nextRotationTime, this.rotationPeriod});

  $WorkloadKMSSettings.fromJson(core.Map json_)
    : this(
        nextRotationTime: json_['nextRotationTime'] as core.String?,
        rotationPeriod: json_['rotationPeriod'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextRotationTime != null) 'nextRotationTime': nextRotationTime!,
    if (rotationPeriod != null) 'rotationPeriod': rotationPeriod!,
  };
}

/// Used by:
///
/// - cloudcontrolspartner:v1 : WorkloadOnboardingStep
/// - cloudcontrolspartner:v1beta : WorkloadOnboardingStep
class $WorkloadOnboardingStep {
  /// The completion state of the onboarding step.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "COMPLETION_STATE_UNSPECIFIED" : Unspecified completion state.
  /// - "PENDING" : Task started (has start date) but not yet completed.
  /// - "SUCCEEDED" : Succeeded state.
  /// - "FAILED" : Failed state.
  /// - "NOT_APPLICABLE" : Not applicable state.
  core.String? completionState;

  /// The completion time of the onboarding step.
  core.String? completionTime;

  /// The starting time of the onboarding step.
  core.String? startTime;

  /// The onboarding step.
  /// Possible string values are:
  /// - "STEP_UNSPECIFIED" : Unspecified step.
  /// - "EKM_PROVISIONED" : EKM Provisioned step.
  /// - "SIGNED_ACCESS_APPROVAL_CONFIGURED" : Signed Access Approval step.
  core.String? step;

  $WorkloadOnboardingStep({
    this.completionState,
    this.completionTime,
    this.startTime,
    this.step,
  });

  $WorkloadOnboardingStep.fromJson(core.Map json_)
    : this(
        completionState: json_['completionState'] as core.String?,
        completionTime: json_['completionTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        step: json_['step'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completionState != null) 'completionState': completionState!,
    if (completionTime != null) 'completionTime': completionTime!,
    if (startTime != null) 'startTime': startTime!,
    if (step != null) 'step': step!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadPartnerPermissions
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadPartnerPermissions
class $WorkloadPartnerPermissions {
  /// Allow partner to view support case details for an AXT log
  ///
  /// Optional.
  core.bool? accessTransparencyLogsSupportCaseViewer;

  /// Allow partner to view violation alerts.
  ///
  /// Optional.
  core.bool? assuredWorkloadsMonitoring;

  /// Allow the partner to view inspectability logs and monitoring violations.
  ///
  /// Optional.
  core.bool? dataLogsViewer;

  /// Allow partner to view access approval logs.
  ///
  /// Optional.
  core.bool? serviceAccessApprover;

  $WorkloadPartnerPermissions({
    this.accessTransparencyLogsSupportCaseViewer,
    this.assuredWorkloadsMonitoring,
    this.dataLogsViewer,
    this.serviceAccessApprover,
  });

  $WorkloadPartnerPermissions.fromJson(core.Map json_)
    : this(
        accessTransparencyLogsSupportCaseViewer:
            json_['accessTransparencyLogsSupportCaseViewer'] as core.bool?,
        assuredWorkloadsMonitoring:
            json_['assuredWorkloadsMonitoring'] as core.bool?,
        dataLogsViewer: json_['dataLogsViewer'] as core.bool?,
        serviceAccessApprover: json_['serviceAccessApprover'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessTransparencyLogsSupportCaseViewer != null)
      'accessTransparencyLogsSupportCaseViewer':
          accessTransparencyLogsSupportCaseViewer!,
    if (assuredWorkloadsMonitoring != null)
      'assuredWorkloadsMonitoring': assuredWorkloadsMonitoring!,
    if (dataLogsViewer != null) 'dataLogsViewer': dataLogsViewer!,
    if (serviceAccessApprover != null)
      'serviceAccessApprover': serviceAccessApprover!,
  };
}

/// Used by:
///
/// - container:v1 : WorkloadPolicyConfig
/// - container:v1beta1 : WorkloadPolicyConfig
class $WorkloadPolicyConfig {
  /// If true, workloads can use NET_ADMIN capability.
  core.bool? allowNetAdmin;

  /// If true, enables the GCW Auditor that audits workloads on standard
  /// clusters.
  core.bool? autopilotCompatibilityAuditingEnabled;

  $WorkloadPolicyConfig({
    this.allowNetAdmin,
    this.autopilotCompatibilityAuditingEnabled,
  });

  $WorkloadPolicyConfig.fromJson(core.Map json_)
    : this(
        allowNetAdmin: json_['allowNetAdmin'] as core.bool?,
        autopilotCompatibilityAuditingEnabled:
            json_['autopilotCompatibilityAuditingEnabled'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowNetAdmin != null) 'allowNetAdmin': allowNetAdmin!,
    if (autopilotCompatibilityAuditingEnabled != null)
      'autopilotCompatibilityAuditingEnabled':
          autopilotCompatibilityAuditingEnabled!,
  };
}

/// Used by:
///
/// - apphub:v1 : WorkloadProperties
/// - apphub:v1alpha : WorkloadProperties
class $WorkloadProperties {
  /// The service project identifier that the underlying cloud resource resides
  /// in.
  ///
  /// Empty for non-cloud resources.
  ///
  /// Output only.
  core.String? gcpProject;

  /// The location that the underlying compute resource resides in (for example,
  /// us-west1).
  ///
  /// Output only.
  core.String? location;

  /// The location that the underlying compute resource resides in if it is
  /// zonal (for example, us-west1-a).
  ///
  /// Output only.
  core.String? zone;

  $WorkloadProperties({this.gcpProject, this.location, this.zone});

  $WorkloadProperties.fromJson(core.Map json_)
    : this(
        gcpProject: json_['gcpProject'] as core.String?,
        location: json_['location'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcpProject != null) 'gcpProject': gcpProject!,
    if (location != null) 'location': location!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - apphub:v1 : WorkloadReference
/// - apphub:v1alpha : WorkloadReference
class $WorkloadReference {
  /// The underlying compute resource uri.
  ///
  /// Output only.
  core.String? uri;

  $WorkloadReference({this.uri});

  $WorkloadReference.fromJson(core.Map json_)
    : this(uri: json_['uri'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (uri != null) 'uri': uri!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadResourceInfo
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadResourceInfo
class $WorkloadResourceInfo {
  /// Resource identifier.
  ///
  /// For a project this represents project_number.
  ///
  /// Output only.
  core.String? resourceId;

  /// Indicates the type of resource.
  /// Possible string values are:
  /// - "RESOURCE_TYPE_UNSPECIFIED" : Unknown resource type.
  /// - "CONSUMER_PROJECT" : Deprecated. Existing workloads will continue to
  /// support this, but new CreateWorkloadRequests should not specify this as an
  /// input value.
  /// - "CONSUMER_FOLDER" : Consumer Folder.
  /// - "ENCRYPTION_KEYS_PROJECT" : Consumer project containing encryption keys.
  /// - "KEYRING" : Keyring resource that hosts encryption keys.
  core.String? resourceType;

  $WorkloadResourceInfo({this.resourceId, this.resourceType});

  $WorkloadResourceInfo.fromJson(core.Map json_)
    : this(
        resourceId: json_['resourceId'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceId != null) 'resourceId': resourceId!,
    if (resourceType != null) 'resourceType': resourceType!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadResourceSettings
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadResourceSettings
class $WorkloadResourceSettings {
  /// User-assigned resource display name.
  ///
  /// If not empty it will be used to create a resource with the specified name.
  core.String? displayName;

  /// Resource identifier.
  ///
  /// For a project this represents project_id. If the project is already taken,
  /// the workload creation will fail. For KeyRing, this represents the
  /// keyring_id. For a folder, don't set this value as folder_id is assigned by
  /// Google.
  core.String? resourceId;

  /// Indicates the type of resource.
  ///
  /// This field should be specified to correspond the id to the right project
  /// type (CONSUMER_PROJECT or ENCRYPTION_KEYS_PROJECT)
  /// Possible string values are:
  /// - "RESOURCE_TYPE_UNSPECIFIED" : Unknown resource type.
  /// - "CONSUMER_PROJECT" : Deprecated. Existing workloads will continue to
  /// support this, but new CreateWorkloadRequests should not specify this as an
  /// input value.
  /// - "CONSUMER_FOLDER" : Consumer Folder.
  /// - "ENCRYPTION_KEYS_PROJECT" : Consumer project containing encryption keys.
  /// - "KEYRING" : Keyring resource that hosts encryption keys.
  core.String? resourceType;

  $WorkloadResourceSettings({
    this.displayName,
    this.resourceId,
    this.resourceType,
  });

  $WorkloadResourceSettings.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        resourceId: json_['resourceId'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (resourceId != null) 'resourceId': resourceId!,
    if (resourceType != null) 'resourceType': resourceType!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadSaaEnrollmentResponse
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadSaaEnrollmentResponse
class $WorkloadSaaEnrollmentResponse {
  /// Indicates SAA enrollment setup error if any.
  core.List<core.String>? setupErrors;

  /// Indicates SAA enrollment status of a given workload.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SETUP_STATE_UNSPECIFIED" : Unspecified.
  /// - "STATUS_PENDING" : SAA enrollment pending.
  /// - "STATUS_COMPLETE" : SAA enrollment comopleted.
  core.String? setupStatus;

  $WorkloadSaaEnrollmentResponse({this.setupErrors, this.setupStatus});

  $WorkloadSaaEnrollmentResponse.fromJson(core.Map json_)
    : this(
        setupErrors:
            (json_['setupErrors'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        setupStatus: json_['setupStatus'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (setupErrors != null) 'setupErrors': setupErrors!,
    if (setupStatus != null) 'setupStatus': setupStatus!,
  };
}

/// Used by:
///
/// - assuredworkloads:v1 : GoogleCloudAssuredworkloadsV1WorkloadWorkloadOptions
/// - assuredworkloads:v1beta1 : GoogleCloudAssuredworkloadsV1beta1WorkloadWorkloadOptions
class $WorkloadWorkloadOptions {
  /// Specifies type of KAJ Enrollment if provided.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "KAJ_ENROLLMENT_TYPE_UNSPECIFIED" : KAJ Enrollment type is unspecified
  /// - "KEY_ACCESS_TRANSPARENCY_OFF" : KAT sets External, Hardware, and
  /// Software key feature logging only to TRUE.
  core.String? kajEnrollmentType;

  $WorkloadWorkloadOptions({this.kajEnrollmentType});

  $WorkloadWorkloadOptions.fromJson(core.Map json_)
    : this(kajEnrollmentType: json_['kajEnrollmentType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (kajEnrollmentType != null) 'kajEnrollmentType': kajEnrollmentType!,
  };
}

/// Used by:
///
/// - discoveryengine:v1 : GoogleCloudDiscoveryengineV1WorkspaceConfig
/// - discoveryengine:v1alpha : GoogleCloudDiscoveryengineV1alphaWorkspaceConfig
/// - discoveryengine:v1beta : GoogleCloudDiscoveryengineV1betaWorkspaceConfig
class $WorkspaceConfig {
  /// Obfuscated Dasher customer ID.
  core.String? dasherCustomerId;

  /// The super admin email address for the workspace that will be used for
  /// access token generation.
  ///
  /// For now we only use it for Native Google Drive connector data ingestion.
  ///
  /// Optional.
  core.String? superAdminEmailAddress;

  /// The super admin service account for the workspace that will be used for
  /// access token generation.
  ///
  /// For now we only use it for Native Google Drive connector data ingestion.
  ///
  /// Optional.
  core.String? superAdminServiceAccount;

  /// The Google Workspace data source.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Defaults to an unspecified Workspace type.
  /// - "GOOGLE_DRIVE" : Workspace Data Store contains Drive data
  /// - "GOOGLE_MAIL" : Workspace Data Store contains Mail data
  /// - "GOOGLE_SITES" : Workspace Data Store contains Sites data
  /// - "GOOGLE_CALENDAR" : Workspace Data Store contains Calendar data
  /// - "GOOGLE_CHAT" : Workspace Data Store contains Chat data
  /// - "GOOGLE_GROUPS" : Workspace Data Store contains Groups data
  /// - "GOOGLE_KEEP" : Workspace Data Store contains Keep data
  /// - "GOOGLE_PEOPLE" : Workspace Data Store contains People data
  core.String? type;

  $WorkspaceConfig({
    this.dasherCustomerId,
    this.superAdminEmailAddress,
    this.superAdminServiceAccount,
    this.type,
  });

  $WorkspaceConfig.fromJson(core.Map json_)
    : this(
        dasherCustomerId: json_['dasherCustomerId'] as core.String?,
        superAdminEmailAddress: json_['superAdminEmailAddress'] as core.String?,
        superAdminServiceAccount:
            json_['superAdminServiceAccount'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dasherCustomerId != null) 'dasherCustomerId': dasherCustomerId!,
    if (superAdminEmailAddress != null)
      'superAdminEmailAddress': superAdminEmailAddress!,
    if (superAdminServiceAccount != null)
      'superAdminServiceAccount': superAdminServiceAccount!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - drivelabels:v2 : GoogleAppsDriveLabelsV2WriteControl
/// - drivelabels:v2beta : GoogleAppsDriveLabelsV2betaWriteControl
class $WriteControl {
  /// The revision_id of the label that the write request will be applied to.
  ///
  /// If this is not the latest revision of the label, the request will not be
  /// processed and will return a 400 Bad Request error.
  core.String? requiredRevisionId;

  $WriteControl({this.requiredRevisionId});

  $WriteControl.fromJson(core.Map json_)
    : this(requiredRevisionId: json_['requiredRevisionId'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (requiredRevisionId != null) 'requiredRevisionId': requiredRevisionId!,
  };
}

/// Used by:
///
/// - compute:alpha : XpnResourceId
/// - compute:beta : XpnResourceId
/// - compute:v1 : XpnResourceId
class $XpnResourceId {
  /// The ID of the service resource.
  ///
  /// In the case of projects, this field supports project id (e.g.,
  /// my-project-123) and project number (e.g. 12345678).
  core.String? id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String? type;

  $XpnResourceId({this.id, this.type});

  $XpnResourceId.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (type != null) 'type': type!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1alpha : Xss
/// - websecurityscanner:v1beta : Xss
class $Xss {
  /// An error message generated by a javascript breakage.
  core.String? errorMessage;

  /// Stack traces leading to the point where the XSS occurred.
  core.List<core.String>? stackTraces;

  $Xss({this.errorMessage, this.stackTraces});

  $Xss.fromJson(core.Map json_)
    : this(
        errorMessage: json_['errorMessage'] as core.String?,
        stackTraces:
            (json_['stackTraces'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (stackTraces != null) 'stackTraces': stackTraces!,
  };
}

/// Used by:
///
/// - websecurityscanner:v1 : Xxe
/// - websecurityscanner:v1beta : Xxe
class $Xxe {
  /// Location within the request where the payload was placed.
  /// Possible string values are:
  /// - "LOCATION_UNSPECIFIED" : Unknown Location.
  /// - "COMPLETE_REQUEST_BODY" : The XML payload replaced the complete request
  /// body.
  core.String? payloadLocation;

  /// The XML string that triggered the XXE vulnerability.
  ///
  /// Non-payload values might be redacted.
  core.String? payloadValue;

  $Xxe({this.payloadLocation, this.payloadValue});

  $Xxe.fromJson(core.Map json_)
    : this(
        payloadLocation: json_['payloadLocation'] as core.String?,
        payloadValue: json_['payloadValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (payloadLocation != null) 'payloadLocation': payloadLocation!,
    if (payloadValue != null) 'payloadValue': payloadValue!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : YoutubeAndPartnersBiddingStrategy
/// - displayvideo:v3 : YoutubeAndPartnersBiddingStrategy
/// - displayvideo:v4 : YoutubeAndPartnersBiddingStrategy
class $YoutubeAndPartnersBiddingStrategy {
  /// Source of the effective target CPA value for ad group.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BIDDING_SOURCE_UNSPECIFIED" : Bidding source is not specified or
  /// unknown.
  /// - "BIDDING_SOURCE_LINE_ITEM" : Bidding value is inherited from the line
  /// item.
  /// - "BIDDING_SOURCE_AD_GROUP" : Bidding value is defined in the ad group.
  core.String? adGroupEffectiveTargetCpaSource;

  /// The effective target CPA for ad group, in micros of advertiser's currency.
  ///
  /// Output only.
  core.String? adGroupEffectiveTargetCpaValue;

  /// The type of the bidding strategy.
  /// Possible string values are:
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_UNSPECIFIED" : Type is not
  /// specified or unknown.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MANUAL_CPV" : A bidding
  /// strategy that pays a configurable amount per video view.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MANUAL_CPM" : A bidding
  /// strategy that pays a configurable amount per impression.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPA" : A bidding
  /// strategy that automatically optimizes conversions per dollar.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPM" : A bidding
  /// strategy that pays a configurable amount per impression.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_RESERVE_CPM" : A bidding
  /// strategy for YouTube Instant Reserve line items that pays a fixed amount
  /// per impression.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MAXIMIZE_LIFT" : An
  /// automated bidding strategy that sets bids to achieve maximum lift.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MAXIMIZE_CONVERSIONS" : A
  /// bidding strategy that automatically maximizes number of conversions given
  /// a daily budget.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPV" : A bidding
  /// strategy that automatically optimizes cost per video view.
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_ROAS" : A bidding
  /// strategy that automatically maximizes revenue while averaging a specific
  /// target Return On Ad Spend (ROAS).
  /// - "YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MAXIMIZE_CONVERSION_VALUE" :
  /// A bidding strategy that automatically sets bids to maximize revenue while
  /// spending your budget.
  core.String? type;

  /// The value used by the bidding strategy.
  ///
  /// When the bidding strategy is assigned at the line item level, this field
  /// is only applicable for the following strategy types: *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPA` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_ROAS` When the bidding
  /// strategy is assigned at the ad group level, this field is only applicable
  /// for the following strategy types: *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MANUAL_CPM` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_MANUAL_CPV` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPA` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_CPM` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_RESERVE_CPM` *
  /// `YOUTUBE_AND_PARTNERS_BIDDING_STRATEGY_TYPE_TARGET_ROAS` If not using an
  /// applicable strategy, the value of this field will be 0.
  core.String? value;

  $YoutubeAndPartnersBiddingStrategy({
    this.adGroupEffectiveTargetCpaSource,
    this.adGroupEffectiveTargetCpaValue,
    this.type,
    this.value,
  });

  $YoutubeAndPartnersBiddingStrategy.fromJson(core.Map json_)
    : this(
        adGroupEffectiveTargetCpaSource:
            json_['adGroupEffectiveTargetCpaSource'] as core.String?,
        adGroupEffectiveTargetCpaValue:
            json_['adGroupEffectiveTargetCpaValue'] as core.String?,
        type: json_['type'] as core.String?,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adGroupEffectiveTargetCpaSource != null)
      'adGroupEffectiveTargetCpaSource': adGroupEffectiveTargetCpaSource!,
    if (adGroupEffectiveTargetCpaValue != null)
      'adGroupEffectiveTargetCpaValue': adGroupEffectiveTargetCpaValue!,
    if (type != null) 'type': type!,
    if (value != null) 'value': value!,
  };
}

/// Used by:
///
/// - displayvideo:v3 : YoutubeAndPartnersInventorySourceConfig
/// - displayvideo:v4 : YoutubeAndPartnersInventorySourceConfig
class $YoutubeAndPartnersInventorySourceConfig {
  /// Whether to target inventory in video apps available with Google TV.
  ///
  /// Optional.
  core.bool? includeGoogleTv;

  /// Whether to target inventory on YouTube.
  ///
  /// This includes both search, channels and videos.
  ///
  /// Optional.
  core.bool? includeYoutube;

  /// Whether to target inventory on a collection of partner sites and apps that
  /// follow the same brand safety standards as YouTube.
  core.bool? includeYoutubeVideoPartners;

  $YoutubeAndPartnersInventorySourceConfig({
    this.includeGoogleTv,
    this.includeYoutube,
    this.includeYoutubeVideoPartners,
  });

  $YoutubeAndPartnersInventorySourceConfig.fromJson(core.Map json_)
    : this(
        includeGoogleTv: json_['includeGoogleTv'] as core.bool?,
        includeYoutube: json_['includeYoutube'] as core.bool?,
        includeYoutubeVideoPartners:
            json_['includeYoutubeVideoPartners'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (includeGoogleTv != null) 'includeGoogleTv': includeGoogleTv!,
    if (includeYoutube != null) 'includeYoutube': includeYoutube!,
    if (includeYoutubeVideoPartners != null)
      'includeYoutubeVideoPartners': includeYoutubeVideoPartners!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : YoutubeChannelAssignedTargetingOptionDetails
/// - displayvideo:v3 : YoutubeChannelAssignedTargetingOptionDetails
/// - displayvideo:v4 : YoutubeChannelAssignedTargetingOptionDetails
class $YoutubeChannelAssignedTargetingOptionDetails {
  /// The YouTube uploader channel id or the channel code of a YouTube channel.
  core.String? channelId;

  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  $YoutubeChannelAssignedTargetingOptionDetails({
    this.channelId,
    this.negative,
  });

  $YoutubeChannelAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        channelId: json_['channelId'] as core.String?,
        negative: json_['negative'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (channelId != null) 'channelId': channelId!,
    if (negative != null) 'negative': negative!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : YoutubeVideoAssignedTargetingOptionDetails
/// - displayvideo:v3 : YoutubeVideoAssignedTargetingOptionDetails
/// - displayvideo:v4 : YoutubeVideoAssignedTargetingOptionDetails
class $YoutubeVideoAssignedTargetingOptionDetails {
  /// Indicates if this option is being negatively targeted.
  core.bool? negative;

  /// YouTube video id as it appears on the YouTube watch page.
  core.String? videoId;

  $YoutubeVideoAssignedTargetingOptionDetails({this.negative, this.videoId});

  $YoutubeVideoAssignedTargetingOptionDetails.fromJson(core.Map json_)
    : this(
        negative: json_['negative'] as core.bool?,
        videoId: json_['videoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (negative != null) 'negative': negative!,
    if (videoId != null) 'videoId': videoId!,
  };
}

/// Used by:
///
/// - displayvideo:v2 : YoutubeVideoDetails
/// - displayvideo:v3 : YoutubeVideoDetails
/// - displayvideo:v4 : YoutubeVideoDetails
class $YoutubeVideoDetails {
  /// The YouTube video ID which can be searched on YouTube webpage.
  core.String? id;

  /// The reason why the video data is not available.
  /// Possible string values are:
  /// - "VIDEO_UNAVAILABLE_REASON_UNSPECIFIED" : Unknown or unspecified.
  /// - "VIDEO_UNAVAILABLE_REASON_PRIVATE" : The video is private.
  /// - "VIDEO_UNAVAILABLE_REASON_DELETED" : The video is deleted.
  core.String? unavailableReason;

  $YoutubeVideoDetails({this.id, this.unavailableReason});

  $YoutubeVideoDetails.fromJson(core.Map json_)
    : this(
        id: json_['id'] as core.String?,
        unavailableReason: json_['unavailableReason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (unavailableReason != null) 'unavailableReason': unavailableReason!,
  };
}

/// Used by:
///
/// - osconfig:v1 : YumSettings
/// - osconfig:v1beta : YumSettings
class $YumSettings {
  /// List of packages to exclude from update.
  ///
  /// These packages are excluded by using the yum `--exclude` flag.
  core.List<core.String>? excludes;

  /// An exclusive list of packages to be updated.
  ///
  /// These are the only packages that will be updated. If these packages are
  /// not installed, they will be ignored. This field must not be specified with
  /// any other patch configuration fields.
  core.List<core.String>? exclusivePackages;

  /// Will cause patch to run `yum update-minimal` instead.
  core.bool? minimal;

  /// Adds the `--security` flag to `yum update`.
  ///
  /// Not supported on all platforms.
  core.bool? security;

  $YumSettings({
    this.excludes,
    this.exclusivePackages,
    this.minimal,
    this.security,
  });

  $YumSettings.fromJson(core.Map json_)
    : this(
        excludes:
            (json_['excludes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        exclusivePackages:
            (json_['exclusivePackages'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        minimal: json_['minimal'] as core.bool?,
        security: json_['security'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (excludes != null) 'excludes': excludes!,
    if (exclusivePackages != null) 'exclusivePackages': exclusivePackages!,
    if (minimal != null) 'minimal': minimal!,
    if (security != null) 'security': security!,
  };
}

/// Used by:
///
/// - appengine:v1 : ZipInfo
/// - appengine:v1beta : ZipInfo
class $ZipInfo {
  /// An estimate of the number of files in a zip for a zip deployment.
  ///
  /// If set, must be greater than or equal to the actual number of files. Used
  /// for optimizing performance; if not provided, deployment may be slow.
  core.int? filesCount;

  /// URL of the zip file to deploy from.
  ///
  /// Must be a URL to a resource in Google Cloud Storage in the form
  /// 'http(s)://storage.googleapis.com//'.
  core.String? sourceUrl;

  $ZipInfo({this.filesCount, this.sourceUrl});

  $ZipInfo.fromJson(core.Map json_)
    : this(
        filesCount: json_['filesCount'] as core.int?,
        sourceUrl: json_['sourceUrl'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filesCount != null) 'filesCount': filesCount!,
    if (sourceUrl != null) 'sourceUrl': sourceUrl!,
  };
}

/// Used by:
///
/// - redis:v1 : ZoneDistributionConfig
/// - redis:v1beta1 : ZoneDistributionConfig
class $ZoneDistributionConfig {
  /// The mode of zone distribution.
  ///
  /// Defaults to MULTI_ZONE, when not specified.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ZONE_DISTRIBUTION_MODE_UNSPECIFIED" : Not Set. Default: MULTI_ZONE
  /// - "MULTI_ZONE" : Distribute all resources across 3 zones picked at random,
  /// within the region.
  /// - "SINGLE_ZONE" : Distribute all resources in a single zone. The zone
  /// field must be specified, when this mode is selected.
  core.String? mode;

  /// When SINGLE ZONE distribution is selected, zone field would be used to
  /// allocate all resources in that zone.
  ///
  /// This is not applicable to MULTI_ZONE, and would be ignored for MULTI_ZONE
  /// clusters.
  ///
  /// Optional.
  core.String? zone;

  $ZoneDistributionConfig({this.mode, this.zone});

  $ZoneDistributionConfig.fromJson(core.Map json_)
    : this(
        mode: json_['mode'] as core.String?,
        zone: json_['zone'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mode != null) 'mode': mode!,
    if (zone != null) 'zone': zone!,
  };
}

/// Used by:
///
/// - cloudasset:v1 : ZypperPatch
/// - osconfig:v1 : InventoryZypperPatch
/// - osconfig:v1alpha : InventoryZypperPatch
class $ZypperPatch {
  /// The category of the patch.
  core.String? category;

  /// The name of the patch.
  core.String? patchName;

  /// The severity specified for this patch
  core.String? severity;

  /// Any summary information provided about this patch.
  core.String? summary;

  $ZypperPatch({this.category, this.patchName, this.severity, this.summary});

  $ZypperPatch.fromJson(core.Map json_)
    : this(
        category: json_['category'] as core.String?,
        patchName: json_['patchName'] as core.String?,
        severity: json_['severity'] as core.String?,
        summary: json_['summary'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (patchName != null) 'patchName': patchName!,
    if (severity != null) 'severity': severity!,
    if (summary != null) 'summary': summary!,
  };
}

/// Used by:
///
/// - osconfig:v1 : ZypperSettings
/// - osconfig:v1beta : ZypperSettings
class $ZypperSettings {
  /// Install only patches with these categories.
  ///
  /// Common categories include security, recommended, and feature.
  core.List<core.String>? categories;

  /// List of patches to exclude from update.
  core.List<core.String>? excludes;

  /// An exclusive list of patches to be updated.
  ///
  /// These are the only patches that will be installed using 'zypper patch
  /// patch:' command. This field must not be used with any other patch
  /// configuration fields.
  core.List<core.String>? exclusivePatches;

  /// Install only patches with these severities.
  ///
  /// Common severities include critical, important, moderate, and low.
  core.List<core.String>? severities;

  /// Adds the `--with-optional` flag to `zypper patch`.
  core.bool? withOptional;

  /// Adds the `--with-update` flag, to `zypper patch`.
  core.bool? withUpdate;

  $ZypperSettings({
    this.categories,
    this.excludes,
    this.exclusivePatches,
    this.severities,
    this.withOptional,
    this.withUpdate,
  });

  $ZypperSettings.fromJson(core.Map json_)
    : this(
        categories:
            (json_['categories'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        excludes:
            (json_['excludes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        exclusivePatches:
            (json_['exclusivePatches'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        severities:
            (json_['severities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        withOptional: json_['withOptional'] as core.bool?,
        withUpdate: json_['withUpdate'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categories != null) 'categories': categories!,
    if (excludes != null) 'excludes': excludes!,
    if (exclusivePatches != null) 'exclusivePatches': exclusivePatches!,
    if (severities != null) 'severities': severities!,
    if (withOptional != null) 'withOptional': withOptional!,
    if (withUpdate != null) 'withUpdate': withUpdate!,
  };
}
