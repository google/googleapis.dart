// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: file_names
// ignore_for_file: library_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_expression_function_bodies
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unnecessary_string_interpolations

library googleapis.compute.v1;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

/// Creates and runs virtual machines on Google Cloud Platform.
class ComputeApi {
  /// View and manage your data across Google Cloud Platform services
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View and manage your Google Compute Engine resources
  static const computeScope = 'https://www.googleapis.com/auth/compute';

  /// View your Google Compute Engine resources
  static const computeReadonlyScope =
      'https://www.googleapis.com/auth/compute.readonly';

  /// Manage your data and permissions in Google Cloud Storage
  static const devstorageFullControlScope =
      'https://www.googleapis.com/auth/devstorage.full_control';

  /// View your data in Google Cloud Storage
  static const devstorageReadOnlyScope =
      'https://www.googleapis.com/auth/devstorage.read_only';

  /// Manage your data in Google Cloud Storage
  static const devstorageReadWriteScope =
      'https://www.googleapis.com/auth/devstorage.read_write';

  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi get acceleratorTypes =>
      AcceleratorTypesResourceApi(_requester);
  AddressesResourceApi get addresses => AddressesResourceApi(_requester);
  AutoscalersResourceApi get autoscalers => AutoscalersResourceApi(_requester);
  BackendBucketsResourceApi get backendBuckets =>
      BackendBucketsResourceApi(_requester);
  BackendServicesResourceApi get backendServices =>
      BackendServicesResourceApi(_requester);
  DiskTypesResourceApi get diskTypes => DiskTypesResourceApi(_requester);
  DisksResourceApi get disks => DisksResourceApi(_requester);
  ExternalVpnGatewaysResourceApi get externalVpnGateways =>
      ExternalVpnGatewaysResourceApi(_requester);
  FirewallsResourceApi get firewalls => FirewallsResourceApi(_requester);
  ForwardingRulesResourceApi get forwardingRules =>
      ForwardingRulesResourceApi(_requester);
  GlobalAddressesResourceApi get globalAddresses =>
      GlobalAddressesResourceApi(_requester);
  GlobalForwardingRulesResourceApi get globalForwardingRules =>
      GlobalForwardingRulesResourceApi(_requester);
  GlobalNetworkEndpointGroupsResourceApi get globalNetworkEndpointGroups =>
      GlobalNetworkEndpointGroupsResourceApi(_requester);
  GlobalOperationsResourceApi get globalOperations =>
      GlobalOperationsResourceApi(_requester);
  HealthChecksResourceApi get healthChecks =>
      HealthChecksResourceApi(_requester);
  HttpHealthChecksResourceApi get httpHealthChecks =>
      HttpHealthChecksResourceApi(_requester);
  HttpsHealthChecksResourceApi get httpsHealthChecks =>
      HttpsHealthChecksResourceApi(_requester);
  ImagesResourceApi get images => ImagesResourceApi(_requester);
  InstanceGroupManagersResourceApi get instanceGroupManagers =>
      InstanceGroupManagersResourceApi(_requester);
  InstanceGroupsResourceApi get instanceGroups =>
      InstanceGroupsResourceApi(_requester);
  InstanceTemplatesResourceApi get instanceTemplates =>
      InstanceTemplatesResourceApi(_requester);
  InstancesResourceApi get instances => InstancesResourceApi(_requester);
  InterconnectAttachmentsResourceApi get interconnectAttachments =>
      InterconnectAttachmentsResourceApi(_requester);
  InterconnectLocationsResourceApi get interconnectLocations =>
      InterconnectLocationsResourceApi(_requester);
  InterconnectsResourceApi get interconnects =>
      InterconnectsResourceApi(_requester);
  LicenseCodesResourceApi get licenseCodes =>
      LicenseCodesResourceApi(_requester);
  LicensesResourceApi get licenses => LicensesResourceApi(_requester);
  MachineTypesResourceApi get machineTypes =>
      MachineTypesResourceApi(_requester);
  NetworkEndpointGroupsResourceApi get networkEndpointGroups =>
      NetworkEndpointGroupsResourceApi(_requester);
  NetworksResourceApi get networks => NetworksResourceApi(_requester);
  NodeGroupsResourceApi get nodeGroups => NodeGroupsResourceApi(_requester);
  NodeTemplatesResourceApi get nodeTemplates =>
      NodeTemplatesResourceApi(_requester);
  NodeTypesResourceApi get nodeTypes => NodeTypesResourceApi(_requester);
  PacketMirroringsResourceApi get packetMirrorings =>
      PacketMirroringsResourceApi(_requester);
  ProjectsResourceApi get projects => ProjectsResourceApi(_requester);
  RegionAutoscalersResourceApi get regionAutoscalers =>
      RegionAutoscalersResourceApi(_requester);
  RegionBackendServicesResourceApi get regionBackendServices =>
      RegionBackendServicesResourceApi(_requester);
  RegionCommitmentsResourceApi get regionCommitments =>
      RegionCommitmentsResourceApi(_requester);
  RegionDiskTypesResourceApi get regionDiskTypes =>
      RegionDiskTypesResourceApi(_requester);
  RegionDisksResourceApi get regionDisks => RegionDisksResourceApi(_requester);
  RegionHealthCheckServicesResourceApi get regionHealthCheckServices =>
      RegionHealthCheckServicesResourceApi(_requester);
  RegionHealthChecksResourceApi get regionHealthChecks =>
      RegionHealthChecksResourceApi(_requester);
  RegionInstanceGroupManagersResourceApi get regionInstanceGroupManagers =>
      RegionInstanceGroupManagersResourceApi(_requester);
  RegionInstanceGroupsResourceApi get regionInstanceGroups =>
      RegionInstanceGroupsResourceApi(_requester);
  RegionNetworkEndpointGroupsResourceApi get regionNetworkEndpointGroups =>
      RegionNetworkEndpointGroupsResourceApi(_requester);
  RegionNotificationEndpointsResourceApi get regionNotificationEndpoints =>
      RegionNotificationEndpointsResourceApi(_requester);
  RegionOperationsResourceApi get regionOperations =>
      RegionOperationsResourceApi(_requester);
  RegionSslCertificatesResourceApi get regionSslCertificates =>
      RegionSslCertificatesResourceApi(_requester);
  RegionTargetHttpProxiesResourceApi get regionTargetHttpProxies =>
      RegionTargetHttpProxiesResourceApi(_requester);
  RegionTargetHttpsProxiesResourceApi get regionTargetHttpsProxies =>
      RegionTargetHttpsProxiesResourceApi(_requester);
  RegionUrlMapsResourceApi get regionUrlMaps =>
      RegionUrlMapsResourceApi(_requester);
  RegionsResourceApi get regions => RegionsResourceApi(_requester);
  ReservationsResourceApi get reservations =>
      ReservationsResourceApi(_requester);
  ResourcePoliciesResourceApi get resourcePolicies =>
      ResourcePoliciesResourceApi(_requester);
  RoutersResourceApi get routers => RoutersResourceApi(_requester);
  RoutesResourceApi get routes => RoutesResourceApi(_requester);
  SecurityPoliciesResourceApi get securityPolicies =>
      SecurityPoliciesResourceApi(_requester);
  SnapshotsResourceApi get snapshots => SnapshotsResourceApi(_requester);
  SslCertificatesResourceApi get sslCertificates =>
      SslCertificatesResourceApi(_requester);
  SslPoliciesResourceApi get sslPolicies => SslPoliciesResourceApi(_requester);
  SubnetworksResourceApi get subnetworks => SubnetworksResourceApi(_requester);
  TargetGrpcProxiesResourceApi get targetGrpcProxies =>
      TargetGrpcProxiesResourceApi(_requester);
  TargetHttpProxiesResourceApi get targetHttpProxies =>
      TargetHttpProxiesResourceApi(_requester);
  TargetHttpsProxiesResourceApi get targetHttpsProxies =>
      TargetHttpsProxiesResourceApi(_requester);
  TargetInstancesResourceApi get targetInstances =>
      TargetInstancesResourceApi(_requester);
  TargetPoolsResourceApi get targetPools => TargetPoolsResourceApi(_requester);
  TargetSslProxiesResourceApi get targetSslProxies =>
      TargetSslProxiesResourceApi(_requester);
  TargetTcpProxiesResourceApi get targetTcpProxies =>
      TargetTcpProxiesResourceApi(_requester);
  TargetVpnGatewaysResourceApi get targetVpnGateways =>
      TargetVpnGatewaysResourceApi(_requester);
  UrlMapsResourceApi get urlMaps => UrlMapsResourceApi(_requester);
  VpnGatewaysResourceApi get vpnGateways => VpnGatewaysResourceApi(_requester);
  VpnTunnelsResourceApi get vpnTunnels => VpnTunnelsResourceApi(_requester);
  ZoneOperationsResourceApi get zoneOperations =>
      ZoneOperationsResourceApi(_requester);
  ZonesResourceApi get zones => ZonesResourceApi(_requester);

  ComputeApi(http.Client client,
      {core.String rootUrl = 'https://compute.googleapis.com/',
      core.String servicePath = 'compute/v1/projects/'})
      : _requester =
            commons.ApiRequester(client, rootUrl, servicePath, userAgent);
}

class AcceleratorTypesResourceApi {
  final commons.ApiRequester _requester;

  AcceleratorTypesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of accelerator types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/acceleratorTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => AcceleratorTypeAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified accelerator type.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [acceleratorType] - Name of the accelerator type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorType> get(
    core.String project,
    core.String zone,
    core.String acceleratorType, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (acceleratorType == null) {
      throw core.ArgumentError('Parameter acceleratorType is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes/' +
        commons.Escaper.ecapeVariable('$acceleratorType');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          AcceleratorType.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of accelerator types that are available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/acceleratorTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => AcceleratorTypeList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class AddressesResourceApi {
  final commons.ApiRequester _requester;

  AddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/addresses';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => AddressAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String address, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (address == null) {
      throw core.ArgumentError('Parameter address is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String region,
    core.String address, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (address == null) {
      throw core.ArgumentError('Parameter address is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Address.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of addresses contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/addresses';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          AddressList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class AutoscalersResourceApi {
  final commons.ApiRequester _requester;

  AutoscalersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of autoscalers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/autoscalers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => AutoscalerAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (autoscaler == null) {
      throw core.ArgumentError('Parameter autoscaler is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified autoscaler resource. Gets a list of available
  /// autoscalers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (autoscaler == null) {
      throw core.ArgumentError('Parameter autoscaler is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Autoscaler.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of autoscalers contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          AutoscalerList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String autoscaler,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (autoscaler != null) {
      _queryParams['autoscaler'] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String autoscaler,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (autoscaler != null) {
      _queryParams['autoscaler'] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class BackendBucketsResourceApi {
  final commons.ApiRequester _requester;

  BackendBucketsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendBucket, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket') +
        '/addSignedUrlKey';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified BackendBucket resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendBucket, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendBucket,
    core.String keyName, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if (keyName == null) {
      throw core.ArgumentError('Parameter keyName is required.');
    }
    _queryParams['keyName'] = [keyName];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket') +
        '/deleteSignedUrlKey';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified BackendBucket resource. Gets a list of available
  /// backend buckets by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucket].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucket> get(
    core.String project,
    core.String backendBucket, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          BackendBucket.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a BackendBucket resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendBucket request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of BackendBucket resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucketList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucketList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/backendBuckets';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendBucketList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendBucket] - Name of the BackendBucket resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendBucket == null) {
      throw core.ArgumentError('Parameter backendBucket is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.Escaper.ecapeVariable('$backendBucket');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class BackendServicesResourceApi {
  final commons.ApiRequester _requester;

  BackendServicesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/addSignedUrlKey';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of all BackendService resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/backendServices';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendServiceAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendService,
    core.String keyName, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (keyName == null) {
      throw core.ArgumentError('Parameter keyName is required.');
    }
    _queryParams['keyName'] = [keyName];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/deleteSignedUrlKey';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified BackendService resource. Gets a list of available
  /// backend services.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String backendService, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          BackendService.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the most recent health check results for this BackendService.
  ///
  /// Example request body:
  ///
  /// { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// queried instance belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String backendService, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendServiceGroupHealth.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a BackendService resource in the specified project using the data
  /// included in the request. For more information, see  Backend services
  /// overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of BackendService resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/backendServices';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendServiceList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified BackendService resource with the data included in
  /// the request. For more information, see  Backend services overview. This
  /// method supports PATCH semantics and uses the JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the security policy for the specified backend service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// security policy should be set. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSecurityPolicy(
    SecurityPolicyReference request,
    core.String project,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/setSecurityPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified BackendService resource with the data included in
  /// the request. For more information, see Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class DiskTypesResourceApi {
  final commons.ApiRequester _requester;

  DiskTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of disk types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/diskTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskTypeAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified disk type. Gets a list of available disk types by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String zone,
    core.String diskType, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (diskType == null) {
      throw core.ArgumentError('Parameter diskType is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes/' +
        commons.Escaper.ecapeVariable('$diskType');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskType.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of disk types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/diskTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          DiskTypeList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class DisksResourceApi {
  final commons.ApiRequester _requester;

  DisksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a disk. You can only add one policy
  /// which will be applied to this disk for scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    DisksAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves an aggregated list of persistent disks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/disks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a snapshot of a specified persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to snapshot.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [guestFlush] - [Input Only] Whether to attempt an application consistent
  /// snapshot by informing the OS to prepare for the snapshot process.
  /// Currently only supported on Windows instances using the Volume Shadow Copy
  /// Service (VSS).
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.bool guestFlush,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (guestFlush != null) {
      _queryParams['guestFlush'] = ['${guestFlush}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/createSnapshot';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified persistent disk. Deleting a disk removes its data
  /// permanently and is irreversible. However, deleting a disk does not delete
  /// any snapshots previously made from the disk. You must separately delete
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns a specified persistent disk. Gets a list of available persistent
  /// disks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the persistent disk to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Disk.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a persistent disk in the specified project using the data in the
  /// request. You can create a disk from a source (sourceImage, sourceSnapshot,
  /// or sourceDisk) or create an empty 500 GB data disk by omitting all
  /// properties. You can also create a disk that is larger than the default
  /// size by specifying the sizeGb property.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Optional. Source image to restore onto a disk.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String sourceImage,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if (sourceImage != null) {
      _queryParams['sourceImage'] = [sourceImage];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of persistent disks contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes resource policies from a disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    DisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Resizes the specified persistent disk. You can only increase the size of
  /// the disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The name of the persistent disk.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    DisksResizeRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/resize';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on a disk. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    ZoneSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ExternalVpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  ExternalVpnGatewaysResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified externalVpnGateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateways to delete.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String externalVpnGateway, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (externalVpnGateway == null) {
      throw core.ArgumentError('Parameter externalVpnGateway is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$externalVpnGateway');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified externalVpnGateway. Get a list of available
  /// externalVpnGateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateway to return.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGateway> get(
    core.String project,
    core.String externalVpnGateway, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (externalVpnGateway == null) {
      throw core.ArgumentError('Parameter externalVpnGateway is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$externalVpnGateway');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ExternalVpnGateway.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a ExternalVpnGateway in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ExternalVpnGateway request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of ExternalVpnGateway available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGatewayList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ExternalVpnGatewayList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on an ExternalVpnGateway. To learn more about labels, read
  /// the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class FirewallsResourceApi {
  final commons.ApiRequester _requester;

  FirewallsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String firewall, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (firewall == null) {
      throw core.ArgumentError('Parameter firewall is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Firewall].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Firewall> get(
    core.String project,
    core.String firewall, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (firewall == null) {
      throw core.ArgumentError('Parameter firewall is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Firewall.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a firewall rule in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Firewall request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of firewall rules available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/firewalls';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          FirewallList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (firewall == null) {
      throw core.ArgumentError('Parameter firewall is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified firewall rule with the data included in the request.
  /// Note that all fields will be updated if using PUT, even fields that are
  /// not specified. To update individual fields, please use PATCH instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [firewall] - Name of the firewall rule to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (firewall == null) {
      throw core.ArgumentError('Parameter firewall is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/firewalls/' +
        commons.Escaper.ecapeVariable('$firewall');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  ForwardingRulesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of forwarding rules.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/forwardingRules';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ForwardingRuleAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          ForwardingRule.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a ForwardingRule resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of ForwardingRule resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ForwardingRuleList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules. Currently, you can only patch the
  /// network_tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes target URL for forwarding rule. The new target should be of the
  /// same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class GlobalAddressesResourceApi {
  final commons.ApiRequester _requester;

  GlobalAddressesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String address, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (address == null) {
      throw core.ArgumentError('Parameter address is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified address resource. Gets a list of available addresses
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String address, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (address == null) {
      throw core.ArgumentError('Parameter address is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/addresses/' +
        commons.Escaper.ecapeVariable('$address');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Address.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of global addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/addresses';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          AddressList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class GlobalForwardingRulesResourceApi {
  final commons.ApiRequester _requester;

  GlobalForwardingRulesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified GlobalForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified GlobalForwardingRule resource. Gets a list of
  /// available forwarding rules by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String forwardingRule, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          ForwardingRule.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a GlobalForwardingRule resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of GlobalForwardingRule resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/forwardingRules';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ForwardingRuleList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules. Currently, you can only patch the
  /// network_tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes target URL for the GlobalForwardingRule resource. The new target
  /// should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String forwardingRule, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (forwardingRule == null) {
      throw core.ArgumentError('Parameter forwardingRule is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.Escaper.ecapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class GlobalNetworkEndpointGroupsResourceApi {
  final commons.ApiRequester _requester;

  GlobalNetworkEndpointGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Attach a network endpoint to the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    GlobalNetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified network endpoint group.Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Detach the network endpoint from the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    GlobalNetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified network endpoint group. Gets a list of available
  /// network endpoint groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String networkEndpointGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroup.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    core.String project,
    core.String networkEndpointGroup, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupsListNetworkEndpoints.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class GlobalOperationsResourceApi {
  final commons.ApiRequester _requester;

  GlobalOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of all operations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/operations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => OperationAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
    core.String project,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => null,
    );
  }

  /// Retrieves the specified Operations resource. Gets a list of operations by
  /// making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/operations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          OperationList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class HealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HealthChecksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all HealthCheck resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthChecksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthChecksAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/healthChecks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HealthChecksAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified HealthCheck resource. Gets a list of available
  /// health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String healthCheck, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          HealthCheck.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/healthChecks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          HealthCheckList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class HttpHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpHealthCheck == null) {
      throw core.ArgumentError('Parameter httpHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified HttpHealthCheck resource. Gets a list of available
  /// HTTP health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheck> get(
    core.String project,
    core.String httpHealthCheck, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpHealthCheck == null) {
      throw core.ArgumentError('Parameter httpHealthCheck is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          HttpHealthCheck.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpHealthCheck request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of HttpHealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheckList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpHealthChecks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HttpHealthCheckList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpHealthCheck == null) {
      throw core.ArgumentError('Parameter httpHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpHealthCheck == null) {
      throw core.ArgumentError('Parameter httpHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpHealthCheck');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class HttpsHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  HttpsHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HttpsHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpsHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpsHealthCheck == null) {
      throw core.ArgumentError('Parameter httpsHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified HttpsHealthCheck resource. Gets a list of available
  /// HTTPS health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheck> get(
    core.String project,
    core.String httpsHealthCheck, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpsHealthCheck == null) {
      throw core.ArgumentError('Parameter httpsHealthCheck is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HttpsHealthCheck.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpsHealthCheck request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of HttpsHealthCheck resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheckList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/httpsHealthChecks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HttpsHealthCheckList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request. This method supports PATCH semantics and
  /// uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpsHealthCheck == null) {
      throw core.ArgumentError('Parameter httpsHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (httpsHealthCheck == null) {
      throw core.ArgumentError('Parameter httpsHealthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.Escaper.ecapeVariable('$httpsHealthCheck');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ImagesResourceApi {
  final commons.ApiRequester _requester;

  ImagesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified image.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String image, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (image == null) {
      throw core.ArgumentError('Parameter image is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the deprecation status of an image.
  ///
  /// If an empty request body is given, clears the deprecation status instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Image name.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deprecate(
    DeprecationStatus request,
    core.String project,
    core.String image, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (image == null) {
      throw core.ArgumentError('Parameter image is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image') +
        '/deprecate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified image. Gets a list of available images by making a
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> get(
    core.String project,
    core.String image, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (image == null) {
      throw core.ArgumentError('Parameter image is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Image.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the latest image that is part of an image family and is not
  /// deprecated.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> getFromFamily(
    core.String project,
    core.String family, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (family == null) {
      throw core.ArgumentError('Parameter family is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/family/' +
        commons.Escaper.ecapeVariable('$family');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Image.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an image in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [forceCreate] - Force image creation if true.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Image request,
    core.String project, {
    core.bool forceCreate,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (forceCreate != null) {
      _queryParams['forceCreate'] = ['${forceCreate}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of custom images available to the specified project.
  /// Custom images are images you create that belong to your project. This
  /// method does not get any images that belong to other projects, including
  /// publicly-available images, like Debian 8. If you want to get a list of
  /// publicly-available images, use this method to make a request to the
  /// respective image project, such as debian-cloud or windows-cloud.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/images';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ImageList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified image with the data included in the request. Only
  /// the following fields can be modified: family, description, deprecation
  /// status.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [image] - Name of the image resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Image request,
    core.String project,
    core.String image, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (image == null) {
      throw core.ArgumentError('Parameter image is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$image');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on an image. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/images/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be removed from the managed instance
  /// group. Abandoning an instance does not delete the instance, but it does
  /// remove the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    InstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of managed instance groups and groups them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroupManagers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManagerAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Applies changes to selected instances on the managed instance group. This
  /// method can be used to apply new overrides and/or new versions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// Should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    InstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates instances with per-instance configs in this managed instance
  /// group. Instances are created using the current instance template. The
  /// create instances operation is marked DONE if the createInstances request
  /// is successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    InstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group. Note that the instance group must not belong to a backend
  /// service. Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Flags the specified instances in the managed instance group for immediate
  /// deletion. The instances are also removed from any target pools of which
  /// they were a member. This method reduces the targetSize of the managed
  /// instance group by the number of instances that you delete. This operation
  /// is marked as DONE when the action is scheduled even if the instances are
  /// still being deleted. You must separately verify the status of the deleting
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    InstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    InstanceGroupManagersDeletePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns all of the details about the specified managed instance group.
  /// Gets a list of available managed instance groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManager.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, instances in the group are
  /// created using the specified instance template. This operation is marked as
  /// DONE when the group is created even if the instances in the group have not
  /// yet been created. You must separately verify the status of the individual
  /// instances with the listmanagedinstances method.
  ///
  /// A managed instance group can have up to 1000 VM instances per group.
  /// Please contact Cloud Support if you need an increase in this limit.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of managed instance groups that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManagerList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all errors thrown by actions on instances for a given managed
  /// instance group. The filter and orderBy query parameters are not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|[1-9][0-9]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManagersListErrorsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all of the instances in the managed instance group. Each instance in
  /// the list has a currentAction, which indicates the action that the managed
  /// instance group is performing on the instance. For example, if the group is
  /// still creating an instance, the currentAction is CREATING. If a previous
  /// action failed, the list displays the errors for that failed action. The
  /// orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListManagedInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListManagedInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManagersListManagedInstancesResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListPerInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListPerInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManagersListPerInstanceConfigsResp.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request. This operation is marked as DONE when the group is patched
  /// even if the instances in the group are still in the process of being
  /// patched. You must separately verify the status of the individual instances
  /// with the listManagedInstances method. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Inserts or patches per-instance configs for the managed instance group.
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    InstanceGroupManagersPatchPerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the flag is set even if the instances have not yet
  /// been recreated. You must separately verify the status of the recreating
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    InstanceGroupManagersRecreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Resizes the managed instance group. If you increase the size, the group
  /// creates new instances using the current instance template. If you decrease
  /// the size, the group deletes instances. The resize operation is marked DONE
  /// when the resize actions are scheduled even if the group has not yet added
  /// or deleted any instances. You must separately verify the status of the
  /// creating or deleting actions with the listmanagedinstances method.
  ///
  /// When resizing down, the instance group arbitrarily chooses the order in
  /// which VMs are deleted. The group takes into account some VM attributes
  /// when making the selection including:
  ///
  /// + The status of the VM instance. + The health of the VM instance. + The
  /// instance template version the VM is based on. + For regional managed
  /// instance groups, the location of the VM instance.
  ///
  /// This list is subject to change.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [size] - The number of running instances that the managed instance group
  /// should maintain at any given time. The group automatically adds or removes
  /// instances to maintain the number of instances specified by this parameter.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String zone,
    core.String instanceGroupManager,
    core.int size, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (size == null) {
      throw core.ArgumentError('Parameter size is required.');
    }
    _queryParams['size'] = ['${size}'];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Specifies the instance template to use when creating new instances in this
  /// group. The templates for existing instances in the group do not change
  /// unless you recreate them.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    InstanceGroupManagersSetInstanceTemplateRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Modifies the target pools to which all instances in this managed instance
  /// group are assigned. The target pools automatically apply to all of the
  /// instances in the managed instance group. This operation is marked DONE
  /// when you make the request even if the instances have not yet been added to
  /// their target pools. The change might take some time to apply to all of the
  /// instances in the group depending on the size of the group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    InstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Inserts or updates per-instance configs for the managed instance group.
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    InstanceGroupManagersUpdatePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  InstanceGroupsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a list of instances to the specified instance group. All of the
  /// instances in the instance group must be in the same network/subnetwork.
  /// Read  Adding instances for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where you are adding
  /// instances.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstances(
    InstanceGroupsAddInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/addInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of instance groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/instanceGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified instance group. The instances in the group are not
  /// deleted. Note that instance group must not belong to a backend service.
  /// Read  Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified zonal instance group. Get a list of available zonal
  /// instance groups by making a list() request.
  ///
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          InstanceGroup.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an instance group in the specified project using the parameters
  /// that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroup request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of zonal instance group resources contained within the
  /// specified zone.
  ///
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the instances in the specified instance group. The orderBy query
  /// parameter is not supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group from which you want to
  /// generate a list of included instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupsListInstances> listInstances(
    InstanceGroupsListInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupsListInstances.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes one or more instances from the specified instance group, but does
  /// not delete those instances.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration before the VM instance is removed or deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the specified
  /// instances will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstances(
    InstanceGroupsRemoveInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/removeInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the named ports for the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the named ports are
  /// updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    InstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InstanceTemplatesResourceApi {
  final commons.ApiRequester _requester;

  InstanceTemplatesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified instance template. Deleting an instance template is
  /// permanent and cannot be undone. It is not possible to delete templates
  /// that are already in use by a managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String instanceTemplate, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (instanceTemplate == null) {
      throw core.ArgumentError('Parameter instanceTemplate is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified instance template. Gets a list of available instance
  /// templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [instanceTemplate] - The name of the instance template.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplate> get(
    core.String project,
    core.String instanceTemplate, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (instanceTemplate == null) {
      throw core.ArgumentError('Parameter instanceTemplate is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$instanceTemplate');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceTemplate.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an instance template in the specified project using the data that
  /// is included in the request. If you are creating a new template to update
  /// an existing instance group, your new instance template must use the same
  /// network or, if applicable, the same subnetwork as the original template.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceTemplate request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of instance templates that are contained within the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplateList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/instanceTemplates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceTemplateList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InstancesResourceApi {
  final commons.ApiRequester _requester;

  InstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds an access config to an instance's network interface.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface to add to this
  /// instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (networkInterface == null) {
      throw core.ArgumentError('Parameter networkInterface is required.');
    }
    _queryParams['networkInterface'] = [networkInterface];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/addAccessConfig';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Adds existing resource policies to an instance. You can only add one
  /// policy right now which will be applied to this instance for scheduling
  /// live migrations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    InstancesAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/addResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves aggregated list of all of the instances in your project across
  /// all regions and zones.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/instances';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Attaches an existing Disk resource to an instance. You must first create
  /// the disk before you can attach it. It is not possible to create and attach
  /// a disk at the same time. For more information, read Adding a persistent
  /// disk to your instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [forceAttach] - Whether to force attach the regional disk even if it's
  /// currently attached to another instance. If you try to force attach a zonal
  /// disk to an instance, you will receive an error.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachDisk(
    AttachedDisk request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.bool forceAttach,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (forceAttach != null) {
      _queryParams['forceAttach'] = ['${forceAttach}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/attachDisk';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified Instance resource. For more information, see
  /// Stopping or Deleting an Instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes an access config from an instance's network interface.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [accessConfig] - The name of the access config to delete.
  ///
  /// [networkInterface] - The name of the network interface.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteAccessConfig(
    core.String project,
    core.String zone,
    core.String instance,
    core.String accessConfig,
    core.String networkInterface, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (accessConfig == null) {
      throw core.ArgumentError('Parameter accessConfig is required.');
    }
    _queryParams['accessConfig'] = [accessConfig];
    if (networkInterface == null) {
      throw core.ArgumentError('Parameter networkInterface is required.');
    }
    _queryParams['networkInterface'] = [networkInterface];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/deleteAccessConfig';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Detaches a disk from an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [deviceName] - The device name of the disk to detach. Make a get() request
  /// on the instance to view currently attached disks and device names.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachDisk(
    core.String project,
    core.String zone,
    core.String instance,
    core.String deviceName, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (deviceName == null) {
      throw core.ArgumentError('Parameter deviceName is required.');
    }
    _queryParams['deviceName'] = [deviceName];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/detachDisk';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified Instance resource. Gets a list of available
  /// instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Instance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Instance> get(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Instance.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified guest attributes entry.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [queryPath] - Specifies the guest attributes path to be queried.
  ///
  /// [variableKey] - Specifies the key for the guest attributes entry.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GuestAttributes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GuestAttributes> getGuestAttributes(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String queryPath,
    core.String variableKey,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (queryPath != null) {
      _queryParams['queryPath'] = [queryPath];
    }
    if (variableKey != null) {
      _queryParams['variableKey'] = [variableKey];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/getGuestAttributes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          GuestAttributes.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the screenshot from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Screenshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Screenshot> getScreenshot(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/screenshot';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Screenshot.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the last 1 MB of serial port output from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [port] - Specifies which COM or serial port to retrieve data from.
  /// Value must be between "1" and "4".
  ///
  /// [start_1] - Specifies the starting byte position of the output to return.
  /// To start with the first byte of output to the specified port, omit this
  /// field or set it to `0`.
  ///
  /// If the output for that byte position is available, this field matches the
  /// `start` parameter sent with the request. If the amount of serial console
  /// output exceeds the size of the buffer (1 MB), the oldest output is
  /// discarded and is no longer available. If the requested start position
  /// refers to discarded output, the start position is adjusted to the oldest
  /// output still available, and the adjusted start position is returned as the
  /// `start` property value.
  ///
  /// You can also provide a negative start position, which translates to the
  /// most recent number of bytes written to the serial port. For example, -3 is
  /// interpreted as the most recent 3 bytes written to the serial console.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SerialPortOutput].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SerialPortOutput> getSerialPortOutput(
    core.String project,
    core.String zone,
    core.String instance, {
    core.int port,
    core.String start_1,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (port != null) {
      _queryParams['port'] = ['${port}'];
    }
    if (start_1 != null) {
      _queryParams['start'] = [start_1];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/serialPort';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SerialPortOutput.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the Shielded Instance Identity of an instance
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ShieldedInstanceIdentity].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ShieldedInstanceIdentity> getShieldedInstanceIdentity(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/getShieldedInstanceIdentity';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ShieldedInstanceIdentity.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an instance resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceInstanceTemplate] - Specifies instance template to create the
  /// instance.
  ///
  /// This field is optional. It can be a full or partial URL. For example, the
  /// following are all valid URLs to an instance template:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
  /// - projects/project/global/instanceTemplates/instanceTemplate
  /// - global/instanceTemplates/instanceTemplate
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Instance request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String sourceInstanceTemplate,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if (sourceInstanceTemplate != null) {
      _queryParams['sourceInstanceTemplate'] = [sourceInstanceTemplate];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of instances contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          InstanceList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of resources that refer to the VM instance specified in
  /// the request. For example, if the VM instance is part of a managed instance
  /// group, the referrers list includes the managed instance group. For more
  /// information, read Viewing Referrers to VM Instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the target instance scoping this request, or '-' if
  /// the request should span over all instances in the container.
  /// Value must have pattern
  /// "-|[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceListReferrers].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceListReferrers> listReferrers(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/referrers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceListReferrers.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes resource policies from an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    InstancesRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/removeResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Performs a reset on the instance. This is a hard reset the VM does not do
  /// a graceful shutdown. For more information, see Resetting an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> reset(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/reset';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets deletion protection on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [deletionProtection] - Whether the resource should be protected against
  /// deletion.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDeletionProtection(
    core.String project,
    core.String zone,
    core.String resource, {
    core.bool deletionProtection,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (deletionProtection != null) {
      _queryParams['deletionProtection'] = ['${deletionProtection}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setDeletionProtection';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the auto-delete flag for a disk attached to an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [autoDelete] - Whether to auto-delete the disk when the instance is
  /// deleted.
  ///
  /// [deviceName] - The device name of the disk to modify. Make a get() request
  /// on the instance to view currently attached disks and device names.
  /// Value must have pattern "\w[\w.-]{0,254}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDiskAutoDelete(
    core.String project,
    core.String zone,
    core.String instance,
    core.bool autoDelete,
    core.String deviceName, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (autoDelete == null) {
      throw core.ArgumentError('Parameter autoDelete is required.');
    }
    _queryParams['autoDelete'] = ['${autoDelete}'];
    if (deviceName == null) {
      throw core.ArgumentError('Parameter deviceName is required.');
    }
    _queryParams['deviceName'] = [deviceName];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setDiskAutoDelete';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets labels on an instance. To learn more about labels, read the Labeling
  /// Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    InstancesSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the number and/or type of accelerator for a stopped instance to
  /// the values specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineResources(
    InstancesSetMachineResourcesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineResources';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the machine type for a stopped instance to the machine type
  /// specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineType(
    InstancesSetMachineTypeRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMachineType';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets metadata for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMetadata(
    Metadata request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMetadata';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the minimum CPU platform that this instance should use. This
  /// method can only be called on a stopped instance. For more information,
  /// read Specifying a Minimum CPU Platform.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMinCpuPlatform(
    InstancesSetMinCpuPlatformRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setMinCpuPlatform';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets an instance's scheduling options. You can only call this method on a
  /// stopped instance, that is, a VM instance that is in a `TERMINATED` state.
  /// See Instance Life Cycle for more information on the possible instance
  /// states.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setScheduling(
    Scheduling request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setScheduling';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the service account on the instance. For more information, read
  /// Changing the service account and access scopes for an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setServiceAccount(
    InstancesSetServiceAccountRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setServiceAccount';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the Shielded Instance integrity policy for an instance. You can only
  /// use this method on a running instance. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setShieldedInstanceIntegrityPolicy(
    ShieldedInstanceIntegrityPolicy request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setShieldedInstanceIntegrityPolicy';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets network tags for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTags(
    Tags request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/setTags';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Simulates a maintenance event on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> simulateMaintenanceEvent(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/simulateMaintenanceEvent';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Starts an instance that was stopped using the instances().stop method. For
  /// more information, see Restart an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> start(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/start';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Starts an instance that was stopped using the instances().stop method. For
  /// more information, see Restart an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> startWithEncryptionKey(
    InstancesStartWithEncryptionKeyRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/startWithEncryptionKey';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Stops a running instance, shutting it down cleanly, and allows you to
  /// restart the instance at a later time. Stopped instances do not incur VM
  /// usage charges while they are stopped. However, resources that the VM is
  /// using, such as persistent disks and static IP addresses, will continue to
  /// be charged until they are deleted. For more information, see Stopping an
  /// instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to stop.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> stop(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/stop';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an instance only if the necessary resources are available. This
  /// method can update only a specific set of instance properties. See
  /// Updating a running instance for a list of updatable instance properties.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [minimalAction] - Specifies the action to take when updating an instance
  /// even if the updated properties do not require it. If not specified, then
  /// Compute Engine acts based on the minimum action that the updated
  /// properties require.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [mostDisruptiveAllowedAction] - Specifies the most disruptive action that
  /// can be taken on the instance as part of the update. Compute Engine returns
  /// an error if the instance properties require a more disruptive action as
  /// part of the instance update. Valid options from lowest to highest are
  /// NO_EFFECT, REFRESH, and RESTART.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Instance request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String minimalAction,
    core.String mostDisruptiveAllowedAction,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (minimalAction != null) {
      _queryParams['minimalAction'] = [minimalAction];
    }
    if (mostDisruptiveAllowedAction != null) {
      _queryParams['mostDisruptiveAllowedAction'] = [
        mostDisruptiveAllowedAction
      ];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified access config from an instance's network interface
  /// with the data included in the request. This method supports PATCH
  /// semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface where the access
  /// config is attached.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (networkInterface == null) {
      throw core.ArgumentError('Parameter networkInterface is required.');
    }
    _queryParams['networkInterface'] = [networkInterface];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateAccessConfig';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the Display config for a VM instance. You can only use this method
  /// on a stopped VM instance. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateDisplayDevice(
    DisplayDevice request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateDisplayDevice';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an instance's network interface. This method follows PATCH
  /// semantics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [networkInterface] - The name of the network interface to update.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateNetworkInterface(
    NetworkInterface request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (networkInterface == null) {
      throw core.ArgumentError('Parameter networkInterface is required.');
    }
    _queryParams['networkInterface'] = [networkInterface];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateNetworkInterface';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the Shielded Instance config for an instance. You can only use
  /// this method on a stopped instance. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateShieldedInstanceConfig(
    ShieldedInstanceConfig request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (instance == null) {
      throw core.ArgumentError('Parameter instance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/instances/' +
        commons.Escaper.ecapeVariable('$instance') +
        '/updateShieldedInstanceConfig';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InterconnectAttachmentsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectAttachmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of interconnect attachments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/interconnectAttachments';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectAttachmentAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (interconnectAttachment == null) {
      throw core.ArgumentError('Parameter interconnectAttachment is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachment> get(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (interconnectAttachment == null) {
      throw core.ArgumentError('Parameter interconnectAttachment is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectAttachment.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an InterconnectAttachment in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [validateOnly] - If true, the request will not be committed.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InterconnectAttachment request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.bool validateOnly,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if (validateOnly != null) {
      _queryParams['validateOnly'] = ['${validateOnly}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of interconnect attachments contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectAttachmentList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified interconnect attachment with the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InterconnectAttachment request,
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (interconnectAttachment == null) {
      throw core.ArgumentError('Parameter interconnectAttachment is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.Escaper.ecapeVariable('$interconnectAttachment');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InterconnectLocationsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectLocationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the details for the specified interconnect location. Gets a list
  /// of available interconnect locations by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnectLocation] - Name of the interconnect location to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocation> get(
    core.String project,
    core.String interconnectLocation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (interconnectLocation == null) {
      throw core.ArgumentError('Parameter interconnectLocation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations/' +
        commons.Escaper.ecapeVariable('$interconnectLocation');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectLocation.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of interconnect locations available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocationList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnectLocations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectLocationList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class InterconnectsResourceApi {
  final commons.ApiRequester _requester;

  InterconnectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String interconnect, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (interconnect == null) {
      throw core.ArgumentError('Parameter interconnect is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified interconnect. Get a list of available interconnects
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Interconnect].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Interconnect> get(
    core.String project,
    core.String interconnect, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (interconnect == null) {
      throw core.ArgumentError('Parameter interconnect is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Interconnect.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the interconnectDiagnostics for the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectsGetDiagnosticsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectsGetDiagnosticsResponse> getDiagnostics(
    core.String project,
    core.String interconnect, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (interconnect == null) {
      throw core.ArgumentError('Parameter interconnect is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect') +
        '/getDiagnostics';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectsGetDiagnosticsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a Interconnect in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Interconnect request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of interconnect available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/interconnects';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InterconnectList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified interconnect with the data included in the request.
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [interconnect] - Name of the interconnect to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Interconnect request,
    core.String project,
    core.String interconnect, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (interconnect == null) {
      throw core.ArgumentError('Parameter interconnect is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/interconnects/' +
        commons.Escaper.ecapeVariable('$interconnect');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class LicenseCodesResourceApi {
  final commons.ApiRequester _requester;

  LicenseCodesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Return a specified license code. License codes are mirrored across all
  /// projects that have permissions to read the License Code.  Caution This
  /// resource is intended for use only by third-party partners who are creating
  /// Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [licenseCode] - Number corresponding to the License code resource to
  /// return.
  /// Value must have pattern "[0-9]{0,61}?".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicenseCode].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicenseCode> get(
    core.String project,
    core.String licenseCode, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (licenseCode == null) {
      throw core.ArgumentError('Parameter licenseCode is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.Escaper.ecapeVariable('$licenseCode');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          LicenseCode.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.  Caution
  /// This resource is intended for use only by third-party partners who are
  /// creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class LicensesResourceApi {
  final commons.ApiRequester _requester;

  LicensesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified license.  Caution This resource is intended for use
  /// only by third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [license] - Name of the license resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String license, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (license == null) {
      throw core.ArgumentError('Parameter license is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$license');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified License resource.  Caution This resource is intended
  /// for use only by third-party partners who are creating Cloud Marketplace
  /// images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [license] - Name of the License resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [License].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<License> get(
    core.String project,
    core.String license, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (license == null) {
      throw core.ArgumentError('Parameter license is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$license');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => License.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.  Caution This resource is intended for use only
  /// by third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Create a License resource in the specified project.  Caution This resource
  /// is intended for use only by third-party partners who are creating Cloud
  /// Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    License request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/licenses';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of licenses available in the specified project. This
  /// method does not get any licenses that belong to other projects, including
  /// licenses attached to publicly-available images, like Debian 9. If you want
  /// to get a list of publicly-available licenses, use this method to make a
  /// request to the respective image project, such as debian-cloud or
  /// windows-cloud.  Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicensesListResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicensesListResponse> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/licenses';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => LicensesListResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.  Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.  Caution
  /// This resource is intended for use only by third-party partners who are
  /// creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/licenses/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class MachineTypesResourceApi {
  final commons.ApiRequester _requester;

  MachineTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of machine types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/machineTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => MachineTypeAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified machine type. Gets a list of available machine types
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [machineType] - Name of the machine type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineType> get(
    core.String project,
    core.String zone,
    core.String machineType, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (machineType == null) {
      throw core.ArgumentError('Parameter machineType is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes/' +
        commons.Escaper.ecapeVariable('$machineType');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          MachineType.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of machine types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/machineTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          MachineTypeList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class NetworkEndpointGroupsResourceApi {
  final commons.ApiRequester _requester;

  NetworkEndpointGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of network endpoint groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Attach a list of network endpoints to the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    NetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified network endpoint group. The network endpoints in the
  /// NEG and the VM instances they belong to are not terminated when the NEG is
  /// deleted. Note that the NEG cannot be deleted if there are backend services
  /// referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Detach a list of network endpoints from the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    NetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified network endpoint group. Gets a list of available
  /// network endpoint groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroup.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    NetworkEndpointGroupsListEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupsListNetworkEndpoints.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class NetworksResourceApi {
  final commons.ApiRequester _requester;

  NetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds a peering to the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to add peering to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addPeering(
    NetworksAddPeeringRequest request,
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/addPeering';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified network. Gets a list of available networks by making
  /// a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Network].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Network> get(
    core.String project,
    core.String network, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Network.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a network in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Network request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of networks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/networks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          NetworkList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the peering routes exchanged over peering connection.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [direction] - The direction of the exchanged routes.
  /// Possible string values are:
  /// - "INCOMING"
  /// - "OUTGOING"
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [peeringName] - The response will show routes exchanged over the given
  /// peering connection.
  ///
  /// [region] - The region of the request. The response will include all subnet
  /// routes, static routes and dynamic routes in the region.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExchangedPeeringRoutesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExchangedPeeringRoutesList> listPeeringRoutes(
    core.String project,
    core.String network, {
    core.String direction,
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.String peeringName,
    core.String region,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (direction != null) {
      _queryParams['direction'] = [direction];
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (peeringName != null) {
      _queryParams['peeringName'] = [peeringName];
    }
    if (region != null) {
      _queryParams['region'] = [region];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/listPeeringRoutes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ExchangedPeeringRoutesList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified network with the data included in the request. Only
  /// the following fields can be modified: routingConfig.routingMode.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Network request,
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes a peering from the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource to remove peering from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removePeering(
    NetworksRemovePeeringRequest request,
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/removePeering';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Switches the network mode from auto subnet mode to custom subnet mode.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network to be updated.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> switchToCustomMode(
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/switchToCustomMode';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified network peering with the data included in the
  /// request Only the following fields can be modified:
  /// NetworkPeering.export_custom_routes, and
  /// NetworkPeering.import_custom_routes
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [network] - Name of the network resource which the updated peering is
  /// belonging to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePeering(
    NetworksUpdatePeeringRequest request,
    core.String project,
    core.String network, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (network == null) {
      throw core.ArgumentError('Parameter network is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/networks/' +
        commons.Escaper.ecapeVariable('$network') +
        '/updatePeering';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class NodeGroupsResourceApi {
  final commons.ApiRequester _requester;

  NodeGroupsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds specified number of nodes to the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addNodes(
    NodeGroupsAddNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/addNodes';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves an aggregated list of node groups. Note: use
  /// nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeGroupAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified NodeGroup resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes specified nodes from the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes will be deleted.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteNodes(
    NodeGroupsDeleteNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/deleteNodes';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified NodeGroup. Get a list of available NodeGroups by
  /// making a list() request. Note: the "nodes" field should not be used. Use
  /// nodeGroups.listNodes instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the node group to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroup> get(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeGroup.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a NodeGroup resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [initialNodeCount] - Initial count of nodes in the node group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.int initialNodeCount, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (initialNodeCount == null) {
      throw core.ArgumentError('Parameter initialNodeCount is required.');
    }
    _queryParams['initialNodeCount'] = ['${initialNodeCount}'];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of node groups available to the specified project. Note:
  /// use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          NodeGroupList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists nodes in the node group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes you want to list.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupsListNodes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupsListNodes> listNodes(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/listNodes';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeGroupsListNodes.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the node template of the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNodeTemplate(
    NodeGroupsSetNodeTemplateRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeGroup == null) {
      throw core.ArgumentError('Parameter nodeGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$nodeGroup') +
        '/setNodeTemplate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeGroups/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class NodeTemplatesResourceApi {
  final commons.ApiRequester _requester;

  NodeTemplatesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node templates.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeTemplates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeTemplateAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified NodeTemplate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeTemplate] - Name of the NodeTemplate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (nodeTemplate == null) {
      throw core.ArgumentError('Parameter nodeTemplate is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$nodeTemplate');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified node template. Gets a list of available node
  /// templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeTemplate] - Name of the node template to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplate> get(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (nodeTemplate == null) {
      throw core.ArgumentError('Parameter nodeTemplate is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$nodeTemplate');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          NodeTemplate.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a NodeTemplate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeTemplate request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of node templates available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeTemplateList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/nodeTemplates/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class NodeTypesResourceApi {
  final commons.ApiRequester _requester;

  NodeTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/nodeTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeTypeAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified node type. Gets a list of available node types by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [nodeType] - Name of the node type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeType> get(
    core.String project,
    core.String zone,
    core.String nodeType, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (nodeType == null) {
      throw core.ArgumentError('Parameter nodeType is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeTypes/' +
        commons.Escaper.ecapeVariable('$nodeType');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NodeType.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of node types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/nodeTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          NodeTypeList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class PacketMirroringsResourceApi {
  final commons.ApiRequester _requester;

  PacketMirroringsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of packetMirrorings.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/packetMirrorings';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => PacketMirroringAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (packetMirroring == null) {
      throw core.ArgumentError('Parameter packetMirroring is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroring].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroring> get(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (packetMirroring == null) {
      throw core.ArgumentError('Parameter packetMirroring is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          PacketMirroring.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a PacketMirroring resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PacketMirroring request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of PacketMirroring resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => PacketMirroringList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified PacketMirroring resource with the data included in
  /// the request. This method supports PATCH semantics and uses JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PacketMirroring request,
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (packetMirroring == null) {
      throw core.ArgumentError('Parameter packetMirroring is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$packetMirroring');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/packetMirrorings/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ProjectsResourceApi {
  final commons.ApiRequester _requester;

  ProjectsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Disable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnHost(
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnHost';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Disable a service resource (also known as service project) associated with
  /// this host project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnResource(
    ProjectsDisableXpnResourceRequest request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/disableXpnResource';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Enable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnHost(
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnHost';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Enable service resource (a.k.a service project) for a host project, so
  /// that subnets in the host project can be used by instances in the service
  /// project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnResource(
    ProjectsEnableXpnResourceRequest request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/enableXpnResource';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified Project resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> get(
    core.String project, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Project.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the shared VPC host project that this project links to. May be empty
  /// if no link exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> getXpnHost(
    core.String project, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnHost';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Project.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets service resources (a.k.a service project) associated with this host
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ProjectsGetXpnResources].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ProjectsGetXpnResources> getXpnResources(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/getXpnResources';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ProjectsGetXpnResources.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all shared VPC host projects visible to the user in an organization.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [XpnHostList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<XpnHostList> listXpnHosts(
    ProjectsListXpnHostsRequest request,
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/listXpnHosts';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          XpnHostList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Moves a persistent disk from one zone to another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveDisk(
    DiskMoveRequest request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveDisk';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Moves an instance and its attached persistent disks from one zone to
  /// another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveInstance(
    InstanceMoveRequest request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/moveInstance';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets metadata common to all instances within the specified project using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setCommonInstanceMetadata(
    Metadata request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/setCommonInstanceMetadata';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the default network tier of the project. The default network tier is
  /// used when an address/forwardingRule/instance is created without specifying
  /// the network tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDefaultNetworkTier(
    ProjectsSetDefaultNetworkTierRequest request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/setDefaultNetworkTier';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Enables the usage export feature and sets the usage export bucket where
  /// reports are stored. If you provide an empty request body using this
  /// method, the usage export feature will be disabled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUsageExportBucket(
    UsageExportLocation request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/setUsageExportBucket';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionAutoscalersResourceApi {
  final commons.ApiRequester _requester;

  RegionAutoscalersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (autoscaler == null) {
      throw core.ArgumentError('Parameter autoscaler is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (autoscaler == null) {
      throw core.ArgumentError('Parameter autoscaler is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers/' +
        commons.Escaper.ecapeVariable('$autoscaler');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Autoscaler.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of autoscalers contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionAutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionAutoscalerList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionAutoscalerList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String autoscaler,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (autoscaler != null) {
      _queryParams['autoscaler'] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String autoscaler,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (autoscaler != null) {
      _queryParams['autoscaler'] = [autoscaler];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/autoscalers';

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionBackendServicesResourceApi {
  final commons.ApiRequester _requester;

  RegionBackendServicesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          BackendService.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the most recent health check results for this regional
  /// BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource for which to get
  /// health.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService') +
        '/getHealth';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendServiceGroupHealth.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a regional BackendService resource in the specified project using
  /// the data included in the request. For more information, see  Backend
  /// services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of regional BackendService resources available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => BackendServiceList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. For more information, see  Understanding backend
  /// services This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request. For more information, see  Backend services
  /// overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (backendService == null) {
      throw core.ArgumentError('Parameter backendService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/backendServices/' +
        commons.Escaper.ecapeVariable('$backendService');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionCommitmentsResourceApi {
  final commons.ApiRequester _requester;

  RegionCommitmentsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of commitments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/commitments';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => CommitmentAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified commitment resource. Gets a list of available
  /// commitments by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [commitment] - Name of the commitment to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Commitment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Commitment> get(
    core.String project,
    core.String region,
    core.String commitment, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (commitment == null) {
      throw core.ArgumentError('Parameter commitment is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments/' +
        commons.Escaper.ecapeVariable('$commitment');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Commitment.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a commitment in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Commitment request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of commitments contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/commitments';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          CommitmentList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionDiskTypesResourceApi {
  final commons.ApiRequester _requester;

  RegionDiskTypesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified regional disk type. Gets a list of available disk
  /// types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String region,
    core.String diskType, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (diskType == null) {
      throw core.ArgumentError('Parameter diskType is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/diskTypes/' +
        commons.Escaper.ecapeVariable('$diskType');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskType.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of regional disk types available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionDiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionDiskTypeList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/diskTypes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionDiskTypeList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionDisksResourceApi {
  final commons.ApiRequester _requester;

  RegionDisksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a regional disk. You can only add one
  /// policy which will be applied to this disk for scheduling snapshot
  /// creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    RegionDisksAddResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a snapshot of this regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to snapshot.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/createSnapshot';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified regional persistent disk. Deleting a regional disk
  /// removes all the replicas of its data permanently and is irreversible.
  /// However, deleting a disk does not delete any snapshots previously made
  /// from the disk. You must separately delete snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns a specified regional persistent disk.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String region,
    core.String disk, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Disk.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a persistent regional disk in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Optional. Source image to restore onto a disk.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String sourceImage,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if (sourceImage != null) {
      _queryParams['sourceImage'] = [sourceImage];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of persistent disks contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => DiskList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes resource policies from a regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    RegionDisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Resizes the specified regional persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - The project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [disk] - Name of the regional persistent disk.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    RegionDisksResizeRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (disk == null) {
      throw core.ArgumentError('Parameter disk is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$disk') +
        '/resize';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on the target regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/disks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionHealthCheckServicesResourceApi {
  final commons.ApiRequester _requester;

  RegionHealthCheckServicesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional HealthCheckService.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheckService] - Name of the HealthCheckService to delete. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheckService == null) {
      throw core.ArgumentError('Parameter healthCheckService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthCheckServices/' +
        commons.Escaper.ecapeVariable('$healthCheckService');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified regional HealthCheckService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckService> get(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheckService == null) {
      throw core.ArgumentError('Parameter healthCheckService is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthCheckServices/' +
        commons.Escaper.ecapeVariable('$healthCheckService');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HealthCheckService.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a regional HealthCheckService resource in the specified project
  /// and region using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheckService request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthCheckServices';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all the HealthCheckService resources that have been configured for
  /// the specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckServicesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckServicesList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthCheckServices';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => HealthCheckServicesList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified regional HealthCheckService resource with the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheckService request,
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheckService == null) {
      throw core.ArgumentError('Parameter healthCheckService is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthCheckServices/' +
        commons.Escaper.ecapeVariable('$healthCheckService');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionHealthChecksResourceApi {
  final commons.ApiRequester _requester;

  RegionHealthChecksResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified HealthCheck resource. Gets a list of available
  /// health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          HealthCheck.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          HealthCheckList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request. This method supports PATCH semantics and uses the
  /// JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (healthCheck == null) {
      throw core.ArgumentError('Parameter healthCheck is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/healthChecks/' +
        commons.Escaper.ecapeVariable('$healthCheck');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionInstanceGroupManagersResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupManagersResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be immediately removed from the managed
  /// instance group. Abandoning an instance does not delete the instance, but
  /// it does remove the instance from any target pools that are applied by the
  /// managed instance group. This method reduces the targetSize of the managed
  /// instance group by the number of instances that you abandon. This operation
  /// is marked as DONE when the action is scheduled even if the instances have
  /// not yet been removed from the group. You must separately verify the status
  /// of the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    RegionInstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Apply updates to selected instances the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    RegionInstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates instances with per-instance configs in this regional managed
  /// instance group. Instances are created using the current instance template.
  /// The create instances operation is marked DONE if the createInstances
  /// request is successful. The underlying actions take additional time. You
  /// must separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where the managed instance group is
  /// located. It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    RegionInstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately deleted. The instances are also removed from any target pools
  /// of which they were a member. This method reduces the targetSize of the
  /// managed instance group by the number of instances that you delete. The
  /// deleteInstances operation is marked DONE if the deleteInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the deleting action with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    RegionInstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    RegionInstanceGroupManagerDeleteInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => InstanceGroupManager.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request. After the group is created, instances in the group are
  /// created using the specified instance template. This operation is marked as
  /// DONE when the group is created even if the instances in the group have not
  /// yet been created. You must separately verify the status of the individual
  /// instances with the listmanagedinstances method.
  ///
  /// A regional managed instance group can contain up to 2000 instances.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of managed instance groups that are contained within
  /// the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagerList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupManagerList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all errors thrown by actions on instances for a given regional
  /// managed instance group. The filter and orderBy query parameters are not
  /// supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request. This should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|[1-9][0-9]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupManagersListErrorsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the instances in the managed instance group and instances that are
  /// scheduled to be created. The list includes any current actions that the
  /// group has scheduled for its instances. The orderBy query parameter is not
  /// supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupManagersListInstancesResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request. This operation is marked as DONE when the group is patched
  /// even if the instances in the group are still in the process of being
  /// patched. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method. This method supports PATCH semantics
  /// and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Insert or patch (for the ones that already exist) per-instance configs for
  /// the managed instance group. perInstanceConfig.instance serves as a key
  /// used to distinguish whether to perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    RegionInstanceGroupManagerPatchInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated. The instances are deleted and recreated using the
  /// current instance template for the managed instance group. This operation
  /// is marked as DONE when the flag is set even if the instances have not yet
  /// been recreated. You must separately verify the status of the recreating
  /// action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    RegionInstanceGroupManagersRecreateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the intended size of the managed instance group. If you increase
  /// the size, the group creates new instances using the current instance
  /// template. If you decrease the size, the group deletes one or more
  /// instances.
  ///
  /// The resize operation is marked DONE if the resize request is successful.
  /// The underlying actions take additional time. You must separately verify
  /// the status of the creating or deleting actions with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [size] - Number of instances that should exist in this instance group
  /// manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String region,
    core.String instanceGroupManager,
    core.int size, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (size == null) {
      throw core.ArgumentError('Parameter size is required.');
    }
    _queryParams['size'] = ['${size}'];
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the instance template to use when creating new instances or
  /// recreating instances in this group. Existing instances are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    RegionInstanceGroupManagersSetTemplateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Modifies the target pools to which all new instances in this group are
  /// assigned. Existing instances in the group are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    RegionInstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Insert or update (for the ones that already exist) per-instance configs
  /// for the managed instance group. perInstanceConfig.instance serves as a key
  /// used to distinguish whether to perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    RegionInstanceGroupManagerUpdateInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroupManager == null) {
      throw core.ArgumentError('Parameter instanceGroupManager is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.Escaper.ecapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionInstanceGroupsResourceApi {
  final commons.ApiRequester _requester;

  RegionInstanceGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Returns the specified instance group resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the instance group resource to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          InstanceGroup.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of instance group resources contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the instances in the specified instance group and displays
  /// information about the named ports. Depending on the specified options,
  /// this method can list all instances or only the instances that are running.
  /// The orderBy query parameter is not supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the regional instance group for which we want to
  /// list the instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupsListInstances> listInstances(
    RegionInstanceGroupsListInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RegionInstanceGroupsListInstances.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the named ports for the specified regional instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - The name of the regional instance group where the named
  /// ports are updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    RegionInstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (instanceGroup == null) {
      throw core.ArgumentError('Parameter instanceGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/instanceGroups/' +
        commons.Escaper.ecapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionNetworkEndpointGroupsResourceApi {
  final commons.ApiRequester _requester;

  RegionNetworkEndpointGroupsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified network endpoint group. Note that the NEG cannot be
  /// deleted if it is configured as a backend of a backend service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified network endpoint group. Gets a list of available
  /// network endpoint groups by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (networkEndpointGroup == null) {
      throw core.ArgumentError('Parameter networkEndpointGroup is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.Escaper.ecapeVariable('$networkEndpointGroup');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroup.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of regional network endpoint groups available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NetworkEndpointGroupList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionNotificationEndpointsResourceApi {
  final commons.ApiRequester _requester;

  RegionNotificationEndpointsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified NotificationEndpoint in the given region
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (notificationEndpoint == null) {
      throw core.ArgumentError('Parameter notificationEndpoint is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.Escaper.ecapeVariable('$notificationEndpoint');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified NotificationEndpoint resource in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpoint> get(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (notificationEndpoint == null) {
      throw core.ArgumentError('Parameter notificationEndpoint is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.Escaper.ecapeVariable('$notificationEndpoint');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NotificationEndpoint.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Create a NotificationEndpoint in the specified project in the given region
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NotificationEndpoint request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/notificationEndpoints';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the NotificationEndpoints for a project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpointList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpointList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/notificationEndpoints';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => NotificationEndpointList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionOperationsResourceApi {
  final commons.ApiRequester _requester;

  RegionOperationsResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
    core.String project,
    core.String region,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => null,
    );
  }

  /// Retrieves the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String region,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          OperationList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String region,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionSslCertificatesResourceApi {
  final commons.ApiRequester _requester;

  RegionSslCertificatesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified SslCertificate resource in the region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (sslCertificate == null) {
      throw core.ArgumentError('Parameter sslCertificate is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified SslCertificate resource in the specified region. Get
  /// a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (sslCertificate == null) {
      throw core.ArgumentError('Parameter sslCertificate is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SslCertificate.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a SslCertificate resource in the specified project and region
  /// using the data included in the request
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/sslCertificates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SslCertificateList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionTargetHttpProxiesResourceApi {
  final commons.ApiRequester _requester;

  RegionTargetHttpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetHttpProxy resource in the specified region.
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetHttpProxy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetHttpProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionTargetHttpsProxiesResourceApi {
  final commons.ApiRequester _requester;

  RegionTargetHttpsProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetHttpsProxy resource in the specified region.
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpsProxy.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetHttpsProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpsProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    RegionTargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionUrlMapsResourceApi {
  final commons.ApiRequester _requester;

  RegionUrlMapsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified UrlMap resource. Gets a list of available URL maps
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UrlMap.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of UrlMap resources available to the specified project
  /// in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          UrlMapList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request. This method supports PATCH semantics and uses JSON merge patch
  /// format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Runs static validation for the UrlMap. In particular, the tests of the
  /// provided UrlMap will be run. Calling this method does NOT create the
  /// UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    RegionUrlMapsValidateRequest request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/validate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UrlMapsValidateResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RegionsResourceApi {
  final commons.ApiRequester _requester;

  RegionsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Region resource. Gets a list of available regions by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Region].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Region> get(
    core.String project,
    core.String region, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Region.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of region resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/regions';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          RegionList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ReservationsResourceApi {
  final commons.ApiRequester _requester;

  ReservationsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of reservations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/reservations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ReservationAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (reservation == null) {
      throw core.ArgumentError('Parameter reservation is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves information about the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to retrieve.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Reservation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Reservation> get(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (reservation == null) {
      throw core.ArgumentError('Parameter reservation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Reservation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a new reservation. For more information, read Reserving zonal
  /// resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Reservation request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// A list of all the reservations that have been configured for the specified
  /// project in specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          ReservationList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Resizes the reservation (applicable to standalone reservations only). For
  /// more information, read Modifying reservations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [reservation] - Name of the reservation to update.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    ReservationsResizeRequest request,
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (reservation == null) {
      throw core.ArgumentError('Parameter reservation is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$reservation') +
        '/resize';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/reservations/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ResourcePoliciesResourceApi {
  final commons.ApiRequester _requester;

  ResourcePoliciesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of resource policies.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/resourcePolicies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ResourcePolicyAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resourcePolicy] - Name of the resource policy to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resourcePolicy == null) {
      throw core.ArgumentError('Parameter resourcePolicy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resourcePolicy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves all information of the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resourcePolicy] - Name of the resource policy to retrieve.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicy> get(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resourcePolicy == null) {
      throw core.ArgumentError('Parameter resourcePolicy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resourcePolicy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          ResourcePolicy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a new resource policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ResourcePolicy request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// A list all the resource policies that have been configured for the
  /// specified project in specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ResourcePolicyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/resourcePolicies/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RoutersResourceApi {
  final commons.ApiRequester _requester;

  RoutersResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of routers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/routers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RouterAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified Router resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String router, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified Router resource. Gets a list of available routers by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Router].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Router> get(
    core.String project,
    core.String region,
    core.String router, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Router.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves runtime Nat mapping information of VM endpoints.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query for Nat Mapping
  /// information of VM endpoints.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VmEndpointNatMappingsList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VmEndpointNatMappingsList> getNatMappingInfo(
    core.String project,
    core.String region,
    core.String router, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/getNatMappingInfo';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => VmEndpointNatMappingsList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves runtime information of the specified router.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterStatusResponse> getRouterStatus(
    core.String project,
    core.String region,
    core.String router, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/getRouterStatus';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RouterStatusResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a Router resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Router request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of Router resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          RouterList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified Router resource with the data included in the
  /// request. This method supports PATCH semantics and uses JSON merge patch
  /// format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Preview fields auto-generated during router create and update operations.
  /// Calling this method does NOT create or update the router.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RoutersPreviewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RoutersPreviewResponse> preview(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router') +
        '/preview';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RoutersPreviewResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified Router resource with the data included in the
  /// request. This method conforms to PUT semantics, which requests that the
  /// state of the target resource be created or replaced with the state defined
  /// by the representation enclosed in the request message payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [router] - Name of the Router resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (router == null) {
      throw core.ArgumentError('Parameter router is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/routers/' +
        commons.Escaper.ecapeVariable('$router');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class RoutesResourceApi {
  final commons.ApiRequester _requester;

  RoutesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Route resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String route, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (route == null) {
      throw core.ArgumentError('Parameter route is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified Route resource. Gets a list of available routes by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [route] - Name of the Route resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Route].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Route> get(
    core.String project,
    core.String route, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (route == null) {
      throw core.ArgumentError('Parameter route is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/routes/' +
        commons.Escaper.ecapeVariable('$route');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Route.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a Route resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Route request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of Route resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouteList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouteList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/routes';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => RouteList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class SecurityPoliciesResourceApi {
  final commons.ApiRequester _requester;

  SecurityPoliciesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Inserts a rule into a security policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/addRule';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String securityPolicy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// List all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to get.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicy> get(
    core.String project,
    core.String securityPolicy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SecurityPolicy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to which the queried rule
  /// belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to get from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyRule> getRule(
    core.String project,
    core.String securityPolicy, {
    core.int priority,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if (priority != null) {
      _queryParams['priority'] = ['${priority}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/getRule';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SecurityPolicyRule.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SecurityPolicy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/securityPolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// List all the policies that have been configured for the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/securityPolicies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SecurityPolicyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the current list of preconfigured Web Application Firewall (WAF)
  /// expressions.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [SecurityPoliciesListPreconfiguredExpressionSetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPoliciesListPreconfiguredExpressionSetsResponse>
      listPreconfiguredExpressionSets(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/listPreconfiguredExpressionSets';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
              data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SecurityPolicy request,
    core.String project,
    core.String securityPolicy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches a rule at the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.int priority,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if (priority != null) {
      _queryParams['priority'] = ['${priority}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/patchRule';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [priority] - The priority of the rule to remove from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
    core.String project,
    core.String securityPolicy, {
    core.int priority,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (securityPolicy == null) {
      throw core.ArgumentError('Parameter securityPolicy is required.');
    }
    if (priority != null) {
      _queryParams['priority'] = ['${priority}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.Escaper.ecapeVariable('$securityPolicy') +
        '/removeRule';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class SnapshotsResourceApi {
  final commons.ApiRequester _requester;

  SnapshotsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Snapshot resource. Keep in mind that deleting a
  /// single snapshot might not necessarily delete all the data on that
  /// snapshot. If any data on the snapshot that is marked for deletion is
  /// needed for subsequent snapshots, the data will be moved to the next
  /// corresponding snapshot.
  ///
  /// For more information, see Deleting snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String snapshot, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (snapshot == null) {
      throw core.ArgumentError('Parameter snapshot is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified Snapshot resource. Gets a list of available
  /// snapshots by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [snapshot] - Name of the Snapshot resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Snapshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Snapshot> get(
    core.String project,
    core.String snapshot, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (snapshot == null) {
      throw core.ArgumentError('Parameter snapshot is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$snapshot');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Snapshot.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of Snapshot resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SnapshotList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SnapshotList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/snapshots';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SnapshotList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on a snapshot. To learn more about labels, read the
  /// Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9_]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/snapshots/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class SslCertificatesResourceApi {
  final commons.ApiRequester _requester;

  SslCertificatesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all SslCertificate resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/sslCertificates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SslCertificateAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified SslCertificate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslCertificate, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (sslCertificate == null) {
      throw core.ArgumentError('Parameter sslCertificate is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified SslCertificate resource. Gets a list of available
  /// SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String sslCertificate, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (sslCertificate == null) {
      throw core.ArgumentError('Parameter sslCertificate is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.Escaper.ecapeVariable('$sslCertificate');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SslCertificate.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a SslCertificate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/sslCertificates';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SslCertificateList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class SslPoliciesResourceApi {
  final commons.ApiRequester _requester;

  SslPoliciesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified SSL policy. The SSL policy resource can be deleted
  /// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
  /// resources.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to delete. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslPolicy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (sslPolicy == null) {
      throw core.ArgumentError('Parameter sslPolicy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPolicy> get(
    core.String project,
    core.String sslPolicy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (sslPolicy == null) {
      throw core.ArgumentError('Parameter sslPolicy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SslPolicy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified SSL policy resource. Gets a list of available SSL
  /// policies by making a list() request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslPolicy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/sslPolicies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all the SSL policies that have been configured for the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/sslPolicies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SslPoliciesList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists all features that can be specified in the SSL policy when using
  /// custom profile.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesListAvailableFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesListAvailableFeaturesResponse> listAvailableFeatures(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/listAvailableFeatures';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SslPoliciesListAvailableFeaturesResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified SSL policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SslPolicy request,
    core.String project,
    core.String sslPolicy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (sslPolicy == null) {
      throw core.ArgumentError('Parameter sslPolicy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.Escaper.ecapeVariable('$sslPolicy');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class SubnetworksResourceApi {
  final commons.ApiRequester _requester;

  SubnetworksResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of subnetworks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/subnetworks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => SubnetworkAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified subnetwork.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (subnetwork == null) {
      throw core.ArgumentError('Parameter subnetwork is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Expands the IP CIDR range of the subnetwork to a specified value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> expandIpCidrRange(
    SubnetworksExpandIpCidrRangeRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (subnetwork == null) {
      throw core.ArgumentError('Parameter subnetwork is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/expandIpCidrRange';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified subnetwork. Gets a list of available subnetworks
  /// list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Subnetwork].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Subnetwork> get(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (subnetwork == null) {
      throw core.ArgumentError('Parameter subnetwork is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          Subnetwork.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the access control policy for a resource. May be empty if no such
  /// policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int optionsRequestedPolicyVersion,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (optionsRequestedPolicyVersion != null) {
      _queryParams['optionsRequestedPolicyVersion'] = [
        '${optionsRequestedPolicyVersion}'
      ];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/getIamPolicy';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a subnetwork in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Subnetwork request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of subnetworks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          SubnetworkList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves an aggregated list of all usable subnetworks in the project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UsableSubnetworksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UsableSubnetworksAggregatedList> listUsable(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/subnetworks/listUsable';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UsableSubnetworksAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified subnetwork with the data included in the request.
  /// Only certain fields can up updated with a patch request as indicated in
  /// the field descriptions. You must specify the current fingerprint of the
  /// subnetwork resource being patched.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [drainTimeoutSeconds] - The drain timeout specifies the upper bound in
  /// seconds on the amount of time allowed to drain connections from the
  /// current ACTIVE subnetwork to the current BACKUP subnetwork. The drain
  /// timeout is only applicable when the following conditions are true: - the
  /// subnetwork being patched has purpose = INTERNAL_HTTPS_LOAD_BALANCER - the
  /// subnetwork being patched has role = BACKUP - the patch request is setting
  /// the role to ACTIVE. Note that after this patch operation the roles of the
  /// ACTIVE and BACKUP subnetworks will be swapped.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Subnetwork request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.int drainTimeoutSeconds,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (subnetwork == null) {
      throw core.ArgumentError('Parameter subnetwork is required.');
    }
    if (drainTimeoutSeconds != null) {
      _queryParams['drainTimeoutSeconds'] = ['${drainTimeoutSeconds}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setIamPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Policy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Set whether VMs in this subnet can access Google services without
  /// assigning external IP addresses through Private Google Access.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [subnetwork] - Name of the Subnetwork resource.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setPrivateIpGoogleAccess(
    SubnetworksSetPrivateIpGoogleAccessRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (subnetwork == null) {
      throw core.ArgumentError('Parameter subnetwork is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$subnetwork') +
        '/setPrivateIpGoogleAccess';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/subnetworks/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetGrpcProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetGrpcProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetGrpcProxy in the given scope
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetGrpcProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetGrpcProxy == null) {
      throw core.ArgumentError('Parameter targetGrpcProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.Escaper.ecapeVariable('$targetGrpcProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetGrpcProxy resource in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxy> get(
    core.String project,
    core.String targetGrpcProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetGrpcProxy == null) {
      throw core.ArgumentError('Parameter targetGrpcProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.Escaper.ecapeVariable('$targetGrpcProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetGrpcProxy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetGrpcProxy in the specified project in the given scope
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetGrpcProxy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetGrpcProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Lists the TargetGrpcProxies for a project in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetGrpcProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetGrpcProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified TargetGrpcProxy resource with the data included in
  /// the request. This method supports PATCH semantics and uses JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetGrpcProxy request,
    core.String project,
    core.String targetGrpcProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetGrpcProxy == null) {
      throw core.ArgumentError('Parameter targetGrpcProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.Escaper.ecapeVariable('$targetGrpcProxy');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetHttpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of all TargetHttpProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetHttpProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpProxyAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetHttpProxy resource. Gets a list of available
  /// target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String targetHttpProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetHttpProxy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetHttpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetHttpProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified TargetHttpProxy resource with the data included in
  /// the request. This method supports PATCH semantics and uses JSON merge
  /// patch format and processing rules. (== suppress_warning http-rest-shadowed
  /// ==)
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetHttpProxy request,
    core.String project,
    core.String targetHttpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpProxy == null) {
      throw core.ArgumentError('Parameter targetHttpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetHttpsProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetHttpsProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of all TargetHttpsProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetHttpsProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpsProxyAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetHttpsProxy resource. Gets a list of available
  /// target HTTPS proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String targetHttpsProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpsProxy.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetHttpsProxy resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetHttpsProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the QUIC override policy for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set the QUIC
  /// override policy for. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setQuicOverride(
    TargetHttpsProxiesSetQuicOverrideRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setQuicOverride';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
  /// server-side support for SSL features. This affects connections between
  /// clients and the HTTPS proxy load balancer. They do not affect the
  /// connection between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose SSL
  /// policy is to be set. The name must be 1-63 characters long, and comply
  /// with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setSslPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose URL map
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetHttpsProxy == null) {
      throw core.ArgumentError('Parameter targetHttpsProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.Escaper.ecapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetInstancesResourceApi {
  final commons.ApiRequester _requester;

  TargetInstancesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetInstances';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetInstanceAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified TargetInstance resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (targetInstance == null) {
      throw core.ArgumentError('Parameter targetInstance is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetInstance resource. Gets a list of available
  /// target instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetInstance] - Name of the TargetInstance resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstance> get(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (targetInstance == null) {
      throw core.ArgumentError('Parameter targetInstance is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances/' +
        commons.Escaper.ecapeVariable('$targetInstance');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetInstance.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetInstance resource in the specified project and zone using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetInstance request,
    core.String project,
    core.String zone, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of TargetInstance resources available to the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/targetInstances';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetInstanceList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetPoolsResourceApi {
  final commons.ApiRequester _requester;

  TargetPoolsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Adds health check URLs to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to add a health check to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addHealthCheck(
    TargetPoolsAddHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addHealthCheck';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Adds an instance to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to add instances to.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstance(
    TargetPoolsAddInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/addInstance';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves an aggregated list of target pools.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/targetPools';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetPoolAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified target pool.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified target pool. Gets a list of available target pools
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPool> get(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetPool.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Gets the most recent health check results for each IP for the instance
  /// that is referenced by the given target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to which the queried
  /// instance belongs.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolInstanceHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolInstanceHealth> getHealth(
    InstanceReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/getHealth';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetPoolInstanceHealth.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a target pool in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetPool request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of target pools available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetPoolList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes health check URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the target pool to remove health checks from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeHealthCheck(
    TargetPoolsRemoveHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeHealthCheck';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Removes instance URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to remove instances from.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstance(
    TargetPoolsRemoveInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/removeInstance';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes a backup target pool's configurations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetPool] - Name of the TargetPool resource to set a backup pool for.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [failoverRatio] - New failoverRatio value for the target pool.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackup(
    TargetReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.double failoverRatio,
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetPool == null) {
      throw core.ArgumentError('Parameter targetPool is required.');
    }
    if (failoverRatio != null) {
      _queryParams['failoverRatio'] = ['${failoverRatio}'];
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetPools/' +
        commons.Escaper.ecapeVariable('$targetPool') +
        '/setBackup';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetSslProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetSslProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetSslProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetSslProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetSslProxy resource. Gets a list of available
  /// target SSL proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxy> get(
    core.String project,
    core.String targetSslProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetSslProxy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetSslProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetSslProxy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetSslProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetSslProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetSslProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the BackendService for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetSslProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setBackendService';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the ProxyHeaderType for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetSslProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setProxyHeader';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes SslCertificates for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// SslCertificate resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetSslProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setSslCertificates';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
  /// server-side support for SSL features. This affects connections between
  /// clients and the SSL proxy load balancer. They do not affect the connection
  /// between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose SSL policy is
  /// to be set. The name must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetSslProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetSslProxy == null) {
      throw core.ArgumentError('Parameter targetSslProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.Escaper.ecapeVariable('$targetSslProxy') +
        '/setSslPolicy';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetTcpProxiesResourceApi {
  final commons.ApiRequester _requester;

  TargetTcpProxiesResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetTcpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetTcpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetTcpProxy == null) {
      throw core.ArgumentError('Parameter targetTcpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified TargetTcpProxy resource. Gets a list of available
  /// target TCP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxy> get(
    core.String project,
    core.String targetTcpProxy, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetTcpProxy == null) {
      throw core.ArgumentError('Parameter targetTcpProxy is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          TargetTcpProxy.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a TargetTcpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetTcpProxy request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of TargetTcpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxyList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/global/targetTcpProxies';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetTcpProxyList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the BackendService for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetTcpProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetTcpProxy == null) {
      throw core.ArgumentError('Parameter targetTcpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setBackendService';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Changes the ProxyHeaderType for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetTcpProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (targetTcpProxy == null) {
      throw core.ArgumentError('Parameter targetTcpProxy is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.Escaper.ecapeVariable('$targetTcpProxy') +
        '/setProxyHeader';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class TargetVpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  TargetVpnGatewaysResourceApi(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of target VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/aggregated/targetVpnGateways';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetVpnGatewayAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified target VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetVpnGateway == null) {
      throw core.ArgumentError('Parameter targetVpnGateway is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified target VPN gateway. Gets a list of available target
  /// VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGateway> get(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (targetVpnGateway == null) {
      throw core.ArgumentError('Parameter targetVpnGateway is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.Escaper.ecapeVariable('$targetVpnGateway');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetVpnGateway.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a target VPN gateway in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetVpnGateway request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of target VPN gateways available to the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/targetVpnGateways';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TargetVpnGatewayList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class UrlMapsResourceApi {
  final commons.ApiRequester _requester;

  UrlMapsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all UrlMap resources, regional and global, available
  /// to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/urlMaps';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UrlMapsAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified UrlMap resource. Gets a list of available URL maps
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String urlMap, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UrlMap.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Initiates a cache invalidation operation, invalidating the specified path,
  /// scoped to the specified UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap scoping this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> invalidateCache(
    CacheInvalidationRule request,
    core.String project,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/invalidateCache';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of UrlMap resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/global/urlMaps';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          UrlMapList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request. This method supports PATCH semantics and uses the JSON merge
  /// patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap');

    final _response = _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Runs static validation for the UrlMap. In particular, the tests of the
  /// provided UrlMap will be run. Calling this method does NOT create the
  /// UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    UrlMapsValidateRequest request,
    core.String project,
    core.String urlMap, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (urlMap == null) {
      throw core.ArgumentError('Parameter urlMap is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/global/urlMaps/' +
        commons.Escaper.ecapeVariable('$urlMap') +
        '/validate';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => UrlMapsValidateResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class VpnGatewaysResourceApi {
  final commons.ApiRequester _requester;

  VpnGatewaysResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url =
        commons.Escaper.ecapeVariable('$project') + '/aggregated/vpnGateways';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => VpnGatewayAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (vpnGateway == null) {
      throw core.ArgumentError('Parameter vpnGateway is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified VPN gateway. Gets a list of available VPN gateways
  /// by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGateway> get(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (vpnGateway == null) {
      throw core.ArgumentError('Parameter vpnGateway is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          VpnGateway.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the status for the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewaysGetStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewaysGetStatusResponse> getStatus(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (vpnGateway == null) {
      throw core.ArgumentError('Parameter vpnGateway is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$vpnGateway') +
        '/getStatus';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => VpnGatewaysGetStatusResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a VPN gateway in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnGateway request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of VPN gateways available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          VpnGatewayList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Sets the labels on a VpnGateway. To learn more about labels, read the
  /// Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/setLabels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (resource == null) {
      throw core.ArgumentError('Parameter resource is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnGateways/' +
        commons.Escaper.ecapeVariable('$resource') +
        '/testIamPermissions';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => TestPermissionsResponse.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }
}

class VpnTunnelsResourceApi {
  final commons.ApiRequester _requester;

  VpnTunnelsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN tunnels.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelAggregatedList> aggregatedList(
    core.String project, {
    core.String filter,
    core.bool includeAllScopes,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (includeAllScopes != null) {
      _queryParams['includeAllScopes'] = ['${includeAllScopes}'];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/aggregated/vpnTunnels';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => VpnTunnelAggregatedList.fromJson(
          data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Deletes the specified VpnTunnel resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (vpnTunnel == null) {
      throw core.ArgumentError('Parameter vpnTunnel is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Returns the specified VpnTunnel resource. Gets a list of available VPN
  /// tunnels by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnel> get(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (vpnTunnel == null) {
      throw core.ArgumentError('Parameter vpnTunnel is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels/' +
        commons.Escaper.ecapeVariable('$vpnTunnel');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => VpnTunnel.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Creates a VpnTunnel resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnTunnel request,
    core.String project,
    core.String region, {
    core.String requestId,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (request != null) {
      _body = convert.json.encode(request.toJson());
    }
    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (requestId != null) {
      _queryParams['requestId'] = [requestId];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of VpnTunnel resources contained in the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelList> list(
    core.String project,
    core.String region, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (region == null) {
      throw core.ArgumentError('Parameter region is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/regions/' +
        commons.Escaper.ecapeVariable('$region') +
        '/vpnTunnels';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          VpnTunnelList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ZoneOperationsResourceApi {
  final commons.ApiRequester _requester;

  ZoneOperationsResourceApi(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future delete(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _downloadOptions = null;

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'DELETE',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => null,
    );
  }

  /// Retrieves the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String zone, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) =>
          OperationList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource. This method differs from the `GET` method in that it
  /// waits for no more than the default deadline (2 minutes) and then returns
  /// the current state of the operation, which might be `DONE` or still in
  /// progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?".
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if (operation == null) {
      throw core.ArgumentError('Parameter operation is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone') +
        '/operations/' +
        commons.Escaper.ecapeVariable('$operation') +
        '/wait';

    final _response = _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Operation.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

class ZonesResourceApi {
  final commons.ApiRequester _requester;

  ZonesResourceApi(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Zone resource. Gets a list of available zones by
  /// making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [zone] - Name of the zone resource to return.
  /// Value must have pattern
  /// "[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?|[1-9][0-9]{0,19}".
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Zone].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Zone> get(
    core.String project,
    core.String zone, {
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (zone == null) {
      throw core.ArgumentError('Parameter zone is required.');
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') +
        '/zones/' +
        commons.Escaper.ecapeVariable('$zone');

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => Zone.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }

  /// Retrieves the list of Zone resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// "(?:(?:[-a-z0-9]{1,63}\.)*(?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?):)?(?:[0-9]{1,19}|(?:[a-z0-9](?:[-a-z0-9]{0,61}[a-z0-9])?))".
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false
  /// and the logic is the same as today.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ZoneList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ZoneList> list(
    core.String project, {
    core.String filter,
    core.int maxResults,
    core.String orderBy,
    core.String pageToken,
    core.bool returnPartialSuccess,
    core.String $fields,
  }) {
    core.String _url;
    final _queryParams = <core.String, core.List<core.String>>{};
    commons.Media _uploadMedia;
    commons.UploadOptions _uploadOptions;
    var _downloadOptions = commons.DownloadOptions.Metadata;
    core.String _body;

    if (project == null) {
      throw core.ArgumentError('Parameter project is required.');
    }
    if (filter != null) {
      _queryParams['filter'] = [filter];
    }
    if (maxResults != null) {
      _queryParams['maxResults'] = ['${maxResults}'];
    }
    if (orderBy != null) {
      _queryParams['orderBy'] = [orderBy];
    }
    if (pageToken != null) {
      _queryParams['pageToken'] = [pageToken];
    }
    if (returnPartialSuccess != null) {
      _queryParams['returnPartialSuccess'] = ['${returnPartialSuccess}'];
    }
    if ($fields != null) {
      _queryParams['fields'] = [$fields];
    }

    _url = commons.Escaper.ecapeVariable('$project') + '/zones';

    final _response = _requester.request(
      _url,
      'GET',
      body: _body,
      queryParams: _queryParams,
      uploadOptions: _uploadOptions,
      uploadMedia: _uploadMedia,
      downloadOptions: _downloadOptions,
    );
    return _response.then(
      (data) => ZoneList.fromJson(data as core.Map<core.String, core.dynamic>),
    );
  }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
class AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance. For example:
  /// projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
  /// If you are creating an instance template, specify only the accelerator
  /// name. See GPUs on Compute Engine for a full list of accelerator types.
  core.String acceleratorType;

  AcceleratorConfig();

  AcceleratorConfig.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorCount')) {
      acceleratorCount = _json['acceleratorCount'] as core.int;
    }
    if (_json.containsKey('acceleratorType')) {
      acceleratorType = _json['acceleratorType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (acceleratorCount != null) {
      _json['acceleratorCount'] = acceleratorCount;
    }
    if (acceleratorType != null) {
      _json['acceleratorType'] = acceleratorType;
    }
    return _json;
  }
}

/// Represents an Accelerator Type resource.
///
/// Google Cloud Platform provides graphics processing units (accelerators) that
/// you can add to VM instances to improve or accelerate performance when
/// working with intensive workloads. For more information, read GPUs on Compute
/// Engine. (== resource_for {$api_version}.acceleratorTypes ==)
class AcceleratorType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this accelerator
  /// type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#acceleratorType for
  /// accelerator types.
  core.String kind;

  /// [Output Only] Maximum number of accelerator cards allowed per instance.
  core.int maximumCardsPerInstance;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined, fully qualified URL for this resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the accelerator type resides,
  /// such as us-central1-a. You must specify this field as part of the HTTP
  /// request URL. It is not settable as a field in the request body.
  core.String zone;

  AcceleratorType();

  AcceleratorType.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('maximumCardsPerInstance')) {
      maximumCardsPerInstance = _json['maximumCardsPerInstance'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (maximumCardsPerInstance != null) {
      _json['maximumCardsPerInstance'] = maximumCardsPerInstance;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeAggregatedListWarningData();

  AcceleratorTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeAggregatedListWarning();

  AcceleratorTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypeAggregatedListWarningData>((value) =>
              AcceleratorTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AcceleratorTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorTypesScopedList resources.
  core.Map<core.String, AcceleratorTypesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#acceleratorTypeAggregatedList for aggregated lists of accelerator
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  AcceleratorTypeAggregatedListWarning warning;

  AcceleratorTypeAggregatedList();

  AcceleratorTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              AcceleratorTypesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AcceleratorTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypeListWarningData();

  AcceleratorTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AcceleratorTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypeListWarning();

  AcceleratorTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypeListWarningData>((value) =>
              AcceleratorTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of accelerator types.
class AcceleratorTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AcceleratorType resources.
  core.List<AcceleratorType> items;

  /// [Output Only] Type of resource. Always compute#acceleratorTypeList for
  /// lists of accelerator types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AcceleratorTypeListWarning warning;

  AcceleratorTypeList();

  AcceleratorTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<AcceleratorType>((value) => AcceleratorType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AcceleratorTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AcceleratorTypesScopedListWarningData();

  AcceleratorTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the accelerator
/// types list is empty.
class AcceleratorTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AcceleratorTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AcceleratorTypesScopedListWarning();

  AcceleratorTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypesScopedListWarningData>((value) =>
              AcceleratorTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AcceleratorTypesScopedList {
  /// [Output Only] A list of accelerator types contained in this scope.
  core.List<AcceleratorType> acceleratorTypes;

  /// [Output Only] An informational warning that appears when the accelerator
  /// types list is empty.
  AcceleratorTypesScopedListWarning warning;

  AcceleratorTypesScopedList();

  AcceleratorTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorTypes')) {
      acceleratorTypes = (_json['acceleratorTypes'] as core.List)
          .map<AcceleratorType>((value) => AcceleratorType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (acceleratorTypes != null) {
      _json['acceleratorTypes'] =
          acceleratorTypes.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// An access configuration attached to an instance's network interface. Only
/// one access config per instance is supported.
class AccessConfig {
  /// [Output Only] Type of the resource. Always compute#accessConfig for access
  /// configs.
  core.String kind;

  /// The name of this access configuration. The default and recommended name is
  /// External NAT, but you can use any arbitrary string, such as My external IP
  /// or Network Access.
  core.String name;

  /// An external IP address associated with this instance. Specify an unused
  /// static external IP address available to the project or leave this field
  /// undefined to use an IP from a shared ephemeral IP address pool. If you
  /// specify a static external IP address, it must live in the same region as
  /// the zone of the instance.
  core.String natIP;

  /// This signifies the networking tier used for configuring this access
  /// configuration and can only take the following values: PREMIUM, STANDARD.
  ///
  /// If an AccessConfig is specified without a valid external IP address, an
  /// ephemeral IP will be created with this networkTier.
  ///
  /// If an AccessConfig with a valid external IP address is specified, it must
  /// match that of the networkTier associated with the Address resource owning
  /// that IP.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// The DNS domain name for the public PTR record. You can set this field only
  /// if the `setPublicPtr` field is enabled.
  core.String publicPtrDomainName;

  /// Specifies whether a public DNS 'PTR' record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  core.bool setPublicPtr;

  /// The type of configuration. The default and only option is ONE_TO_ONE_NAT.
  /// Possible string values are:
  /// - "ONE_TO_ONE_NAT"
  core.String type;

  AccessConfig();

  AccessConfig.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natIP')) {
      natIP = _json['natIP'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('publicPtrDomainName')) {
      publicPtrDomainName = _json['publicPtrDomainName'] as core.String;
    }
    if (_json.containsKey('setPublicPtr')) {
      setPublicPtr = _json['setPublicPtr'] as core.bool;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (natIP != null) {
      _json['natIP'] = natIP;
    }
    if (networkTier != null) {
      _json['networkTier'] = networkTier;
    }
    if (publicPtrDomainName != null) {
      _json['publicPtrDomainName'] = publicPtrDomainName;
    }
    if (setPublicPtr != null) {
      _json['setPublicPtr'] = setPublicPtr;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

/// Use global external addresses for GFE-based external HTTP(S) load balancers
/// in Premium Tier.
///
/// Use global internal addresses for reserved peering network range.
///
/// Use regional external addresses for the following resources:
///
/// - External IP addresses for VM instances - Regional external forwarding
/// rules - Cloud NAT external IP addresses - GFE based LBs in Standard Tier -
/// Network LBs in Premium or Standard Tier - Cloud VPN gateways (both Classic
/// and HA)
///
/// Use regional internal IP addresses for subnet IP ranges (primary and
/// secondary). This includes:
///
/// - Internal IP addresses for VM instances - Alias IP ranges of VM instances
/// (/32 only) - Regional internal forwarding rules - Internal TCP/UDP load
/// balancer addresses - Internal HTTP(S) load balancer addresses - Cloud DNS
/// inbound forwarding IP addresses
///
/// For more information, read reserved IP address.
///
/// (== resource_for {$api_version}.addresses ==) (== resource_for
/// {$api_version}.globalAddresses ==)
class Address {
  /// The static IP address represented by this resource.
  core.String address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL. If
  /// unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "UNSPECIFIED_TYPE"
  core.String addressType;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP version that will be used by this address. Valid options are IPV4
  /// or IPV6. This can only be specified for a global address.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// [Output Only] Type of the resource. Always compute#address for addresses.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// The URL of the network in which to reserve the address. This field can
  /// only be used with INTERNAL type with the VPC_PEERING purpose.
  core.String network;

  /// This signifies the networking tier used for configuring this address and
  /// can only take the following values: PREMIUM or STANDARD. Global forwarding
  /// rules can only be Premium Tier. Regional forwarding rules can be either
  /// Premium or Standard Tier. Standard Tier addresses applied to regional
  /// forwarding rules can be used with any external load balancer. Regional
  /// forwarding rules in Premium Tier can only be used with a network load
  /// balancer.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// The prefix length if the resource reprensents an IP range.
  core.int prefixLength;

  /// The purpose of this resource, which can be one of the following values:
  /// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP
  /// ranges, internal load balancers, and similar resources.
  /// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork
  /// - `VPC_PEERING` for addresses that are reserved for VPC peer networks.
  /// - `NAT_AUTO` for addresses that are external IP addresses automatically
  /// reserved for Cloud NAT.
  /// Possible string values are:
  /// - "DNS_RESOLVER"
  /// - "GCE_ENDPOINT"
  /// - "NAT_AUTO"
  /// - "SHARED_LOADBALANCER_VIP"
  /// - "VPC_PEERING"
  core.String purpose;

  /// [Output Only] The URL of the region where the regional address resides.
  /// This field is not applicable to global addresses. You must specify this
  /// field as part of the HTTP request URL.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the address, which can be one of RESERVING,
  /// RESERVED, or IN_USE. An address that is RESERVING is currently in the
  /// process of being reserved. A RESERVED address is currently reserved and
  /// available to use. An IN_USE address is currently being used by another
  /// resource and is not available.
  /// Possible string values are:
  /// - "IN_USE"
  /// - "RESERVED"
  /// - "RESERVING"
  core.String status;

  /// The URL of the subnetwork in which to reserve the address. If an IP
  /// address is specified, it must be within the subnetwork's IP range. This
  /// field can only be used with INTERNAL type with a GCE_ENDPOINT or
  /// DNS_RESOLVER purpose.
  core.String subnetwork;

  /// [Output Only] The URLs of the resources that are using this address.
  core.List<core.String> users;

  Address();

  Address.fromJson(core.Map _json) {
    if (_json.containsKey('address')) {
      address = _json['address'] as core.String;
    }
    if (_json.containsKey('addressType')) {
      addressType = _json['addressType'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipVersion')) {
      ipVersion = _json['ipVersion'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('prefixLength')) {
      prefixLength = _json['prefixLength'] as core.int;
    }
    if (_json.containsKey('purpose')) {
      purpose = _json['purpose'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('users')) {
      users = (_json['users'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (address != null) {
      _json['address'] = address;
    }
    if (addressType != null) {
      _json['addressType'] = addressType;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (ipVersion != null) {
      _json['ipVersion'] = ipVersion;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (networkTier != null) {
      _json['networkTier'] = networkTier;
    }
    if (prefixLength != null) {
      _json['prefixLength'] = prefixLength;
    }
    if (purpose != null) {
      _json['purpose'] = purpose;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    if (users != null) {
      _json['users'] = users;
    }
    return _json;
  }
}

class AddressAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressAggregatedListWarningData();

  AddressAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressAggregatedListWarning();

  AddressAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressAggregatedListWarningData>((value) =>
              AddressAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AddressAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AddressesScopedList resources.
  core.Map<core.String, AddressesScopedList> items;

  /// [Output Only] Type of resource. Always compute#addressAggregatedList for
  /// aggregated lists of addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  AddressAggregatedListWarning warning;

  AddressAggregatedList();

  AddressAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              AddressesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AddressAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AddressListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressListWarningData();

  AddressListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AddressListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressListWarning();

  AddressListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressListWarningData>((value) =>
              AddressListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of addresses.
class AddressList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Address resources.
  core.List<Address> items;

  /// [Output Only] Type of resource. Always compute#addressList for lists of
  /// addresses.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AddressListWarning warning;

  AddressList();

  AddressList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Address>((value) =>
              Address.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AddressListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AddressesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AddressesScopedListWarningData();

  AddressesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class AddressesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AddressesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AddressesScopedListWarning();

  AddressesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressesScopedListWarningData>((value) =>
              AddressesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AddressesScopedList {
  /// [Output Only] A list of addresses contained in this scope.
  core.List<Address> addresses;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  AddressesScopedListWarning warning;

  AddressesScopedList();

  AddressesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('addresses')) {
      addresses = (_json['addresses'] as core.List)
          .map<Address>((value) =>
              Address.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AddressesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (addresses != null) {
      _json['addresses'] = addresses.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// An alias IP range attached to an instance's network interface.
class AliasIpRange {
  /// The IP alias ranges to allocate for this interface. This IP CIDR range
  /// must belong to the specified subnetwork and cannot contain IP addresses
  /// reserved by system or used by other network interfaces. This range may be
  /// a single IP address (such as 10.2.3.4), a netmask (such as /24) or a
  /// CIDR-formatted string (such as 10.1.2.0/24).
  core.String ipCidrRange;

  /// The name of a subnetwork secondary IP range from which to allocate an IP
  /// alias range. If not specified, the primary range of the subnetwork is
  /// used.
  core.String subnetworkRangeName;

  AliasIpRange();

  AliasIpRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('subnetworkRangeName')) {
      subnetworkRangeName = _json['subnetworkRangeName'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    if (subnetworkRangeName != null) {
      _json['subnetworkRangeName'] = subnetworkRangeName;
    }
    return _json;
  }
}

class AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /// Specifies the size of the disk in base-2 GB.
  core.String diskSizeGb;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME. The default is SCSI. For performance characteristics
  /// of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String interface;

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk();

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk.fromJson(
      core.Map _json) {
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('interface')) {
      interface = _json['interface'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (diskSizeGb != null) {
      _json['diskSizeGb'] = diskSizeGb;
    }
    if (interface != null) {
      _json['interface'] = interface;
    }
    return _json;
  }
}

/// Properties of the SKU instances being reserved. Next ID: 9
class AllocationSpecificSKUAllocationReservedInstanceProperties {
  /// Specifies accelerator type and count.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Specifies amount of local ssd to reserve with each instance. The type of
  /// disk is local-ssd.
  core.List<
          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>
      localSsds;

  /// Specifies type of machine (name only) which has fixed number of vCPUs and
  /// fixed amount of memory. This also includes specifying custom machine type
  /// following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
  core.String machineType;

  /// Minimum cpu platform the reservation.
  core.String minCpuPlatform;

  AllocationSpecificSKUAllocationReservedInstanceProperties();

  AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('localSsds')) {
      localSsds = (_json['localSsds'] as core.List)
          .map<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>(
              (value) =>
                  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (guestAccelerators != null) {
      _json['guestAccelerators'] =
          guestAccelerators.map((value) => value.toJson()).toList();
    }
    if (localSsds != null) {
      _json['localSsds'] = localSsds.map((value) => value.toJson()).toList();
    }
    if (machineType != null) {
      _json['machineType'] = machineType;
    }
    if (minCpuPlatform != null) {
      _json['minCpuPlatform'] = minCpuPlatform;
    }
    return _json;
  }
}

/// This reservation type allows to pre allocate specific instance
/// configuration.
class AllocationSpecificSKUReservation {
  /// Specifies the number of resources that are allocated.
  core.String count;

  /// [Output Only] Indicates how many instances are in use.
  core.String inUseCount;

  /// The instance properties for the reservation.
  AllocationSpecificSKUAllocationReservedInstanceProperties instanceProperties;

  AllocationSpecificSKUReservation();

  AllocationSpecificSKUReservation.fromJson(core.Map _json) {
    if (_json.containsKey('count')) {
      count = _json['count'] as core.String;
    }
    if (_json.containsKey('inUseCount')) {
      inUseCount = _json['inUseCount'] as core.String;
    }
    if (_json.containsKey('instanceProperties')) {
      instanceProperties =
          AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
              _json['instanceProperties']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (count != null) {
      _json['count'] = count;
    }
    if (inUseCount != null) {
      _json['inUseCount'] = inUseCount;
    }
    if (instanceProperties != null) {
      _json['instanceProperties'] = instanceProperties.toJson();
    }
    return _json;
  }
}

/// An instance-attached disk resource.
class AttachedDisk {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool autoDelete;

  /// Indicates that this is a boot disk. The virtual machine will use the first
  /// partition of the disk for its root filesystem.
  core.bool boot;

  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance. This name can be used to reference the device for mounting,
  /// resizing, and so on, from within the instance.
  ///
  /// If not specified, the server chooses a default device name to apply to
  /// this disk, in the form persistent-disk-x, where x is a number assigned by
  /// Google Compute Engine. This field is only applicable for persistent disks.
  core.String deviceName;

  /// Encrypts or decrypts a disk using a customer-supplied encryption key.
  ///
  /// If you are creating a new disk, this field encrypts the new disk using an
  /// encryption key that you provide. If you are attaching an existing disk
  /// that is already encrypted, this field decrypts the disk using the
  /// customer-supplied encryption key.
  ///
  /// If you encrypt a disk using a customer-supplied key, you must provide the
  /// same key again when you attempt to use this resource at a later time. For
  /// example, you must provide the key when you create a snapshot or an image
  /// from the disk or when you attach the disk to a virtual machine instance.
  ///
  /// If you do not provide an encryption key, then the disk will be encrypted
  /// using an automatically generated key and you do not need to provide a key
  /// to use the disk later.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot use your own keys to encrypt disks in a managed instance group.
  CustomerEncryptionKey diskEncryptionKey;

  /// The size of the disk in GB.
  core.String diskSizeGb;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] A zero-based index to this disk, where 0 is reserved for the
  /// boot disk. If you have many disks attached to an instance, each disk would
  /// have a unique index number.
  core.int index;

  /// [Input Only] Specifies the parameters for a new disk that will be created
  /// alongside the new instance. Use initialization parameters to create boot
  /// disks or local SSDs attached to the new instance.
  ///
  /// This property is mutually exclusive with the source property; you can only
  /// define one or the other, but not both.
  AttachedDiskInitializeParams initializeParams;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME. The default is SCSI. Persistent disks must always use
  /// SCSI and the request will fail if you attempt to attach a persistent disk
  /// in any other format than SCSI. Local SSDs can use either NVME or SCSI. For
  /// performance characteristics of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String interface;

  /// [Output Only] Type of the resource. Always compute#attachedDisk for
  /// attached disks.
  core.String kind;

  /// [Output Only] Any valid publicly visible licenses.
  core.List<core.String> licenses;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
  /// not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String mode;

  /// [Output Only] shielded vm initial state stored on disk
  InitialStateConfig shieldedInstanceInitialState;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. When creating a new instance, one of
  /// initializeParams.sourceImage or initializeParams.sourceSnapshot or
  /// disks.source is required except for local SSD.
  ///
  /// If desired, you can also attach existing non-root persistent disks using
  /// this property. This field is only applicable for persistent disks.
  ///
  /// Note that for InstanceTemplate, specify the disk name, not the URL for the
  /// disk.
  core.String source;

  /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
  /// specified, the default is PERSISTENT.
  /// Possible string values are:
  /// - "PERSISTENT"
  /// - "SCRATCH"
  core.String type;

  AttachedDisk();

  AttachedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.bool;
    }
    if (_json.containsKey('boot')) {
      boot = _json['boot'] as core.bool;
    }
    if (_json.containsKey('deviceName')) {
      deviceName = _json['deviceName'] as core.String;
    }
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('index')) {
      index = _json['index'] as core.int;
    }
    if (_json.containsKey('initializeParams')) {
      initializeParams = AttachedDiskInitializeParams.fromJson(
          _json['initializeParams'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('interface')) {
      interface = _json['interface'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('shieldedInstanceInitialState')) {
      shieldedInstanceInitialState = InitialStateConfig.fromJson(
          _json['shieldedInstanceInitialState']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoDelete != null) {
      _json['autoDelete'] = autoDelete;
    }
    if (boot != null) {
      _json['boot'] = boot;
    }
    if (deviceName != null) {
      _json['deviceName'] = deviceName;
    }
    if (diskEncryptionKey != null) {
      _json['diskEncryptionKey'] = diskEncryptionKey.toJson();
    }
    if (diskSizeGb != null) {
      _json['diskSizeGb'] = diskSizeGb;
    }
    if (guestOsFeatures != null) {
      _json['guestOsFeatures'] =
          guestOsFeatures.map((value) => value.toJson()).toList();
    }
    if (index != null) {
      _json['index'] = index;
    }
    if (initializeParams != null) {
      _json['initializeParams'] = initializeParams.toJson();
    }
    if (interface != null) {
      _json['interface'] = interface;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (licenses != null) {
      _json['licenses'] = licenses;
    }
    if (mode != null) {
      _json['mode'] = mode;
    }
    if (shieldedInstanceInitialState != null) {
      _json['shieldedInstanceInitialState'] =
          shieldedInstanceInitialState.toJson();
    }
    if (source != null) {
      _json['source'] = source;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

/// [Input Only] Specifies the parameters for a new disk that will be created
/// alongside the new instance. Use initialization parameters to create boot
/// disks or local SSDs attached to the new instance.
///
/// This property is mutually exclusive with the source property; you can only
/// define one or the other, but not both.
class AttachedDiskInitializeParams {
  /// An optional description. Provide this property when creating the disk.
  core.String description;

  /// Specifies the disk name. If not specified, the default is to use the name
  /// of the instance. If a disk with the same name already exists in the given
  /// region, the existing disk is attached to the new instance and the new disk
  /// is not created.
  core.String diskName;

  /// Specifies the size of the disk in base-2 GB. The size must be at least 10
  /// GB. If you specify a sourceImage, which is required for boot disks, the
  /// default size is the size of the sourceImage. If you do not specify a
  /// sourceImage, the default disk size is 500 GB.
  core.String diskSizeGb;

  /// Specifies the disk type to use to create the instance. If not specified,
  /// the default is pd-standard, specified using the full URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard
  ///
  ///
  /// Other values include pd-ssd and local-ssd. If you define this field, you
  /// can provide either the full or partial URL. For example, the following are
  /// valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
  /// - projects/project/zones/zone/diskTypes/diskType
  /// - zones/zone/diskTypes/diskType  Note that for InstanceTemplate, this is
  /// the name of the disk type, not URL.
  core.String diskType;

  /// Labels to apply to this disk. These can be later modified by the
  /// disks.setLabels method. This field is only applicable for persistent
  /// disks.
  core.Map<core.String, core.String> labels;

  /// Specifies which action to take on instance update with this disk. Default
  /// is to use the existing disk.
  /// Possible string values are:
  /// - "RECREATE_DISK"
  /// - "RECREATE_DISK_IF_SOURCE_CHANGED"
  /// - "USE_EXISTING_DISK"
  core.String onUpdateAction;

  /// Resource policies applied to this disk for automatic snapshot creations.
  /// Specified using the full or partial URL. For instance template, specify
  /// only the resource policy name.
  core.List<core.String> resourcePolicies;

  /// The source image to create this disk. When creating a new instance, one of
  /// initializeParams.sourceImage or initializeParams.sourceSnapshot or
  /// disks.source is required except for local SSD.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  ///
  ///
  /// If the source image is deleted later, this field will not be set.
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot create disks for instances in a managed instance group if the
  /// source images are encrypted with your own keys.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// The source snapshot to create this disk. When creating a new instance, one
  /// of initializeParams.sourceSnapshot or initializeParams.sourceImage or
  /// disks.source is required except for local SSD.
  ///
  /// To create a disk with a snapshot that you created, specify the snapshot
  /// name in the following format:
  /// global/snapshots/my-backup
  ///
  ///
  /// If the source snapshot is deleted later, this field will not be set.
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  AttachedDiskInitializeParams();

  AttachedDiskInitializeParams.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskName')) {
      diskName = _json['diskName'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('diskType')) {
      diskType = _json['diskType'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('onUpdateAction')) {
      onUpdateAction = _json['onUpdateAction'] as core.String;
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (diskName != null) {
      _json['diskName'] = diskName;
    }
    if (diskSizeGb != null) {
      _json['diskSizeGb'] = diskSizeGb;
    }
    if (diskType != null) {
      _json['diskType'] = diskType;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (onUpdateAction != null) {
      _json['onUpdateAction'] = onUpdateAction;
    }
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    if (sourceImage != null) {
      _json['sourceImage'] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json['sourceImageEncryptionKey'] = sourceImageEncryptionKey.toJson();
    }
    if (sourceSnapshot != null) {
      _json['sourceSnapshot'] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json['sourceSnapshotEncryptionKey'] =
          sourceSnapshotEncryptionKey.toJson();
    }
    return _json;
  }
}

/// Specifies the audit configuration for a service. The configuration
/// determines which permission types are logged, and what identities, if any,
/// are exempted from logging. An AuditConfig must have one or more
/// AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service, the
/// union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
/// { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ {
/// "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] },
/// { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service":
/// "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type":
/// "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [
/// "user:aliya@example.com" ] } ] } ] }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts jose@example.com from DATA_READ logging, and
/// aliya@example.com from DATA_WRITE logging.
class AuditConfig {
  /// The configuration for logging of each type of permission.
  core.List<AuditLogConfig> auditLogConfigs;
  core.List<core.String> exemptedMembers;

  /// Specifies a service that will be enabled for audit logging. For example,
  /// `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a
  /// special value that covers all services.
  core.String service;

  AuditConfig();

  AuditConfig.fromJson(core.Map _json) {
    if (_json.containsKey('auditLogConfigs')) {
      auditLogConfigs = (_json['auditLogConfigs'] as core.List)
          .map<AuditLogConfig>((value) => AuditLogConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('exemptedMembers')) {
      exemptedMembers = (_json['exemptedMembers'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (auditLogConfigs != null) {
      _json['auditLogConfigs'] =
          auditLogConfigs.map((value) => value.toJson()).toList();
    }
    if (exemptedMembers != null) {
      _json['exemptedMembers'] = exemptedMembers;
    }
    if (service != null) {
      _json['service'] = service;
    }
    return _json;
  }
}

/// Provides the configuration for logging a type of permissions. Example:
///
/// { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [
/// "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
class AuditLogConfig {
  /// Specifies the identities that do not cause logging for this type of
  /// permission. Follows the same format of [Binding.members][].
  core.List<core.String> exemptedMembers;
  core.bool ignoreChildExemptions;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "LOG_TYPE_UNSPECIFIED"
  core.String logType;

  AuditLogConfig();

  AuditLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('exemptedMembers')) {
      exemptedMembers = (_json['exemptedMembers'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('ignoreChildExemptions')) {
      ignoreChildExemptions = _json['ignoreChildExemptions'] as core.bool;
    }
    if (_json.containsKey('logType')) {
      logType = _json['logType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (exemptedMembers != null) {
      _json['exemptedMembers'] = exemptedMembers;
    }
    if (ignoreChildExemptions != null) {
      _json['ignoreChildExemptions'] = ignoreChildExemptions;
    }
    if (logType != null) {
      _json['logType'] = logType;
    }
    return _json;
  }
}

/// Authorization-related information used by Cloud Audit Logging.
class AuthorizationLoggingOptions {
  /// The type of the permission that was checked.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "ADMIN_WRITE"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "PERMISSION_TYPE_UNSPECIFIED"
  core.String permissionType;

  AuthorizationLoggingOptions();

  AuthorizationLoggingOptions.fromJson(core.Map _json) {
    if (_json.containsKey('permissionType')) {
      permissionType = _json['permissionType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (permissionType != null) {
      _json['permissionType'] = permissionType;
    }
    return _json;
  }
}

/// Represents an Autoscaler resource.
///
/// Google Compute Engine has two Autoscaler resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/autoscalers) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionAutoscalers)
///
/// Use autoscalers to automatically add or delete instances from a managed
/// instance group according to your defined autoscaling policy. For more
/// information, read Autoscaling Groups of Instances.
///
/// For zonal managed instance groups resource, use the autoscaler resource.
///
/// For regional managed instance groups, use the regionAutoscalers resource.
/// (== resource_for {$api_version}.autoscalers ==) (== resource_for
/// {$api_version}.regionAutoscalers ==)
class Autoscaler {
  /// The configuration parameters for the autoscaling algorithm. You can define
  /// one or more of the policies for an autoscaler: cpuUtilization,
  /// customMetricUtilizations, and loadBalancingUtilization.
  ///
  /// If none of these are specified, the default will be to autoscale based on
  /// cpuUtilization to 0.6 or 60%.
  AutoscalingPolicy autoscalingPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#autoscaler for
  /// autoscalers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Target recommended MIG size (number of instances) computed
  /// by autoscaler. Autoscaler calculates recommended MIG size even when
  /// autoscaling policy mode is different from ON. This field is empty when
  /// autoscaler is not connected to the existing managed instance group or
  /// autoscaler did not generate its prediction.
  core.int recommendedSize;

  /// [Output Only] URL of the region where the instance group resides (for
  /// autoscalers living in regional scope).
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the autoscaler configuration. Current set of
  /// possible values:
  /// - PENDING: Autoscaler backend hasn't read new/updated configuration.
  /// - DELETING: Configuration is being deleted.
  /// - ACTIVE: Configuration is acknowledged to be effective. Some warnings
  /// might be present in the statusDetails field.
  /// - ERROR: Configuration has errors. Actionable for users. Details are
  /// present in the statusDetails field.  New values might be added in the
  /// future.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETING"
  /// - "ERROR"
  /// - "PENDING"
  core.String status;

  /// [Output Only] Human-readable details about the current state of the
  /// autoscaler. Read the documentation for Commonly returned status messages
  /// for examples of status messages you might encounter.
  core.List<AutoscalerStatusDetails> statusDetails;

  /// URL of the managed instance group that this autoscaler will scale.
  core.String target;

  /// [Output Only] URL of the zone where the instance group resides (for
  /// autoscalers living in zonal scope).
  core.String zone;

  Autoscaler();

  Autoscaler.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalingPolicy')) {
      autoscalingPolicy = AutoscalingPolicy.fromJson(
          _json['autoscalingPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('recommendedSize')) {
      recommendedSize = _json['recommendedSize'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusDetails')) {
      statusDetails = (_json['statusDetails'] as core.List)
          .map<AutoscalerStatusDetails>((value) =>
              AutoscalerStatusDetails.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoscalingPolicy != null) {
      _json['autoscalingPolicy'] = autoscalingPolicy.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (recommendedSize != null) {
      _json['recommendedSize'] = recommendedSize;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (statusDetails != null) {
      _json['statusDetails'] =
          statusDetails.map((value) => value.toJson()).toList();
    }
    if (target != null) {
      _json['target'] = target;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class AutoscalerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerAggregatedListWarningData();

  AutoscalerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerAggregatedListWarning();

  AutoscalerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalerAggregatedListWarningData>((value) =>
              AutoscalerAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AutoscalerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of AutoscalersScopedList resources.
  core.Map<core.String, AutoscalersScopedList> items;

  /// [Output Only] Type of resource. Always compute#autoscalerAggregatedList
  /// for aggregated lists of autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  AutoscalerAggregatedListWarning warning;

  AutoscalerAggregatedList();

  AutoscalerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              AutoscalersScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalerAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalerListWarningData();

  AutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class AutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalerListWarning();

  AutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalerListWarningData>((value) =>
              AutoscalerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Autoscaler resources.
class AutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// [Output Only] Type of resource. Always compute#autoscalerList for lists of
  /// autoscalers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  AutoscalerListWarning warning;

  AutoscalerList();

  AutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class AutoscalerStatusDetails {
  /// The status message.
  core.String message;

  /// The type of error, warning, or notice returned. Current set of possible
  /// values:
  /// - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group
  /// are unhealthy (not in RUNNING state).
  /// - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  /// attached to the instance group.
  /// - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size
  /// greater than maxNumReplicas.
  /// - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric
  /// samples are not exported often enough to be a credible base for
  /// autoscaling.
  /// - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  /// not exist or does not have the necessary labels.
  /// - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas.
  /// This means the autoscaler cannot add or remove instances from the instance
  /// group.
  /// - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not
  /// receive any data from the custom metric configured for autoscaling.
  /// - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is
  /// configured to scale based on a load balancing signal but the instance
  /// group has not received any requests from the load balancer.
  /// - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances
  /// in the group won't change automatically. The autoscaling configuration is
  /// preserved.
  /// - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only up" mode.
  /// The autoscaler can add instances but not remove any.
  /// - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it.
  /// - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances.
  /// - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  /// there is a resource stockout in the chosen region.
  /// - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  /// exist.
  /// - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling
  /// does not work with an HTTP/S load balancer that has been configured for
  /// maxRate.
  /// - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a
  /// resource stockout in the chosen zone. For regional autoscalers: in at
  /// least one of the zones you're using there is a resource stockout.  New
  /// values might be added in the future. Some of the values might not be
  /// available in all API versions.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY"
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST"
  /// - "CAPPED_AT_MAX_NUM_REPLICAS"
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE"
  /// - "CUSTOM_METRIC_INVALID"
  /// - "MIN_EQUALS_MAX"
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS"
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS"
  /// - "MODE_OFF"
  /// - "MODE_ONLY_SCALE_OUT"
  /// - "MODE_ONLY_UP"
  /// - "MORE_THAN_ONE_BACKEND_SERVICE"
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE"
  /// - "REGION_RESOURCE_STOCKOUT"
  /// - "SCALING_TARGET_DOES_NOT_EXIST"
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION"
  /// - "ZONE_RESOURCE_STOCKOUT"
  core.String type;

  AutoscalerStatusDetails();

  AutoscalerStatusDetails.fromJson(core.Map _json) {
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (message != null) {
      _json['message'] = message;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class AutoscalersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  AutoscalersScopedListWarningData();

  AutoscalersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of autoscalers
/// when the list is empty.
class AutoscalersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<AutoscalersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  AutoscalersScopedListWarning();

  AutoscalersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalersScopedListWarningData>((value) =>
              AutoscalersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class AutoscalersScopedList {
  /// [Output Only] A list of autoscalers contained in this scope.
  core.List<Autoscaler> autoscalers;

  /// [Output Only] Informational warning which replaces the list of autoscalers
  /// when the list is empty.
  AutoscalersScopedListWarning warning;

  AutoscalersScopedList();

  AutoscalersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalers')) {
      autoscalers = (_json['autoscalers'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoscalers != null) {
      _json['autoscalers'] =
          autoscalers.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Cloud Autoscaler policy.
class AutoscalingPolicy {
  /// The number of seconds that the autoscaler should wait before it starts
  /// collecting information from a new instance. This prevents the autoscaler
  /// from collecting information when the instance is initializing, during
  /// which the collected usage would not be reliable. The default time
  /// autoscaler waits is 60 seconds.
  ///
  /// Virtual machine initialization times might vary because of numerous
  /// factors. We recommend that you test how long an instance may take to
  /// initialize. To do this, create an instance and time the startup process.
  core.int coolDownPeriodSec;

  /// Defines the CPU utilization policy that allows the autoscaler to scale
  /// based on the average CPU utilization of a managed instance group.
  AutoscalingPolicyCpuUtilization cpuUtilization;

  /// Configuration parameters of autoscaling based on a custom metric.
  core.List<AutoscalingPolicyCustomMetricUtilization> customMetricUtilizations;

  /// Configuration parameters of autoscaling based on load balancer.
  AutoscalingPolicyLoadBalancingUtilization loadBalancingUtilization;

  /// The maximum number of instances that the autoscaler can scale up to. This
  /// is required when creating or updating an autoscaler. The maximum number of
  /// replicas should not be lower than minimal number of replicas.
  core.int maxNumReplicas;

  /// The minimum number of replicas that the autoscaler can scale down to. This
  /// cannot be less than 0. If not provided, autoscaler will choose a default
  /// value depending on maximum number of instances allowed.
  core.int minNumReplicas;

  /// Defines operating mode for this policy.
  /// Possible string values are:
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_SCALE_OUT"
  /// - "ONLY_UP"
  core.String mode;
  AutoscalingPolicyScaleInControl scaleInControl;

  AutoscalingPolicy();

  AutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('coolDownPeriodSec')) {
      coolDownPeriodSec = _json['coolDownPeriodSec'] as core.int;
    }
    if (_json.containsKey('cpuUtilization')) {
      cpuUtilization = AutoscalingPolicyCpuUtilization.fromJson(
          _json['cpuUtilization'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('customMetricUtilizations')) {
      customMetricUtilizations =
          (_json['customMetricUtilizations'] as core.List)
              .map<AutoscalingPolicyCustomMetricUtilization>((value) =>
                  AutoscalingPolicyCustomMetricUtilization.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList();
    }
    if (_json.containsKey('loadBalancingUtilization')) {
      loadBalancingUtilization =
          AutoscalingPolicyLoadBalancingUtilization.fromJson(
              _json['loadBalancingUtilization']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxNumReplicas')) {
      maxNumReplicas = _json['maxNumReplicas'] as core.int;
    }
    if (_json.containsKey('minNumReplicas')) {
      minNumReplicas = _json['minNumReplicas'] as core.int;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('scaleInControl')) {
      scaleInControl = AutoscalingPolicyScaleInControl.fromJson(
          _json['scaleInControl'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (coolDownPeriodSec != null) {
      _json['coolDownPeriodSec'] = coolDownPeriodSec;
    }
    if (cpuUtilization != null) {
      _json['cpuUtilization'] = cpuUtilization.toJson();
    }
    if (customMetricUtilizations != null) {
      _json['customMetricUtilizations'] =
          customMetricUtilizations.map((value) => value.toJson()).toList();
    }
    if (loadBalancingUtilization != null) {
      _json['loadBalancingUtilization'] = loadBalancingUtilization.toJson();
    }
    if (maxNumReplicas != null) {
      _json['maxNumReplicas'] = maxNumReplicas;
    }
    if (minNumReplicas != null) {
      _json['minNumReplicas'] = minNumReplicas;
    }
    if (mode != null) {
      _json['mode'] = mode;
    }
    if (scaleInControl != null) {
      _json['scaleInControl'] = scaleInControl.toJson();
    }
    return _json;
  }
}

/// CPU utilization policy.
class AutoscalingPolicyCpuUtilization {
  /// The target CPU utilization that the autoscaler should maintain. Must be a
  /// float value in the range (0, 1]. If not specified, the default is 0.6.
  ///
  /// If the CPU level is below the target utilization, the autoscaler scales
  /// down the number of instances until it reaches the minimum number of
  /// instances you specified or until the average CPU of your instances reaches
  /// the target utilization.
  ///
  /// If the average CPU is above the target utilization, the autoscaler scales
  /// up until it reaches the maximum number of instances you specified or until
  /// the average utilization reaches the target utilization.
  core.double utilizationTarget;

  AutoscalingPolicyCpuUtilization();

  AutoscalingPolicyCpuUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (utilizationTarget != null) {
      _json['utilizationTarget'] = utilizationTarget;
    }
    return _json;
  }
}

/// Custom utilization metric policy.
class AutoscalingPolicyCustomMetricUtilization {
  /// The identifier (type) of the Stackdriver Monitoring metric. The metric
  /// cannot have negative values.
  ///
  /// The metric must have a value type of INT64 or DOUBLE.
  core.String metric;

  /// The target value of the metric that autoscaler should maintain. This must
  /// be a positive value. A utilization metric scales number of virtual
  /// machines handling requests to increase or decrease proportionally to the
  /// metric.
  ///
  /// For example, a good metric to use as a utilization_target is
  /// compute.googleapis.com/instance/network/received_bytes_count. The
  /// autoscaler will work to keep this value constant for each of the
  /// instances.
  core.double utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE"
  /// - "DELTA_PER_SECOND"
  /// - "GAUGE"
  core.String utilizationTargetType;

  AutoscalingPolicyCustomMetricUtilization();

  AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
    if (_json.containsKey('utilizationTargetType')) {
      utilizationTargetType = _json['utilizationTargetType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (metric != null) {
      _json['metric'] = metric;
    }
    if (utilizationTarget != null) {
      _json['utilizationTarget'] = utilizationTarget;
    }
    if (utilizationTargetType != null) {
      _json['utilizationTargetType'] = utilizationTargetType;
    }
    return _json;
  }
}

/// Configuration parameters of autoscaling based on load balancing.
class AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(S) load balancing
  /// configuration) that autoscaler should maintain. Must be a positive float
  /// value. If not defined, the default is 0.8.
  core.double utilizationTarget;

  AutoscalingPolicyLoadBalancingUtilization();

  AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (utilizationTarget != null) {
      _json['utilizationTarget'] = utilizationTarget;
    }
    return _json;
  }
}

/// Configuration that allows for slower scale in so that even if Autoscaler
/// recommends an abrupt scale in of a MIG, it will be throttled as specified by
/// the parameters below.
class AutoscalingPolicyScaleInControl {
  /// Maximum allowed number (or %) of VMs that can be deducted from the peak
  /// recommendation during the window autoscaler looks at when computing
  /// recommendations. Possibly all these VMs can be deleted at once so user
  /// service needs to be prepared to lose that many VMs in one step.
  FixedOrPercent maxScaledInReplicas;

  /// How long back autoscaling should look when computing recommendations to
  /// include directives regarding slower scale in, as described above.
  core.int timeWindowSec;

  AutoscalingPolicyScaleInControl();

  AutoscalingPolicyScaleInControl.fromJson(core.Map _json) {
    if (_json.containsKey('maxScaledInReplicas')) {
      maxScaledInReplicas = FixedOrPercent.fromJson(
          _json['maxScaledInReplicas'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeWindowSec')) {
      timeWindowSec = _json['timeWindowSec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (maxScaledInReplicas != null) {
      _json['maxScaledInReplicas'] = maxScaledInReplicas.toJson();
    }
    if (timeWindowSec != null) {
      _json['timeWindowSec'] = timeWindowSec;
    }
    return _json;
  }
}

/// Message containing information of one individual backend.
class Backend {
  /// Specifies the balancing mode for the backend.
  ///
  /// When choosing a balancing mode, you need to consider the
  /// loadBalancingScheme, and protocol for the backend service, as well as the
  /// type of backend (instance group or NEG).
  ///
  ///
  /// - If the load balancing mode is CONNECTION, then the load is spread based
  /// on how many concurrent connections the backend can handle.
  /// You can use the CONNECTION balancing mode if the protocol for the backend
  /// service is SSL, TCP, or UDP.
  ///
  /// If the loadBalancingScheme for the backend service is EXTERNAL (SSL Proxy
  /// and TCP Proxy load balancers), you must also specify exactly one of the
  /// following parameters: maxConnections (except for regional managed instance
  /// groups), maxConnectionsPerInstance, or maxConnectionsPerEndpoint.
  ///
  /// If the loadBalancingScheme for the backend service is INTERNAL (internal
  /// TCP/UDP load balancers), you cannot specify any additional parameters.
  ///
  /// - If the load balancing mode is RATE, the load is spread based on the rate
  /// of HTTP requests per second (RPS).
  /// You can use the RATE balancing mode if the protocol for the backend
  /// service is HTTP or HTTPS. You must specify exactly one of the following
  /// parameters: maxRate (except for regional managed instance groups),
  /// maxRatePerInstance, or maxRatePerEndpoint.
  ///
  /// - If the load balancing mode is UTILIZATION, the load is spread based on
  /// the backend utilization of instances in an instance group.
  /// You can use the UTILIZATION balancing mode if the loadBalancingScheme of
  /// the backend service is EXTERNAL, INTERNAL_SELF_MANAGED, or
  /// INTERNAL_MANAGED and the backends are instance groups. There are no
  /// restrictions on the backend service protocol.
  /// Possible string values are:
  /// - "CONNECTION"
  /// - "RATE"
  /// - "UTILIZATION"
  core.String balancingMode;

  /// A multiplier applied to the group's maximum servicing capacity (based on
  /// UTILIZATION, RATE or CONNECTION). Default value is 1, which means the
  /// group will serve up to 100% of its configured capacity (depending on
  /// balancingMode). A setting of 0 means the group is completely drained,
  /// offering 0% of its available capacity. Valid range is 0.0 and [0.1,1.0].
  /// You cannot configure a setting larger than 0 and smaller than 0.1. You
  /// cannot configure a setting of 0 when there is only one backend attached to
  /// the backend service.
  ///
  /// This cannot be used for internal load balancing.
  core.double capacityScaler;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// This field designates whether this is a failover backend. More than one
  /// failover backend can be configured for a given BackendService.
  core.bool failover;

  /// The fully-qualified URL of an instance group or network endpoint group
  /// (NEG) resource. The type of backend that a backend service supports
  /// depends on the backend service's loadBalancingScheme.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is EXTERNAL,
  /// INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the backend can be either an
  /// instance group or a NEG. The backends on the backend service must be
  /// either all instance groups or all NEGs. You cannot mix instance group and
  /// NEG backends on the same backend service.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is INTERNAL, the
  /// backend must be an instance group in the same region as the backend
  /// service. NEGs are not supported.
  ///
  /// You must use the fully-qualified URL (starting with
  /// https://www.googleapis.com/) to specify the instance group or NEG. Partial
  /// URLs are not supported.
  core.String group;

  /// Defines a target maximum number of simultaneous connections that the
  /// backend can handle. Valid for network endpoint group and instance group
  /// backends (except for regional managed instance groups). If the backend's
  /// balancingMode is UTILIZATION, this is an optional parameter. If the
  /// backend's balancingMode is CONNECTION, and backend is attached to a
  /// backend service whose loadBalancingScheme is EXTERNAL, you must specify
  /// either this parameter, maxConnectionsPerInstance, or
  /// maxConnectionsPerEndpoint.
  ///
  /// Not available if the backend's balancingMode is RATE. If the
  /// loadBalancingScheme is INTERNAL, then maxConnections is not supported,
  /// even though the backend requires a balancing mode of CONNECTION.
  core.int maxConnections;

  /// Defines a target maximum number of simultaneous connections for an
  /// endpoint of a NEG. This is multiplied by the number of endpoints in the
  /// NEG to implicitly calculate a maximum number of target maximum
  /// simultaneous connections for the NEG. If the backend's balancingMode is
  /// CONNECTION, and the backend is attached to a backend service whose
  /// loadBalancingScheme is EXTERNAL, you must specify either this parameter,
  /// maxConnections, or maxConnectionsPerInstance.
  ///
  /// Not available if the backend's balancingMode is RATE. Internal TCP/UDP
  /// load balancing does not support setting maxConnectionsPerEndpoint even
  /// though its backends require a balancing mode of CONNECTION.
  core.int maxConnectionsPerEndpoint;

  /// Defines a target maximum number of simultaneous connections for a single
  /// VM in a backend instance group. This is multiplied by the number of
  /// instances in the instance group to implicitly calculate a target maximum
  /// number of simultaneous connections for the whole instance group. If the
  /// backend's balancingMode is UTILIZATION, this is an optional parameter. If
  /// the backend's balancingMode is CONNECTION, and backend is attached to a
  /// backend service whose loadBalancingScheme is EXTERNAL, you must specify
  /// either this parameter, maxConnections, or maxConnectionsPerEndpoint.
  ///
  /// Not available if the backend's balancingMode is RATE. Internal TCP/UDP
  /// load balancing does not support setting maxConnectionsPerInstance even
  /// though its backends require a balancing mode of CONNECTION.
  core.int maxConnectionsPerInstance;

  /// Defines a maximum number of HTTP requests per second (RPS) that the
  /// backend can handle. Valid for network endpoint group and instance group
  /// backends (except for regional managed instance groups). Must not be
  /// defined if the backend is a managed instance group that uses autoscaling
  /// based on load balancing.
  ///
  /// If the backend's balancingMode is UTILIZATION, this is an optional
  /// parameter. If the backend's balancingMode is RATE, you must specify
  /// maxRate, maxRatePerInstance, or maxRatePerEndpoint.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.int maxRate;

  /// Defines a maximum target for requests per second (RPS) for an endpoint of
  /// a NEG. This is multiplied by the number of endpoints in the NEG to
  /// implicitly calculate a target maximum rate for the NEG.
  ///
  /// If the backend's balancingMode is RATE, you must specify either this
  /// parameter, maxRate (except for regional managed instance groups), or
  /// maxRatePerInstance.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double maxRatePerEndpoint;

  /// Defines a maximum target for requests per second (RPS) for a single VM in
  /// a backend instance group. This is multiplied by the number of instances in
  /// the instance group to implicitly calculate a target maximum rate for the
  /// whole instance group.
  ///
  /// If the backend's balancingMode is UTILIZATION, this is an optional
  /// parameter. If the backend's balancingMode is RATE, you must specify either
  /// this parameter, maxRate (except for regional managed instance groups), or
  /// maxRatePerEndpoint.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double maxRatePerInstance;

  /// Defines the maximum average backend utilization of a backend VM in an
  /// instance group. The valid range is [0.0, 1.0]. This is an optional
  /// parameter if the backend's balancingMode is UTILIZATION.
  ///
  /// This parameter can be used in conjunction with maxRate,
  /// maxRatePerInstance, maxConnections (except for regional managed instance
  /// groups), or maxConnectionsPerInstance.
  core.double maxUtilization;

  Backend();

  Backend.fromJson(core.Map _json) {
    if (_json.containsKey('balancingMode')) {
      balancingMode = _json['balancingMode'] as core.String;
    }
    if (_json.containsKey('capacityScaler')) {
      capacityScaler = (_json['capacityScaler'] as core.num).toDouble();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('failover')) {
      failover = _json['failover'] as core.bool;
    }
    if (_json.containsKey('group')) {
      group = _json['group'] as core.String;
    }
    if (_json.containsKey('maxConnections')) {
      maxConnections = _json['maxConnections'] as core.int;
    }
    if (_json.containsKey('maxConnectionsPerEndpoint')) {
      maxConnectionsPerEndpoint =
          _json['maxConnectionsPerEndpoint'] as core.int;
    }
    if (_json.containsKey('maxConnectionsPerInstance')) {
      maxConnectionsPerInstance =
          _json['maxConnectionsPerInstance'] as core.int;
    }
    if (_json.containsKey('maxRate')) {
      maxRate = _json['maxRate'] as core.int;
    }
    if (_json.containsKey('maxRatePerEndpoint')) {
      maxRatePerEndpoint = (_json['maxRatePerEndpoint'] as core.num).toDouble();
    }
    if (_json.containsKey('maxRatePerInstance')) {
      maxRatePerInstance = (_json['maxRatePerInstance'] as core.num).toDouble();
    }
    if (_json.containsKey('maxUtilization')) {
      maxUtilization = (_json['maxUtilization'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (balancingMode != null) {
      _json['balancingMode'] = balancingMode;
    }
    if (capacityScaler != null) {
      _json['capacityScaler'] = capacityScaler;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (failover != null) {
      _json['failover'] = failover;
    }
    if (group != null) {
      _json['group'] = group;
    }
    if (maxConnections != null) {
      _json['maxConnections'] = maxConnections;
    }
    if (maxConnectionsPerEndpoint != null) {
      _json['maxConnectionsPerEndpoint'] = maxConnectionsPerEndpoint;
    }
    if (maxConnectionsPerInstance != null) {
      _json['maxConnectionsPerInstance'] = maxConnectionsPerInstance;
    }
    if (maxRate != null) {
      _json['maxRate'] = maxRate;
    }
    if (maxRatePerEndpoint != null) {
      _json['maxRatePerEndpoint'] = maxRatePerEndpoint;
    }
    if (maxRatePerInstance != null) {
      _json['maxRatePerInstance'] = maxRatePerInstance;
    }
    if (maxUtilization != null) {
      _json['maxUtilization'] = maxUtilization;
    }
    return _json;
  }
}

/// Represents a Cloud Storage Bucket resource.
///
/// This Cloud Storage bucket resource is referenced by a URL map of a load
/// balancer. For more information, read Backend Buckets.
class BackendBucket {
  /// Cloud Storage bucket name.
  core.String bucketName;

  /// Cloud CDN configuration for this BackendBucket.
  BackendBucketCdnPolicy cdnPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String description;

  /// If true, enable Cloud CDN for this BackendBucket.
  core.bool enableCdn;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  BackendBucket();

  BackendBucket.fromJson(core.Map _json) {
    if (_json.containsKey('bucketName')) {
      bucketName = _json['bucketName'] as core.String;
    }
    if (_json.containsKey('cdnPolicy')) {
      cdnPolicy = BackendBucketCdnPolicy.fromJson(
          _json['cdnPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableCdn')) {
      enableCdn = _json['enableCdn'] as core.bool;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bucketName != null) {
      _json['bucketName'] = bucketName;
    }
    if (cdnPolicy != null) {
      _json['cdnPolicy'] = cdnPolicy.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enableCdn != null) {
      _json['enableCdn'] = enableCdn;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// Message containing Cloud CDN configuration for a backend bucket.
class BackendBucketCdnPolicy {
  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh. After this time period, the response will be revalidated
  /// before being served. Defaults to 1hr (3600s). When serving responses to
  /// signed URL requests, Cloud CDN will internally behave as though all
  /// responses from this backend had a "Cache-Control: public, max-age=[TTL]"
  /// header, regardless of any existing Cache-Control header. The actual
  /// headers served in responses will not be altered.
  core.String signedUrlCacheMaxAgeSec;

  /// [Output Only] Names of the keys for signing request URLs.
  core.List<core.String> signedUrlKeyNames;

  BackendBucketCdnPolicy();

  BackendBucketCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('signedUrlCacheMaxAgeSec')) {
      signedUrlCacheMaxAgeSec = _json['signedUrlCacheMaxAgeSec'] as core.String;
    }
    if (_json.containsKey('signedUrlKeyNames')) {
      signedUrlKeyNames = (_json['signedUrlKeyNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (signedUrlCacheMaxAgeSec != null) {
      _json['signedUrlCacheMaxAgeSec'] = signedUrlCacheMaxAgeSec;
    }
    if (signedUrlKeyNames != null) {
      _json['signedUrlKeyNames'] = signedUrlKeyNames;
    }
    return _json;
  }
}

class BackendBucketListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendBucketListWarningData();

  BackendBucketListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendBucketListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendBucketListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendBucketListWarning();

  BackendBucketListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendBucketListWarningData>((value) =>
              BackendBucketListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendBucket resources.
class BackendBucketList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendBucket resources.
  core.List<BackendBucket> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendBucketListWarning warning;

  BackendBucketList();

  BackendBucketList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<BackendBucket>((value) => BackendBucket.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = BackendBucketListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Backend Service resource.
///
/// A backend service defines how Google Cloud load balancers distribute
/// traffic. The backend service configuration contains a set of values, such as
/// the protocol used to connect to backends, various distribution and session
/// settings, health checks, and timeouts. These settings provide fine-grained
/// control over how your load balancer behaves. Most of the settings have
/// default values that allow for easy configuration if you need to get started
/// quickly.
///
/// Backend services in Google Compute Engine can be either regionally or
/// globally scoped.
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/backendServices) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionBackendServices)
///
/// For more information, see Backend Services.
///
/// (== resource_for {$api_version}.backendService ==)
class BackendService {
  /// Lifetime of cookies in seconds. Only applicable if the loadBalancingScheme
  /// is EXTERNAL, INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is
  /// HTTP or HTTPS, and the sessionAffinity is GENERATED_COOKIE, or
  /// HTTP_COOKIE.
  ///
  /// If set to 0, the cookie is non-persistent and lasts only until the end of
  /// the browser session (or equivalent). The maximum allowed value is one day
  /// (86,400).
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int affinityCookieTtlSec;

  /// The list of backends that serve this BackendService.
  core.List<Backend> backends;

  /// Cloud CDN configuration for this BackendService.
  BackendServiceCdnPolicy cdnPolicy;

  /// Settings controlling the volume of connections to a backend service. If
  /// not set, this feature is considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  CircuitBreakers circuitBreakers;
  ConnectionDraining connectionDraining;

  /// Consistent Hash-based load balancing can be used to provide soft session
  /// affinity based on HTTP headers, cookies or other properties. This load
  /// balancing policy is applicable only for HTTP connections. The affinity to
  /// a particular destination host will be lost when one or more hosts are
  /// added/removed from the destination service. This field specifies
  /// parameters that control consistent hashing. This field is only applicable
  /// when localityLbPolicy is set to MAGLEV or RING_HASH.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  ConsistentHashLoadBalancerSettings consistentHash;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Headers that the HTTP/S load balancer should add to proxied requests.
  core.List<core.String> customRequestHeaders;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// If true, enables Cloud CDN for the backend service. Only applicable if the
  /// loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
  core.bool enableCDN;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. Requires
  /// at least one backend instance group to be defined as a backup (failover)
  /// backend.
  BackendServiceFailoverPolicy failoverPolicy;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a BackendService. An up-to-date fingerprint must be
  /// provided in order to update the BackendService, otherwise the request will
  /// fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// BackendService.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
  /// httpsHealthChecks (legacy) resource for health checking this backend
  /// service. Not all backend services support legacy health checks. See  Load
  /// balancer guide. Currently, at most one health check can be specified for
  /// each backend service. Backend services with instance group or zonal NEG
  /// backends must have a health check. Backend services with internet or
  /// serverless NEG backends must not have a health check.
  core.List<core.String> healthChecks;

  /// The configurations for Identity-Aware Proxy on this resource.
  BackendServiceIAP iap;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#backendService for backend
  /// services.
  core.String kind;

  /// Specifies the load balancer type. Choose EXTERNAL for load balancers that
  /// receive traffic from external clients. Choose INTERNAL for Internal
  /// TCP/UDP Load Balancing. Choose INTERNAL_MANAGED for Internal HTTP(S) Load
  /// Balancing. Choose INTERNAL_SELF_MANAGED for Traffic Director. A backend
  /// service created for one type of load balancing cannot be used with
  /// another. For more information, refer to Choosing a load balancer.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID_LOAD_BALANCING_SCHEME"
  core.String loadBalancingScheme;

  /// The load balancing algorithm used within the scope of the locality. The
  /// possible values are:
  /// - ROUND_ROBIN: This is a simple policy in which each healthy backend is
  /// selected in round robin order. This is the default.
  /// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts
  /// and picks the host which has fewer active requests.
  /// - RING_HASH: The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests.
  /// - RANDOM: The load balancer selects a random healthy host.
  /// - ORIGINAL_DESTINATION: Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer.
  /// - MAGLEV: used as a drop in replacement for the ring hash load balancer.
  /// Maglev is not as stable as ring hash but has faster table lookup build
  /// times and host selection times. For more information about Maglev, see
  /// https://ai.google/research/pubs/pub44824
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// If sessionAffinity is not NONE, and this field is not set to MAGLEV or
  /// RING_HASH, session affinity settings will not take effect.
  ///
  /// Only the default ROUND_ROBIN policy is supported when the backend service
  /// is referenced by a URL map that is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  /// Possible string values are:
  /// - "INVALID_LB_POLICY"
  /// - "LEAST_REQUEST"
  /// - "MAGLEV"
  /// - "ORIGINAL_DESTINATION"
  /// - "RANDOM"
  /// - "RING_HASH"
  /// - "ROUND_ROBIN"
  core.String localityLbPolicy;

  /// This field denotes the logging options for the load balancer traffic
  /// served by this backend service. If logging is enabled, logs will be
  /// exported to Stackdriver.
  BackendServiceLogConfig logConfig;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The URL of the network to which this backend service belongs. This field
  /// can only be spcified when the load balancing scheme is set to INTERNAL.
  core.String network;

  /// Settings controlling the eviction of unhealthy hosts from the load
  /// balancing pool for the backend service. If not set, this feature is
  /// considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  OutlierDetection outlierDetection;

  /// Deprecated in favor of portName. The TCP port to connect on the backend.
  /// The default value is 80.
  ///
  /// This cannot be used if the loadBalancingScheme is INTERNAL (Internal
  /// TCP/UDP Load Balancing).
  core.int port;

  /// A named port on a backend instance group representing the port for
  /// communication to the backend VMs in that group. Required when the
  /// loadBalancingScheme is EXTERNAL, INTERNAL_MANAGED, or
  /// INTERNAL_SELF_MANAGED and the backends are instance groups. The named port
  /// must be defined on each backend instance group. This parameter has no
  /// meaning if the backends are NEGs.
  ///
  ///
  ///
  /// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP
  /// Load Balancing).
  core.String portName;

  /// The protocol this BackendService uses to communicate with backends.
  ///
  /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending
  /// on the chosen load balancer or Traffic Director configuration. Refer to
  /// the documentation for the load balancer or for Traffic Director for more
  /// information.
  ///
  /// Must be set to GRPC when the backend service is referenced by a URL map
  /// that is bound to target gRPC proxy.
  /// Possible string values are:
  /// - "GRPC"
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "SSL"
  /// - "TCP"
  /// - "UDP"
  core.String protocol;

  /// [Output Only] URL of the region where the regional backend service
  /// resides. This field is not applicable to global backend services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] The resource URL for the security policy associated with
  /// this backend service.
  core.String securityPolicy;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Type of session affinity to use. The default is NONE. Session affinity is
  /// not applicable if the --protocol is UDP.
  ///
  /// When the loadBalancingScheme is EXTERNAL, possible values are NONE,
  /// CLIENT_IP, or GENERATED_COOKIE. You can use GENERATED_COOKIE if the
  /// protocol is HTTP or HTTPS.
  ///
  /// When the loadBalancingScheme is INTERNAL, possible values are NONE,
  /// CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
  ///
  /// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or
  /// INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE,
  /// HEADER_FIELD, or HTTP_COOKIE.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  /// The backend service timeout has a different meaning depending on the type
  /// of load balancer. For more information see,  Backend service settings The
  /// default is 30 seconds.
  core.int timeoutSec;

  BackendService();

  BackendService.fromJson(core.Map _json) {
    if (_json.containsKey('affinityCookieTtlSec')) {
      affinityCookieTtlSec = _json['affinityCookieTtlSec'] as core.int;
    }
    if (_json.containsKey('backends')) {
      backends = (_json['backends'] as core.List)
          .map<Backend>((value) =>
              Backend.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('cdnPolicy')) {
      cdnPolicy = BackendServiceCdnPolicy.fromJson(
          _json['cdnPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('circuitBreakers')) {
      circuitBreakers = CircuitBreakers.fromJson(
          _json['circuitBreakers'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('connectionDraining')) {
      connectionDraining = ConnectionDraining.fromJson(
          _json['connectionDraining'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('consistentHash')) {
      consistentHash = ConsistentHashLoadBalancerSettings.fromJson(
          _json['consistentHash'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customRequestHeaders')) {
      customRequestHeaders = (_json['customRequestHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableCDN')) {
      enableCDN = _json['enableCDN'] as core.bool;
    }
    if (_json.containsKey('failoverPolicy')) {
      failoverPolicy = BackendServiceFailoverPolicy.fromJson(
          _json['failoverPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('iap')) {
      iap = BackendServiceIAP.fromJson(
          _json['iap'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('loadBalancingScheme')) {
      loadBalancingScheme = _json['loadBalancingScheme'] as core.String;
    }
    if (_json.containsKey('localityLbPolicy')) {
      localityLbPolicy = _json['localityLbPolicy'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = BackendServiceLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('outlierDetection')) {
      outlierDetection = OutlierDetection.fromJson(
          _json['outlierDetection'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('protocol')) {
      protocol = _json['protocol'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('securityPolicy')) {
      securityPolicy = _json['securityPolicy'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sessionAffinity')) {
      sessionAffinity = _json['sessionAffinity'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (affinityCookieTtlSec != null) {
      _json['affinityCookieTtlSec'] = affinityCookieTtlSec;
    }
    if (backends != null) {
      _json['backends'] = backends.map((value) => value.toJson()).toList();
    }
    if (cdnPolicy != null) {
      _json['cdnPolicy'] = cdnPolicy.toJson();
    }
    if (circuitBreakers != null) {
      _json['circuitBreakers'] = circuitBreakers.toJson();
    }
    if (connectionDraining != null) {
      _json['connectionDraining'] = connectionDraining.toJson();
    }
    if (consistentHash != null) {
      _json['consistentHash'] = consistentHash.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (customRequestHeaders != null) {
      _json['customRequestHeaders'] = customRequestHeaders;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enableCDN != null) {
      _json['enableCDN'] = enableCDN;
    }
    if (failoverPolicy != null) {
      _json['failoverPolicy'] = failoverPolicy.toJson();
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (healthChecks != null) {
      _json['healthChecks'] = healthChecks;
    }
    if (iap != null) {
      _json['iap'] = iap.toJson();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (loadBalancingScheme != null) {
      _json['loadBalancingScheme'] = loadBalancingScheme;
    }
    if (localityLbPolicy != null) {
      _json['localityLbPolicy'] = localityLbPolicy;
    }
    if (logConfig != null) {
      _json['logConfig'] = logConfig.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (outlierDetection != null) {
      _json['outlierDetection'] = outlierDetection.toJson();
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (protocol != null) {
      _json['protocol'] = protocol;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (securityPolicy != null) {
      _json['securityPolicy'] = securityPolicy;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sessionAffinity != null) {
      _json['sessionAffinity'] = sessionAffinity;
    }
    if (timeoutSec != null) {
      _json['timeoutSec'] = timeoutSec;
    }
    return _json;
  }
}

class BackendServiceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceAggregatedListWarningData();

  BackendServiceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceAggregatedListWarning();

  BackendServiceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServiceAggregatedListWarningData>((value) =>
              BackendServiceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendServicesScopedList.
class BackendServiceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendServicesScopedList resources.
  core.Map<core.String, BackendServicesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  BackendServiceAggregatedListWarning warning;

  BackendServiceAggregatedList();

  BackendServiceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              BackendServicesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = BackendServiceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Message containing Cloud CDN configuration for a backend service.
class BackendServiceCdnPolicy {
  /// The CacheKeyPolicy for this CdnPolicy.
  CacheKeyPolicy cacheKeyPolicy;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh. After this time period, the response will be revalidated
  /// before being served. Defaults to 1hr (3600s). When serving responses to
  /// signed URL requests, Cloud CDN will internally behave as though all
  /// responses from this backend had a "Cache-Control: public, max-age=[TTL]"
  /// header, regardless of any existing Cache-Control header. The actual
  /// headers served in responses will not be altered.
  core.String signedUrlCacheMaxAgeSec;

  /// [Output Only] Names of the keys for signing request URLs.
  core.List<core.String> signedUrlKeyNames;

  BackendServiceCdnPolicy();

  BackendServiceCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('cacheKeyPolicy')) {
      cacheKeyPolicy = CacheKeyPolicy.fromJson(
          _json['cacheKeyPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('signedUrlCacheMaxAgeSec')) {
      signedUrlCacheMaxAgeSec = _json['signedUrlCacheMaxAgeSec'] as core.String;
    }
    if (_json.containsKey('signedUrlKeyNames')) {
      signedUrlKeyNames = (_json['signedUrlKeyNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cacheKeyPolicy != null) {
      _json['cacheKeyPolicy'] = cacheKeyPolicy.toJson();
    }
    if (signedUrlCacheMaxAgeSec != null) {
      _json['signedUrlCacheMaxAgeSec'] = signedUrlCacheMaxAgeSec;
    }
    if (signedUrlKeyNames != null) {
      _json['signedUrlKeyNames'] = signedUrlKeyNames;
    }
    return _json;
  }
}

/// Applicable only to Failover for Internal TCP/UDP Load Balancing. On failover
/// or failback, this field indicates whether connection draining will be
/// honored. GCP has a fixed connection draining timeout of 10 minutes. A
/// setting of true terminates existing TCP connections to the active pool
/// during failover and failback, immediately draining traffic. A setting of
/// false allows existing TCP connections to persist, even on VMs no longer in
/// the active pool, for up to the duration of the connection draining timeout
/// (10 minutes).
class BackendServiceFailoverPolicy {
  /// This can be set to true only if the protocol is TCP.
  ///
  /// The default is false.
  core.bool disableConnectionDrainOnFailover;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. If set to
  /// true, connections to the load balancer are dropped when all primary and
  /// all backup backend VMs are unhealthy. If set to false, connections are
  /// distributed among all primary VMs when all primary and all backup backend
  /// VMs are unhealthy.
  ///
  /// The default is false.
  core.bool dropTrafficIfUnhealthy;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing. The value
  /// of the field must be in the range [0, 1]. If the value is 0, the load
  /// balancer performs a failover when the number of healthy primary VMs equals
  /// zero. For all other values, the load balancer performs a failover when the
  /// total number of healthy primary VMs is less than this ratio.
  core.double failoverRatio;

  BackendServiceFailoverPolicy();

  BackendServiceFailoverPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('disableConnectionDrainOnFailover')) {
      disableConnectionDrainOnFailover =
          _json['disableConnectionDrainOnFailover'] as core.bool;
    }
    if (_json.containsKey('dropTrafficIfUnhealthy')) {
      dropTrafficIfUnhealthy = _json['dropTrafficIfUnhealthy'] as core.bool;
    }
    if (_json.containsKey('failoverRatio')) {
      failoverRatio = (_json['failoverRatio'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (disableConnectionDrainOnFailover != null) {
      _json['disableConnectionDrainOnFailover'] =
          disableConnectionDrainOnFailover;
    }
    if (dropTrafficIfUnhealthy != null) {
      _json['dropTrafficIfUnhealthy'] = dropTrafficIfUnhealthy;
    }
    if (failoverRatio != null) {
      _json['failoverRatio'] = failoverRatio;
    }
    return _json;
  }
}

class BackendServiceGroupHealth {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String> annotations;

  /// Health state of the backend instances or endpoints in requested instance
  /// or network endpoint group, determined based on configured health checks.
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#backendServiceGroupHealth
  /// for the health of backend services.
  core.String kind;

  BackendServiceGroupHealth();

  BackendServiceGroupHealth.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations = (_json['annotations'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('healthStatus')) {
      healthStatus = (_json['healthStatus'] as core.List)
          .map<HealthStatus>((value) => HealthStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (annotations != null) {
      _json['annotations'] = annotations;
    }
    if (healthStatus != null) {
      _json['healthStatus'] =
          healthStatus.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    return _json;
  }
}

/// Identity-Aware Proxy
class BackendServiceIAP {
  /// Whether the serving infrastructure will authenticate and authorize all
  /// incoming requests. If true, the oauth2ClientId and oauth2ClientSecret
  /// fields must be non-empty.
  core.bool enabled;

  /// OAuth2 client ID to use for the authentication flow.
  core.String oauth2ClientId;

  /// OAuth2 client secret to use for the authentication flow. For security
  /// reasons, this value cannot be retrieved via the API. Instead, the SHA-256
  /// hash of the value is returned in the oauth2ClientSecretSha256 field.
  core.String oauth2ClientSecret;

  /// [Output Only] SHA256 hash value for the field oauth2_client_secret above.
  core.String oauth2ClientSecretSha256;

  BackendServiceIAP();

  BackendServiceIAP.fromJson(core.Map _json) {
    if (_json.containsKey('enabled')) {
      enabled = _json['enabled'] as core.bool;
    }
    if (_json.containsKey('oauth2ClientId')) {
      oauth2ClientId = _json['oauth2ClientId'] as core.String;
    }
    if (_json.containsKey('oauth2ClientSecret')) {
      oauth2ClientSecret = _json['oauth2ClientSecret'] as core.String;
    }
    if (_json.containsKey('oauth2ClientSecretSha256')) {
      oauth2ClientSecretSha256 =
          _json['oauth2ClientSecretSha256'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enabled != null) {
      _json['enabled'] = enabled;
    }
    if (oauth2ClientId != null) {
      _json['oauth2ClientId'] = oauth2ClientId;
    }
    if (oauth2ClientSecret != null) {
      _json['oauth2ClientSecret'] = oauth2ClientSecret;
    }
    if (oauth2ClientSecretSha256 != null) {
      _json['oauth2ClientSecretSha256'] = oauth2ClientSecretSha256;
    }
    return _json;
  }
}

class BackendServiceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServiceListWarningData();

  BackendServiceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class BackendServiceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServiceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServiceListWarning();

  BackendServiceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServiceListWarningData>((value) =>
              BackendServiceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of BackendService resources.
class BackendServiceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of BackendService resources.
  core.List<BackendService> items;

  /// [Output Only] Type of resource. Always compute#backendServiceList for
  /// lists of backend services.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  BackendServiceListWarning warning;

  BackendServiceList();

  BackendServiceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<BackendService>((value) => BackendService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = BackendServiceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// The available logging options for the load balancer traffic served by this
/// backend service.
class BackendServiceLogConfig {
  /// This field denotes whether to enable logging for the load balancer traffic
  /// served by this backend service.
  core.bool enable;

  /// This field can only be specified if logging is enabled for this backend
  /// service. The value of the field must be in [0, 1]. This configures the
  /// sampling rate of requests to the load balancer where 1.0 means all logged
  /// requests are reported and 0.0 means no logged requests are reported. The
  /// default value is 1.0.
  core.double sampleRate;

  BackendServiceLogConfig();

  BackendServiceLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('sampleRate')) {
      sampleRate = (_json['sampleRate'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enable != null) {
      _json['enable'] = enable;
    }
    if (sampleRate != null) {
      _json['sampleRate'] = sampleRate;
    }
    return _json;
  }
}

class BackendServiceReference {
  core.String backendService;

  BackendServiceReference();

  BackendServiceReference.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backendService != null) {
      _json['backendService'] = backendService;
    }
    return _json;
  }
}

class BackendServicesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  BackendServicesScopedListWarningData();

  BackendServicesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class BackendServicesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<BackendServicesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  BackendServicesScopedListWarning();

  BackendServicesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServicesScopedListWarningData>((value) =>
              BackendServicesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class BackendServicesScopedList {
  /// A list of BackendServices contained in this scope.
  core.List<BackendService> backendServices;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  BackendServicesScopedListWarning warning;

  BackendServicesScopedList();

  BackendServicesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('backendServices')) {
      backendServices = (_json['backendServices'] as core.List)
          .map<BackendService>((value) => BackendService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = BackendServicesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backendServices != null) {
      _json['backendServices'] =
          backendServices.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Associates `members` with a `role`.
class Binding {
  /// A client-specified ID for this binding. Expected to be globally unique to
  /// support the internal bindings-by-ID API.
  core.String bindingId;

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request.
  ///
  /// If the condition evaluates to `false`, then this binding does not apply to
  /// the current request. However, a different role binding might grant the
  /// same role to one or more of the members in this binding.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  Expr condition;

  /// Specifies the identities requesting access for a Cloud Platform resource.
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is on the
  /// internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone who
  /// is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  /// account. For example, `alice@example.com` .
  ///
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  /// account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a user that has been recently deleted. For
  /// example, `alice@example.com?uid=123456789012345678901`. If the user is
  /// recovered, this value reverts to `user:{emailid}` and the recovered user
  /// retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address
  /// (plus unique identifier) representing a service account that has been
  /// recently deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a Google group that has been recently deleted.
  /// For example, `admins@example.com?uid=123456789012345678901`. If the group
  /// is recovered, this value reverts to `group:{emailid}` and the recovered
  /// group retains the role in the binding.
  ///
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  /// users of that domain. For example, `google.com` or `example.com`.
  core.List<core.String> members;

  /// Role that is assigned to `members`. For example, `roles/viewer`,
  /// `roles/editor`, or `roles/owner`.
  core.String role;

  Binding();

  Binding.fromJson(core.Map _json) {
    if (_json.containsKey('bindingId')) {
      bindingId = _json['bindingId'] as core.String;
    }
    if (_json.containsKey('condition')) {
      condition = Expr.fromJson(
          _json['condition'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('members')) {
      members = (_json['members'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('role')) {
      role = _json['role'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bindingId != null) {
      _json['bindingId'] = bindingId;
    }
    if (condition != null) {
      _json['condition'] = condition.toJson();
    }
    if (members != null) {
      _json['members'] = members;
    }
    if (role != null) {
      _json['role'] = role;
    }
    return _json;
  }
}

class CacheInvalidationRule {
  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String host;
  core.String path;

  CacheInvalidationRule();

  CacheInvalidationRule.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (host != null) {
      _json['host'] = host;
    }
    if (path != null) {
      _json['path'] = path;
    }
    return _json;
  }
}

/// Message containing what to include in the cache key for a request for Cloud
/// CDN.
class CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool includeHost;

  /// If true, http and https requests will be cached separately.
  core.bool includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist. If neither is set, the
  /// entire query string will be included. If false, the query string will be
  /// excluded from the cache key entirely.
  core.bool includeQueryString;

  /// Names of query string parameters to exclude in cache keys. All other
  /// parameters will be included. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringBlacklist;

  /// Names of query string parameters to include in cache keys. All other
  /// parameters will be excluded. Either specify query_string_whitelist or
  /// query_string_blacklist, not both. '&' and '=' will be percent encoded and
  /// not treated as delimiters.
  core.List<core.String> queryStringWhitelist;

  CacheKeyPolicy();

  CacheKeyPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('includeHost')) {
      includeHost = _json['includeHost'] as core.bool;
    }
    if (_json.containsKey('includeProtocol')) {
      includeProtocol = _json['includeProtocol'] as core.bool;
    }
    if (_json.containsKey('includeQueryString')) {
      includeQueryString = _json['includeQueryString'] as core.bool;
    }
    if (_json.containsKey('queryStringBlacklist')) {
      queryStringBlacklist = (_json['queryStringBlacklist'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('queryStringWhitelist')) {
      queryStringWhitelist = (_json['queryStringWhitelist'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (includeHost != null) {
      _json['includeHost'] = includeHost;
    }
    if (includeProtocol != null) {
      _json['includeProtocol'] = includeProtocol;
    }
    if (includeQueryString != null) {
      _json['includeQueryString'] = includeQueryString;
    }
    if (queryStringBlacklist != null) {
      _json['queryStringBlacklist'] = queryStringBlacklist;
    }
    if (queryStringWhitelist != null) {
      _json['queryStringWhitelist'] = queryStringWhitelist;
    }
    return _json;
  }
}

/// Settings controlling the volume of connections to a backend service.
class CircuitBreakers {
  /// The maximum number of connections to the backend service. If not
  /// specified, there is no limit.
  core.int maxConnections;

  /// The maximum number of pending requests allowed to the backend service. If
  /// not specified, there is no limit.
  core.int maxPendingRequests;

  /// The maximum number of parallel requests that allowed to the backend
  /// service. If not specified, there is no limit.
  core.int maxRequests;

  /// Maximum requests for a single connection to the backend service. This
  /// parameter is respected by both the HTTP/1.1 and HTTP/2 implementations. If
  /// not specified, there is no limit. Setting this parameter to 1 will
  /// effectively disable keep alive.
  core.int maxRequestsPerConnection;

  /// The maximum number of parallel retries allowed to the backend cluster. If
  /// not specified, the default is 1.
  core.int maxRetries;

  CircuitBreakers();

  CircuitBreakers.fromJson(core.Map _json) {
    if (_json.containsKey('maxConnections')) {
      maxConnections = _json['maxConnections'] as core.int;
    }
    if (_json.containsKey('maxPendingRequests')) {
      maxPendingRequests = _json['maxPendingRequests'] as core.int;
    }
    if (_json.containsKey('maxRequests')) {
      maxRequests = _json['maxRequests'] as core.int;
    }
    if (_json.containsKey('maxRequestsPerConnection')) {
      maxRequestsPerConnection = _json['maxRequestsPerConnection'] as core.int;
    }
    if (_json.containsKey('maxRetries')) {
      maxRetries = _json['maxRetries'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (maxConnections != null) {
      _json['maxConnections'] = maxConnections;
    }
    if (maxPendingRequests != null) {
      _json['maxPendingRequests'] = maxPendingRequests;
    }
    if (maxRequests != null) {
      _json['maxRequests'] = maxRequests;
    }
    if (maxRequestsPerConnection != null) {
      _json['maxRequestsPerConnection'] = maxRequestsPerConnection;
    }
    if (maxRetries != null) {
      _json['maxRetries'] = maxRetries;
    }
    return _json;
  }
}

/// Represents a regional Commitment resource.
///
/// Creating a commitment resource means that you are purchasing a committed use
/// contract with an explicit start and end time. You can create commitments
/// based on vCPUs and memory usage and receive discounted rates. For full
/// details, read Signing Up for Committed Use Discounts. (== resource_for
/// {$api_version}.regionCommitments ==)
class Commitment {
  /// The category of the commitment. Category MACHINE specifies commitments
  /// composed of machine resources such as VCPU or MEMORY, listed in resources.
  /// Category LICENSE specifies commitments composed of software licenses,
  /// listed in licenseResources. Note that only MACHINE commitments should have
  /// a Type specified.
  /// Possible string values are:
  /// - "CATEGORY_UNSPECIFIED"
  /// - "LICENSE"
  /// - "MACHINE"
  core.String category;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Commitment end time in RFC3339 text format.
  core.String endTimestamp;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#commitment for
  /// commitments.
  core.String kind;

  /// The license specification required as part of a license commitment.
  LicenseResourceCommitment licenseResource;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The plan for this commitment, which determines duration and discount rate.
  /// The currently supported plans are TWELVE_MONTH (1 year), and
  /// THIRTY_SIX_MONTH (3 years).
  /// Possible string values are:
  /// - "INVALID"
  /// - "THIRTY_SIX_MONTH"
  /// - "TWELVE_MONTH"
  core.String plan;

  /// [Output Only] URL of the region where this commitment may be used.
  core.String region;

  /// List of reservations in this commitment.
  core.List<Reservation> reservations;

  /// A list of commitment amounts for particular resources. Note that VCPU and
  /// MEMORY resource commitments must occur together.
  core.List<ResourceCommitment> resources;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Commitment start time in RFC3339 text format.
  core.String startTimestamp;

  /// [Output Only] Status of the commitment with regards to eventual expiration
  /// (each commitment has an end date defined). One of the following values:
  /// NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CREATING"
  /// - "EXPIRED"
  /// - "NOT_YET_ACTIVE"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  Commitment();

  Commitment.fromJson(core.Map _json) {
    if (_json.containsKey('category')) {
      category = _json['category'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTimestamp')) {
      endTimestamp = _json['endTimestamp'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseResource')) {
      licenseResource = LicenseResourceCommitment.fromJson(
          _json['licenseResource'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('plan')) {
      plan = _json['plan'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('reservations')) {
      reservations = (_json['reservations'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('resources')) {
      resources = (_json['resources'] as core.List)
          .map<ResourceCommitment>((value) => ResourceCommitment.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('startTimestamp')) {
      startTimestamp = _json['startTimestamp'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (category != null) {
      _json['category'] = category;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (endTimestamp != null) {
      _json['endTimestamp'] = endTimestamp;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (licenseResource != null) {
      _json['licenseResource'] = licenseResource.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (plan != null) {
      _json['plan'] = plan;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (reservations != null) {
      _json['reservations'] =
          reservations.map((value) => value.toJson()).toList();
    }
    if (resources != null) {
      _json['resources'] = resources.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (startTimestamp != null) {
      _json['startTimestamp'] = startTimestamp;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (statusMessage != null) {
      _json['statusMessage'] = statusMessage;
    }
    return _json;
  }
}

class CommitmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentAggregatedListWarningData();

  CommitmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentAggregatedListWarning();

  CommitmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentAggregatedListWarningData>((value) =>
              CommitmentAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class CommitmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of CommitmentsScopedList resources.
  core.Map<core.String, CommitmentsScopedList> items;

  /// [Output Only] Type of resource. Always compute#commitmentAggregatedList
  /// for aggregated lists of commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  CommitmentAggregatedListWarning warning;

  CommitmentAggregatedList();

  CommitmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              CommitmentsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class CommitmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentListWarningData();

  CommitmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class CommitmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentListWarning();

  CommitmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentListWarningData>((value) =>
              CommitmentListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Commitment resources.
class CommitmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Commitment resources.
  core.List<Commitment> items;

  /// [Output Only] Type of resource. Always compute#commitmentList for lists of
  /// commitments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  CommitmentListWarning warning;

  CommitmentList();

  CommitmentList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Commitment>((value) =>
              Commitment.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class CommitmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  CommitmentsScopedListWarningData();

  CommitmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of commitments
/// when the list is empty.
class CommitmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<CommitmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  CommitmentsScopedListWarning();

  CommitmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentsScopedListWarningData>((value) =>
              CommitmentsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class CommitmentsScopedList {
  /// [Output Only] A list of commitments contained in this scope.
  core.List<Commitment> commitments;

  /// [Output Only] Informational warning which replaces the list of commitments
  /// when the list is empty.
  CommitmentsScopedListWarning warning;

  CommitmentsScopedList();

  CommitmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('commitments')) {
      commitments = (_json['commitments'] as core.List)
          .map<Commitment>((value) =>
              Commitment.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (commitments != null) {
      _json['commitments'] =
          commitments.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A condition to be met.
class Condition {
  /// Trusted attributes supplied by the IAM system.
  /// Possible string values are:
  /// - "APPROVER"
  /// - "ATTRIBUTION"
  /// - "AUTHORITY"
  /// - "CREDENTIALS_TYPE"
  /// - "CREDS_ASSERTION"
  /// - "JUSTIFICATION_TYPE"
  /// - "NO_ATTR"
  /// - "SECURITY_REALM"
  core.String iam;

  /// An operator to apply the subject with.
  /// Possible string values are:
  /// - "DISCHARGED"
  /// - "EQUALS"
  /// - "IN"
  /// - "NOT_EQUALS"
  /// - "NOT_IN"
  /// - "NO_OP"
  core.String op;

  /// Trusted attributes discharged by the service.
  core.String svc;

  /// Trusted attributes supplied by any service that owns resources and uses
  /// the IAM system for access control.
  /// Possible string values are:
  /// - "IP"
  /// - "NAME"
  /// - "NO_ATTR"
  /// - "REGION"
  /// - "SERVICE"
  core.String sys;

  /// The objects of the condition.
  core.List<core.String> values;

  Condition();

  Condition.fromJson(core.Map _json) {
    if (_json.containsKey('iam')) {
      iam = _json['iam'] as core.String;
    }
    if (_json.containsKey('op')) {
      op = _json['op'] as core.String;
    }
    if (_json.containsKey('svc')) {
      svc = _json['svc'] as core.String;
    }
    if (_json.containsKey('sys')) {
      sys = _json['sys'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (iam != null) {
      _json['iam'] = iam;
    }
    if (op != null) {
      _json['op'] = op;
    }
    if (svc != null) {
      _json['svc'] = svc;
    }
    if (sys != null) {
      _json['sys'] = sys;
    }
    if (values != null) {
      _json['values'] = values;
    }
    return _json;
  }
}

/// A set of Confidential Instance options.
class ConfidentialInstanceConfig {
  /// Defines whether the instance should have confidential compute enabled.
  core.bool enableConfidentialCompute;

  ConfidentialInstanceConfig();

  ConfidentialInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enableConfidentialCompute')) {
      enableConfidentialCompute =
          _json['enableConfidentialCompute'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enableConfidentialCompute != null) {
      _json['enableConfidentialCompute'] = enableConfidentialCompute;
    }
    return _json;
  }
}

/// Message containing connection draining configuration.
class ConnectionDraining {
  /// The amount of time in seconds to allow existing connections to persist
  /// while on unhealthy backend VMs. Only applicable if the protocol is not
  /// UDP. The valid range is [0, 3600].
  core.int drainingTimeoutSec;

  ConnectionDraining();

  ConnectionDraining.fromJson(core.Map _json) {
    if (_json.containsKey('drainingTimeoutSec')) {
      drainingTimeoutSec = _json['drainingTimeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (drainingTimeoutSec != null) {
      _json['drainingTimeoutSec'] = drainingTimeoutSec;
    }
    return _json;
  }
}

/// This message defines settings for a consistent hash style load balancer.
class ConsistentHashLoadBalancerSettings {
  /// Hash is based on HTTP Cookie. This field describes a HTTP cookie that will
  /// be used as the hash key for the consistent hash load balancer. If the
  /// cookie is not present, it will be generated. This field is applicable if
  /// the sessionAffinity is set to HTTP_COOKIE.
  ConsistentHashLoadBalancerSettingsHttpCookie httpCookie;

  /// The hash based on the value of the specified header field. This field is
  /// applicable if the sessionAffinity is set to HEADER_FIELD.
  core.String httpHeaderName;

  /// The minimum number of virtual nodes to use for the hash ring. Defaults to
  /// 1024. Larger ring sizes result in more granular load distributions. If the
  /// number of hosts in the load balancing pool is larger than the ring size,
  /// each host will be assigned a single virtual node.
  core.String minimumRingSize;

  ConsistentHashLoadBalancerSettings();

  ConsistentHashLoadBalancerSettings.fromJson(core.Map _json) {
    if (_json.containsKey('httpCookie')) {
      httpCookie = ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(
          _json['httpCookie'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpHeaderName')) {
      httpHeaderName = _json['httpHeaderName'] as core.String;
    }
    if (_json.containsKey('minimumRingSize')) {
      minimumRingSize = _json['minimumRingSize'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (httpCookie != null) {
      _json['httpCookie'] = httpCookie.toJson();
    }
    if (httpHeaderName != null) {
      _json['httpHeaderName'] = httpHeaderName;
    }
    if (minimumRingSize != null) {
      _json['minimumRingSize'] = minimumRingSize;
    }
    return _json;
  }
}

/// The information about the HTTP Cookie on which the hash function is based
/// for load balancing policies that use a consistent hash.
class ConsistentHashLoadBalancerSettingsHttpCookie {
  /// Name of the cookie.
  core.String name;

  /// Path to set for the cookie.
  core.String path;

  /// Lifetime of the cookie.
  Duration ttl;

  ConsistentHashLoadBalancerSettingsHttpCookie();

  ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
    if (_json.containsKey('ttl')) {
      ttl = Duration.fromJson(
          _json['ttl'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    if (path != null) {
      _json['path'] = path;
    }
    if (ttl != null) {
      _json['ttl'] = ttl.toJson();
    }
    return _json;
  }
}

/// The specification for allowing client side cross-origin requests. Please see
/// W3C Recommendation for Cross Origin Resource Sharing
class CorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials. This translates to the
  /// Access-Control-Allow-Credentials header.
  /// Default is false.
  core.bool allowCredentials;

  /// Specifies the content for the Access-Control-Allow-Headers header.
  core.List<core.String> allowHeaders;

  /// Specifies the content for the Access-Control-Allow-Methods header.
  core.List<core.String> allowMethods;

  /// Specifies the regualar expression patterns that match allowed origins. For
  /// regular expression grammar please see
  /// en.cppreference.com/w/cpp/regex/ecmascript
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String> allowOriginRegexes;

  /// Specifies the list of origins that will be allowed to do CORS requests.
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String> allowOrigins;

  /// If true, specifies the CORS policy is disabled. The default value of
  /// false, which indicates that the CORS policy is in effect.
  core.bool disabled;

  /// Specifies the content for the Access-Control-Expose-Headers header.
  core.List<core.String> exposeHeaders;

  /// Specifies how long results of a preflight request can be cached in
  /// seconds. This translates to the Access-Control-Max-Age header.
  core.int maxAge;

  CorsPolicy();

  CorsPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('allowCredentials')) {
      allowCredentials = _json['allowCredentials'] as core.bool;
    }
    if (_json.containsKey('allowHeaders')) {
      allowHeaders = (_json['allowHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowMethods')) {
      allowMethods = (_json['allowMethods'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowOriginRegexes')) {
      allowOriginRegexes = (_json['allowOriginRegexes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowOrigins')) {
      allowOrigins = (_json['allowOrigins'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('disabled')) {
      disabled = _json['disabled'] as core.bool;
    }
    if (_json.containsKey('exposeHeaders')) {
      exposeHeaders = (_json['exposeHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('maxAge')) {
      maxAge = _json['maxAge'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (allowCredentials != null) {
      _json['allowCredentials'] = allowCredentials;
    }
    if (allowHeaders != null) {
      _json['allowHeaders'] = allowHeaders;
    }
    if (allowMethods != null) {
      _json['allowMethods'] = allowMethods;
    }
    if (allowOriginRegexes != null) {
      _json['allowOriginRegexes'] = allowOriginRegexes;
    }
    if (allowOrigins != null) {
      _json['allowOrigins'] = allowOrigins;
    }
    if (disabled != null) {
      _json['disabled'] = disabled;
    }
    if (exposeHeaders != null) {
      _json['exposeHeaders'] = exposeHeaders;
    }
    if (maxAge != null) {
      _json['maxAge'] = maxAge;
    }
    return _json;
  }
}

class CustomerEncryptionKey {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  core.String kmsKeyName;

  /// The service account being used for the encryption request for the given
  /// KMS key. If absent, the Compute Engine default service account is used.
  core.String kmsKeyServiceAccount;

  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  core.String rawKey;

  /// [Output only] The RFC 4648 base64 encoded SHA-256 hash of the
  /// customer-supplied encryption key that protects this resource.
  core.String sha256;

  CustomerEncryptionKey();

  CustomerEncryptionKey.fromJson(core.Map _json) {
    if (_json.containsKey('kmsKeyName')) {
      kmsKeyName = _json['kmsKeyName'] as core.String;
    }
    if (_json.containsKey('kmsKeyServiceAccount')) {
      kmsKeyServiceAccount = _json['kmsKeyServiceAccount'] as core.String;
    }
    if (_json.containsKey('rawKey')) {
      rawKey = _json['rawKey'] as core.String;
    }
    if (_json.containsKey('sha256')) {
      sha256 = _json['sha256'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kmsKeyName != null) {
      _json['kmsKeyName'] = kmsKeyName;
    }
    if (kmsKeyServiceAccount != null) {
      _json['kmsKeyServiceAccount'] = kmsKeyServiceAccount;
    }
    if (rawKey != null) {
      _json['rawKey'] = rawKey;
    }
    if (sha256 != null) {
      _json['sha256'] = sha256;
    }
    return _json;
  }
}

class CustomerEncryptionKeyProtectedDisk {
  /// Decrypts data associated with the disk with a customer-supplied encryption
  /// key.
  CustomerEncryptionKey diskEncryptionKey;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource. This field is only applicable for persistent disks.
  core.String source;

  CustomerEncryptionKeyProtectedDisk();

  CustomerEncryptionKeyProtectedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (diskEncryptionKey != null) {
      _json['diskEncryptionKey'] = diskEncryptionKey.toJson();
    }
    if (source != null) {
      _json['source'] = source;
    }
    return _json;
  }
}

/// Deprecation status for a public resource.
class DeprecationStatus {
  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DELETED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deleted;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DEPRECATED. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String deprecated;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to OBSOLETE. This is only informational and the
  /// status will not change unless the client explicitly changes it.
  core.String obsolete;

  /// The URL of the suggested replacement for a deprecated resource. The
  /// suggested replacement resource must be the same kind of resource as the
  /// deprecated resource.
  core.String replacement;

  /// The deprecation state of this resource. This can be ACTIVE, DEPRECATED,
  /// OBSOLETE, or DELETED. Operations which communicate the end of life date
  /// for an image, can use ACTIVE. Operations which create a new resource using
  /// a DEPRECATED resource will return successfully, but with a warning
  /// indicating the deprecated resource and recommending its replacement.
  /// Operations which use OBSOLETE or DELETED resources will be rejected and
  /// result in an error.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETED"
  /// - "DEPRECATED"
  /// - "OBSOLETE"
  core.String state;

  DeprecationStatus();

  DeprecationStatus.fromJson(core.Map _json) {
    if (_json.containsKey('deleted')) {
      deleted = _json['deleted'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = _json['deprecated'] as core.String;
    }
    if (_json.containsKey('obsolete')) {
      obsolete = _json['obsolete'] as core.String;
    }
    if (_json.containsKey('replacement')) {
      replacement = _json['replacement'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (deleted != null) {
      _json['deleted'] = deleted;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated;
    }
    if (obsolete != null) {
      _json['obsolete'] = obsolete;
    }
    if (replacement != null) {
      _json['replacement'] = replacement;
    }
    if (state != null) {
      _json['state'] = state;
    }
    return _json;
  }
}

/// Represents a Persistent Disk resource.
///
/// Google Compute Engine has two Disk resources:
///
/// * [Zonal](/compute/docs/reference/rest/{$api_version}/disks) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionDisks)
///
/// Persistent disks are required for running your VM instances. Create both
/// boot and non-boot (data) persistent disks. For more information, read
/// Persistent Disks. For more storage options, read Storage options.
///
/// The disks resource represents a zonal persistent disk. For more information,
/// read Zonal persistent disks.
///
/// The regionDisks resource represents a regional persistent disk. For more
/// information, read  Regional resources. (== resource_for {$api_version}.disks
/// ==) (== resource_for {$api_version}.regionDisks ==)
class Disk {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Encrypts the disk using a customer-supplied encryption key.
  ///
  /// After you encrypt a disk with a customer-supplied key, you must provide
  /// the same key if you use the disk later (e.g. to create a disk snapshot, to
  /// create a disk image, to create a machine image, or to attach the disk to a
  /// virtual machine).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the disk, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the disk later.
  CustomerEncryptionKey diskEncryptionKey;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#disk for disks.
  core.String kind;

  /// A fingerprint for the labels being applied to this disk, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a disk.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this disk. These can be later modified by the setLabels
  /// method.
  core.Map<core.String, core.String> labels;

  /// [Output Only] Last attach timestamp in RFC3339 text format.
  core.String lastAttachTimestamp;

  /// [Output Only] Last detach timestamp in RFC3339 text format.
  core.String lastDetachTimestamp;

  /// Integer license codes indicating which licenses are attached to this disk.
  core.List<core.String> licenseCodes;

  /// A list of publicly visible licenses. Reserved for Google's use.
  core.List<core.String> licenses;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Internal use only.
  core.String options;

  /// Physical block size of the persistent disk, in bytes. If not present in a
  /// request, a default value is used. The currently supported size is 4096,
  /// other sizes may be added in the future. If an unsupported value is
  /// requested, the error message will list the supported values for the
  /// caller's project.
  core.String physicalBlockSizeBytes;

  /// [Output Only] URL of the region where the disk resides. Only applicable
  /// for regional resources. You must specify this field as part of the HTTP
  /// request URL. It is not settable as a field in the request body.
  core.String region;

  /// URLs of the zones where the disk should be replicated to. Only applicable
  /// for regional resources.
  core.List<core.String> replicaZones;

  /// Resource policies applied to this disk for automatic snapshot creations.
  core.List<core.String> resourcePolicies;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Size, in GB, of the persistent disk. You can specify this field when
  /// creating a persistent disk using the sourceImage, sourceSnapshot, or
  /// sourceDisk parameter, or specify it alone to create an empty persistent
  /// disk.
  ///
  /// If you specify this field along with a source, the value of sizeGb must
  /// not be less than the size of the source. Acceptable values are 1 to 65536,
  /// inclusive.
  core.String sizeGb;

  /// The source disk used to create this disk. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String sourceDisk;

  /// [Output Only] The unique ID of the disk used to create this disk. This
  /// value identifies the exact disk that was used to create this persistent
  /// disk. For example, if you created the persistent disk from a disk that was
  /// later deleted and recreated under the same name, the source disk ID would
  /// identify the exact version of the disk that was used.
  core.String sourceDiskId;

  /// The source image used to create this disk. If the source image is deleted,
  /// this field will not be set.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this disk. This
  /// value identifies the exact image that was used to create this persistent
  /// disk. For example, if you created the persistent disk from an image that
  /// was later deleted and recreated under the same name, the source image ID
  /// would identify the exact version of the image that was used.
  core.String sourceImageId;

  /// The source snapshot used to create this disk. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot
  /// - projects/project/global/snapshots/snapshot
  /// - global/snapshots/snapshot
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot. Required if
  /// the source snapshot is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  /// [Output Only] The unique ID of the snapshot used to create this disk. This
  /// value identifies the exact snapshot that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// snapshot that was later deleted and recreated under the same name, the
  /// source snapshot ID would identify the exact version of the snapshot that
  /// was used.
  core.String sourceSnapshotId;

  /// [Output Only] The status of disk creation. CREATING: Disk is provisioning.
  /// RESTORING: Source data is being copied into the disk. FAILED: Disk
  /// creation failed. READY: Disk is ready for use. DELETING: Disk is deleting.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "RESTORING"
  core.String status;

  /// URL of the disk type resource describing which disk type to use to create
  /// the disk. Provide this when creating the disk. For example:
  /// projects/project/zones/zone/diskTypes/pd-standard  or pd-ssd
  core.String type;

  /// [Output Only] Links to the users of the disk (attached instances) in form:
  /// projects/project/zones/zone/instances/instance
  core.List<core.String> users;

  /// [Output Only] URL of the zone where the disk resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Disk();

  Disk.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('lastAttachTimestamp')) {
      lastAttachTimestamp = _json['lastAttachTimestamp'] as core.String;
    }
    if (_json.containsKey('lastDetachTimestamp')) {
      lastDetachTimestamp = _json['lastDetachTimestamp'] as core.String;
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('options')) {
      options = _json['options'] as core.String;
    }
    if (_json.containsKey('physicalBlockSizeBytes')) {
      physicalBlockSizeBytes = _json['physicalBlockSizeBytes'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('replicaZones')) {
      replicaZones = (_json['replicaZones'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceImageId')) {
      sourceImageId = _json['sourceImageId'] as core.String;
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshotId')) {
      sourceSnapshotId = _json['sourceSnapshotId'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('users')) {
      users = (_json['users'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (diskEncryptionKey != null) {
      _json['diskEncryptionKey'] = diskEncryptionKey.toJson();
    }
    if (guestOsFeatures != null) {
      _json['guestOsFeatures'] =
          guestOsFeatures.map((value) => value.toJson()).toList();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (lastAttachTimestamp != null) {
      _json['lastAttachTimestamp'] = lastAttachTimestamp;
    }
    if (lastDetachTimestamp != null) {
      _json['lastDetachTimestamp'] = lastDetachTimestamp;
    }
    if (licenseCodes != null) {
      _json['licenseCodes'] = licenseCodes;
    }
    if (licenses != null) {
      _json['licenses'] = licenses;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (options != null) {
      _json['options'] = options;
    }
    if (physicalBlockSizeBytes != null) {
      _json['physicalBlockSizeBytes'] = physicalBlockSizeBytes;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (replicaZones != null) {
      _json['replicaZones'] = replicaZones;
    }
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sizeGb != null) {
      _json['sizeGb'] = sizeGb;
    }
    if (sourceDisk != null) {
      _json['sourceDisk'] = sourceDisk;
    }
    if (sourceDiskId != null) {
      _json['sourceDiskId'] = sourceDiskId;
    }
    if (sourceImage != null) {
      _json['sourceImage'] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json['sourceImageEncryptionKey'] = sourceImageEncryptionKey.toJson();
    }
    if (sourceImageId != null) {
      _json['sourceImageId'] = sourceImageId;
    }
    if (sourceSnapshot != null) {
      _json['sourceSnapshot'] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json['sourceSnapshotEncryptionKey'] =
          sourceSnapshotEncryptionKey.toJson();
    }
    if (sourceSnapshotId != null) {
      _json['sourceSnapshotId'] = sourceSnapshotId;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (type != null) {
      _json['type'] = type;
    }
    if (users != null) {
      _json['users'] = users;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class DiskAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskAggregatedListWarningData();

  DiskAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskAggregatedListWarning();

  DiskAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskAggregatedListWarningData>((value) =>
              DiskAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class DiskAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DisksScopedList resources.
  core.Map<core.String, DisksScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskAggregatedList for
  /// aggregated lists of persistent disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  DiskAggregatedListWarning warning;

  DiskAggregatedList();

  DiskAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              DisksScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A specification of the desired way to instantiate a disk in the instance
/// template when its created from a source instance.
class DiskInstantiationConfig {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool autoDelete;

  /// The custom source image to be used to restore this disk when instantiating
  /// this instance template.
  core.String customImage;

  /// Specifies the device name of the disk to which the configurations apply
  /// to.
  core.String deviceName;

  /// Specifies whether to include the disk and what image to use. Possible
  /// values are:
  /// - source-image: to use the same image that was used to create the source
  /// instance's corresponding disk. Applicable to the boot disk and additional
  /// read-write disks.
  /// - source-image-family: to use the same image family that was used to
  /// create the source instance's corresponding disk. Applicable to the boot
  /// disk and additional read-write disks.
  /// - custom-image: to use a user-provided image url for disk creation.
  /// Applicable to the boot disk and additional read-write disks.
  /// - attach-read-only: to attach a read-only disk. Applicable to read-only
  /// disks.
  /// - do-not-include: to exclude a disk from the template. Applicable to
  /// additional read-write disks, local SSDs, and read-only disks.
  /// Possible string values are:
  /// - "ATTACH_READ_ONLY"
  /// - "BLANK"
  /// - "CUSTOM_IMAGE"
  /// - "DEFAULT"
  /// - "DO_NOT_INCLUDE"
  /// - "SOURCE_IMAGE"
  /// - "SOURCE_IMAGE_FAMILY"
  core.String instantiateFrom;

  DiskInstantiationConfig();

  DiskInstantiationConfig.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.bool;
    }
    if (_json.containsKey('customImage')) {
      customImage = _json['customImage'] as core.String;
    }
    if (_json.containsKey('deviceName')) {
      deviceName = _json['deviceName'] as core.String;
    }
    if (_json.containsKey('instantiateFrom')) {
      instantiateFrom = _json['instantiateFrom'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoDelete != null) {
      _json['autoDelete'] = autoDelete;
    }
    if (customImage != null) {
      _json['customImage'] = customImage;
    }
    if (deviceName != null) {
      _json['deviceName'] = deviceName;
    }
    if (instantiateFrom != null) {
      _json['instantiateFrom'] = instantiateFrom;
    }
    return _json;
  }
}

class DiskListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskListWarningData();

  DiskListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskListWarning();

  DiskListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskListWarningData>((value) => DiskListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// A list of Disk resources.
class DiskList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Disk resources.
  core.List<Disk> items;

  /// [Output Only] Type of resource. Always compute#diskList for lists of
  /// disks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskListWarning warning;

  DiskList();

  DiskList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Disk>((value) =>
              Disk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = DiskListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class DiskMoveRequest {
  /// The URL of the destination zone to move the disk. This can be a full or
  /// partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target disk to move. This can be a full or partial URL. For
  /// example, the following are all valid URLs to a disk:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String targetDisk;

  DiskMoveRequest();

  DiskMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey('destinationZone')) {
      destinationZone = _json['destinationZone'] as core.String;
    }
    if (_json.containsKey('targetDisk')) {
      targetDisk = _json['targetDisk'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (destinationZone != null) {
      _json['destinationZone'] = destinationZone;
    }
    if (targetDisk != null) {
      _json['targetDisk'] = targetDisk;
    }
    return _json;
  }
}

/// Represents a Disk Type resource.
///
/// Google Compute Engine has two Disk Type resources:
///
/// * [Regional](/compute/docs/reference/rest/{$api_version}/regionDiskTypes) *
/// [Zonal](/compute/docs/reference/rest/{$api_version}/diskTypes)
///
/// You can choose from a variety of disk types based on your needs. For more
/// information, read Storage options.
///
/// The diskTypes resource represents disk types for a zonal persistent disk.
/// For more information, read Zonal persistent disks.
///
/// The regionDiskTypes resource represents disk types for a regional persistent
/// disk. For more information, read Regional persistent disks. (== resource_for
/// {$api_version}.diskTypes ==) (== resource_for {$api_version}.regionDiskTypes
/// ==)
class DiskType {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Server-defined default disk size in GB.
  core.String defaultDiskSizeGb;

  /// [Output Only] The deprecation status associated with this disk type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional description of this resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#diskType for disk
  /// types.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] URL of the region where the disk type resides. Only
  /// applicable for regional resources. You must specify this field as part of
  /// the HTTP request URL. It is not settable as a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] An optional textual description of the valid disk size, such
  /// as "10GB-10TB".
  core.String validDiskSize;

  /// [Output Only] URL of the zone where the disk type resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  DiskType();

  DiskType.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultDiskSizeGb')) {
      defaultDiskSizeGb = _json['defaultDiskSizeGb'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('validDiskSize')) {
      validDiskSize = _json['validDiskSize'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (defaultDiskSizeGb != null) {
      _json['defaultDiskSizeGb'] = defaultDiskSizeGb;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (validDiskSize != null) {
      _json['validDiskSize'] = validDiskSize;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class DiskTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeAggregatedListWarningData();

  DiskTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeAggregatedListWarning();

  DiskTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypeAggregatedListWarningData>((value) =>
              DiskTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class DiskTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskTypesScopedList resources.
  core.Map<core.String, DiskTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  DiskTypeAggregatedListWarning warning;

  DiskTypeAggregatedList();

  DiskTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              DiskTypesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class DiskTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypeListWarningData();

  DiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class DiskTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypeListWarning();

  DiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypeListWarningData>((value) =>
              DiskTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of disk types.
class DiskTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskType resources.
  core.List<DiskType> items;

  /// [Output Only] Type of resource. Always compute#diskTypeList for disk
  /// types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  DiskTypeListWarning warning;

  DiskTypeList();

  DiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class DiskTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DiskTypesScopedListWarningData();

  DiskTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disk types
/// when the list is empty.
class DiskTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DiskTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DiskTypesScopedListWarning();

  DiskTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypesScopedListWarningData>((value) =>
              DiskTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class DiskTypesScopedList {
  /// [Output Only] A list of disk types contained in this scope.
  core.List<DiskType> diskTypes;

  /// [Output Only] Informational warning which replaces the list of disk types
  /// when the list is empty.
  DiskTypesScopedListWarning warning;

  DiskTypesScopedList();

  DiskTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('diskTypes')) {
      diskTypes = (_json['diskTypes'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (diskTypes != null) {
      _json['diskTypes'] = diskTypes.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class DisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk. Currently you can only specify
  /// one policy here.
  core.List<core.String> resourcePolicies;

  DisksAddResourcePoliciesRequest();

  DisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class DisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String> resourcePolicies;

  DisksRemoveResourcePoliciesRequest();

  DisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String sizeGb;

  DisksResizeRequest();

  DisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sizeGb != null) {
      _json['sizeGb'] = sizeGb;
    }
    return _json;
  }
}

class DisksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  DisksScopedListWarningData();

  DisksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of disks when
/// the list is empty.
class DisksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<DisksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  DisksScopedListWarning();

  DisksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DisksScopedListWarningData>((value) =>
              DisksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class DisksScopedList {
  /// [Output Only] A list of disks contained in this scope.
  core.List<Disk> disks;

  /// [Output Only] Informational warning which replaces the list of disks when
  /// the list is empty.
  DisksScopedListWarning warning;

  DisksScopedList();

  DisksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<Disk>((value) =>
              Disk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DisksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (disks != null) {
      _json['disks'] = disks.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A set of Display Device options
class DisplayDevice {
  /// Defines whether the instance has Display enabled.
  core.bool enableDisplay;

  DisplayDevice();

  DisplayDevice.fromJson(core.Map _json) {
    if (_json.containsKey('enableDisplay')) {
      enableDisplay = _json['enableDisplay'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enableDisplay != null) {
      _json['enableDisplay'] = enableDisplay;
    }
    return _json;
  }
}

class DistributionPolicy {
  /// Zones where the regional managed instance group will create and manage
  /// instances.
  core.List<DistributionPolicyZoneConfiguration> zones;

  DistributionPolicy();

  DistributionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('zones')) {
      zones = (_json['zones'] as core.List)
          .map<DistributionPolicyZoneConfiguration>((value) =>
              DistributionPolicyZoneConfiguration.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (zones != null) {
      _json['zones'] = zones.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class DistributionPolicyZoneConfiguration {
  /// The URL of the zone. The zone must exist in the region where the managed
  /// instance group is located.
  core.String zone;

  DistributionPolicyZoneConfiguration();

  DistributionPolicyZoneConfiguration.fromJson(core.Map _json) {
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

/// A Duration represents a fixed-length span of time represented as a count of
/// seconds and fractions of seconds at nanosecond resolution. It is independent
/// of any calendar and concepts like "day" or "month". Range is approximately
/// 10,000 years.
class Duration {
  /// Span of time that's a fraction of a second at nanosecond resolution.
  /// Durations less than one second are represented with a 0 `seconds` field
  /// and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
  core.int nanos;

  /// Span of time at a resolution of a second. Must be from 0 to
  /// 315,576,000,000 inclusive. Note: these bounds are computed from: 60
  /// sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
  core.String seconds;

  Duration();

  Duration.fromJson(core.Map _json) {
    if (_json.containsKey('nanos')) {
      nanos = _json['nanos'] as core.int;
    }
    if (_json.containsKey('seconds')) {
      seconds = _json['seconds'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nanos != null) {
      _json['nanos'] = nanos;
    }
    if (seconds != null) {
      _json['seconds'] = seconds;
    }
    return _json;
  }
}

class ExchangedPeeringRoute {
  /// The destination range of the route.
  core.String destRange;

  /// True if the peering route has been imported from a peer. The actual import
  /// happens if the field networkPeering.importCustomRoutes is true for this
  /// network, and networkPeering.exportCustomRoutes is true for the peer
  /// network, and the import does not result in a route conflict.
  core.bool imported;

  /// The region of peering route next hop, only applies to dynamic routes.
  core.String nextHopRegion;

  /// The priority of the peering route.
  core.int priority;

  /// The type of the peering route.
  /// Possible string values are:
  /// - "DYNAMIC_PEERING_ROUTE"
  /// - "STATIC_PEERING_ROUTE"
  /// - "SUBNET_PEERING_ROUTE"
  core.String type;

  ExchangedPeeringRoute();

  ExchangedPeeringRoute.fromJson(core.Map _json) {
    if (_json.containsKey('destRange')) {
      destRange = _json['destRange'] as core.String;
    }
    if (_json.containsKey('imported')) {
      imported = _json['imported'] as core.bool;
    }
    if (_json.containsKey('nextHopRegion')) {
      nextHopRegion = _json['nextHopRegion'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (destRange != null) {
      _json['destRange'] = destRange;
    }
    if (imported != null) {
      _json['imported'] = imported;
    }
    if (nextHopRegion != null) {
      _json['nextHopRegion'] = nextHopRegion;
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class ExchangedPeeringRoutesListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ExchangedPeeringRoutesListWarningData();

  ExchangedPeeringRoutesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ExchangedPeeringRoutesListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ExchangedPeeringRoutesListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ExchangedPeeringRoutesListWarning();

  ExchangedPeeringRoutesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ExchangedPeeringRoutesListWarningData>((value) =>
              ExchangedPeeringRoutesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ExchangedPeeringRoutesList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ExchangedPeeringRoute resources.
  core.List<ExchangedPeeringRoute> items;

  /// [Output Only] Type of resource. Always compute#exchangedPeeringRoutesList
  /// for exchanged peering routes lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ExchangedPeeringRoutesListWarning warning;

  ExchangedPeeringRoutesList();

  ExchangedPeeringRoutesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ExchangedPeeringRoute>((value) => ExchangedPeeringRoute.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ExchangedPeeringRoutesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at https://github.com/google/cel-spec.
///
/// Example (Comparison):
///
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() < 100"
///
/// Example (Equality):
///
/// title: "Requestor is owner" description: "Determines if requestor is the
/// document owner" expression: "document.owner == request.auth.claims.email"
///
/// Example (Logic):
///
/// title: "Public documents" description: "Determine whether the document
/// should be publicly visible" expression: "document.type != 'private' &&
/// document.type != 'internal'"
///
/// Example (Data Manipulation):
///
/// title: "Notification string" description: "Create a notification string with
/// a timestamp." expression: "'New message received at ' +
/// string(document.create_time)"
///
/// The exact variables and functions that may be referenced within an
/// expression are determined by the service that evaluates it. See the service
/// documentation for additional information.
class Expr {
  /// Optional. Description of the expression. This is a longer text which
  /// describes the expression, e.g. when hovered over it in a UI.
  core.String description;

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  core.String expression;

  /// Optional. String indicating the location of the expression for error
  /// reporting, e.g. a file name and a position in the file.
  core.String location;

  /// Optional. Title for the expression, i.e. a short string describing its
  /// purpose. This can be used e.g. in UIs which allow to enter the expression.
  core.String title;

  Expr();

  Expr.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expression')) {
      expression = _json['expression'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('title')) {
      title = _json['title'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (expression != null) {
      _json['expression'] = expression;
    }
    if (location != null) {
      _json['location'] = location;
    }
    if (title != null) {
      _json['title'] = title;
    }
    return _json;
  }
}

/// Represents an external VPN gateway.
///
/// External VPN gateway is the on-premises VPN gateway(s) or another cloud
/// provider's VPN gateway that connects to your Google Cloud VPN gateway.
///
/// To create a highly available VPN from Google Cloud Platform to your VPN
/// gateway or another cloud provider's VPN gateway, you must create a external
/// VPN gateway resource with information about the other gateway.
///
/// For more information about using external VPN gateways, see  Creating an HA
/// VPN gateway and tunnel pair to a peer VPN. (== resource_for
/// {$api_version}.externalVpnGateways ==)
class ExternalVpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// List of interfaces for this external VPN gateway.
  core.List<ExternalVpnGatewayInterface> interfaces;

  /// [Output Only] Type of the resource. Always compute#externalVpnGateway for
  /// externalVpnGateways.
  core.String kind;

  /// A fingerprint for the labels being applied to this ExternalVpnGateway,
  /// which is essentially a hash of the labels set used for optimistic locking.
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// ExternalVpnGateway.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource. These can only be added or modified by the
  /// setLabels method. Each label key/value pair must comply with RFC1035.
  /// Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Indicates the user-supplied redundancy type of this external VPN gateway.
  /// Possible string values are:
  /// - "FOUR_IPS_REDUNDANCY"
  /// - "SINGLE_IP_INTERNALLY_REDUNDANT"
  /// - "TWO_IPS_REDUNDANCY"
  core.String redundancyType;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  ExternalVpnGateway();

  ExternalVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interfaces')) {
      interfaces = (_json['interfaces'] as core.List)
          .map<ExternalVpnGatewayInterface>((value) =>
              ExternalVpnGatewayInterface.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('redundancyType')) {
      redundancyType = _json['redundancyType'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (interfaces != null) {
      _json['interfaces'] = interfaces.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (redundancyType != null) {
      _json['redundancyType'] = redundancyType;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// The interface for the external VPN gateway.
class ExternalVpnGatewayInterface {
  /// The numeric ID of this interface. The allowed input values for this id for
  /// different redundancy types of external VPN gateway:
  /// SINGLE_IP_INTERNALLY_REDUNDANT - 0 TWO_IPS_REDUNDANCY - 0, 1
  /// FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
  core.int id;

  /// IP address of the interface in the external VPN gateway. Only IPv4 is
  /// supported. This IP address can be either from your on-premise gateway or
  /// another Cloud provider's VPN gateway, it cannot be an IP address from
  /// Google Compute Engine.
  core.String ipAddress;

  ExternalVpnGatewayInterface();

  ExternalVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.int;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    return _json;
  }
}

class ExternalVpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ExternalVpnGatewayListWarningData();

  ExternalVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ExternalVpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ExternalVpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ExternalVpnGatewayListWarning();

  ExternalVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ExternalVpnGatewayListWarningData>((value) =>
              ExternalVpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of externalVpnGateways.
class ExternalVpnGatewayList {
  core.String etag;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ExternalVpnGateway resources.
  core.List<ExternalVpnGateway> items;

  /// [Output Only] Type of resource. Always compute#externalVpnGatewayList  for
  /// lists of externalVpnGateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ExternalVpnGatewayListWarning warning;

  ExternalVpnGatewayList();

  ExternalVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ExternalVpnGateway>((value) => ExternalVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ExternalVpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class FileContentBuffer {
  /// The raw content in the secure keys file.
  core.String content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content);

  set contentAsBytes(core.List<core.int> _bytes) {
    content =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The file type of source file.
  /// Possible string values are:
  /// - "BIN"
  /// - "UNDEFINED"
  /// - "X509"
  core.String fileType;

  FileContentBuffer();

  FileContentBuffer.fromJson(core.Map _json) {
    if (_json.containsKey('content')) {
      content = _json['content'] as core.String;
    }
    if (_json.containsKey('fileType')) {
      fileType = _json['fileType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (content != null) {
      _json['content'] = content;
    }
    if (fileType != null) {
      _json['fileType'] = fileType;
    }
    return _json;
  }
}

class FirewallAllowed {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp) or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for the UDP or TCP protocol. Each entry must be either an
  /// integer or a range. If not specified, this rule applies to connections
  /// through any port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallAllowed();

  FirewallAllowed.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (IPProtocol != null) {
      _json['IPProtocol'] = IPProtocol;
    }
    if (ports != null) {
      _json['ports'] = ports;
    }
    return _json;
  }
}

class FirewallDenied {
  /// The IP protocol to which this rule applies. The protocol type is required
  /// when creating a firewall rule. This value can either be one of the
  /// following well known protocol strings (tcp, udp, icmp, esp, ah, ipip,
  /// sctp) or the IP protocol number.
  core.String IPProtocol;

  /// An optional list of ports to which this rule applies. This field is only
  /// applicable for the UDP or TCP protocol. Each entry must be either an
  /// integer or a range. If not specified, this rule applies to connections
  /// through any port.
  ///
  /// Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
  core.List<core.String> ports;

  FirewallDenied();

  FirewallDenied.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (IPProtocol != null) {
      _json['IPProtocol'] = IPProtocol;
    }
    if (ports != null) {
      _json['ports'] = ports;
    }
    return _json;
  }
}

/// Represents a Firewall Rule resource.
///
/// Firewall rules allow or deny ingress traffic to, and egress traffic from
/// your instances. For more information, read Firewall rules.
class Firewall {
  /// The list of ALLOW rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a permitted connection.
  core.List<FirewallAllowed> allowed;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The list of DENY rules specified by this firewall. Each rule specifies a
  /// protocol and port-range tuple that describes a denied connection.
  core.List<FirewallDenied> denied;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// If destination ranges are specified, the firewall rule applies only to
  /// traffic that has destination IP address in these ranges. These ranges must
  /// be expressed in CIDR format. Only IPv4 is supported.
  core.List<core.String> destinationRanges;

  /// Direction of traffic to which this firewall applies, either `INGRESS` or
  /// `EGRESS`. The default is `INGRESS`. For `INGRESS` traffic, you cannot
  /// specify the destinationRanges field, and for `EGRESS` traffic, you cannot
  /// specify the sourceRanges or sourceTags fields.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String direction;

  /// Denotes whether the firewall rule is disabled. When set to true, the
  /// firewall rule is not enforced and the network behaves as if it did not
  /// exist. If this is unspecified, the firewall rule will be enabled.
  core.bool disabled;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#firewall for firewall
  /// rules.
  core.String kind;

  /// This field denotes the logging options for a particular firewall rule. If
  /// logging is enabled, logs will be exported to Cloud Logging.
  FirewallLogConfig logConfig;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// URL of the network resource for this firewall rule. If not specified when
  /// creating a firewall rule, the default network is used:
  /// global/networks/default
  /// If you choose to specify this field, you can specify the network as a full
  /// or partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
  /// - projects/myproject/global/networks/my-network
  /// - global/networks/default
  core.String network;

  /// Priority for this rule. This is an integer between `0` and `65535`, both
  /// inclusive. The default value is `1000`. Relative priorities determine
  /// which rule takes effect if multiple rules apply. Lower values indicate
  /// higher priority. For example, a rule with priority `0` has higher
  /// precedence than a rule with priority `1`. DENY rules take precedence over
  /// ALLOW rules if they have equal priority. Note that VPC networks have
  /// implied rules with a priority of `65535`. To avoid conflicts with the
  /// implied rules, use a priority number less than `65535`.
  core.int priority;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// If source ranges are specified, the firewall rule applies only to traffic
  /// that has a source IP address in these ranges. These ranges must be
  /// expressed in CIDR format. One or both of sourceRanges and sourceTags may
  /// be set. If both fields are set, the rule applies to traffic that has a
  /// source IP address within sourceRanges OR a source IP from a resource with
  /// a matching tag listed in the sourceTags field. The connection does not
  /// need to match both fields for the rule to apply. Only IPv4 is supported.
  core.List<core.String> sourceRanges;

  /// If source service accounts are specified, the firewall rules apply only to
  /// traffic originating from an instance with a service account in this list.
  /// Source service accounts cannot be used to control traffic to an instance's
  /// external IP address because service accounts are associated with an
  /// instance, not an IP address. sourceRanges can be set at the same time as
  /// sourceServiceAccounts. If both are set, the firewall applies to traffic
  /// that has a source IP address within the sourceRanges OR a source IP that
  /// belongs to an instance with service account listed in
  /// sourceServiceAccount. The connection does not need to match both fields
  /// for the firewall to apply. sourceServiceAccounts cannot be used at the
  /// same time as sourceTags or targetTags.
  core.List<core.String> sourceServiceAccounts;

  /// If source tags are specified, the firewall rule applies only to traffic
  /// with source IPs that match the primary network interfaces of VM instances
  /// that have the tag and are in the same VPC network. Source tags cannot be
  /// used to control traffic to an instance's external IP address, it only
  /// applies to traffic between instances in the same virtual network. Because
  /// tags are associated with instances, not IP addresses. One or both of
  /// sourceRanges and sourceTags may be set. If both fields are set, the
  /// firewall applies to traffic that has a source IP address within
  /// sourceRanges OR a source IP from a resource with a matching tag listed in
  /// the sourceTags field. The connection does not need to match both fields
  /// for the firewall to apply.
  core.List<core.String> sourceTags;

  /// A list of service accounts indicating sets of instances located in the
  /// network that may make network connections as specified in allowed[].
  /// targetServiceAccounts cannot be used at the same time as targetTags or
  /// sourceTags. If neither targetServiceAccounts nor targetTags are specified,
  /// the firewall rule applies to all instances on the specified network.
  core.List<core.String> targetServiceAccounts;

  /// A list of tags that controls which instances the firewall rule applies to.
  /// If targetTags are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those tags. If no targetTags
  /// are specified, the firewall rule applies to all instances on the specified
  /// network.
  core.List<core.String> targetTags;

  Firewall();

  Firewall.fromJson(core.Map _json) {
    if (_json.containsKey('allowed')) {
      allowed = (_json['allowed'] as core.List)
          .map<FirewallAllowed>((value) => FirewallAllowed.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('denied')) {
      denied = (_json['denied'] as core.List)
          .map<FirewallDenied>((value) => FirewallDenied.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('destinationRanges')) {
      destinationRanges = (_json['destinationRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('direction')) {
      direction = _json['direction'] as core.String;
    }
    if (_json.containsKey('disabled')) {
      disabled = _json['disabled'] as core.bool;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = FirewallLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sourceRanges')) {
      sourceRanges = (_json['sourceRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceServiceAccounts')) {
      sourceServiceAccounts = (_json['sourceServiceAccounts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceTags')) {
      sourceTags = (_json['sourceTags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetServiceAccounts')) {
      targetServiceAccounts = (_json['targetServiceAccounts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetTags')) {
      targetTags = (_json['targetTags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (allowed != null) {
      _json['allowed'] = allowed.map((value) => value.toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (denied != null) {
      _json['denied'] = denied.map((value) => value.toJson()).toList();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (destinationRanges != null) {
      _json['destinationRanges'] = destinationRanges;
    }
    if (direction != null) {
      _json['direction'] = direction;
    }
    if (disabled != null) {
      _json['disabled'] = disabled;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (logConfig != null) {
      _json['logConfig'] = logConfig.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sourceRanges != null) {
      _json['sourceRanges'] = sourceRanges;
    }
    if (sourceServiceAccounts != null) {
      _json['sourceServiceAccounts'] = sourceServiceAccounts;
    }
    if (sourceTags != null) {
      _json['sourceTags'] = sourceTags;
    }
    if (targetServiceAccounts != null) {
      _json['targetServiceAccounts'] = targetServiceAccounts;
    }
    if (targetTags != null) {
      _json['targetTags'] = targetTags;
    }
    return _json;
  }
}

class FirewallListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  FirewallListWarningData();

  FirewallListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class FirewallListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<FirewallListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  FirewallListWarning();

  FirewallListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<FirewallListWarningData>((value) =>
              FirewallListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of firewalls.
class FirewallList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Firewall resources.
  core.List<Firewall> items;

  /// [Output Only] Type of resource. Always compute#firewallList for lists of
  /// firewalls.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  FirewallListWarning warning;

  FirewallList();

  FirewallList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Firewall>((value) =>
              Firewall.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = FirewallListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// The available logging options for a firewall rule.
class FirewallLogConfig {
  /// This field denotes whether to enable logging for a particular firewall
  /// rule.
  core.bool enable;

  /// This field can only be specified for a particular firewall rule if logging
  /// is enabled for that rule. This field denotes whether to include or exclude
  /// metadata for firewall logs.
  /// Possible string values are:
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String metadata;

  FirewallLogConfig();

  FirewallLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('metadata')) {
      metadata = _json['metadata'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enable != null) {
      _json['enable'] = enable;
    }
    if (metadata != null) {
      _json['metadata'] = metadata;
    }
    return _json;
  }
}

/// Encapsulates numeric value that can be either absolute or relative.
class FixedOrPercent {
  /// [Output Only] Absolute value of VM instances calculated based on the
  /// specific mode.
  ///
  ///
  /// - If the value is fixed, then the calculated value is equal to the fixed
  /// value.
  /// - If the value is a percent, then the calculated value is percent/100 *
  /// targetSize. For example, the calculated value of a 80% of a managed
  /// instance group with 150 instances would be (80/100 * 150) = 120 VM
  /// instances. If there is a remainder, the number is rounded up.
  core.int calculated;

  /// Specifies a fixed number of VM instances. This must be a positive integer.
  core.int fixed;

  /// Specifies a percentage of instances between 0 to 100%, inclusive. For
  /// example, specify 80 for 80%.
  core.int percent;

  FixedOrPercent();

  FixedOrPercent.fromJson(core.Map _json) {
    if (_json.containsKey('calculated')) {
      calculated = _json['calculated'] as core.int;
    }
    if (_json.containsKey('fixed')) {
      fixed = _json['fixed'] as core.int;
    }
    if (_json.containsKey('percent')) {
      percent = _json['percent'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (calculated != null) {
      _json['calculated'] = calculated;
    }
    if (fixed != null) {
      _json['fixed'] = fixed;
    }
    if (percent != null) {
      _json['percent'] = percent;
    }
    return _json;
  }
}

/// Represents a Forwarding Rule resource.
///
/// Forwarding rule resources in GCP can be either regional or global in scope:
///
/// *
/// [Global](/compute/docs/reference/rest/{$api_version}/globalForwardingRules)
/// * [Regional](/compute/docs/reference/rest/{$api_version}/forwardingRules)
///
/// A forwarding rule and its corresponding IP address represent the frontend
/// configuration of a Google Cloud Platform load balancer. Forwarding rules can
/// also reference target instances and Cloud VPN Classic gateways
/// (targetVpnGateway).
///
/// For more information, read Forwarding rule concepts and Using protocol
/// forwarding.
///
/// (== resource_for {$api_version}.forwardingRules ==) (== resource_for
/// {$api_version}.globalForwardingRules ==) (== resource_for
/// {$api_version}.regionForwardingRules ==)
class ForwardingRule {
  /// IP address that this forwarding rule serves. When a client sends traffic
  /// to this IP address, the forwarding rule directs the traffic to the target
  /// that you specify in the forwarding rule.
  ///
  /// If you don't specify a reserved IP address, an ephemeral IP address is
  /// assigned. Methods for specifying an IP address:
  ///
  /// * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in
  /// https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name
  /// * Partial URL or by name, as in: *
  /// projects/project_id/regions/region/addresses/address-name *
  /// regions/region/addresses/address-name * global/addresses/address-name *
  /// address-name
  ///
  /// The loadBalancingScheme and the forwarding rule's target determine the
  /// type of IP address that you can use. For detailed information, refer to
  /// [IP address
  /// specifications](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  ///
  /// Must be set to `0.0.0.0` when the target is targetGrpcProxy that has
  /// validateForProxyless field set to true.
  core.String IPAddress;

  /// The IP protocol to which this rule applies. For protocol forwarding, valid
  /// options are TCP, UDP, ESP, AH, SCTP or ICMP.
  ///
  /// For Internal TCP/UDP Load Balancing, the load balancing scheme is
  /// INTERNAL, and one of TCP or UDP are valid. For Traffic Director, the load
  /// balancing scheme is INTERNAL_SELF_MANAGED, and only TCPis valid. For
  /// Internal HTTP(S) Load Balancing, the load balancing scheme is
  /// INTERNAL_MANAGED, and only TCP is valid. For HTTP(S), SSL Proxy, and TCP
  /// Proxy Load Balancing, the load balancing scheme is EXTERNAL and only TCP
  /// is valid. For Network TCP/UDP Load Balancing, the load balancing scheme is
  /// EXTERNAL, and one of TCP or UDP is valid.
  /// Possible string values are:
  /// - "AH"
  /// - "ESP"
  /// - "ICMP"
  /// - "SCTP"
  /// - "TCP"
  /// - "UDP"
  core.String IPProtocol;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance. This field
  /// cannot be used with port or portRange fields.
  ///
  /// When the load balancing scheme is INTERNAL and protocol is TCP/UDP,
  /// specify this field to allow packets addressed to any ports will be
  /// forwarded to the backends configured with this forwarding rule.
  core.bool allPorts;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance. If the
  /// field is set to TRUE, clients can access ILB from all regions. Otherwise
  /// only allows access from clients in the same region as the internal load
  /// balancer.
  core.bool allowGlobalAccess;

  /// This field is only used for INTERNAL load balancing.
  ///
  /// For internal load balancing, this field identifies the BackendService
  /// resource to receive the matched traffic.
  core.String backendService;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a ForwardingRule. Include the fingerprint in patch
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// ForwardingRule.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The IP Version that will be used by this forwarding rule. Valid options
  /// are IPV4 or IPV6. This can only be specified for an external global
  /// forwarding rule.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String ipVersion;

  /// Indicates whether or not this load balancer can be used as a collector for
  /// packet mirroring. To prevent mirroring loops, instances behind this load
  /// balancer will not have their traffic mirrored even if a PacketMirroring
  /// rule applies to them. This can only be set to true for load balancers that
  /// have their loadBalancingScheme set to INTERNAL.
  core.bool isMirroringCollector;

  /// [Output Only] Type of the resource. Always compute#forwardingRule for
  /// Forwarding Rule resources.
  core.String kind;

  /// Specifies the forwarding rule type.
  ///
  ///
  /// - EXTERNAL is used for:
  /// - Classic Cloud VPN gateways
  /// - Protocol forwarding to VMs from an external IP address
  /// - The following load balancers: HTTP(S), SSL Proxy, TCP Proxy, and Network
  /// TCP/UDP
  /// - INTERNAL is used for:
  /// - Protocol forwarding to VMs from an internal IP address
  /// - Internal TCP/UDP load balancers
  /// - INTERNAL_MANAGED is used for:
  /// - Internal HTTP(S) load balancers
  /// - INTERNAL_SELF_MANAGED is used for:
  /// - Traffic Director
  ///
  /// For more information about forwarding rules, refer to Forwarding rule
  /// concepts.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID"
  core.String loadBalancingScheme;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients. In their xDS
  /// requests to Loadbalancer, xDS clients present node metadata. When there is
  /// a match, the relevant configuration is made available to those proxies.
  /// Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by
  /// the ForwardingRule will not be visible to those proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata. If multiple metadataFilters are
  /// specified, all of them need to be satisfied in order to be considered a
  /// match.
  /// metadataFilters specified here will be applifed before those specified in
  /// the UrlMap that this ForwardingRule references.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.List<MetadataFilter> metadataFilters;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// This field is not used for external load balancing.
  ///
  /// For internal load balancing, this field identifies the network that the
  /// load balanced IP should belong to for this Forwarding Rule. If this field
  /// is not specified, the default network will be used.
  core.String network;

  /// This signifies the networking tier used for configuring this load balancer
  /// and can only take the following values: PREMIUM, STANDARD.
  ///
  /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD.
  /// For GlobalForwardingRule, the valid value is PREMIUM.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM. If IPAddress
  /// is specified, this value must be equal to the networkTier of the Address.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  /// When the load balancing scheme is EXTERNAL, INTERNAL_SELF_MANAGED and
  /// INTERNAL_MANAGED, you can specify a port_range. Use with a forwarding rule
  /// that points to a target proxy or a target pool. Do not use with a
  /// forwarding rule that points to a backend service. This field is used along
  /// with the target field for TargetHttpProxy, TargetHttpsProxy,
  /// TargetSslProxy, TargetTcpProxy, TargetGrpcProxy, TargetVpnGateway,
  /// TargetPool, TargetInstance.
  ///
  /// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
  /// addressed to ports in the specified range will be forwarded to target.
  /// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
  /// disjoint port ranges.
  ///
  /// Some types of forwarding target have constraints on the acceptable ports:
  /// - TargetHttpProxy: 80, 8080
  /// - TargetHttpsProxy: 443
  /// - TargetGrpcProxy: Any ports
  /// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetVpnGateway: 500, 4500
  core.String portRange;

  /// This field is used along with the backend_service field for internal load
  /// balancing.
  ///
  /// When the load balancing scheme is INTERNAL, a list of ports can be
  /// configured, for example, ['80'], ['8000','9000']. Only packets addressed
  /// to these ports are forwarded to the backends configured with the
  /// forwarding rule.
  ///
  /// If the forwarding rule's loadBalancingScheme is INTERNAL, you can specify
  /// ports in one of the following ways:
  ///
  /// * A list of up to five ports, which can be non-contiguous * Keyword ALL,
  /// which causes the forwarding rule to forward traffic on any port of the
  /// forwarding rule's protocol.
  core.List<core.String> ports;

  /// [Output Only] URL of the region where the regional forwarding rule
  /// resides. This field is not applicable to global forwarding rules. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// An optional prefix to the service name for this Forwarding Rule. If
  /// specified, the prefix is the first label of the fully qualified service
  /// name.
  ///
  /// The label must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the label must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  ///
  /// This field is only used for internal load balancing.
  core.String serviceLabel;

  /// [Output Only] The internal fully qualified service name for this
  /// Forwarding Rule.
  ///
  /// This field is only used for internal load balancing.
  core.String serviceName;

  /// This field is only used for internal load balancing.
  ///
  /// For internal load balancing, this field identifies the subnetwork that the
  /// load balanced IP should belong to for this Forwarding Rule.
  ///
  /// If the network specified is in auto subnet mode, this field is optional.
  /// However, if the network is in custom subnet mode, a subnetwork must be
  /// specified.
  core.String subnetwork;

  /// The URL of the target resource to receive the matched traffic. For
  /// regional forwarding rules, this target must live in the same region as the
  /// forwarding rule. For global forwarding rules, this target must be a global
  /// load balancing resource. The forwarded traffic must be of a type
  /// appropriate to the target object. For INTERNAL_SELF_MANAGED load
  /// balancing, only targetHttpProxy and targetGrpcProxy are valid, not
  /// targetHttpsProxy.
  core.String target;

  ForwardingRule();

  ForwardingRule.fromJson(core.Map _json) {
    if (_json.containsKey('IPAddress')) {
      IPAddress = _json['IPAddress'] as core.String;
    }
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('allPorts')) {
      allPorts = _json['allPorts'] as core.bool;
    }
    if (_json.containsKey('allowGlobalAccess')) {
      allowGlobalAccess = _json['allowGlobalAccess'] as core.bool;
    }
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipVersion')) {
      ipVersion = _json['ipVersion'] as core.String;
    }
    if (_json.containsKey('isMirroringCollector')) {
      isMirroringCollector = _json['isMirroringCollector'] as core.bool;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('loadBalancingScheme')) {
      loadBalancingScheme = _json['loadBalancingScheme'] as core.String;
    }
    if (_json.containsKey('metadataFilters')) {
      metadataFilters = (_json['metadataFilters'] as core.List)
          .map<MetadataFilter>((value) => MetadataFilter.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('portRange')) {
      portRange = _json['portRange'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serviceLabel')) {
      serviceLabel = _json['serviceLabel'] as core.String;
    }
    if (_json.containsKey('serviceName')) {
      serviceName = _json['serviceName'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (IPAddress != null) {
      _json['IPAddress'] = IPAddress;
    }
    if (IPProtocol != null) {
      _json['IPProtocol'] = IPProtocol;
    }
    if (allPorts != null) {
      _json['allPorts'] = allPorts;
    }
    if (allowGlobalAccess != null) {
      _json['allowGlobalAccess'] = allowGlobalAccess;
    }
    if (backendService != null) {
      _json['backendService'] = backendService;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (ipVersion != null) {
      _json['ipVersion'] = ipVersion;
    }
    if (isMirroringCollector != null) {
      _json['isMirroringCollector'] = isMirroringCollector;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (loadBalancingScheme != null) {
      _json['loadBalancingScheme'] = loadBalancingScheme;
    }
    if (metadataFilters != null) {
      _json['metadataFilters'] =
          metadataFilters.map((value) => value.toJson()).toList();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (networkTier != null) {
      _json['networkTier'] = networkTier;
    }
    if (portRange != null) {
      _json['portRange'] = portRange;
    }
    if (ports != null) {
      _json['ports'] = ports;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (serviceLabel != null) {
      _json['serviceLabel'] = serviceLabel;
    }
    if (serviceName != null) {
      _json['serviceName'] = serviceName;
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    if (target != null) {
      _json['target'] = target;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleAggregatedListWarningData();

  ForwardingRuleAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleAggregatedListWarning();

  ForwardingRuleAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRuleAggregatedListWarningData>((value) =>
              ForwardingRuleAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ForwardingRuleAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRulesScopedList resources.
  core.Map<core.String, ForwardingRulesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#forwardingRuleAggregatedList for lists of forwarding rules.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  ForwardingRuleAggregatedListWarning warning;

  ForwardingRuleAggregatedList();

  ForwardingRuleAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              ForwardingRulesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRuleAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class ForwardingRuleListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRuleListWarningData();

  ForwardingRuleListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ForwardingRuleListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRuleListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRuleListWarning();

  ForwardingRuleListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRuleListWarningData>((value) =>
              ForwardingRuleListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of ForwardingRule resources.
class ForwardingRuleList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ForwardingRule resources.
  core.List<ForwardingRule> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ForwardingRuleListWarning warning;

  ForwardingRuleList();

  ForwardingRuleList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ForwardingRule>((value) => ForwardingRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRuleListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class ForwardingRuleReference {
  core.String forwardingRule;

  ForwardingRuleReference();

  ForwardingRuleReference.fromJson(core.Map _json) {
    if (_json.containsKey('forwardingRule')) {
      forwardingRule = _json['forwardingRule'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (forwardingRule != null) {
      _json['forwardingRule'] = forwardingRule;
    }
    return _json;
  }
}

class ForwardingRulesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ForwardingRulesScopedListWarningData();

  ForwardingRulesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of forwarding rules when the
/// list is empty.
class ForwardingRulesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ForwardingRulesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ForwardingRulesScopedListWarning();

  ForwardingRulesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRulesScopedListWarningData>((value) =>
              ForwardingRulesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ForwardingRulesScopedList {
  /// A list of forwarding rules contained in this scope.
  core.List<ForwardingRule> forwardingRules;

  /// Informational warning which replaces the list of forwarding rules when the
  /// list is empty.
  ForwardingRulesScopedListWarning warning;

  ForwardingRulesScopedList();

  ForwardingRulesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('forwardingRules')) {
      forwardingRules = (_json['forwardingRules'] as core.List)
          .map<ForwardingRule>((value) => ForwardingRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRulesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (forwardingRules != null) {
      _json['forwardingRules'] =
          forwardingRules.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class GRPCHealthCheck {
  /// The gRPC service name for the health check. This field is optional. The
  /// value of grpc_service_name has the following meanings by convention:
  /// - Empty service_name means the overall status of all services at the
  /// backend.
  /// - Non-empty service_name means the health of that gRPC service, as defined
  /// by the owner of the service.
  /// The grpc_service_name can only be ASCII.
  core.String grpcServiceName;

  /// The port number for the health check request. Must be specified if
  /// port_name and port_specification are not set or if port_specification is
  /// USE_FIXED_PORT. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence. The port_name should conform
  /// to RFC1035.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, gRPC health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  GRPCHealthCheck();

  GRPCHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('grpcServiceName')) {
      grpcServiceName = _json['grpcServiceName'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (grpcServiceName != null) {
      _json['grpcServiceName'] = grpcServiceName;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    return _json;
  }
}

class GlobalNetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint> networkEndpoints;

  GlobalNetworkEndpointGroupsAttachEndpointsRequest();

  GlobalNetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkEndpoints != null) {
      _json['networkEndpoints'] =
          networkEndpoints.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class GlobalNetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint> networkEndpoints;

  GlobalNetworkEndpointGroupsDetachEndpointsRequest();

  GlobalNetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkEndpoints != null) {
      _json['networkEndpoints'] =
          networkEndpoints.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash when updating or changing
  /// labels, otherwise the request will fail with error 412 conditionNotMet.
  /// Make a get() request to the resource to get the latest fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of labels to apply for this resource. Each label key & value must
  /// comply with RFC1035. Specifically, the name must be 1-63 characters long
  /// and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
  /// the first character must be a lowercase letter, and all following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash. For example, "webserver-frontend":
  /// "images". A label value can also be empty (e.g. "my-label": "").
  core.Map<core.String, core.String> labels;

  GlobalSetLabelsRequest();

  GlobalSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    return _json;
  }
}

class GlobalSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  GlobalSetPolicyRequest();

  GlobalSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bindings != null) {
      _json['bindings'] = bindings.map((value) => value.toJson()).toList();
    }
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (policy != null) {
      _json['policy'] = policy.toJson();
    }
    return _json;
  }
}

/// A guest attributes entry.
class GuestAttributes {
  /// [Output Only] Type of the resource. Always compute#guestAttributes for
  /// guest attributes entry.
  core.String kind;

  /// The path to be queried. This can be the default namespace ('/') or a
  /// nested namespace ('/\/') or a specified key ('/\/\')
  core.String queryPath;

  /// [Output Only] The value of the requested queried path.
  GuestAttributesValue queryValue;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// The key to search for.
  core.String variableKey;

  /// [Output Only] The value found for the requested key.
  core.String variableValue;

  GuestAttributes();

  GuestAttributes.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('queryPath')) {
      queryPath = _json['queryPath'] as core.String;
    }
    if (_json.containsKey('queryValue')) {
      queryValue = GuestAttributesValue.fromJson(
          _json['queryValue'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('variableKey')) {
      variableKey = _json['variableKey'] as core.String;
    }
    if (_json.containsKey('variableValue')) {
      variableValue = _json['variableValue'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (queryPath != null) {
      _json['queryPath'] = queryPath;
    }
    if (queryValue != null) {
      _json['queryValue'] = queryValue.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (variableKey != null) {
      _json['variableKey'] = variableKey;
    }
    if (variableValue != null) {
      _json['variableValue'] = variableValue;
    }
    return _json;
  }
}

/// A guest attributes namespace/key/value entry.
class GuestAttributesEntry {
  /// Key for the guest attribute entry.
  core.String key;

  /// Namespace for the guest attribute entry.
  core.String namespace;

  /// Value for the guest attribute entry.
  core.String value;

  GuestAttributesEntry();

  GuestAttributesEntry.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('namespace')) {
      namespace = _json['namespace'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (namespace != null) {
      _json['namespace'] = namespace;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Array of guest attribute namespace/key/value tuples.
class GuestAttributesValue {
  core.List<GuestAttributesEntry> items;

  GuestAttributesValue();

  GuestAttributesValue.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<GuestAttributesEntry>((value) => GuestAttributesEntry.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// Guest OS features.
class GuestOsFeature {
  /// The ID of a supported feature. Read  Enabling guest operating system
  /// features to see a list of available options.
  /// Possible string values are:
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "MULTI_IP_SUBNET"
  /// - "SECURE_BOOT"
  /// - "SEV_CAPABLE"
  /// - "UEFI_COMPATIBLE"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String type;

  GuestOsFeature();

  GuestOsFeature.fromJson(core.Map _json) {
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class HTTP2HealthCheck {
  /// The value of the host header in the HTTP/2 health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTP2 health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTP/2 health check request. The default value is
  /// /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTP2HealthCheck();

  HTTP2HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (host != null) {
      _json['host'] = host;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (requestPath != null) {
      _json['requestPath'] = requestPath;
    }
    if (response != null) {
      _json['response'] = response;
    }
    return _json;
  }
}

class HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTP health check request. The default value is /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTPHealthCheck();

  HTTPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (host != null) {
      _json['host'] = host;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (requestPath != null) {
      _json['requestPath'] = requestPath;
    }
    if (response != null) {
      _json['response'] = response;
    }
    return _json;
  }
}

class HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the IP on behalf of which this health check is
  /// performed will be used.
  core.String host;

  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, HTTPS health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The request path of the HTTPS health check request. The default value is
  /// /.
  core.String requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String response;

  HTTPSHealthCheck();

  HTTPSHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (host != null) {
      _json['host'] = host;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (requestPath != null) {
      _json['requestPath'] = requestPath;
    }
    if (response != null) {
      _json['response'] = response;
    }
    return _json;
  }
}

/// Represents a Health Check resource.
///
/// Google Compute Engine has two Health Check resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/healthChecks) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionHealthChecks)
///
/// Internal HTTP(S) load balancers must use regional health checks. Internal
/// TCP/UDP load balancers can use either regional or global health checks. All
/// other types of GCP load balancers and managed instance group auto-healing
/// must use global health checks. For more information, read Health Check
/// Concepts.
///
/// To perform health checks on network load balancers, you must use either
/// httpHealthChecks or httpsHealthChecks.
class HealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in 3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;
  GRPCHealthCheck grpcHealthCheck;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;
  HTTP2HealthCheck http2HealthCheck;
  HTTPHealthCheck httpHealthCheck;
  HTTPSHealthCheck httpsHealthCheck;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Region where the health check resides. Not applicable to
  /// global health checks.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;
  SSLHealthCheck sslHealthCheck;
  TCPHealthCheck tcpHealthCheck;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or
  /// HTTP2. If not specified, the default is TCP. Exactly one of the
  /// protocol-specific health check field must be specified, which must match
  /// type field.
  /// Possible string values are:
  /// - "GRPC"
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "INVALID"
  /// - "SSL"
  /// - "TCP"
  core.String type;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HealthCheck();

  HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('grpcHealthCheck')) {
      grpcHealthCheck = GRPCHealthCheck.fromJson(
          _json['grpcHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('http2HealthCheck')) {
      http2HealthCheck = HTTP2HealthCheck.fromJson(
          _json['http2HealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpHealthCheck')) {
      httpHealthCheck = HTTPHealthCheck.fromJson(
          _json['httpHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpsHealthCheck')) {
      httpsHealthCheck = HTTPSHealthCheck.fromJson(
          _json['httpsHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sslHealthCheck')) {
      sslHealthCheck = SSLHealthCheck.fromJson(
          _json['sslHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tcpHealthCheck')) {
      tcpHealthCheck = TCPHealthCheck.fromJson(
          _json['tcpHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (checkIntervalSec != null) {
      _json['checkIntervalSec'] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (grpcHealthCheck != null) {
      _json['grpcHealthCheck'] = grpcHealthCheck.toJson();
    }
    if (healthyThreshold != null) {
      _json['healthyThreshold'] = healthyThreshold;
    }
    if (http2HealthCheck != null) {
      _json['http2HealthCheck'] = http2HealthCheck.toJson();
    }
    if (httpHealthCheck != null) {
      _json['httpHealthCheck'] = httpHealthCheck.toJson();
    }
    if (httpsHealthCheck != null) {
      _json['httpsHealthCheck'] = httpsHealthCheck.toJson();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sslHealthCheck != null) {
      _json['sslHealthCheck'] = sslHealthCheck.toJson();
    }
    if (tcpHealthCheck != null) {
      _json['tcpHealthCheck'] = tcpHealthCheck.toJson();
    }
    if (timeoutSec != null) {
      _json['timeoutSec'] = timeoutSec;
    }
    if (type != null) {
      _json['type'] = type;
    }
    if (unhealthyThreshold != null) {
      _json['unhealthyThreshold'] = unhealthyThreshold;
    }
    return _json;
  }
}

class HealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthCheckListWarningData();

  HealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthCheckListWarning();

  HealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthCheckListWarningData>((value) =>
              HealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of HealthCheck resources.
class HealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthCheck resources.
  core.List<HealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HealthCheckListWarning warning;

  HealthCheckList();

  HealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HealthCheck>((value) => HealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A full or valid partial URL to a health check. For example, the following
/// are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
/// - projects/project-id/global/httpHealthChecks/health-check
/// - global/httpHealthChecks/health-check
class HealthCheckReference {
  core.String healthCheck;

  HealthCheckReference();

  HealthCheckReference.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthCheck != null) {
      _json['healthCheck'] = healthCheck;
    }
    return _json;
  }
}

/// Represents a Health-Check as a Service resource.
///
/// (== resource_for {$api_version}.regionHealthCheckServices ==)
class HealthCheckService {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a HealthCheckService. An up-to-date fingerprint
  /// must be provided in order to patch/update the HealthCheckService;
  /// Otherwise, the request will fail with error 412 conditionNotMet. To see
  /// the latest fingerprint, make a get() request to retrieve the
  /// HealthCheckService.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// List of URLs to the HealthCheck resources. Must have at least one
  /// HealthCheck, and not more than 10. HealthCheck resources must have
  /// portSpecification=USE_SERVING_PORT. For regional HealthCheckService, the
  /// HealthCheck must be regional and in the same region. For global
  /// HealthCheckService, HealthCheck must be global. Mix of regional and global
  /// HealthChecks is not supported. Multiple regional HealthChecks must belong
  /// to the same region. Regional HealthChecks</code? must belong to the same
  /// region as zones of NEGs.
  core.List<core.String> healthChecks;

  /// Optional. Policy for how the results from multiple health checks for the
  /// same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified.
  /// - NO_AGGREGATION. An EndpointHealth message is returned for each backend
  /// in the health check service.
  /// - AND. If any backend's health check reports UNHEALTHY, then UNHEALTHY is
  /// the HealthState of the entire health check service. If all backend's are
  /// healthy, the HealthState of the health check service is HEALTHY. .
  /// Possible string values are:
  /// - "AND"
  /// - "NO_AGGREGATION"
  core.String healthStatusAggregationPolicy;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output only] Type of the resource. Always compute#healthCheckServicefor
  /// health check services.
  core.String kind;

  /// Name of the resource. The name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// List of URLs to the NetworkEndpointGroup resources. Must not have more
  /// than 100. For regional HealthCheckService, NEGs must be in zones in the
  /// region of the HealthCheckService.
  core.List<core.String> networkEndpointGroups;

  /// List of URLs to the NotificationEndpoint resources. Must not have more
  /// than 10. A list of endpoints for receiving notifications of change in
  /// health status. For regional HealthCheckService, NotificationEndpoint must
  /// be regional and in the same region. For global HealthCheckService,
  /// NotificationEndpoint must be global.
  core.List<core.String> notificationEndpoints;

  /// [Output Only] URL of the region where the health check service resides.
  /// This field is not applicable to global health check services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  HealthCheckService();

  HealthCheckService.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('healthStatusAggregationPolicy')) {
      healthStatusAggregationPolicy =
          _json['healthStatusAggregationPolicy'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkEndpointGroups')) {
      networkEndpointGroups = (_json['networkEndpointGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('notificationEndpoints')) {
      notificationEndpoints = (_json['notificationEndpoints'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (healthChecks != null) {
      _json['healthChecks'] = healthChecks;
    }
    if (healthStatusAggregationPolicy != null) {
      _json['healthStatusAggregationPolicy'] = healthStatusAggregationPolicy;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (networkEndpointGroups != null) {
      _json['networkEndpointGroups'] = networkEndpointGroups;
    }
    if (notificationEndpoints != null) {
      _json['notificationEndpoints'] = notificationEndpoints;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// A full or valid partial URL to a health check service. For example, the
/// following are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// -
/// projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// - regions/us-west1/healthCheckServices/health-check-service
class HealthCheckServiceReference {
  core.String healthCheckService;

  HealthCheckServiceReference();

  HealthCheckServiceReference.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheckService')) {
      healthCheckService = _json['healthCheckService'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthCheckService != null) {
      _json['healthCheckService'] = healthCheckService;
    }
    return _json;
  }
}

class HealthCheckServicesListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthCheckServicesListWarningData();

  HealthCheckServicesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthCheckServicesListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthCheckServicesListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthCheckServicesListWarning();

  HealthCheckServicesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthCheckServicesListWarningData>((value) =>
              HealthCheckServicesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class HealthCheckServicesList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthCheckService resources.
  core.List<HealthCheckService> items;

  /// [Output Only] Type of the resource. Always compute#healthCheckServicesList
  /// for lists of HealthCheckServices.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HealthCheckServicesListWarning warning;

  HealthCheckServicesList();

  HealthCheckServicesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HealthCheckService>((value) => HealthCheckService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HealthCheckServicesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class HealthChecksAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthChecksAggregatedListWarningData();

  HealthChecksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HealthChecksAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthChecksAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthChecksAggregatedListWarning();

  HealthChecksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthChecksAggregatedListWarningData>((value) =>
              HealthChecksAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class HealthChecksAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HealthChecksScopedList resources.
  core.Map<core.String, HealthChecksScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  HealthChecksAggregatedListWarning warning;

  HealthChecksAggregatedList();

  HealthChecksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              HealthChecksScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = HealthChecksAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class HealthChecksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HealthChecksScopedListWarningData();

  HealthChecksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class HealthChecksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HealthChecksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HealthChecksScopedListWarning();

  HealthChecksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthChecksScopedListWarningData>((value) =>
              HealthChecksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class HealthChecksScopedList {
  /// A list of HealthChecks contained in this scope.
  core.List<HealthCheck> healthChecks;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  HealthChecksScopedListWarning warning;

  HealthChecksScopedList();

  HealthChecksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheck>((value) => HealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = HealthChecksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthChecks != null) {
      _json['healthChecks'] =
          healthChecks.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class HealthStatus {
  /// Metadata defined as annotations for network endpoint.
  core.Map<core.String, core.String> annotations;

  /// Health state of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String healthState;

  /// URL of the instance resource.
  core.String instance;

  /// A forwarding rule IP address assigned to this instance.
  core.String ipAddress;

  /// The named port of the instance group, not necessarily the port that is
  /// health-checked.
  core.int port;

  HealthStatus();

  HealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations = (_json['annotations'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('healthState')) {
      healthState = _json['healthState'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (annotations != null) {
      _json['annotations'] = annotations;
    }
    if (healthState != null) {
      _json['healthState'] = healthState;
    }
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    if (port != null) {
      _json['port'] = port;
    }
    return _json;
  }
}

class HealthStatusForNetworkEndpoint {
  /// URL of the backend service associated with the health state of the network
  /// endpoint.
  BackendServiceReference backendService;

  /// URL of the forwarding rule associated with the health state of the network
  /// endpoint.
  ForwardingRuleReference forwardingRule;

  /// URL of the health check associated with the health state of the network
  /// endpoint.
  HealthCheckReference healthCheck;

  /// URL of the health check service associated with the health state of the
  /// network endpoint.
  HealthCheckServiceReference healthCheckService;

  /// Health state of the network endpoint determined based on the health checks
  /// configured.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String healthState;

  HealthStatusForNetworkEndpoint();

  HealthStatusForNetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = BackendServiceReference.fromJson(
          _json['backendService'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('forwardingRule')) {
      forwardingRule = ForwardingRuleReference.fromJson(
          _json['forwardingRule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthCheck')) {
      healthCheck = HealthCheckReference.fromJson(
          _json['healthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthCheckService')) {
      healthCheckService = HealthCheckServiceReference.fromJson(
          _json['healthCheckService'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthState')) {
      healthState = _json['healthState'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backendService != null) {
      _json['backendService'] = backendService.toJson();
    }
    if (forwardingRule != null) {
      _json['forwardingRule'] = forwardingRule.toJson();
    }
    if (healthCheck != null) {
      _json['healthCheck'] = healthCheck.toJson();
    }
    if (healthCheckService != null) {
      _json['healthCheckService'] = healthCheckService.toJson();
    }
    if (healthState != null) {
      _json['healthState'] = healthState;
    }
    return _json;
  }
}

/// UrlMaps A host-matching rule for a URL. If matched, will use the named
/// PathMatcher to select the BackendService.
class HostRule {
  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// The list of host patterns to match. They must be valid hostnames with
  /// optional port numbers in the format host:port. * matches any string of
  /// ([a-z0-9-.]*). In that case, * must be the first character and must be
  /// followed in the pattern by either - or ..
  /// * based matching is not supported when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  core.List<core.String> hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String pathMatcher;

  HostRule();

  HostRule.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('hosts')) {
      hosts = (_json['hosts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('pathMatcher')) {
      pathMatcher = _json['pathMatcher'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (hosts != null) {
      _json['hosts'] = hosts;
    }
    if (pathMatcher != null) {
      _json['pathMatcher'] = pathMatcher;
    }
    return _json;
  }
}

/// Specification for how requests are aborted as part of fault injection.
class HttpFaultAbort {
  /// The HTTP status code used to abort the request.
  /// The value must be between 200 and 599 inclusive.
  core.int httpStatus;

  /// The percentage of traffic (connections/operations/requests) which will be
  /// aborted as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double percentage;

  HttpFaultAbort();

  HttpFaultAbort.fromJson(core.Map _json) {
    if (_json.containsKey('httpStatus')) {
      httpStatus = _json['httpStatus'] as core.int;
    }
    if (_json.containsKey('percentage')) {
      percentage = (_json['percentage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (httpStatus != null) {
      _json['httpStatus'] = httpStatus;
    }
    if (percentage != null) {
      _json['percentage'] = percentage;
    }
    return _json;
  }
}

/// Specifies the delay introduced by Loadbalancer before forwarding the request
/// to the backend service as part of fault injection.
class HttpFaultDelay {
  /// Specifies the value of the fixed delay interval.
  Duration fixedDelay;

  /// The percentage of traffic (connections/operations/requests) on which delay
  /// will be introduced as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double percentage;

  HttpFaultDelay();

  HttpFaultDelay.fromJson(core.Map _json) {
    if (_json.containsKey('fixedDelay')) {
      fixedDelay = Duration.fromJson(
          _json['fixedDelay'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('percentage')) {
      percentage = (_json['percentage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fixedDelay != null) {
      _json['fixedDelay'] = fixedDelay.toJson();
    }
    if (percentage != null) {
      _json['percentage'] = percentage;
    }
    return _json;
  }
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure. As part of fault
/// injection, when clients send requests to a backend service, delays can be
/// introduced by Loadbalancer on a percentage of requests before sending those
/// request to the backend service. Similarly requests from clients can be
/// aborted by the Loadbalancer for a percentage of requests.
class HttpFaultInjection {
  /// The specification for how client requests are aborted as part of fault
  /// injection.
  HttpFaultAbort abort;

  /// The specification for how client requests are delayed as part of fault
  /// injection, before being sent to a backend service.
  HttpFaultDelay delay;

  HttpFaultInjection();

  HttpFaultInjection.fromJson(core.Map _json) {
    if (_json.containsKey('abort')) {
      abort = HttpFaultAbort.fromJson(
          _json['abort'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('delay')) {
      delay = HttpFaultDelay.fromJson(
          _json['delay'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (abort != null) {
      _json['abort'] = abort.toJson();
    }
    if (delay != null) {
      _json['delay'] = delay.toJson();
    }
    return _json;
  }
}

/// The request and response header transformations that take effect before the
/// request is passed along to the selected backendService.
class HttpHeaderAction {
  /// Headers to add to a matching request prior to forwarding the request to
  /// the backendService.
  core.List<HttpHeaderOption> requestHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// request prior to forwarding the request to the backendService.
  core.List<core.String> requestHeadersToRemove;

  /// Headers to add the response prior to sending the response back to the
  /// client.
  core.List<HttpHeaderOption> responseHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// response prior to sending the response back to the client.
  core.List<core.String> responseHeadersToRemove;

  HttpHeaderAction();

  HttpHeaderAction.fromJson(core.Map _json) {
    if (_json.containsKey('requestHeadersToAdd')) {
      requestHeadersToAdd = (_json['requestHeadersToAdd'] as core.List)
          .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('requestHeadersToRemove')) {
      requestHeadersToRemove = (_json['requestHeadersToRemove'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('responseHeadersToAdd')) {
      responseHeadersToAdd = (_json['responseHeadersToAdd'] as core.List)
          .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('responseHeadersToRemove')) {
      responseHeadersToRemove = (_json['responseHeadersToRemove'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (requestHeadersToAdd != null) {
      _json['requestHeadersToAdd'] =
          requestHeadersToAdd.map((value) => value.toJson()).toList();
    }
    if (requestHeadersToRemove != null) {
      _json['requestHeadersToRemove'] = requestHeadersToRemove;
    }
    if (responseHeadersToAdd != null) {
      _json['responseHeadersToAdd'] =
          responseHeadersToAdd.map((value) => value.toJson()).toList();
    }
    if (responseHeadersToRemove != null) {
      _json['responseHeadersToRemove'] = responseHeadersToRemove;
    }
    return _json;
  }
}

/// matchRule criteria for request header matches.
class HttpHeaderMatch {
  /// The value should exactly match contents of exactMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String exactMatch;

  /// The name of the HTTP header to match.
  /// For matching against the HTTP request's authority, use a headerMatch with
  /// the header name ":authority".
  /// For matching a request's method, use the headerName ":method".
  /// When the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true, only non-binary user-specified
  /// custom metadata and the `content-type` header are supported. The following
  /// transport-level headers cannot be used in header matching rules:
  /// `:authority`, `:method`, `:path`, `:scheme`, `user-agent`,
  /// `accept-encoding`, `content-encoding`, `grpc-accept-encoding`,
  /// `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`,
  /// `grpc-timeout` and `grpc-trace-bin.
  core.String headerName;

  /// If set to false, the headerMatch is considered a match if the match
  /// criteria above are met. If set to true, the headerMatch is considered a
  /// match if the match criteria above are NOT met.
  /// The default setting is false.
  core.bool invertMatch;

  /// The value of the header must start with the contents of prefixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String prefixMatch;

  /// A header with the contents of headerName must exist. The match takes place
  /// whether or not the request's header has a value.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.bool presentMatch;

  /// The header value must be an integer and its value must be in the range
  /// specified in rangeMatch. If the header does not contain an integer, number
  /// or is empty, the match fails.
  /// For example for a range [-5, 0]
  /// - -3 will match.
  /// - 0 will not match.
  /// - 0.25 will not match.
  /// - -3someString will not match.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that rangeMatch is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  Int64RangeMatch rangeMatch;

  /// The value of the header must match the regular expression specified in
  /// regexMatch. For regular expression grammar, please see:
  /// en.cppreference.com/w/cpp/regex/ecmascript
  /// For matching against a port specified in the HTTP request, use a
  /// headerMatch with headerName set to PORT and a regular expression that
  /// satisfies the RFC2616 Host header's port specifier.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  /// The value of the header must end with the contents of suffixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String suffixMatch;

  HttpHeaderMatch();

  HttpHeaderMatch.fromJson(core.Map _json) {
    if (_json.containsKey('exactMatch')) {
      exactMatch = _json['exactMatch'] as core.String;
    }
    if (_json.containsKey('headerName')) {
      headerName = _json['headerName'] as core.String;
    }
    if (_json.containsKey('invertMatch')) {
      invertMatch = _json['invertMatch'] as core.bool;
    }
    if (_json.containsKey('prefixMatch')) {
      prefixMatch = _json['prefixMatch'] as core.String;
    }
    if (_json.containsKey('presentMatch')) {
      presentMatch = _json['presentMatch'] as core.bool;
    }
    if (_json.containsKey('rangeMatch')) {
      rangeMatch = Int64RangeMatch.fromJson(
          _json['rangeMatch'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
    if (_json.containsKey('suffixMatch')) {
      suffixMatch = _json['suffixMatch'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (exactMatch != null) {
      _json['exactMatch'] = exactMatch;
    }
    if (headerName != null) {
      _json['headerName'] = headerName;
    }
    if (invertMatch != null) {
      _json['invertMatch'] = invertMatch;
    }
    if (prefixMatch != null) {
      _json['prefixMatch'] = prefixMatch;
    }
    if (presentMatch != null) {
      _json['presentMatch'] = presentMatch;
    }
    if (rangeMatch != null) {
      _json['rangeMatch'] = rangeMatch.toJson();
    }
    if (regexMatch != null) {
      _json['regexMatch'] = regexMatch;
    }
    if (suffixMatch != null) {
      _json['suffixMatch'] = suffixMatch;
    }
    return _json;
  }
}

/// Specification determining how headers are added to requests or responses.
class HttpHeaderOption {
  /// The name of the header.
  core.String headerName;

  /// The value of the header to add.
  core.String headerValue;

  /// If false, headerValue is appended to any values that already exist for the
  /// header. If true, headerValue is set for the header, discarding any values
  /// that were set for that header.
  /// The default value is false.
  core.bool replace;

  HttpHeaderOption();

  HttpHeaderOption.fromJson(core.Map _json) {
    if (_json.containsKey('headerName')) {
      headerName = _json['headerName'] as core.String;
    }
    if (_json.containsKey('headerValue')) {
      headerValue = _json['headerValue'] as core.String;
    }
    if (_json.containsKey('replace')) {
      replace = _json['replace'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (headerName != null) {
      _json['headerName'] = headerName;
    }
    if (headerValue != null) {
      _json['headerValue'] = headerValue;
    }
    if (replace != null) {
      _json['replace'] = replace;
    }
    return _json;
  }
}

/// Represents a legacy HTTP Health Check resource.
///
/// Legacy health checks are required by network load balancers. For more
/// information, read Health Check Concepts.
class HttpHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTP health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#httpHealthCheck for
  /// HTTP health checks.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTP health check request. The default value
  /// is 80.
  core.int port;

  /// The request path of the HTTP health check request. The default value is /.
  /// This field does not support query parameters.
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpHealthCheck();

  HttpHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (checkIntervalSec != null) {
      _json['checkIntervalSec'] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (healthyThreshold != null) {
      _json['healthyThreshold'] = healthyThreshold;
    }
    if (host != null) {
      _json['host'] = host;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (requestPath != null) {
      _json['requestPath'] = requestPath;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (timeoutSec != null) {
      _json['timeoutSec'] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json['unhealthyThreshold'] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpHealthCheckListWarningData();

  HttpHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpHealthCheckListWarning();

  HttpHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HttpHealthCheckListWarningData>((value) =>
              HttpHealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpHealthCheck resources.
class HttpHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpHealthCheck resources.
  core.List<HttpHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpHealthCheckListWarning warning;

  HttpHealthCheckList();

  HttpHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HttpHealthCheck>((value) => HttpHealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HttpHealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch criteria for a request's query parameter.
class HttpQueryParameterMatch {
  /// The queryParameterMatch matches if the value of the parameter exactly
  /// matches the contents of exactMatch.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.String exactMatch;

  /// The name of the query parameter to match. The query parameter must exist
  /// in the request, in the absence of which the request match fails.
  core.String name;

  /// Specifies that the queryParameterMatch matches if the request contains the
  /// query parameter, irrespective of whether the parameter has a value or not.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.bool presentMatch;

  /// The queryParameterMatch matches if the value of the parameter matches the
  /// regular expression specified by regexMatch. For the regular expression
  /// grammar, please see en.cppreference.com/w/cpp/regex/ecmascript
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  /// Note that regexMatch only applies when the loadBalancingScheme is set to
  /// INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  HttpQueryParameterMatch();

  HttpQueryParameterMatch.fromJson(core.Map _json) {
    if (_json.containsKey('exactMatch')) {
      exactMatch = _json['exactMatch'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('presentMatch')) {
      presentMatch = _json['presentMatch'] as core.bool;
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (exactMatch != null) {
      _json['exactMatch'] = exactMatch;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (presentMatch != null) {
      _json['presentMatch'] = presentMatch;
    }
    if (regexMatch != null) {
      _json['regexMatch'] = regexMatch;
    }
    return _json;
  }
}

/// Specifies settings for an HTTP redirect.
class HttpRedirectAction {
  /// The host that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// The value must be between 1 and 255 characters.
  core.String hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to https.
  /// If set to false, the URL scheme of the redirected request will remain the
  /// same as that of the request.
  /// This must only be set for UrlMaps used in TargetHttpProxys. Setting this
  /// true for TargetHttpsProxy is not permitted.
  /// The default is set to false.
  core.bool httpsRedirect;

  /// The path that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// pathRedirect cannot be supplied together with prefixRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String pathRedirect;

  /// The prefix that replaces the prefixMatch specified in the
  /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
  /// redirecting the request.
  /// prefixRedirect cannot be supplied together with pathRedirect. Supply one
  /// alone or neither. If neither is supplied, the path of the original request
  /// will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String prefixRedirect;

  /// The HTTP Status code to use for this RedirectAction.
  /// Supported values are:
  /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
  /// 301.
  /// - FOUND, which corresponds to 302.
  /// - SEE_OTHER which corresponds to 303.
  /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request
  /// method will be retained.
  /// - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request
  /// method will be retained.
  /// Possible string values are:
  /// - "FOUND"
  /// - "MOVED_PERMANENTLY_DEFAULT"
  /// - "PERMANENT_REDIRECT"
  /// - "SEE_OTHER"
  /// - "TEMPORARY_REDIRECT"
  core.String redirectResponseCode;

  /// If set to true, any accompanying query portion of the original URL is
  /// removed prior to redirecting the request. If set to false, the query
  /// portion of the original URL is retained.
  /// The default is set to false.
  core.bool stripQuery;

  HttpRedirectAction();

  HttpRedirectAction.fromJson(core.Map _json) {
    if (_json.containsKey('hostRedirect')) {
      hostRedirect = _json['hostRedirect'] as core.String;
    }
    if (_json.containsKey('httpsRedirect')) {
      httpsRedirect = _json['httpsRedirect'] as core.bool;
    }
    if (_json.containsKey('pathRedirect')) {
      pathRedirect = _json['pathRedirect'] as core.String;
    }
    if (_json.containsKey('prefixRedirect')) {
      prefixRedirect = _json['prefixRedirect'] as core.String;
    }
    if (_json.containsKey('redirectResponseCode')) {
      redirectResponseCode = _json['redirectResponseCode'] as core.String;
    }
    if (_json.containsKey('stripQuery')) {
      stripQuery = _json['stripQuery'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (hostRedirect != null) {
      _json['hostRedirect'] = hostRedirect;
    }
    if (httpsRedirect != null) {
      _json['httpsRedirect'] = httpsRedirect;
    }
    if (pathRedirect != null) {
      _json['pathRedirect'] = pathRedirect;
    }
    if (prefixRedirect != null) {
      _json['prefixRedirect'] = prefixRedirect;
    }
    if (redirectResponseCode != null) {
      _json['redirectResponseCode'] = redirectResponseCode;
    }
    if (stripQuery != null) {
      _json['stripQuery'] = stripQuery;
    }
    return _json;
  }
}

/// The retry policy associates with HttpRouteRule
class HttpRetryPolicy {
  /// Specifies the allowed number retries. This number must be > 0. If not
  /// specified, defaults to 1.
  core.int numRetries;

  /// Specifies a non-zero timeout per retry attempt.
  /// If not specified, will use the timeout set in HttpRouteAction. If timeout
  /// in HttpRouteAction is not set, will use the largest timeout among all
  /// backend services associated with the route.
  Duration perTryTimeout;

  /// Specfies one or more conditions when this retry rule applies. Valid values
  /// are:
  /// - 5xx: Loadbalancer will attempt a retry if the backend service responds
  /// with any 5xx response code, or if the backend service does not respond at
  /// all, example: disconnects, reset, read timeout, connection failure, and
  /// refused streams.
  /// - gateway-error: Similar to 5xx, but only applies to response codes 502,
  /// 503 or 504.
  /// -
  /// - connect-failure: Loadbalancer will retry on failures connecting to
  /// backend services, for example due to connection timeouts.
  /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
  /// Currently the only retriable error supported is 409.
  /// - refused-stream:Loadbalancer will retry if the backend service resets the
  /// stream with a REFUSED_STREAM error code. This reset type indicates that it
  /// is safe to retry.
  /// - cancelledLoadbalancer will retry if the gRPC status code in the response
  /// header is set to cancelled
  /// - deadline-exceeded: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to deadline-exceeded
  /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to resource-exhausted
  /// - unavailable: Loadbalancer will retry if the gRPC status code in the
  /// response header is set to unavailable
  core.List<core.String> retryConditions;

  HttpRetryPolicy();

  HttpRetryPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('numRetries')) {
      numRetries = _json['numRetries'] as core.int;
    }
    if (_json.containsKey('perTryTimeout')) {
      perTryTimeout = Duration.fromJson(
          _json['perTryTimeout'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryConditions')) {
      retryConditions = (_json['retryConditions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (numRetries != null) {
      _json['numRetries'] = numRetries;
    }
    if (perTryTimeout != null) {
      _json['perTryTimeout'] = perTryTimeout.toJson();
    }
    if (retryConditions != null) {
      _json['retryConditions'] = retryConditions;
    }
    return _json;
  }
}

class HttpRouteAction {
  /// The specification for allowing client side cross-origin requests. Please
  /// see W3C Recommendation for Cross Origin Resource Sharing
  /// Not supported when the URL map is bound to target gRPC proxy.
  CorsPolicy corsPolicy;

  /// The specification for fault injection introduced into traffic to test the
  /// resiliency of clients to backend service failure. As part of fault
  /// injection, when clients send requests to a backend service, delays can be
  /// introduced by Loadbalancer on a percentage of requests before sending
  /// those request to the backend service. Similarly requests from clients can
  /// be aborted by the Loadbalancer for a percentage of requests.
  /// timeout and retry_policy will be ignored by clients that are configured
  /// with a fault_injection_policy.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpFaultInjection faultInjectionPolicy;

  /// Specifies the policy on how requests intended for the route's backends are
  /// shadowed to a separate mirrored backend service. Loadbalancer does not
  /// wait for responses from the shadow service. Prior to sending traffic to
  /// the shadow service, the host / authority header is suffixed with -shadow.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  RequestMirrorPolicy requestMirrorPolicy;

  /// Specifies the retry policy associated with this route.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpRetryPolicy retryPolicy;

  /// Specifies the timeout for the selected route. Timeout is computed from the
  /// time the request has been fully processed (i.e. end-of-stream) up until
  /// the response has been completely processed. Timeout includes all retries.
  /// If not specified, will use the largest timeout among all backend services
  /// associated with the route.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  Duration timeout;

  /// The spec to modify the URL of the request, prior to forwarding the request
  /// to the matched service.
  /// urlRewrite is the only action supported in UrlMaps for external HTTP(S)
  /// load balancers.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  UrlRewrite urlRewrite;

  /// A list of weighted backend services to send traffic to when a route match
  /// occurs. The weights determine the fraction of traffic that flows to their
  /// corresponding backend service. If all traffic needs to go to a single
  /// backend service, there must be one  weightedBackendService with weight set
  /// to a non-zero number.
  /// Once a backendService is identified and before forwarding the request to
  /// the backend service, advanced routing actions such as URL rewrites and
  /// header transformations are applied depending on additional settings
  /// specified in this HttpRouteAction.
  core.List<WeightedBackendService> weightedBackendServices;

  HttpRouteAction();

  HttpRouteAction.fromJson(core.Map _json) {
    if (_json.containsKey('corsPolicy')) {
      corsPolicy = CorsPolicy.fromJson(
          _json['corsPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('faultInjectionPolicy')) {
      faultInjectionPolicy = HttpFaultInjection.fromJson(
          _json['faultInjectionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('requestMirrorPolicy')) {
      requestMirrorPolicy = RequestMirrorPolicy.fromJson(
          _json['requestMirrorPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryPolicy')) {
      retryPolicy = HttpRetryPolicy.fromJson(
          _json['retryPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeout')) {
      timeout = Duration.fromJson(
          _json['timeout'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('urlRewrite')) {
      urlRewrite = UrlRewrite.fromJson(
          _json['urlRewrite'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weightedBackendServices')) {
      weightedBackendServices = (_json['weightedBackendServices'] as core.List)
          .map<WeightedBackendService>((value) =>
              WeightedBackendService.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (corsPolicy != null) {
      _json['corsPolicy'] = corsPolicy.toJson();
    }
    if (faultInjectionPolicy != null) {
      _json['faultInjectionPolicy'] = faultInjectionPolicy.toJson();
    }
    if (requestMirrorPolicy != null) {
      _json['requestMirrorPolicy'] = requestMirrorPolicy.toJson();
    }
    if (retryPolicy != null) {
      _json['retryPolicy'] = retryPolicy.toJson();
    }
    if (timeout != null) {
      _json['timeout'] = timeout.toJson();
    }
    if (urlRewrite != null) {
      _json['urlRewrite'] = urlRewrite.toJson();
    }
    if (weightedBackendServices != null) {
      _json['weightedBackendServices'] =
          weightedBackendServices.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// An HttpRouteRule specifies how to match an HTTP request and the
/// corresponding routing action that load balancing proxies will perform.
class HttpRouteRule {
  /// The short description conveying the intent of this routeRule.
  /// The description can have a maximum length of 1024 characters.
  core.String description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here are applied before the matching
  /// pathMatchers[].headerAction and after
  /// pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction headerAction;

  /// The list of criteria for matching attributes of a request to this
  /// routeRule. This list has OR semantics: the request matches this routeRule
  /// when any of the matchRules are satisfied. However predicates within a
  /// given matchRule have AND semantics. All predicates within a matchRule must
  /// match for the request to match the rule.
  core.List<HttpRouteRuleMatch> matchRules;

  /// For routeRules within a given pathMatcher, priority determines the order
  /// in which load balancer will interpret routeRules. RouteRules are evaluated
  /// in order of priority, from the lowest to highest number. The priority of a
  /// rule decreases as its number increases (1, 2, 3, N+1). The first rule that
  /// matches the request is applied.
  /// You cannot configure two or more routeRules with the same priority.
  /// Priority for each rule must be set to a number between 0 and 2147483647
  /// inclusive.
  /// Priority numbers can have gaps, which enable you to add or remove rules in
  /// the future without affecting the rest of the rules. For example, 1, 2, 3,
  /// 4, 5, 9, 12, 16 is a valid series of priority numbers to which you could
  /// add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future
  /// without any impact on existing rules.
  core.int priority;

  /// In response to a matching matchRule, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc. prior to
  /// forwarding the request to the selected backend. If  routeAction specifies
  /// any  weightedBackendServices, service must not be set. Conversely if
  /// service is set, routeAction cannot contain any  weightedBackendServices.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a routeRule's routeAction.
  HttpRouteAction routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched. If routeAction is additionally
  /// specified, advanced routing actions like URL Rewrites, etc. take effect
  /// prior to sending the request to the backend. However, if service is
  /// specified, routeAction cannot contain any weightedBackendService s.
  /// Conversely, if routeAction specifies any  weightedBackendServices, service
  /// must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String service;

  /// When this rule is matched, the request is redirected to a URL specified by
  /// urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction urlRedirect;

  HttpRouteRule();

  HttpRouteRule.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('matchRules')) {
      matchRules = (_json['matchRules'] as core.List)
          .map<HttpRouteRuleMatch>((value) => HttpRouteRuleMatch.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('routeAction')) {
      routeAction = HttpRouteAction.fromJson(
          _json['routeAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlRedirect')) {
      urlRedirect = HttpRedirectAction.fromJson(
          _json['urlRedirect'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (headerAction != null) {
      _json['headerAction'] = headerAction.toJson();
    }
    if (matchRules != null) {
      _json['matchRules'] = matchRules.map((value) => value.toJson()).toList();
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    if (routeAction != null) {
      _json['routeAction'] = routeAction.toJson();
    }
    if (service != null) {
      _json['service'] = service;
    }
    if (urlRedirect != null) {
      _json['urlRedirect'] = urlRedirect.toJson();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
/// HttpRouteRule. All specified criteria must be satisfied for a match to
/// occur.
class HttpRouteRuleMatch {
  /// For satisfying the matchRule condition, the path of the request must
  /// exactly match the value specified in fullPathMatch after removing any
  /// query parameters and anchor that may be part of the original URL.
  /// fullPathMatch must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String fullPathMatch;

  /// Specifies a list of header match criteria, all of which must match
  /// corresponding headers in the request.
  core.List<HttpHeaderMatch> headerMatches;

  /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  /// The default value is false.
  /// ignoreCase must not be used with regexMatch.
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.bool ignoreCase;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients. In their xDS
  /// requests to Loadbalancer, xDS clients present node metadata. When there is
  /// a match, the relevant routing configuration is made available to those
  /// proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata. If multiple metadataFilters are
  /// specified, all of them need to be satisfied in order to be considered a
  /// match.
  /// metadataFilters specified here will be applied after those specified in
  /// ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch belongs
  /// to.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.List<MetadataFilter> metadataFilters;

  /// For satisfying the matchRule condition, the request's path must begin with
  /// the specified prefixMatch. prefixMatch must begin with a /.
  /// The value must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String prefixMatch;

  /// Specifies a list of query parameter match criteria, all of which must
  /// match corresponding query parameters in the request.
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.List<HttpQueryParameterMatch> queryParameterMatches;

  /// For satisfying the matchRule condition, the path of the request must
  /// satisfy the regular expression specified in regexMatch after removing any
  /// query parameters and anchor supplied with the original URL. For regular
  /// expression grammar please see en.cppreference.com/w/cpp/regex/ecmascript
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String regexMatch;

  HttpRouteRuleMatch();

  HttpRouteRuleMatch.fromJson(core.Map _json) {
    if (_json.containsKey('fullPathMatch')) {
      fullPathMatch = _json['fullPathMatch'] as core.String;
    }
    if (_json.containsKey('headerMatches')) {
      headerMatches = (_json['headerMatches'] as core.List)
          .map<HttpHeaderMatch>((value) => HttpHeaderMatch.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('ignoreCase')) {
      ignoreCase = _json['ignoreCase'] as core.bool;
    }
    if (_json.containsKey('metadataFilters')) {
      metadataFilters = (_json['metadataFilters'] as core.List)
          .map<MetadataFilter>((value) => MetadataFilter.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('prefixMatch')) {
      prefixMatch = _json['prefixMatch'] as core.String;
    }
    if (_json.containsKey('queryParameterMatches')) {
      queryParameterMatches = (_json['queryParameterMatches'] as core.List)
          .map<HttpQueryParameterMatch>((value) =>
              HttpQueryParameterMatch.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fullPathMatch != null) {
      _json['fullPathMatch'] = fullPathMatch;
    }
    if (headerMatches != null) {
      _json['headerMatches'] =
          headerMatches.map((value) => value.toJson()).toList();
    }
    if (ignoreCase != null) {
      _json['ignoreCase'] = ignoreCase;
    }
    if (metadataFilters != null) {
      _json['metadataFilters'] =
          metadataFilters.map((value) => value.toJson()).toList();
    }
    if (prefixMatch != null) {
      _json['prefixMatch'] = prefixMatch;
    }
    if (queryParameterMatches != null) {
      _json['queryParameterMatches'] =
          queryParameterMatches.map((value) => value.toJson()).toList();
    }
    if (regexMatch != null) {
      _json['regexMatch'] = regexMatch;
    }
    return _json;
  }
}

/// Represents a legacy HTTPS Health Check resource.
///
/// Legacy health checks are required by network load balancers. For more
/// information, read Health Check Concepts.
class HttpsHealthCheck {
  /// How often (in seconds) to send a health check. The default value is 5
  /// seconds.
  core.int checkIntervalSec;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes. The default value is 2.
  core.int healthyThreshold;

  /// The value of the host header in the HTTPS health check request. If left
  /// empty (default value), the public IP on behalf of which this health check
  /// is performed will be used.
  core.String host;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Type of the resource.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The TCP port number for the HTTPS health check request. The default value
  /// is 443.
  core.int port;

  /// The request path of the HTTPS health check request. The default value is
  /// "/".
  core.String requestPath;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// How long (in seconds) to wait before claiming failure. The default value
  /// is 5 seconds. It is invalid for timeoutSec to have a greater value than
  /// checkIntervalSec.
  core.int timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures. The default value is 2.
  core.int unhealthyThreshold;

  HttpsHealthCheck();

  HttpsHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (checkIntervalSec != null) {
      _json['checkIntervalSec'] = checkIntervalSec;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (healthyThreshold != null) {
      _json['healthyThreshold'] = healthyThreshold;
    }
    if (host != null) {
      _json['host'] = host;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (port != null) {
      _json['port'] = port;
    }
    if (requestPath != null) {
      _json['requestPath'] = requestPath;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (timeoutSec != null) {
      _json['timeoutSec'] = timeoutSec;
    }
    if (unhealthyThreshold != null) {
      _json['unhealthyThreshold'] = unhealthyThreshold;
    }
    return _json;
  }
}

class HttpsHealthCheckListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  HttpsHealthCheckListWarningData();

  HttpsHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class HttpsHealthCheckListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<HttpsHealthCheckListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  HttpsHealthCheckListWarning();

  HttpsHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HttpsHealthCheckListWarningData>((value) =>
              HttpsHealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of HttpsHealthCheck resources.
class HttpsHealthCheckList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of HttpsHealthCheck resources.
  core.List<HttpsHealthCheck> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  HttpsHealthCheckListWarning warning;

  HttpsHealthCheckList();

  HttpsHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HttpsHealthCheck>((value) => HttpsHealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HttpsHealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// The parameters of the raw disk image.
class ImageRawDisk {
  /// The format used to encode and transmit the block device, which should be
  /// TAR. This is just a container and transmission format and not a runtime
  /// format. Provided by the client when the disk image is created.
  /// Possible string values are:
  /// - "TAR"
  core.String containerType;

  /// [Deprecated] This field is deprecated. An optional SHA1 checksum of the
  /// disk image before unpackaging provided by the client when the disk image
  /// is created.
  core.String sha1Checksum;

  /// The full Google Cloud Storage URL where the disk image is stored. You must
  /// provide either this property or the sourceDisk property but not both.
  core.String source;

  ImageRawDisk();

  ImageRawDisk.fromJson(core.Map _json) {
    if (_json.containsKey('containerType')) {
      containerType = _json['containerType'] as core.String;
    }
    if (_json.containsKey('sha1Checksum')) {
      sha1Checksum = _json['sha1Checksum'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (containerType != null) {
      _json['containerType'] = containerType;
    }
    if (sha1Checksum != null) {
      _json['sha1Checksum'] = sha1Checksum;
    }
    if (source != null) {
      _json['source'] = source;
    }
    return _json;
  }
}

/// Represents an Image resource.
///
/// You can use images to create boot disks for your VM instances. For more
/// information, read Images. (== resource_for {$api_version}.images ==)
class Image {
  /// Size of the image tar.gz archive stored in Google Cloud Storage (in
  /// bytes).
  core.String archiveSizeBytes;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The deprecation status associated with this image.
  DeprecationStatus deprecated;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Size of the image when restored onto a persistent disk (in GB).
  core.String diskSizeGb;

  /// The name of the image family to which this image belongs. You can create
  /// disks by specifying an image family instead of a specific image name. The
  /// image family always returns its latest image that is not deprecated. The
  /// name of the image family must comply with RFC1035.
  core.String family;

  /// A list of features to enable on the guest operating system. Applicable
  /// only for bootable images. Read  Enabling guest operating system features
  /// to see a list of available options.
  core.List<GuestOsFeature> guestOsFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Encrypts the image using a customer-supplied encryption key.
  ///
  /// After you encrypt an image with a customer-supplied key, you must provide
  /// the same key if you use the image later (e.g. to create a disk from the
  /// image).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the image, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the image later.
  CustomerEncryptionKey imageEncryptionKey;

  /// [Output Only] Type of the resource. Always compute#image for images.
  core.String kind;

  /// A fingerprint for the labels being applied to this image, which is
  /// essentially a hash of the labels used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an image.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this image. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Integer license codes indicating which licenses are attached to this
  /// image.
  core.List<core.String> licenseCodes;

  /// Any applicable license URI.
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The parameters of the raw disk image.
  ImageRawDisk rawDisk;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Set the secure boot keys of shielded instance.
  InitialStateConfig shieldedInstanceInitialState;

  /// URL of the source disk used to create this image. This can be a full or
  /// valid partial URL. You must provide either this property or the
  /// rawDisk.source property but not both to create an image. For example, the
  /// following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// [Output Only] The ID value of the disk used to create this image. This
  /// value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given disk name.
  core.String sourceDiskId;

  /// URL of the source image used to create this image.
  ///
  /// In order to create an image, you must provide the full or partial URL of
  /// one of the following:
  /// - The selfLink URL
  /// - This property
  /// - The rawDisk.source URL
  /// - The sourceDisk URL
  core.String sourceImage;

  /// The customer-supplied encryption key of the source image. Required if the
  /// source image is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceImageEncryptionKey;

  /// [Output Only] The ID value of the image used to create this image. This
  /// value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given image name.
  core.String sourceImageId;

  /// URL of the source snapshot used to create this image.
  ///
  /// In order to create an image, you must provide the full or partial URL of
  /// one of the following:
  /// - The selfLink URL
  /// - This property
  /// - The sourceImage URL
  /// - The rawDisk.source URL
  /// - The sourceDisk URL
  core.String sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot. Required if
  /// the source snapshot is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceSnapshotEncryptionKey;

  /// [Output Only] The ID value of the snapshot used to create this image. This
  /// value may be used to determine whether the snapshot was taken from the
  /// current or a previous instance of a given snapshot name.
  core.String sourceSnapshotId;

  /// The type of the image used to create this disk. The default and only value
  /// is RAW
  /// Possible string values are:
  /// - "RAW"
  core.String sourceType;

  /// [Output Only] The status of the image. An image can be used to create
  /// other resources, such as instances, only after the image has been
  /// successfully created and the status is set to READY. Possible values are
  /// FAILED, PENDING, or READY.
  /// Possible string values are:
  /// - "DELETING"
  /// - "FAILED"
  /// - "PENDING"
  /// - "READY"
  core.String status;

  /// Cloud Storage bucket storage location of the image (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  Image();

  Image.fromJson(core.Map _json) {
    if (_json.containsKey('archiveSizeBytes')) {
      archiveSizeBytes = _json['archiveSizeBytes'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('family')) {
      family = _json['family'] as core.String;
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('imageEncryptionKey')) {
      imageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['imageEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rawDisk')) {
      rawDisk = ImageRawDisk.fromJson(
          _json['rawDisk'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('shieldedInstanceInitialState')) {
      shieldedInstanceInitialState = InitialStateConfig.fromJson(
          _json['shieldedInstanceInitialState']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskEncryptionKey')) {
      sourceDiskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceDiskEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceImageId')) {
      sourceImageId = _json['sourceImageId'] as core.String;
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshotId')) {
      sourceSnapshotId = _json['sourceSnapshotId'] as core.String;
    }
    if (_json.containsKey('sourceType')) {
      sourceType = _json['sourceType'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (archiveSizeBytes != null) {
      _json['archiveSizeBytes'] = archiveSizeBytes;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (diskSizeGb != null) {
      _json['diskSizeGb'] = diskSizeGb;
    }
    if (family != null) {
      _json['family'] = family;
    }
    if (guestOsFeatures != null) {
      _json['guestOsFeatures'] =
          guestOsFeatures.map((value) => value.toJson()).toList();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (imageEncryptionKey != null) {
      _json['imageEncryptionKey'] = imageEncryptionKey.toJson();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (licenseCodes != null) {
      _json['licenseCodes'] = licenseCodes;
    }
    if (licenses != null) {
      _json['licenses'] = licenses;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (rawDisk != null) {
      _json['rawDisk'] = rawDisk.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (shieldedInstanceInitialState != null) {
      _json['shieldedInstanceInitialState'] =
          shieldedInstanceInitialState.toJson();
    }
    if (sourceDisk != null) {
      _json['sourceDisk'] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json['sourceDiskEncryptionKey'] = sourceDiskEncryptionKey.toJson();
    }
    if (sourceDiskId != null) {
      _json['sourceDiskId'] = sourceDiskId;
    }
    if (sourceImage != null) {
      _json['sourceImage'] = sourceImage;
    }
    if (sourceImageEncryptionKey != null) {
      _json['sourceImageEncryptionKey'] = sourceImageEncryptionKey.toJson();
    }
    if (sourceImageId != null) {
      _json['sourceImageId'] = sourceImageId;
    }
    if (sourceSnapshot != null) {
      _json['sourceSnapshot'] = sourceSnapshot;
    }
    if (sourceSnapshotEncryptionKey != null) {
      _json['sourceSnapshotEncryptionKey'] =
          sourceSnapshotEncryptionKey.toJson();
    }
    if (sourceSnapshotId != null) {
      _json['sourceSnapshotId'] = sourceSnapshotId;
    }
    if (sourceType != null) {
      _json['sourceType'] = sourceType;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (storageLocations != null) {
      _json['storageLocations'] = storageLocations;
    }
    return _json;
  }
}

class ImageListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ImageListWarningData();

  ImageListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ImageListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ImageListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ImageListWarning();

  ImageListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ImageListWarningData>((value) => ImageListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of images.
class ImageList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Image resources.
  core.List<Image> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ImageListWarning warning;

  ImageList();

  ImageList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Image>((value) =>
              Image.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ImageListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Initial State for shielded instance, these are public keys which are safe to
/// store in public
class InitialStateConfig {
  /// The Key Database (db).
  core.List<FileContentBuffer> dbs;

  /// The forbidden key database (dbx).
  core.List<FileContentBuffer> dbxs;

  /// The Key Exchange Key (KEK).
  core.List<FileContentBuffer> keks;

  /// The Platform Key (PK).
  FileContentBuffer pk;

  InitialStateConfig();

  InitialStateConfig.fromJson(core.Map _json) {
    if (_json.containsKey('dbs')) {
      dbs = (_json['dbs'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('dbxs')) {
      dbxs = (_json['dbxs'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('keks')) {
      keks = (_json['keks'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('pk')) {
      pk = FileContentBuffer.fromJson(
          _json['pk'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (dbs != null) {
      _json['dbs'] = dbs.map((value) => value.toJson()).toList();
    }
    if (dbxs != null) {
      _json['dbxs'] = dbxs.map((value) => value.toJson()).toList();
    }
    if (keks != null) {
      _json['keks'] = keks.map((value) => value.toJson()).toList();
    }
    if (pk != null) {
      _json['pk'] = pk.toJson();
    }
    return _json;
  }
}

/// Represents an Instance resource.
///
/// An instance is a virtual machine that is hosted on Google Cloud Platform.
/// For more information, read Virtual Machine Instances. (== resource_for
/// {$api_version}.instances ==)
class Instance {
  /// Allows this instance to send and receive packets with non-matching
  /// destination or source IPs. This is required if you plan to use this
  /// instance to forward routes. For more information, see Enabling IP
  /// Forwarding.
  core.bool canIpForward;
  ConfidentialInstanceConfig confidentialInstanceConfig;

  /// [Output Only] The CPU platform used by this instance.
  core.String cpuPlatform;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Whether the resource should be protected against deletion.
  core.bool deletionProtection;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Array of disks associated with this instance. Persistent disks must be
  /// created before you can assign them.
  core.List<AttachedDisk> disks;

  /// Enables display device for the instance.
  DisplayDevice displayDevice;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the instance's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update the instance. You must always provide an up-to-date
  /// fingerprint hash in order to update the instance.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Specifies the hostname of the instance. The specified hostname must be
  /// RFC1035 compliant. If hostname is not specified, the default hostname is
  /// [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and
  /// [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
  core.String hostname;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#instance for instances.
  core.String kind;

  /// A fingerprint for this request, which is essentially a hash of the label's
  /// contents and used for optimistic locking. The fingerprint is initially
  /// generated by Compute Engine and changes after every request to modify or
  /// update labels. You must always provide an up-to-date fingerprint hash in
  /// order to update or change labels.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this instance. These can be later modified by the
  /// setLabels method.
  core.Map<core.String, core.String> labels;

  /// Full or partial URL of the machine type resource to use for this instance,
  /// in the format: zones/zone/machineTypes/machine-type. This is provided by
  /// the client when the instance is created. For example, the following is a
  /// valid partial url to a predefined machine type:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  ///
  ///
  /// To create a custom machine type, provide a URL to a machine type in the
  /// following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ...
  /// 24, etc), and MEMORY is the total memory for this instance. Memory must be
  /// a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is
  /// 5120 MB):
  /// zones/zone/machineTypes/custom-CPUS-MEMORY
  ///
  ///
  /// For example: zones/us-central1-f/machineTypes/custom-4-5120
  ///
  /// For a full list of restrictions, read the Specifications for custom
  /// machine types.
  core.String machineType;

  /// The metadata key/value pairs assigned to this instance. This includes
  /// custom metadata and predefined keys.
  Metadata metadata;

  /// Specifies a minimum CPU platform for the VM instance. Applicable values
  /// are the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  core.String minCpuPlatform;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// An array of network configurations for this instance. These specify how
  /// interfaces are configured to interact with other network services, such as
  /// connecting to the internet. Multiple interfaces are supported per
  /// instance.
  core.List<NetworkInterface> networkInterfaces;

  /// The private IPv6 google access type for the VM. If not specified, use
  /// INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  /// - "INHERIT_FROM_SUBNETWORK"
  core.String privateIpv6GoogleAccess;

  /// Specifies the reservations that this instance can consume from.
  ReservationAffinity reservationAffinity;

  /// Resource policies applied to this instance.
  core.List<core.String> resourcePolicies;

  /// Sets the scheduling options for this instance.
  Scheduling scheduling;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// A list of service accounts, with their specified scopes, authorized for
  /// this instance. Only one service account per VM instance is supported.
  ///
  /// Service accounts generate access tokens that can be accessed through the
  /// metadata server and used to authenticate applications on the instance. See
  /// Service Accounts for more information.
  core.List<ServiceAccount> serviceAccounts;
  ShieldedInstanceConfig shieldedInstanceConfig;
  ShieldedInstanceIntegrityPolicy shieldedInstanceIntegrityPolicy;

  /// [Output Only] Whether a VM has been restricted for start because Compute
  /// Engine has detected suspicious activity.
  core.bool startRestricted;

  /// [Output Only] The status of the instance. One of the following values:
  /// PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED,
  /// REPAIRING, and TERMINATED.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  /// Tags to apply to this instance. Tags are used to identify valid sources or
  /// targets for network firewalls and are specified by the client during
  /// instance creation. The tags can be later modified by the setTags method.
  /// Each tag within the list must comply with RFC1035. Multiple tags can be
  /// specified via the 'tags.items' field.
  Tags tags;

  /// [Output Only] URL of the zone where the instance resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String zone;

  Instance();

  Instance.fromJson(core.Map _json) {
    if (_json.containsKey('canIpForward')) {
      canIpForward = _json['canIpForward'] as core.bool;
    }
    if (_json.containsKey('confidentialInstanceConfig')) {
      confidentialInstanceConfig = ConfidentialInstanceConfig.fromJson(
          _json['confidentialInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cpuPlatform')) {
      cpuPlatform = _json['cpuPlatform'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deletionProtection')) {
      deletionProtection = _json['deletionProtection'] as core.bool;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<AttachedDisk>((value) => AttachedDisk.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('displayDevice')) {
      displayDevice = DisplayDevice.fromJson(
          _json['displayDevice'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('hostname')) {
      hostname = _json['hostname'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('metadata')) {
      metadata = Metadata.fromJson(
          _json['metadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkInterfaces')) {
      networkInterfaces = (_json['networkInterfaces'] as core.List)
          .map<NetworkInterface>((value) => NetworkInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('reservationAffinity')) {
      reservationAffinity = ReservationAffinity.fromJson(
          _json['reservationAffinity'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('scheduling')) {
      scheduling = Scheduling.fromJson(
          _json['scheduling'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serviceAccounts')) {
      serviceAccounts = (_json['serviceAccounts'] as core.List)
          .map<ServiceAccount>((value) => ServiceAccount.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('shieldedInstanceConfig')) {
      shieldedInstanceConfig = ShieldedInstanceConfig.fromJson(
          _json['shieldedInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('shieldedInstanceIntegrityPolicy')) {
      shieldedInstanceIntegrityPolicy =
          ShieldedInstanceIntegrityPolicy.fromJson(
              _json['shieldedInstanceIntegrityPolicy']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('startRestricted')) {
      startRestricted = _json['startRestricted'] as core.bool;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
    if (_json.containsKey('tags')) {
      tags =
          Tags.fromJson(_json['tags'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canIpForward != null) {
      _json['canIpForward'] = canIpForward;
    }
    if (confidentialInstanceConfig != null) {
      _json['confidentialInstanceConfig'] = confidentialInstanceConfig.toJson();
    }
    if (cpuPlatform != null) {
      _json['cpuPlatform'] = cpuPlatform;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deletionProtection != null) {
      _json['deletionProtection'] = deletionProtection;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (disks != null) {
      _json['disks'] = disks.map((value) => value.toJson()).toList();
    }
    if (displayDevice != null) {
      _json['displayDevice'] = displayDevice.toJson();
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (guestAccelerators != null) {
      _json['guestAccelerators'] =
          guestAccelerators.map((value) => value.toJson()).toList();
    }
    if (hostname != null) {
      _json['hostname'] = hostname;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (machineType != null) {
      _json['machineType'] = machineType;
    }
    if (metadata != null) {
      _json['metadata'] = metadata.toJson();
    }
    if (minCpuPlatform != null) {
      _json['minCpuPlatform'] = minCpuPlatform;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (networkInterfaces != null) {
      _json['networkInterfaces'] =
          networkInterfaces.map((value) => value.toJson()).toList();
    }
    if (privateIpv6GoogleAccess != null) {
      _json['privateIpv6GoogleAccess'] = privateIpv6GoogleAccess;
    }
    if (reservationAffinity != null) {
      _json['reservationAffinity'] = reservationAffinity.toJson();
    }
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    if (scheduling != null) {
      _json['scheduling'] = scheduling.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (serviceAccounts != null) {
      _json['serviceAccounts'] =
          serviceAccounts.map((value) => value.toJson()).toList();
    }
    if (shieldedInstanceConfig != null) {
      _json['shieldedInstanceConfig'] = shieldedInstanceConfig.toJson();
    }
    if (shieldedInstanceIntegrityPolicy != null) {
      _json['shieldedInstanceIntegrityPolicy'] =
          shieldedInstanceIntegrityPolicy.toJson();
    }
    if (startRestricted != null) {
      _json['startRestricted'] = startRestricted;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (statusMessage != null) {
      _json['statusMessage'] = statusMessage;
    }
    if (tags != null) {
      _json['tags'] = tags.toJson();
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class InstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceAggregatedListWarningData();

  InstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceAggregatedListWarning();

  InstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceAggregatedListWarningData>((value) =>
              InstanceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// An object that contains a list of instances scoped by zone.
  core.Map<core.String, InstancesScopedList> items;

  /// [Output Only] Type of resource. Always compute#instanceAggregatedList for
  /// aggregated lists of Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  InstanceAggregatedListWarning warning;

  InstanceAggregatedList();

  InstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              InstancesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents an Instance Group resource.
///
/// Instance Groups can be used to configure a target for load balancing.
///
/// Instance groups can either be managed or unmanaged.
///
/// To create  managed instance groups, use the instanceGroupManager or
/// regionInstanceGroupManager resource instead.
///
/// Use zonal unmanaged instance groups if you need to apply load balancing to
/// groups of heterogeneous instances or if you need to manage the instances
/// yourself. You cannot create regional unmanaged instance groups.
///
/// For more information, read Instance groups.
///
/// (== resource_for {$api_version}.instanceGroups ==) (== resource_for
/// {$api_version}.regionInstanceGroups ==)
class InstanceGroup {
  /// [Output Only] The creation timestamp for this instance group in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The fingerprint of the named ports. The system uses this
  /// fingerprint to detect conflicts when multiple users change the named ports
  /// concurrently.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] A unique identifier for this instance group, generated by
  /// the server.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceGroup for
  /// instance groups.
  core.String kind;

  /// The name of the instance group. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// Assigns a name to a port number. For example: {name: "http", port: 80}
  ///
  /// This allows the system to reference ports by the assigned name instead of
  /// a port number. Named ports can also contain multiple ports. For example:
  /// [{name: "http", port: 80},{name: "http", port: 8080}]
  ///
  /// Named ports apply to all instances in this instance group.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The URL of the network to which all instances in the
  /// instance group belong. If your instance has multiple network interfaces,
  /// then the network and subnetwork fields only refer to the network and
  /// subnet used by your primary interface (nic0).
  core.String network;

  /// [Output Only] The URL of the region where the instance group is located
  /// (for regional resources).
  core.String region;

  /// [Output Only] The URL for this instance group. The server generates this
  /// URL.
  core.String selfLink;

  /// [Output Only] The total number of instances in the instance group.
  core.int size;

  /// [Output Only] The URL of the subnetwork to which all instances in the
  /// instance group belong. If your instance has multiple network interfaces,
  /// then the network and subnetwork fields only refer to the network and
  /// subnet used by your primary interface (nic0).
  core.String subnetwork;

  /// [Output Only] The URL of the zone where the instance group is located (for
  /// zonal resources).
  core.String zone;

  InstanceGroup();

  InstanceGroup.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (namedPorts != null) {
      _json['namedPorts'] = namedPorts.map((value) => value.toJson()).toList();
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (size != null) {
      _json['size'] = size;
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class InstanceGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupAggregatedListWarningData();

  InstanceGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupAggregatedListWarning();

  InstanceGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupAggregatedListWarningData>((value) =>
              InstanceGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupsScopedList resources.
  core.Map<core.String, InstanceGroupsScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupAggregatedList for aggregated lists of instance
  /// groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  InstanceGroupAggregatedListWarning warning;

  InstanceGroupAggregatedList();

  InstanceGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              InstanceGroupsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupListWarningData();

  InstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupListWarning();

  InstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupListWarningData>((value) =>
              InstanceGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// A list of InstanceGroup resources.
class InstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// [Output Only] The resource type, which is always compute#instanceGroupList
  /// for instance group lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupListWarning warning;

  InstanceGroupList();

  InstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Managed Instance Group resource.
///
/// An instance group is a collection of VM instances that you can manage as a
/// single entity. For more information, read Instance groups.
///
/// For zonal Managed Instance Group, use the instanceGroupManagers resource.
///
/// For regional Managed Instance Group, use the regionInstanceGroupManagers
/// resource. (== resource_for {$api_version}.instanceGroupManagers ==) (==
/// resource_for {$api_version}.regionInstanceGroupManagers ==)
class InstanceGroupManager {
  /// The autohealing policy for this managed instance group. You can specify
  /// only one value.
  core.List<InstanceGroupManagerAutoHealingPolicy> autoHealingPolicies;

  /// The base instance name to use for instances in this group. The value must
  /// be 1-58 characters long. Instances are named by appending a hyphen and a
  /// random four-character string to the base instance name. The base instance
  /// name must comply with RFC1035.
  core.String baseInstanceName;

  /// [Output Only] The creation timestamp for this managed instance group in
  /// RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The list of instance actions and the number of instances in
  /// this managed instance group that are scheduled for each of those actions.
  InstanceGroupManagerActionsSummary currentActions;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Policy specifying intended distribution of instances in regional managed
  /// instance group.
  DistributionPolicy distributionPolicy;

  /// Fingerprint of this resource. This field may be used in optimistic
  /// locking. It will be ignored when inserting an InstanceGroupManager. An
  /// up-to-date fingerprint must be provided in order to update the
  /// InstanceGroupManager, otherwise the request will fail with error 412
  /// conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// InstanceGroupManager.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] A unique identifier for this resource type. The server
  /// generates this identifier.
  core.String id;

  /// [Output Only] The URL of the Instance Group resource.
  core.String instanceGroup;

  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManager for managed instance groups.
  core.String kind;

  /// The name of the managed instance group. The name must be 1-63 characters
  /// long, and comply with RFC1035.
  core.String name;

  /// Named ports configured for the Instance Groups complementary to this
  /// Instance Group Manager.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The URL of the region where the managed instance group
  /// resides (for regional resources).
  core.String region;

  /// [Output Only] The URL for this managed instance group. The server defines
  /// this URL.
  core.String selfLink;

  /// Stateful configuration for this Instanced Group Manager
  StatefulPolicy statefulPolicy;

  /// [Output Only] The status of this managed instance group.
  InstanceGroupManagerStatus status;

  /// The URLs for all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  /// The target number of running instances for this managed instance group.
  /// You can reduce this number by using the instanceGroupManager
  /// deleteInstances or abandonInstances methods. Resizing the group also
  /// changes this number.
  core.int targetSize;

  /// The update policy for this managed instance group.
  InstanceGroupManagerUpdatePolicy updatePolicy;

  /// Specifies the instance templates used by this managed instance group to
  /// create instances.
  ///
  /// Each version is defined by an instanceTemplate and a name. Every version
  /// can appear at most once per instance group. This field overrides the
  /// top-level instanceTemplate field. Read more about the relationships
  /// between these fields. Exactly one version must leave the targetSize field
  /// unset. That version will be applied to all remaining instances. For more
  /// information, read about canary updates.
  core.List<InstanceGroupManagerVersion> versions;

  /// [Output Only] The URL of the zone where the managed instance group is
  /// located (for zonal resources).
  core.String zone;

  InstanceGroupManager();

  InstanceGroupManager.fromJson(core.Map _json) {
    if (_json.containsKey('autoHealingPolicies')) {
      autoHealingPolicies = (_json['autoHealingPolicies'] as core.List)
          .map<InstanceGroupManagerAutoHealingPolicy>((value) =>
              InstanceGroupManagerAutoHealingPolicy.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('baseInstanceName')) {
      baseInstanceName = _json['baseInstanceName'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('currentActions')) {
      currentActions = InstanceGroupManagerActionsSummary.fromJson(
          _json['currentActions'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('distributionPolicy')) {
      distributionPolicy = DistributionPolicy.fromJson(
          _json['distributionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instanceGroup')) {
      instanceGroup = _json['instanceGroup'] as core.String;
    }
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('statefulPolicy')) {
      statefulPolicy = StatefulPolicy.fromJson(
          _json['statefulPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = InstanceGroupManagerStatus.fromJson(
          _json['status'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetSize')) {
      targetSize = _json['targetSize'] as core.int;
    }
    if (_json.containsKey('updatePolicy')) {
      updatePolicy = InstanceGroupManagerUpdatePolicy.fromJson(
          _json['updatePolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versions')) {
      versions = (_json['versions'] as core.List)
          .map<InstanceGroupManagerVersion>((value) =>
              InstanceGroupManagerVersion.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoHealingPolicies != null) {
      _json['autoHealingPolicies'] =
          autoHealingPolicies.map((value) => value.toJson()).toList();
    }
    if (baseInstanceName != null) {
      _json['baseInstanceName'] = baseInstanceName;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (currentActions != null) {
      _json['currentActions'] = currentActions.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (distributionPolicy != null) {
      _json['distributionPolicy'] = distributionPolicy.toJson();
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (instanceGroup != null) {
      _json['instanceGroup'] = instanceGroup;
    }
    if (instanceTemplate != null) {
      _json['instanceTemplate'] = instanceTemplate;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (namedPorts != null) {
      _json['namedPorts'] = namedPorts.map((value) => value.toJson()).toList();
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (statefulPolicy != null) {
      _json['statefulPolicy'] = statefulPolicy.toJson();
    }
    if (status != null) {
      _json['status'] = status.toJson();
    }
    if (targetPools != null) {
      _json['targetPools'] = targetPools;
    }
    if (targetSize != null) {
      _json['targetSize'] = targetSize;
    }
    if (updatePolicy != null) {
      _json['updatePolicy'] = updatePolicy.toJson();
    }
    if (versions != null) {
      _json['versions'] = versions.map((value) => value.toJson()).toList();
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class InstanceGroupManagerActionsSummary {
  /// [Output Only] The total number of instances in the managed instance group
  /// that are scheduled to be abandoned. Abandoning an instance removes it from
  /// the managed instance group without deleting it.
  core.int abandoning;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be created or are currently being created. If the group
  /// fails to create any of these instances, it tries again until it creates
  /// the instance successfully.
  ///
  /// If you have disabled creation retries, this field will not be populated;
  /// instead, the creatingWithoutRetries field will be populated.
  core.int creating;

  /// [Output Only] The number of instances that the managed instance group will
  /// attempt to create. The group attempts to create each instance only once.
  /// If the group fails to create any of these instances, it decreases the
  /// group's targetSize value accordingly.
  core.int creatingWithoutRetries;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be deleted or are currently being deleted.
  core.int deleting;

  /// [Output Only] The number of instances in the managed instance group that
  /// are running and have no scheduled actions.
  core.int none;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be recreated or are currently being being recreated.
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  core.int recreating;

  /// [Output Only] The number of instances in the managed instance group that
  /// are being reconfigured with properties that do not require a restart or a
  /// recreate action. For example, setting or removing target pools for the
  /// instance.
  core.int refreshing;

  /// [Output Only] The number of instances in the managed instance group that
  /// are scheduled to be restarted or are currently being restarted.
  core.int restarting;

  /// [Output Only] The number of instances in the managed instance group that
  /// are being verified. See the managedInstances[].currentAction property in
  /// the listManagedInstances method documentation.
  core.int verifying;

  InstanceGroupManagerActionsSummary();

  InstanceGroupManagerActionsSummary.fromJson(core.Map _json) {
    if (_json.containsKey('abandoning')) {
      abandoning = _json['abandoning'] as core.int;
    }
    if (_json.containsKey('creating')) {
      creating = _json['creating'] as core.int;
    }
    if (_json.containsKey('creatingWithoutRetries')) {
      creatingWithoutRetries = _json['creatingWithoutRetries'] as core.int;
    }
    if (_json.containsKey('deleting')) {
      deleting = _json['deleting'] as core.int;
    }
    if (_json.containsKey('none')) {
      none = _json['none'] as core.int;
    }
    if (_json.containsKey('recreating')) {
      recreating = _json['recreating'] as core.int;
    }
    if (_json.containsKey('refreshing')) {
      refreshing = _json['refreshing'] as core.int;
    }
    if (_json.containsKey('restarting')) {
      restarting = _json['restarting'] as core.int;
    }
    if (_json.containsKey('verifying')) {
      verifying = _json['verifying'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (abandoning != null) {
      _json['abandoning'] = abandoning;
    }
    if (creating != null) {
      _json['creating'] = creating;
    }
    if (creatingWithoutRetries != null) {
      _json['creatingWithoutRetries'] = creatingWithoutRetries;
    }
    if (deleting != null) {
      _json['deleting'] = deleting;
    }
    if (none != null) {
      _json['none'] = none;
    }
    if (recreating != null) {
      _json['recreating'] = recreating;
    }
    if (refreshing != null) {
      _json['refreshing'] = refreshing;
    }
    if (restarting != null) {
      _json['restarting'] = restarting;
    }
    if (verifying != null) {
      _json['verifying'] = verifying;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerAggregatedListWarningData();

  InstanceGroupManagerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerAggregatedListWarning();

  InstanceGroupManagerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagerAggregatedListWarningData>((value) =>
              InstanceGroupManagerAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupManagerAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManagersScopedList resources.
  core.Map<core.String, InstanceGroupManagersScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerAggregatedList for an aggregated list of
  /// managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerAggregatedListWarning warning;

  InstanceGroupManagerAggregatedList();

  InstanceGroupManagerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              InstanceGroupManagersScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagerAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerAutoHealingPolicy {
  /// The URL for the health check that signals autohealing.
  core.String healthCheck;

  /// The number of seconds that the managed instance group waits before it
  /// applies autohealing policies to new instances or recently recreated
  /// instances. This initial delay allows instances to initialize and run their
  /// startup scripts before the instance group determines that they are
  /// UNHEALTHY. This prevents the managed instance group from recreating its
  /// instances prematurely. This value must be from range [0, 3600].
  core.int initialDelaySec;

  InstanceGroupManagerAutoHealingPolicy();

  InstanceGroupManagerAutoHealingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
    if (_json.containsKey('initialDelaySec')) {
      initialDelaySec = _json['initialDelaySec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthCheck != null) {
      _json['healthCheck'] = healthCheck;
    }
    if (initialDelaySec != null) {
      _json['initialDelaySec'] = initialDelaySec;
    }
    return _json;
  }
}

class InstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagerListWarningData();

  InstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagerListWarning();

  InstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagerListWarningData>((value) =>
              InstanceGroupManagerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// [Output Only] A list of managed instance groups.
class InstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupManagerListWarning warning;

  InstanceGroupManagerList();

  InstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerStatus {
  /// [Output Only] The URL of the Autoscaler that targets this instance group
  /// manager.
  core.String autoscaler;

  /// [Output Only] A bit indicating whether the managed instance group is in a
  /// stable state. A stable state means that: none of the instances in the
  /// managed instance group is currently undergoing any type of change (for
  /// example, creation, restart, or deletion); no future changes are scheduled
  /// for instances in the managed instance group; and the managed instance
  /// group itself is not being modified.
  core.bool isStable;

  /// [Output Only] Stateful status of the given Instance Group Manager.
  InstanceGroupManagerStatusStateful stateful;

  /// [Output Only] A status of consistency of Instances' versions with their
  /// target version specified by version field on Instance Group Manager.
  InstanceGroupManagerStatusVersionTarget versionTarget;

  InstanceGroupManagerStatus();

  InstanceGroupManagerStatus.fromJson(core.Map _json) {
    if (_json.containsKey('autoscaler')) {
      autoscaler = _json['autoscaler'] as core.String;
    }
    if (_json.containsKey('isStable')) {
      isStable = _json['isStable'] as core.bool;
    }
    if (_json.containsKey('stateful')) {
      stateful = InstanceGroupManagerStatusStateful.fromJson(
          _json['stateful'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versionTarget')) {
      versionTarget = InstanceGroupManagerStatusVersionTarget.fromJson(
          _json['versionTarget'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoscaler != null) {
      _json['autoscaler'] = autoscaler;
    }
    if (isStable != null) {
      _json['isStable'] = isStable;
    }
    if (stateful != null) {
      _json['stateful'] = stateful.toJson();
    }
    if (versionTarget != null) {
      _json['versionTarget'] = versionTarget.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerStatusStateful {
  /// [Output Only] A bit indicating whether the managed instance group has
  /// stateful configuration, that is, if you have configured any items in a
  /// stateful policy or in per-instance configs. The group might report that it
  /// has no stateful config even when there is still some preserved state on a
  /// managed instance, for example, if you have deleted all PICs but not yet
  /// applied those deletions.
  core.bool hasStatefulConfig;

  /// [Output Only] Status of per-instance configs on the instance.
  InstanceGroupManagerStatusStatefulPerInstanceConfigs perInstanceConfigs;

  InstanceGroupManagerStatusStateful();

  InstanceGroupManagerStatusStateful.fromJson(core.Map _json) {
    if (_json.containsKey('hasStatefulConfig')) {
      hasStatefulConfig = _json['hasStatefulConfig'] as core.bool;
    }
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs =
          InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(
              _json['perInstanceConfigs']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (hasStatefulConfig != null) {
      _json['hasStatefulConfig'] = hasStatefulConfig;
    }
    if (perInstanceConfigs != null) {
      _json['perInstanceConfigs'] = perInstanceConfigs.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  /// A bit indicating if all of the group's per-instance configs (listed in the
  /// output of a listPerInstanceConfigs API call) have status EFFECTIVE or
  /// there are no per-instance-configs.
  core.bool allEffective;

  InstanceGroupManagerStatusStatefulPerInstanceConfigs();

  InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(
      core.Map _json) {
    if (_json.containsKey('allEffective')) {
      allEffective = _json['allEffective'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (allEffective != null) {
      _json['allEffective'] = allEffective;
    }
    return _json;
  }
}

class InstanceGroupManagerStatusVersionTarget {
  /// [Output Only] A bit indicating whether version target has been reached in
  /// this managed instance group, i.e. all instances are in their target
  /// version. Instances' target version are specified by version field on
  /// Instance Group Manager.
  core.bool isReached;

  InstanceGroupManagerStatusVersionTarget();

  InstanceGroupManagerStatusVersionTarget.fromJson(core.Map _json) {
    if (_json.containsKey('isReached')) {
      isReached = _json['isReached'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (isReached != null) {
      _json['isReached'] = isReached;
    }
    return _json;
  }
}

class InstanceGroupManagerUpdatePolicy {
  /// The  instance redistribution policy for regional managed instance groups.
  /// Valid values are:
  /// - PROACTIVE (default): The group attempts to maintain an even distribution
  /// of VM instances across zones in the region.
  /// - NONE: For non-autoscaled groups, proactive redistribution is disabled.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROACTIVE"
  core.String instanceRedistributionType;

  /// The maximum number of instances that can be created above the specified
  /// targetSize during the update process. By default, a fixed value of 1 is
  /// used. This value can be either a fixed number or a percentage if the
  /// instance group has 10 or more instances. If you set a percentage, the
  /// number of instances will be rounded up if necessary.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxSurge.
  FixedOrPercent maxSurge;

  /// The maximum number of instances that can be unavailable during the update
  /// process. An instance is considered available if all of the following
  /// conditions are satisfied:
  ///
  ///
  /// - The instance's status is RUNNING.
  /// - If there is a health check on the instance group, the instance's
  /// liveness health check result must be HEALTHY at least once. If there is no
  /// health check on the group, then the instance only needs to have a status
  /// of RUNNING to be considered available.  By default, a fixed value of 1 is
  /// used. This value can be either a fixed number or a percentage if the
  /// instance group has 10 or more instances. If you set a percentage, the
  /// number of instances will be rounded up if necessary.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxUnavailable.
  FixedOrPercent maxUnavailable;

  /// Minimal action to be taken on an instance. You can specify either RESTART
  /// to restart existing instances or REPLACE to delete and create new
  /// instances from the target template. If you specify a RESTART, the Updater
  /// will attempt to perform that action only. However, if the Updater
  /// determines that the minimal action you specify is not enough to perform
  /// the update, it might perform a more disruptive action.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// What action should be used to replace instances. See
  /// minimal_action.REPLACE
  /// Possible string values are:
  /// - "RECREATE"
  /// - "SUBSTITUTE"
  core.String replacementMethod;

  /// The type of update process. You can specify either PROACTIVE so that the
  /// instance group manager proactively executes actions in order to bring
  /// instances to their target versions or OPPORTUNISTIC so that no action is
  /// proactively executed but the update will be performed as part of other
  /// actions (for example, resizes or recreateInstances calls).
  /// Possible string values are:
  /// - "OPPORTUNISTIC"
  /// - "PROACTIVE"
  core.String type;

  InstanceGroupManagerUpdatePolicy();

  InstanceGroupManagerUpdatePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('instanceRedistributionType')) {
      instanceRedistributionType =
          _json['instanceRedistributionType'] as core.String;
    }
    if (_json.containsKey('maxSurge')) {
      maxSurge = FixedOrPercent.fromJson(
          _json['maxSurge'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxUnavailable')) {
      maxUnavailable = FixedOrPercent.fromJson(
          _json['maxUnavailable'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('replacementMethod')) {
      replacementMethod = _json['replacementMethod'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceRedistributionType != null) {
      _json['instanceRedistributionType'] = instanceRedistributionType;
    }
    if (maxSurge != null) {
      _json['maxSurge'] = maxSurge.toJson();
    }
    if (maxUnavailable != null) {
      _json['maxUnavailable'] = maxUnavailable.toJson();
    }
    if (minimalAction != null) {
      _json['minimalAction'] = minimalAction;
    }
    if (replacementMethod != null) {
      _json['replacementMethod'] = replacementMethod;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class InstanceGroupManagerVersion {
  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create new instances in
  /// the managed instance group until the `targetSize` for this version is
  /// reached.
  core.String instanceTemplate;

  /// Name of the version. Unique among all versions in the scope of this
  /// managed instance group.
  core.String name;

  /// Specifies the intended number of instances to be created from the
  /// instanceTemplate. The final number of instances created from the template
  /// will be equal to:
  /// - If expressed as a fixed number, the minimum of either targetSize.fixed
  /// or instanceGroupManager.targetSize is used.
  /// - if expressed as a percent, the targetSize would be
  /// (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a
  /// remainder, the number is rounded up.  If unset, this version will update
  /// any remaining instances not updated by another version. Read Starting a
  /// canary update for more information.
  FixedOrPercent targetSize;

  InstanceGroupManagerVersion();

  InstanceGroupManagerVersion.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('targetSize')) {
      targetSize = FixedOrPercent.fromJson(
          _json['targetSize'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceTemplate != null) {
      _json['instanceTemplate'] = instanceTemplate;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (targetSize != null) {
      _json['targetSize'] = targetSize.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersAbandonInstancesRequest();

  InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

/// InstanceGroupManagers.applyUpdatesToInstances
class InstanceGroupManagersApplyUpdatesRequest {
  /// The list of URLs of one or more instances for which you want to apply
  /// updates. Each URL can be a full URL or a partial URL, such as
  /// zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the minimum
  /// action is NONE. If your update requires a more disruptive action than you
  /// set with this flag, the necessary action is performed to execute the
  /// update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String mostDisruptiveAllowedAction;

  InstanceGroupManagersApplyUpdatesRequest();

  InstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('mostDisruptiveAllowedAction')) {
      mostDisruptiveAllowedAction =
          _json['mostDisruptiveAllowedAction'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    if (minimalAction != null) {
      _json['minimalAction'] = minimalAction;
    }
    if (mostDisruptiveAllowedAction != null) {
      _json['mostDisruptiveAllowedAction'] = mostDisruptiveAllowedAction;
    }
    return _json;
  }
}

/// InstanceGroupManagers.createInstances
class InstanceGroupManagersCreateInstancesRequest {
  /// [Required] List of specifications of per-instance configs.
  core.List<PerInstanceConfig> instances;

  InstanceGroupManagersCreateInstancesRequest();

  InstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersDeleteInstancesRequest();

  InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

/// InstanceGroupManagers.deletePerInstanceConfigs
class InstanceGroupManagersDeletePerInstanceConfigsReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String> names;

  InstanceGroupManagersDeletePerInstanceConfigsReq();

  InstanceGroupManagersDeletePerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('names')) {
      names = (_json['names'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (names != null) {
      _json['names'] = names;
    }
    return _json;
  }
}

class InstanceGroupManagersListErrorsResponse {
  /// [Output Only] The list of errors of the managed instance group.
  core.List<InstanceManagedByIgmError> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  InstanceGroupManagersListErrorsResponse();

  InstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceManagedByIgmError>((value) =>
              InstanceManagedByIgmError.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    return _json;
  }
}

class InstanceGroupManagersListManagedInstancesResponse {
  /// [Output Only] The list of instances in the managed instance group.
  core.List<ManagedInstance> managedInstances;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  InstanceGroupManagersListManagedInstancesResponse();

  InstanceGroupManagersListManagedInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('managedInstances')) {
      managedInstances = (_json['managedInstances'] as core.List)
          .map<ManagedInstance>((value) => ManagedInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (managedInstances != null) {
      _json['managedInstances'] =
          managedInstances.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    return _json;
  }
}

class InstanceGroupManagersListPerInstanceConfigsRespWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagersListPerInstanceConfigsRespWarningData();

  InstanceGroupManagersListPerInstanceConfigsRespWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupManagersListPerInstanceConfigsRespWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagersListPerInstanceConfigsRespWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagersListPerInstanceConfigsRespWarning();

  InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
      core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagersListPerInstanceConfigsRespWarningData>(
              (value) =>
                  InstanceGroupManagersListPerInstanceConfigsRespWarningData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupManagersListPerInstanceConfigsResp {
  /// [Output Only] The list of PerInstanceConfig.
  core.List<PerInstanceConfig> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  InstanceGroupManagersListPerInstanceConfigsRespWarning warning;

  InstanceGroupManagersListPerInstanceConfigsResp();

  InstanceGroupManagersListPerInstanceConfigsResp.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// InstanceGroupManagers.patchPerInstanceConfigs
class InstanceGroupManagersPatchPerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig> perInstanceConfigs;

  InstanceGroupManagersPatchPerInstanceConfigsReq();

  InstanceGroupManagersPatchPerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (perInstanceConfigs != null) {
      _json['perInstanceConfigs'] =
          perInstanceConfigs.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupManagersRecreateInstancesRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  InstanceGroupManagersRecreateInstancesRequest();

  InstanceGroupManagersRecreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupManagersScopedListWarningData();

  InstanceGroupManagersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] The warning that replaces the list of managed instance groups
/// when the list is empty.
class InstanceGroupManagersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupManagersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupManagersScopedListWarning();

  InstanceGroupManagersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagersScopedListWarningData>((value) =>
              InstanceGroupManagersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupManagersScopedList {
  /// [Output Only] The list of managed instance groups that are contained in
  /// the specified project and zone.
  core.List<InstanceGroupManager> instanceGroupManagers;

  /// [Output Only] The warning that replaces the list of managed instance
  /// groups when the list is empty.
  InstanceGroupManagersScopedListWarning warning;

  InstanceGroupManagersScopedList();

  InstanceGroupManagersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instanceGroupManagers')) {
      instanceGroupManagers = (_json['instanceGroupManagers'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceGroupManagers != null) {
      _json['instanceGroupManagers'] =
          instanceGroupManagers.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group. The group uses this template to create all new instances
  /// in the managed instance group.
  core.String instanceTemplate;

  InstanceGroupManagersSetInstanceTemplateRequest();

  InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceTemplate != null) {
      _json['instanceTemplate'] = instanceTemplate;
    }
    return _json;
  }
}

class InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information. Use this optional
  /// property to prevent conflicts when multiple users change the target pools
  /// settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to. The managed instance group applies these target pools to all of
  /// the instances in the group. Existing instances and new instances in the
  /// group all receive these target pool settings.
  core.List<core.String> targetPools;

  InstanceGroupManagersSetTargetPoolsRequest();

  InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (targetPools != null) {
      _json['targetPools'] = targetPools;
    }
    return _json;
  }
}

/// InstanceGroupManagers.updatePerInstanceConfigs
class InstanceGroupManagersUpdatePerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig> perInstanceConfigs;

  InstanceGroupManagersUpdatePerInstanceConfigsReq();

  InstanceGroupManagersUpdatePerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (perInstanceConfigs != null) {
      _json['perInstanceConfigs'] =
          perInstanceConfigs.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsAddInstancesRequest {
  /// The list of instances to add to the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsAddInstancesRequest();

  InstanceGroupsAddInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsListInstancesWarningData();

  InstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsListInstancesWarning();

  InstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupsListInstancesWarningData>((value) =>
              InstanceGroupsListInstancesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupsListInstances for the list of instances in the
  /// specified instance group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceGroupsListInstancesWarning warning;

  InstanceGroupsListInstances();

  InstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceWithNamedPorts>((value) =>
              InstanceWithNamedPorts.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupsListInstancesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group. Valid
  /// options are ALL or RUNNING. If you do not specify this parameter the list
  /// includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  InstanceGroupsListInstancesRequest();

  InstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceState')) {
      instanceState = _json['instanceState'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceState != null) {
      _json['instanceState'] = instanceState;
    }
    return _json;
  }
}

class InstanceGroupsRemoveInstancesRequest {
  /// The list of instances to remove from the instance group.
  core.List<InstanceReference> instances;

  InstanceGroupsRemoveInstancesRequest();

  InstanceGroupsRemoveInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceGroupsScopedListWarningData();

  InstanceGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that replaces the list of instance
/// groups when the list is empty.
class InstanceGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceGroupsScopedListWarning();

  InstanceGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupsScopedListWarningData>((value) =>
              InstanceGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceGroupsScopedList {
  /// [Output Only] The list of instance groups that are contained in this
  /// scope.
  core.List<InstanceGroup> instanceGroups;

  /// [Output Only] An informational warning that replaces the list of instance
  /// groups when the list is empty.
  InstanceGroupsScopedListWarning warning;

  InstanceGroupsScopedList();

  InstanceGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instanceGroups')) {
      instanceGroups = (_json['instanceGroups'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceGroups != null) {
      _json['instanceGroups'] =
          instanceGroups.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request. A request with an incorrect fingerprint will fail with
  /// error 412 conditionNotMet.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  InstanceGroupsSetNamedPortsRequest();

  InstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (namedPorts != null) {
      _json['namedPorts'] = namedPorts.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListWarningData();

  InstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListWarning();

  InstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceListWarningData>((value) =>
              InstanceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of instances.
class InstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Instance resources.
  core.List<Instance> items;

  /// [Output Only] Type of resource. Always compute#instanceList for lists of
  /// Instance resources.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListWarning warning;

  InstanceList();

  InstanceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Instance>((value) =>
              Instance.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceListReferrersWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceListReferrersWarningData();

  InstanceListReferrersWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceListReferrersWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceListReferrersWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceListReferrersWarning();

  InstanceListReferrersWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceListReferrersWarningData>((value) =>
              InstanceListReferrersWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of instance referrers.
class InstanceListReferrers {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Reference resources.
  core.List<Reference> items;

  /// [Output Only] Type of resource. Always compute#instanceListReferrers for
  /// lists of Instance referrers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceListReferrersWarning warning;

  InstanceListReferrers();

  InstanceListReferrers.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Reference>((value) =>
              Reference.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceListReferrersWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceManagedByIgmError {
  /// [Output Only] Contents of the error.
  InstanceManagedByIgmErrorManagedInstanceError error;

  /// [Output Only] Details of the instance action that triggered this error.
  /// May be null, if the error was not caused by an action on an instance. This
  /// field is optional.
  InstanceManagedByIgmErrorInstanceActionDetails instanceActionDetails;

  /// [Output Only] The time that this error occurred. This value is in RFC3339
  /// text format.
  core.String timestamp;

  InstanceManagedByIgmError();

  InstanceManagedByIgmError.fromJson(core.Map _json) {
    if (_json.containsKey('error')) {
      error = InstanceManagedByIgmErrorManagedInstanceError.fromJson(
          _json['error'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('instanceActionDetails')) {
      instanceActionDetails =
          InstanceManagedByIgmErrorInstanceActionDetails.fromJson(
              _json['instanceActionDetails']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timestamp')) {
      timestamp = _json['timestamp'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (error != null) {
      _json['error'] = error.toJson();
    }
    if (instanceActionDetails != null) {
      _json['instanceActionDetails'] = instanceActionDetails.toJson();
    }
    if (timestamp != null) {
      _json['timestamp'] = timestamp;
    }
    return _json;
  }
}

class InstanceManagedByIgmErrorInstanceActionDetails {
  /// [Output Only] Action that managed instance group was executing on the
  /// instance when the error occurred. Possible values:
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String action;

  /// [Output Only] The URL of the instance. The URL can be set even if the
  /// instance has not yet been created.
  core.String instance;

  /// [Output Only] Version this instance was created from, or was being created
  /// from, but the creation failed. Corresponds to one of the versions that
  /// were set on the Instance Group Manager resource at the time this instance
  /// was being created.
  ManagedInstanceVersion version;

  InstanceManagedByIgmErrorInstanceActionDetails();

  InstanceManagedByIgmErrorInstanceActionDetails.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('version')) {
      version = ManagedInstanceVersion.fromJson(
          _json['version'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (action != null) {
      _json['action'] = action;
    }
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (version != null) {
      _json['version'] = version.toJson();
    }
    return _json;
  }
}

class InstanceManagedByIgmErrorManagedInstanceError {
  /// [Output Only] Error code.
  core.String code;

  /// [Output Only] Error message.
  core.String message;

  InstanceManagedByIgmErrorManagedInstanceError();

  InstanceManagedByIgmErrorManagedInstanceError.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstanceMoveRequest {
  /// The URL of the destination zone to move the instance. This can be a full
  /// or partial URL. For example, the following are all valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String destinationZone;

  /// The URL of the target instance to move. This can be a full or partial URL.
  /// For example, the following are all valid URLs to an instance:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String targetInstance;

  InstanceMoveRequest();

  InstanceMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey('destinationZone')) {
      destinationZone = _json['destinationZone'] as core.String;
    }
    if (_json.containsKey('targetInstance')) {
      targetInstance = _json['targetInstance'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (destinationZone != null) {
      _json['destinationZone'] = destinationZone;
    }
    if (targetInstance != null) {
      _json['targetInstance'] = targetInstance;
    }
    return _json;
  }
}

class InstanceProperties {
  /// Enables instances created based on these properties to send packets with
  /// source IP addresses other than their own and receive packets with
  /// destination IP addresses other than their own. If these instances will be
  /// used as an IP gateway or it will be set as the next-hop in a Route
  /// resource, specify true. If unsure, leave this set to false. See the Enable
  /// IP forwarding documentation for more information.
  core.bool canIpForward;

  /// Specifies the Confidential Instance options.
  ConfidentialInstanceConfig confidentialInstanceConfig;

  /// An optional text description for the instances that are created from these
  /// properties.
  core.String description;

  /// An array of disks that are associated with the instances that are created
  /// from these properties.
  core.List<AttachedDisk> disks;

  /// A list of guest accelerator cards' type and count to use for instances
  /// created from these properties.
  core.List<AcceleratorConfig> guestAccelerators;

  /// Labels to apply to instances that are created from these properties.
  core.Map<core.String, core.String> labels;

  /// The machine type to use for instances that are created from these
  /// properties.
  core.String machineType;

  /// The metadata key/value pairs to assign to instances that are created from
  /// these properties. These pairs can consist of custom metadata or predefined
  /// keys. See Project and instance metadata for more information.
  Metadata metadata;

  /// Minimum cpu/platform to be used by instances. The instance may be
  /// scheduled on the specified or newer cpu/platform. Applicable values are
  /// the friendly names of CPU platforms, such as minCpuPlatform: "Intel
  /// Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information,
  /// read Specifying a Minimum CPU Platform.
  core.String minCpuPlatform;

  /// An array of network access configurations for this interface.
  core.List<NetworkInterface> networkInterfaces;

  /// The private IPv6 google access type for VMs. If not specified, use
  /// INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  /// - "INHERIT_FROM_SUBNETWORK"
  core.String privateIpv6GoogleAccess;

  /// Specifies the reservations that instances can consume from.
  ReservationAffinity reservationAffinity;

  /// Resource policies (names, not ULRs) applied to instances created from
  /// these properties.
  core.List<core.String> resourcePolicies;

  /// Specifies the scheduling options for the instances that are created from
  /// these properties.
  Scheduling scheduling;

  /// A list of service accounts with specified scopes. Access tokens for these
  /// service accounts are available to the instances that are created from
  /// these properties. Use metadata queries to obtain the access tokens for
  /// these instances.
  core.List<ServiceAccount> serviceAccounts;
  ShieldedInstanceConfig shieldedInstanceConfig;

  /// A list of tags to apply to the instances that are created from these
  /// properties. The tags identify valid sources or targets for network
  /// firewalls. The setTags method can modify this list of tags. Each tag
  /// within the list must comply with RFC1035.
  Tags tags;

  InstanceProperties();

  InstanceProperties.fromJson(core.Map _json) {
    if (_json.containsKey('canIpForward')) {
      canIpForward = _json['canIpForward'] as core.bool;
    }
    if (_json.containsKey('confidentialInstanceConfig')) {
      confidentialInstanceConfig = ConfidentialInstanceConfig.fromJson(
          _json['confidentialInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<AttachedDisk>((value) => AttachedDisk.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('metadata')) {
      metadata = Metadata.fromJson(
          _json['metadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
    if (_json.containsKey('networkInterfaces')) {
      networkInterfaces = (_json['networkInterfaces'] as core.List)
          .map<NetworkInterface>((value) => NetworkInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('reservationAffinity')) {
      reservationAffinity = ReservationAffinity.fromJson(
          _json['reservationAffinity'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('scheduling')) {
      scheduling = Scheduling.fromJson(
          _json['scheduling'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('serviceAccounts')) {
      serviceAccounts = (_json['serviceAccounts'] as core.List)
          .map<ServiceAccount>((value) => ServiceAccount.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('shieldedInstanceConfig')) {
      shieldedInstanceConfig = ShieldedInstanceConfig.fromJson(
          _json['shieldedInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tags')) {
      tags =
          Tags.fromJson(_json['tags'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canIpForward != null) {
      _json['canIpForward'] = canIpForward;
    }
    if (confidentialInstanceConfig != null) {
      _json['confidentialInstanceConfig'] = confidentialInstanceConfig.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (disks != null) {
      _json['disks'] = disks.map((value) => value.toJson()).toList();
    }
    if (guestAccelerators != null) {
      _json['guestAccelerators'] =
          guestAccelerators.map((value) => value.toJson()).toList();
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (machineType != null) {
      _json['machineType'] = machineType;
    }
    if (metadata != null) {
      _json['metadata'] = metadata.toJson();
    }
    if (minCpuPlatform != null) {
      _json['minCpuPlatform'] = minCpuPlatform;
    }
    if (networkInterfaces != null) {
      _json['networkInterfaces'] =
          networkInterfaces.map((value) => value.toJson()).toList();
    }
    if (privateIpv6GoogleAccess != null) {
      _json['privateIpv6GoogleAccess'] = privateIpv6GoogleAccess;
    }
    if (reservationAffinity != null) {
      _json['reservationAffinity'] = reservationAffinity.toJson();
    }
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    if (scheduling != null) {
      _json['scheduling'] = scheduling.toJson();
    }
    if (serviceAccounts != null) {
      _json['serviceAccounts'] =
          serviceAccounts.map((value) => value.toJson()).toList();
    }
    if (shieldedInstanceConfig != null) {
      _json['shieldedInstanceConfig'] = shieldedInstanceConfig.toJson();
    }
    if (tags != null) {
      _json['tags'] = tags.toJson();
    }
    return _json;
  }
}

class InstanceReference {
  /// The URL for a specific instance.
  core.String instance;

  InstanceReference();

  InstanceReference.fromJson(core.Map _json) {
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instance != null) {
      _json['instance'] = instance;
    }
    return _json;
  }
}

/// Represents an Instance Template resource.
///
/// You can use instance templates to create VM instances and managed instance
/// groups. For more information, read Instance Templates. (== resource_for
/// {$api_version}.instanceTemplates ==)
class InstanceTemplate {
  /// [Output Only] The creation timestamp for this instance template in RFC3339
  /// text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A unique identifier for this instance template. The server
  /// defines this identifier.
  core.String id;

  /// [Output Only] The resource type, which is always compute#instanceTemplate
  /// for instance templates.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The instance properties for this instance template.
  InstanceProperties properties;

  /// [Output Only] The URL for this instance template. The server defines this
  /// URL.
  core.String selfLink;

  /// The source instance used to create the template. You can provide this as a
  /// partial or full URL to the resource. For example, the following are valid
  /// values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  core.String sourceInstance;

  /// The source instance params to use to create this instance template.
  SourceInstanceParams sourceInstanceParams;

  InstanceTemplate();

  InstanceTemplate.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('properties')) {
      properties = InstanceProperties.fromJson(
          _json['properties'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sourceInstance')) {
      sourceInstance = _json['sourceInstance'] as core.String;
    }
    if (_json.containsKey('sourceInstanceParams')) {
      sourceInstanceParams = SourceInstanceParams.fromJson(
          _json['sourceInstanceParams'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (properties != null) {
      _json['properties'] = properties.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sourceInstance != null) {
      _json['sourceInstance'] = sourceInstance;
    }
    if (sourceInstanceParams != null) {
      _json['sourceInstanceParams'] = sourceInstanceParams.toJson();
    }
    return _json;
  }
}

class InstanceTemplateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstanceTemplateListWarningData();

  InstanceTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InstanceTemplateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstanceTemplateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstanceTemplateListWarning();

  InstanceTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceTemplateListWarningData>((value) =>
              InstanceTemplateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// A list of instance templates.
class InstanceTemplateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceTemplate resources.
  core.List<InstanceTemplate> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceTemplatesListResponse for instance template lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InstanceTemplateListWarning warning;

  InstanceTemplateList();

  InstanceTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceTemplate>((value) => InstanceTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceTemplateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstanceWithNamedPorts {
  /// [Output Only] The URL of the instance.
  core.String instance;

  /// [Output Only] The named ports that belong to this instance group.
  core.List<NamedPort> namedPorts;

  /// [Output Only] The status of the instance.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String status;

  InstanceWithNamedPorts();

  InstanceWithNamedPorts.fromJson(core.Map _json) {
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (namedPorts != null) {
      _json['namedPorts'] = namedPorts.map((value) => value.toJson()).toList();
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

class InstancesAddResourcePoliciesRequest {
  /// Resource policies to be added to this instance.
  core.List<core.String> resourcePolicies;

  InstancesAddResourcePoliciesRequest();

  InstancesAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class InstancesRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this instance.
  core.List<core.String> resourcePolicies;

  InstancesRemoveResourcePoliciesRequest();

  InstancesRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class InstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InstancesScopedListWarningData();

  InstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of instances
/// when the list is empty.
class InstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InstancesScopedListWarning();

  InstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstancesScopedListWarningData>((value) =>
              InstancesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InstancesScopedList {
  /// [Output Only] A list of instances contained in this scope.
  core.List<Instance> instances;

  /// [Output Only] Informational warning which replaces the list of instances
  /// when the list is empty.
  InstancesScopedListWarning warning;

  InstancesScopedList();

  InstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<Instance>((value) =>
              Instance.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstancesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts. Provide the latest fingerprint value when making a
  /// request to add or change labels.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  core.Map<core.String, core.String> labels;

  InstancesSetLabelsRequest();

  InstancesSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    return _json;
  }
}

class InstancesSetMachineResourcesRequest {
  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig> guestAccelerators;

  InstancesSetMachineResourcesRequest();

  InstancesSetMachineResourcesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (guestAccelerators != null) {
      _json['guestAccelerators'] =
          guestAccelerators.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource. See Machine Types for a
  /// full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String machineType;

  InstancesSetMachineTypeRequest();

  InstancesSetMachineTypeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (machineType != null) {
      _json['machineType'] = machineType;
    }
    return _json;
  }
}

class InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String minCpuPlatform;

  InstancesSetMinCpuPlatformRequest();

  InstancesSetMinCpuPlatformRequest.fromJson(core.Map _json) {
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (minCpuPlatform != null) {
      _json['minCpuPlatform'] = minCpuPlatform;
    }
    return _json;
  }
}

class InstancesSetServiceAccountRequest {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  InstancesSetServiceAccountRequest();

  InstancesSetServiceAccountRequest.fromJson(core.Map _json) {
    if (_json.containsKey('email')) {
      email = _json['email'] as core.String;
    }
    if (_json.containsKey('scopes')) {
      scopes = (_json['scopes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (email != null) {
      _json['email'] = email;
    }
    if (scopes != null) {
      _json['scopes'] = scopes;
    }
    return _json;
  }
}

class InstancesStartWithEncryptionKeyRequest {
  /// Array of disks associated with this instance that are protected with a
  /// customer-supplied encryption key.
  ///
  /// In order to start the instance, the disk url and its corresponding key
  /// must be provided.
  ///
  /// If the disk is not protected with a customer-supplied encryption key it
  /// should not be specified.
  core.List<CustomerEncryptionKeyProtectedDisk> disks;

  InstancesStartWithEncryptionKeyRequest();

  InstancesStartWithEncryptionKeyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<CustomerEncryptionKeyProtectedDisk>((value) =>
              CustomerEncryptionKeyProtectedDisk.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (disks != null) {
      _json['disks'] = disks.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// HttpRouteRuleMatch criteria for field values that must stay within the
/// specified integer range.
class Int64RangeMatch {
  /// The end of the range (exclusive) in signed long integer format.
  core.String rangeEnd;

  /// The start of the range (inclusive) in signed long integer format.
  core.String rangeStart;

  Int64RangeMatch();

  Int64RangeMatch.fromJson(core.Map _json) {
    if (_json.containsKey('rangeEnd')) {
      rangeEnd = _json['rangeEnd'] as core.String;
    }
    if (_json.containsKey('rangeStart')) {
      rangeStart = _json['rangeStart'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (rangeEnd != null) {
      _json['rangeEnd'] = rangeEnd;
    }
    if (rangeStart != null) {
      _json['rangeStart'] = rangeStart;
    }
    return _json;
  }
}

/// Represents an Interconnect resource.
///
/// An Interconnect resource is a dedicated connection between the GCP network
/// and your on-premises network. For more information, read the  Dedicated
/// Interconnect Overview. (== resource_for {$api_version}.interconnects ==)
class Interconnect {
  /// Administrative status of the interconnect. When this is set to true, the
  /// Interconnect is functional and can carry traffic. When set to false, no
  /// packets can be carried over the interconnect and no BGP routes are
  /// exchanged over it. By default, the status is set to true.
  core.bool adminEnabled;

  /// [Output Only] A list of CircuitInfo objects, that describe the individual
  /// circuits in this LAG.
  core.List<InterconnectCircuitInfo> circuitInfos;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// Customer name, to put in the Letter of Authorization as the party
  /// authorized to request a crossconnect.
  core.String customerName;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A list of outages expected for this Interconnect.
  core.List<InterconnectOutageNotification> expectedOutages;

  /// [Output Only] IP address configured on the Google side of the Interconnect
  /// link. This can be used only for ping tests.
  core.String googleIpAddress;

  /// [Output Only] Google reference ID to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of the URLs of all InterconnectAttachments configured
  /// to use this Interconnect.
  core.List<core.String> interconnectAttachments;

  /// Type of interconnect, which can take one of the following values:
  /// - PARTNER: A partner-managed interconnection shared between customers
  /// though a partner.
  /// - DEDICATED: A dedicated physical interconnection with the customer. Note
  /// that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "IT_PRIVATE"
  /// - "PARTNER"
  core.String interconnectType;

  /// [Output Only] Type of the resource. Always compute#interconnect for
  /// interconnects.
  core.String kind;

  /// Type of link requested, which can take one of the following values:
  /// - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics
  /// - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that
  /// this field indicates the speed of each of the links in the bundle, not the
  /// speed of the entire bundle.
  /// Possible string values are:
  /// - "LINK_TYPE_ETHERNET_100G_LR"
  /// - "LINK_TYPE_ETHERNET_10G_LR"
  core.String linkType;

  /// URL of the InterconnectLocation object that represents where this
  /// connection is to be provisioned.
  core.String location;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Email address to contact the customer NOC for operations and maintenance
  /// notifications regarding this Interconnect. If specified, this will be used
  /// for notifications in addition to all other forms described, such as
  /// Stackdriver logs alerting and Cloud Notifications.
  core.String nocContactEmail;

  /// [Output Only] The current status of this Interconnect's functionality,
  /// which can take one of the following values:
  /// - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use.
  /// Attachments may be provisioned on this Interconnect.
  /// - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No
  /// attachments may be provisioned on this Interconnect.
  /// - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal
  /// maintenance. No attachments may be provisioned or updated on this
  /// Interconnect.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output Only] IP address configured on the customer side of the
  /// Interconnect link. The customer should configure this IP address during
  /// turnup when prompted by Google NOC. This can be used only for ping tests.
  core.String peerIpAddress;

  /// [Output Only] Number of links actually provisioned in this interconnect.
  core.int provisionedLinkCount;

  /// Target number of physical links in the link bundle, as requested by the
  /// customer.
  core.int requestedLinkCount;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The current state of Interconnect functionality, which can
  /// take one of the following values:
  /// - ACTIVE: The Interconnect is valid, turned up and ready to use.
  /// Attachments may be provisioned on this Interconnect.
  /// - UNPROVISIONED: The Interconnect has not completed turnup. No attachments
  /// may be provisioned on this Interconnect.
  /// - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance.
  /// No attachments may be provisioned or updated on this Interconnect.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "UNPROVISIONED"
  core.String state;

  Interconnect();

  Interconnect.fromJson(core.Map _json) {
    if (_json.containsKey('adminEnabled')) {
      adminEnabled = _json['adminEnabled'] as core.bool;
    }
    if (_json.containsKey('circuitInfos')) {
      circuitInfos = (_json['circuitInfos'] as core.List)
          .map<InterconnectCircuitInfo>((value) =>
              InterconnectCircuitInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customerName')) {
      customerName = _json['customerName'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expectedOutages')) {
      expectedOutages = (_json['expectedOutages'] as core.List)
          .map<InterconnectOutageNotification>((value) =>
              InterconnectOutageNotification.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('googleIpAddress')) {
      googleIpAddress = _json['googleIpAddress'] as core.String;
    }
    if (_json.containsKey('googleReferenceId')) {
      googleReferenceId = _json['googleReferenceId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interconnectAttachments')) {
      interconnectAttachments = (_json['interconnectAttachments'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('interconnectType')) {
      interconnectType = _json['interconnectType'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('linkType')) {
      linkType = _json['linkType'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nocContactEmail')) {
      nocContactEmail = _json['nocContactEmail'] as core.String;
    }
    if (_json.containsKey('operationalStatus')) {
      operationalStatus = _json['operationalStatus'] as core.String;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
    if (_json.containsKey('provisionedLinkCount')) {
      provisionedLinkCount = _json['provisionedLinkCount'] as core.int;
    }
    if (_json.containsKey('requestedLinkCount')) {
      requestedLinkCount = _json['requestedLinkCount'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (adminEnabled != null) {
      _json['adminEnabled'] = adminEnabled;
    }
    if (circuitInfos != null) {
      _json['circuitInfos'] =
          circuitInfos.map((value) => value.toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (customerName != null) {
      _json['customerName'] = customerName;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (expectedOutages != null) {
      _json['expectedOutages'] =
          expectedOutages.map((value) => value.toJson()).toList();
    }
    if (googleIpAddress != null) {
      _json['googleIpAddress'] = googleIpAddress;
    }
    if (googleReferenceId != null) {
      _json['googleReferenceId'] = googleReferenceId;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (interconnectAttachments != null) {
      _json['interconnectAttachments'] = interconnectAttachments;
    }
    if (interconnectType != null) {
      _json['interconnectType'] = interconnectType;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (linkType != null) {
      _json['linkType'] = linkType;
    }
    if (location != null) {
      _json['location'] = location;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (nocContactEmail != null) {
      _json['nocContactEmail'] = nocContactEmail;
    }
    if (operationalStatus != null) {
      _json['operationalStatus'] = operationalStatus;
    }
    if (peerIpAddress != null) {
      _json['peerIpAddress'] = peerIpAddress;
    }
    if (provisionedLinkCount != null) {
      _json['provisionedLinkCount'] = provisionedLinkCount;
    }
    if (requestedLinkCount != null) {
      _json['requestedLinkCount'] = requestedLinkCount;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (state != null) {
      _json['state'] = state;
    }
    return _json;
  }
}

/// Represents an Interconnect Attachment (VLAN) resource.
///
/// You can use Interconnect attachments (VLANS) to connect your Virtual Private
/// Cloud networks to your on-premises networks through an Interconnect. For
/// more information, read  Creating VLAN Attachments. (== resource_for
/// {$api_version}.interconnectAttachments ==)
class InterconnectAttachment {
  /// Determines whether this Attachment will carry packets. Not present for
  /// PARTNER_PROVIDER.
  core.bool adminEnabled;

  /// Provisioned bandwidth capacity for the interconnect attachment. For
  /// attachments of type DEDICATED, the user can set the bandwidth. For
  /// attachments of type PARTNER, the Google Partner that is operating the
  /// interconnect must set the bandwidth. Output only for PARTNER type, mutable
  /// for PARTNER_PROVIDER and DEDICATED, and can take one of the following
  /// values:
  /// - BPS_50M: 50 Mbit/s
  /// - BPS_100M: 100 Mbit/s
  /// - BPS_200M: 200 Mbit/s
  /// - BPS_300M: 300 Mbit/s
  /// - BPS_400M: 400 Mbit/s
  /// - BPS_500M: 500 Mbit/s
  /// - BPS_1G: 1 Gbit/s
  /// - BPS_2G: 2 Gbit/s
  /// - BPS_5G: 5 Gbit/s
  /// - BPS_10G: 10 Gbit/s
  /// - BPS_20G: 20 Gbit/s
  /// - BPS_50G: 50 Gbit/s
  /// Possible string values are:
  /// - "BPS_100M"
  /// - "BPS_10G"
  /// - "BPS_1G"
  /// - "BPS_200M"
  /// - "BPS_20G"
  /// - "BPS_2G"
  /// - "BPS_300M"
  /// - "BPS_400M"
  /// - "BPS_500M"
  /// - "BPS_50G"
  /// - "BPS_50M"
  /// - "BPS_5G"
  core.String bandwidth;

  /// Up to 16 candidate prefixes that can be used to restrict the allocation of
  /// cloudRouterIpAddress and customerRouterIpAddress for this attachment. All
  /// prefixes must be within link-local address space (169.254.0.0/16) and must
  /// be /29 or shorter (/28, /27, etc). Google will attempt to select an unused
  /// /29 from the supplied candidate prefix(es). The request will fail if all
  /// possible /29s are in use on Google's edge. If not supplied, Google will
  /// randomly select an unused /29 from all of link-local space.
  core.List<core.String> candidateSubnets;

  /// [Output Only] IPv4 address + prefix length to be configured on Cloud
  /// Router Interface for this interconnect attachment.
  core.String cloudRouterIpAddress;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] IPv4 address + prefix length to be configured on the
  /// customer router subinterface for this interconnect attachment.
  core.String customerRouterIpAddress;

  /// An optional description of this resource.
  core.String description;

  /// Desired availability domain for the attachment. Only available for type
  /// PARTNER, at creation time, and can take one of the following values:
  /// - AVAILABILITY_DOMAIN_ANY
  /// - AVAILABILITY_DOMAIN_1
  /// - AVAILABILITY_DOMAIN_2 For improved reliability, customers should
  /// configure a pair of attachments, one per availability domain. The selected
  /// availability domain will be provided to the Partner via the pairing key,
  /// so that the provisioned circuit will lie in the specified domain. If not
  /// specified, the value will default to AVAILABILITY_DOMAIN_ANY.
  /// Possible string values are:
  /// - "AVAILABILITY_DOMAIN_1"
  /// - "AVAILABILITY_DOMAIN_2"
  /// - "AVAILABILITY_DOMAIN_ANY"
  core.String edgeAvailabilityDomain;

  /// [Output Only] Google reference ID, to be used when raising support tickets
  /// with Google or otherwise to debug backend connectivity issues.
  /// [Deprecated] This field is not used.
  core.String googleReferenceId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// URL of the underlying Interconnect object that this attachment's traffic
  /// will traverse through.
  core.String interconnect;

  /// [Output Only] Type of the resource. Always compute#interconnectAttachment
  /// for interconnect attachments.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] The current status of whether or not this interconnect
  /// attachment is functional, which can take one of the following values:
  /// - OS_ACTIVE: The attachment has been turned up and is ready to use.
  /// - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup
  /// is not complete.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String operationalStatus;

  /// [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not
  /// present for DEDICATED]. The opaque identifier of an PARTNER attachment
  /// used to initiate provisioning with a selected partner. Of the form
  /// "XXXXX/region/domain"
  core.String pairingKey;

  /// Optional BGP ASN for the router supplied by a Layer 3 Partner if they
  /// configured BGP on behalf of the customer. Output only for PARTNER type,
  /// input only for PARTNER_PROVIDER, not available for DEDICATED.
  core.String partnerAsn;

  /// Informational metadata about Partner attachments from Partners to display
  /// to customers. Output only for for PARTNER type, mutable for
  /// PARTNER_PROVIDER, not available for DEDICATED.
  InterconnectAttachmentPartnerMetadata partnerMetadata;

  /// [Output Only] Information specific to an InterconnectAttachment. This
  /// property is populated if the interconnect that this is attached to is of
  /// type DEDICATED.
  InterconnectAttachmentPrivateInfo privateInterconnectInfo;

  /// [Output Only] URL of the region where the regional interconnect attachment
  /// resides. You must specify this field as part of the HTTP request URL. It
  /// is not settable as a field in the request body.
  core.String region;

  /// URL of the Cloud Router to be used for dynamic routing. This router must
  /// be in the same region as this InterconnectAttachment. The
  /// InterconnectAttachment will automatically connect the Interconnect to the
  /// network & region within which the Cloud Router is configured.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The current state of this attachment's functionality. Enum
  /// values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER,
  /// and PARTNER_PROVIDER interconnect attachments, while enum values
  /// PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used
  /// for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state
  /// can take one of the following values:
  /// - ACTIVE: The attachment has been turned up and is ready to use.
  /// - UNPROVISIONED: The attachment is not ready to use yet, because turnup is
  /// not complete.
  /// - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet
  /// been configured on the Partner side.
  /// - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of
  /// provisioning after a PARTNER_PROVIDER attachment was created that
  /// references it.
  /// - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is
  /// waiting for a customer to activate it.
  /// - DEFUNCT: The attachment was deleted externally and is no longer
  /// functional. This could be because the associated Interconnect was removed,
  /// or because the other side of a Partner attachment was deleted.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DEFUNCT"
  /// - "PARTNER_REQUEST_RECEIVED"
  /// - "PENDING_CUSTOMER"
  /// - "PENDING_PARTNER"
  /// - "STATE_UNSPECIFIED"
  /// - "UNPROVISIONED"
  core.String state;

  /// The type of interconnect attachment this is, which can take one of the
  /// following values:
  /// - DEDICATED: an attachment to a Dedicated Interconnect.
  /// - PARTNER: an attachment to a Partner Interconnect, created by the
  /// customer.
  /// - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by
  /// the partner.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "PARTNER"
  /// - "PARTNER_PROVIDER"
  core.String type;

  /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only
  /// specified at creation time.
  core.int vlanTag8021q;

  InterconnectAttachment();

  InterconnectAttachment.fromJson(core.Map _json) {
    if (_json.containsKey('adminEnabled')) {
      adminEnabled = _json['adminEnabled'] as core.bool;
    }
    if (_json.containsKey('bandwidth')) {
      bandwidth = _json['bandwidth'] as core.String;
    }
    if (_json.containsKey('candidateSubnets')) {
      candidateSubnets = (_json['candidateSubnets'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('cloudRouterIpAddress')) {
      cloudRouterIpAddress = _json['cloudRouterIpAddress'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customerRouterIpAddress')) {
      customerRouterIpAddress = _json['customerRouterIpAddress'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('edgeAvailabilityDomain')) {
      edgeAvailabilityDomain = _json['edgeAvailabilityDomain'] as core.String;
    }
    if (_json.containsKey('googleReferenceId')) {
      googleReferenceId = _json['googleReferenceId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interconnect')) {
      interconnect = _json['interconnect'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('operationalStatus')) {
      operationalStatus = _json['operationalStatus'] as core.String;
    }
    if (_json.containsKey('pairingKey')) {
      pairingKey = _json['pairingKey'] as core.String;
    }
    if (_json.containsKey('partnerAsn')) {
      partnerAsn = _json['partnerAsn'] as core.String;
    }
    if (_json.containsKey('partnerMetadata')) {
      partnerMetadata = InterconnectAttachmentPartnerMetadata.fromJson(
          _json['partnerMetadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('privateInterconnectInfo')) {
      privateInterconnectInfo = InterconnectAttachmentPrivateInfo.fromJson(
          _json['privateInterconnectInfo']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('router')) {
      router = _json['router'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('vlanTag8021q')) {
      vlanTag8021q = _json['vlanTag8021q'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (adminEnabled != null) {
      _json['adminEnabled'] = adminEnabled;
    }
    if (bandwidth != null) {
      _json['bandwidth'] = bandwidth;
    }
    if (candidateSubnets != null) {
      _json['candidateSubnets'] = candidateSubnets;
    }
    if (cloudRouterIpAddress != null) {
      _json['cloudRouterIpAddress'] = cloudRouterIpAddress;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (customerRouterIpAddress != null) {
      _json['customerRouterIpAddress'] = customerRouterIpAddress;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (edgeAvailabilityDomain != null) {
      _json['edgeAvailabilityDomain'] = edgeAvailabilityDomain;
    }
    if (googleReferenceId != null) {
      _json['googleReferenceId'] = googleReferenceId;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (interconnect != null) {
      _json['interconnect'] = interconnect;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (operationalStatus != null) {
      _json['operationalStatus'] = operationalStatus;
    }
    if (pairingKey != null) {
      _json['pairingKey'] = pairingKey;
    }
    if (partnerAsn != null) {
      _json['partnerAsn'] = partnerAsn;
    }
    if (partnerMetadata != null) {
      _json['partnerMetadata'] = partnerMetadata.toJson();
    }
    if (privateInterconnectInfo != null) {
      _json['privateInterconnectInfo'] = privateInterconnectInfo.toJson();
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (router != null) {
      _json['router'] = router;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (state != null) {
      _json['state'] = state;
    }
    if (type != null) {
      _json['type'] = type;
    }
    if (vlanTag8021q != null) {
      _json['vlanTag8021q'] = vlanTag8021q;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentAggregatedListWarningData();

  InterconnectAttachmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentAggregatedListWarning();

  InterconnectAttachmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentAggregatedListWarningData>((value) =>
              InterconnectAttachmentAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachmentsScopedList resources.
  core.Map<core.String, InterconnectAttachmentsScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#interconnectAttachmentAggregatedList for aggregated lists of
  /// interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentAggregatedListWarning warning;

  InterconnectAttachmentAggregatedList();

  InterconnectAttachmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              InterconnectAttachmentsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class InterconnectAttachmentListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentListWarningData();

  InterconnectAttachmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectAttachmentListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentListWarning();

  InterconnectAttachmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentListWarningData>((value) =>
              InterconnectAttachmentListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect
/// attachments.
class InterconnectAttachmentList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectAttachment resources.
  core.List<InterconnectAttachment> items;

  /// [Output Only] Type of resource. Always compute#interconnectAttachmentList
  /// for lists of interconnect attachments.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectAttachmentListWarning warning;

  InterconnectAttachmentList();

  InterconnectAttachmentList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InterconnectAttachment>((value) =>
              InterconnectAttachment.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Informational metadata about Partner attachments from Partners to display to
/// customers. These fields are propagated from PARTNER_PROVIDER attachments to
/// their corresponding PARTNER attachments.
class InterconnectAttachmentPartnerMetadata {
  /// Plain text name of the Interconnect this attachment is connected to, as
  /// displayed in the Partner's portal. For instance "Chicago 1". This value
  /// may be validated to match approved Partner values.
  core.String interconnectName;

  /// Plain text name of the Partner providing this attachment. This value may
  /// be validated to match approved Partner values.
  core.String partnerName;

  /// URL of the Partner's portal for this Attachment. Partners may customise
  /// this to be a deep link to the specific resource on the Partner portal.
  /// This value may be validated to match approved Partner values.
  core.String portalUrl;

  InterconnectAttachmentPartnerMetadata();

  InterconnectAttachmentPartnerMetadata.fromJson(core.Map _json) {
    if (_json.containsKey('interconnectName')) {
      interconnectName = _json['interconnectName'] as core.String;
    }
    if (_json.containsKey('partnerName')) {
      partnerName = _json['partnerName'] as core.String;
    }
    if (_json.containsKey('portalUrl')) {
      portalUrl = _json['portalUrl'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (interconnectName != null) {
      _json['interconnectName'] = interconnectName;
    }
    if (partnerName != null) {
      _json['partnerName'] = partnerName;
    }
    if (portalUrl != null) {
      _json['portalUrl'] = portalUrl;
    }
    return _json;
  }
}

/// Information for an interconnect attachment when this belongs to an
/// interconnect of type DEDICATED.
class InterconnectAttachmentPrivateInfo {
  /// [Output Only] 802.1q encapsulation tag to be used for traffic between
  /// Google and the customer, going to and from this network and region.
  core.int tag8021q;

  InterconnectAttachmentPrivateInfo();

  InterconnectAttachmentPrivateInfo.fromJson(core.Map _json) {
    if (_json.containsKey('tag8021q')) {
      tag8021q = _json['tag8021q'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (tag8021q != null) {
      _json['tag8021q'] = tag8021q;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectAttachmentsScopedListWarningData();

  InterconnectAttachmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class InterconnectAttachmentsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectAttachmentsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectAttachmentsScopedListWarning();

  InterconnectAttachmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentsScopedListWarningData>((value) =>
              InterconnectAttachmentsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class InterconnectAttachmentsScopedList {
  /// A list of interconnect attachments contained in this scope.
  core.List<InterconnectAttachment> interconnectAttachments;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  InterconnectAttachmentsScopedListWarning warning;

  InterconnectAttachmentsScopedList();

  InterconnectAttachmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('interconnectAttachments')) {
      interconnectAttachments = (_json['interconnectAttachments'] as core.List)
          .map<InterconnectAttachment>((value) =>
              InterconnectAttachment.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (interconnectAttachments != null) {
      _json['interconnectAttachments'] =
          interconnectAttachments.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Describes a single physical circuit between the Customer and Google.
/// CircuitInfo objects are created by Google, so all fields are output only.
class InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String customerDemarcId;

  /// Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
  core.String googleCircuitId;

  /// Google-side demarc ID for this circuit. Assigned at circuit turn-up and
  /// provided by Google to the customer in the LOA.
  core.String googleDemarcId;

  InterconnectCircuitInfo();

  InterconnectCircuitInfo.fromJson(core.Map _json) {
    if (_json.containsKey('customerDemarcId')) {
      customerDemarcId = _json['customerDemarcId'] as core.String;
    }
    if (_json.containsKey('googleCircuitId')) {
      googleCircuitId = _json['googleCircuitId'] as core.String;
    }
    if (_json.containsKey('googleDemarcId')) {
      googleDemarcId = _json['googleDemarcId'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (customerDemarcId != null) {
      _json['customerDemarcId'] = customerDemarcId;
    }
    if (googleCircuitId != null) {
      _json['googleCircuitId'] = googleCircuitId;
    }
    if (googleDemarcId != null) {
      _json['googleDemarcId'] = googleDemarcId;
    }
    return _json;
  }
}

/// Diagnostics information about interconnect, contains detailed and current
/// technical information about Google's side of the connection.
class InterconnectDiagnostics {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing individual
  /// neighbors currently seen by the Google router in the ARP cache for the
  /// Interconnect. This will be empty when the Interconnect is not bundled.
  core.List<InterconnectDiagnosticsARPEntry> arpCaches;

  /// A list of InterconnectDiagnostics.LinkStatus objects, describing the
  /// status for each link on the Interconnect.
  core.List<InterconnectDiagnosticsLinkStatus> links;

  /// The MAC address of the Interconnect's bundle interface.
  core.String macAddress;

  InterconnectDiagnostics();

  InterconnectDiagnostics.fromJson(core.Map _json) {
    if (_json.containsKey('arpCaches')) {
      arpCaches = (_json['arpCaches'] as core.List)
          .map<InterconnectDiagnosticsARPEntry>((value) =>
              InterconnectDiagnosticsARPEntry.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('links')) {
      links = (_json['links'] as core.List)
          .map<InterconnectDiagnosticsLinkStatus>((value) =>
              InterconnectDiagnosticsLinkStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('macAddress')) {
      macAddress = _json['macAddress'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (arpCaches != null) {
      _json['arpCaches'] = arpCaches.map((value) => value.toJson()).toList();
    }
    if (links != null) {
      _json['links'] = links.map((value) => value.toJson()).toList();
    }
    if (macAddress != null) {
      _json['macAddress'] = macAddress;
    }
    return _json;
  }
}

/// Describing the ARP neighbor entries seen on this link
class InterconnectDiagnosticsARPEntry {
  /// The IP address of this ARP neighbor.
  core.String ipAddress;

  /// The MAC address of this ARP neighbor.
  core.String macAddress;

  InterconnectDiagnosticsARPEntry();

  InterconnectDiagnosticsARPEntry.fromJson(core.Map _json) {
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('macAddress')) {
      macAddress = _json['macAddress'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    if (macAddress != null) {
      _json['macAddress'] = macAddress;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkLACPStatus {
  /// System ID of the port on Google's side of the LACP exchange.
  core.String googleSystemId;

  /// System ID of the port on the neighbor's side of the LACP exchange.
  core.String neighborSystemId;

  /// The state of a LACP link, which can take one of the following values:
  /// - ACTIVE: The link is configured and active within the bundle.
  /// - DETACHED: The link is not configured within the bundle. This means that
  /// the rest of the object should be empty.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DETACHED"
  core.String state;

  InterconnectDiagnosticsLinkLACPStatus();

  InterconnectDiagnosticsLinkLACPStatus.fromJson(core.Map _json) {
    if (_json.containsKey('googleSystemId')) {
      googleSystemId = _json['googleSystemId'] as core.String;
    }
    if (_json.containsKey('neighborSystemId')) {
      neighborSystemId = _json['neighborSystemId'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (googleSystemId != null) {
      _json['googleSystemId'] = googleSystemId;
    }
    if (neighborSystemId != null) {
      _json['neighborSystemId'] = neighborSystemId;
    }
    if (state != null) {
      _json['state'] = state;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkOpticalPower {
  /// The status of the current value when compared to the warning and alarm
  /// levels for the receiving or transmitting transceiver. Possible states
  /// include:
  /// - OK: The value has not crossed a warning threshold.
  /// - LOW_WARNING: The value has crossed below the low warning threshold.
  /// - HIGH_WARNING: The value has crossed above the high warning threshold.
  /// - LOW_ALARM: The value has crossed below the low alarm threshold.
  /// - HIGH_ALARM: The value has crossed above the high alarm threshold.
  /// Possible string values are:
  /// - "HIGH_ALARM"
  /// - "HIGH_WARNING"
  /// - "LOW_ALARM"
  /// - "LOW_WARNING"
  /// - "OK"
  core.String state;

  /// Value of the current receiving or transmitting optical power, read in dBm.
  /// Take a known good optical value, give it a 10% margin and trigger warnings
  /// relative to that value. In general, a -7dBm warning and a -11dBm alarm are
  /// good optical value estimates for most links.
  core.double value;

  InterconnectDiagnosticsLinkOpticalPower();

  InterconnectDiagnosticsLinkOpticalPower.fromJson(core.Map _json) {
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = (_json['value'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (state != null) {
      _json['state'] = state;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

class InterconnectDiagnosticsLinkStatus {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
  /// neighbor entries seen on this link. This will be empty if the link is
  /// bundled
  core.List<InterconnectDiagnosticsARPEntry> arpCaches;

  /// The unique ID for this link assigned during turn up by Google.
  core.String circuitId;

  /// The Demarc address assigned by Google and provided in the LoA.
  core.String googleDemarc;
  InterconnectDiagnosticsLinkLACPStatus lacpStatus;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the received light level.
  InterconnectDiagnosticsLinkOpticalPower receivingOpticalPower;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the transmitted light level.
  InterconnectDiagnosticsLinkOpticalPower transmittingOpticalPower;

  InterconnectDiagnosticsLinkStatus();

  InterconnectDiagnosticsLinkStatus.fromJson(core.Map _json) {
    if (_json.containsKey('arpCaches')) {
      arpCaches = (_json['arpCaches'] as core.List)
          .map<InterconnectDiagnosticsARPEntry>((value) =>
              InterconnectDiagnosticsARPEntry.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('circuitId')) {
      circuitId = _json['circuitId'] as core.String;
    }
    if (_json.containsKey('googleDemarc')) {
      googleDemarc = _json['googleDemarc'] as core.String;
    }
    if (_json.containsKey('lacpStatus')) {
      lacpStatus = InterconnectDiagnosticsLinkLACPStatus.fromJson(
          _json['lacpStatus'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('receivingOpticalPower')) {
      receivingOpticalPower = InterconnectDiagnosticsLinkOpticalPower.fromJson(
          _json['receivingOpticalPower']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('transmittingOpticalPower')) {
      transmittingOpticalPower =
          InterconnectDiagnosticsLinkOpticalPower.fromJson(
              _json['transmittingOpticalPower']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (arpCaches != null) {
      _json['arpCaches'] = arpCaches.map((value) => value.toJson()).toList();
    }
    if (circuitId != null) {
      _json['circuitId'] = circuitId;
    }
    if (googleDemarc != null) {
      _json['googleDemarc'] = googleDemarc;
    }
    if (lacpStatus != null) {
      _json['lacpStatus'] = lacpStatus.toJson();
    }
    if (receivingOpticalPower != null) {
      _json['receivingOpticalPower'] = receivingOpticalPower.toJson();
    }
    if (transmittingOpticalPower != null) {
      _json['transmittingOpticalPower'] = transmittingOpticalPower.toJson();
    }
    return _json;
  }
}

class InterconnectListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectListWarningData();

  InterconnectListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectListWarning();

  InterconnectListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectListWarningData>((value) =>
              InterconnectListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnects.
class InterconnectList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Interconnect resources.
  core.List<Interconnect> items;

  /// [Output Only] Type of resource. Always compute#interconnectList for lists
  /// of interconnects.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectListWarning warning;

  InterconnectList();

  InterconnectList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Interconnect>((value) => Interconnect.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents an Interconnect Attachment (VLAN) Location resource.
///
/// You can use this resource to find location details about an Interconnect
/// attachment (VLAN). For more information about interconnect attachments, read
/// Creating VLAN Attachments.
class InterconnectLocation {
  /// [Output Only] The postal address of the Point of Presence, each line in
  /// the address is separated by a newline character.
  core.String address;

  /// [Output Only] Availability zone for this InterconnectLocation. Within a
  /// metropolitan area (metro), maintenance will not be simultaneously
  /// scheduled in more than one availability zone. Example: "zone1" or "zone2".
  core.String availabilityZone;

  /// [Output Only] Metropolitan area designator that indicates which city an
  /// interconnect is located. For example: "Chicago, IL", "Amsterdam,
  /// Netherlands".
  core.String city;

  /// [Output Only] Continent for this location, which can take one of the
  /// following values:
  /// - AFRICA
  /// - ASIA_PAC
  /// - EUROPE
  /// - NORTH_AMERICA
  /// - SOUTH_AMERICA
  /// Possible string values are:
  /// - "AFRICA"
  /// - "ASIA_PAC"
  /// - "C_AFRICA"
  /// - "C_ASIA_PAC"
  /// - "C_EUROPE"
  /// - "C_NORTH_AMERICA"
  /// - "C_SOUTH_AMERICA"
  /// - "EUROPE"
  /// - "NORTH_AMERICA"
  /// - "SOUTH_AMERICA"
  core.String continent;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] An optional description of the resource.
  core.String description;

  /// [Output Only] The name of the provider for this facility (e.g., EQUINIX).
  core.String facilityProvider;

  /// [Output Only] A provider-assigned Identifier for this facility (e.g.,
  /// Ashburn-DC1).
  core.String facilityProviderFacilityId;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#interconnectLocation
  /// for interconnect locations.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] The peeringdb identifier for this facility (corresponding
  /// with a netfac type in peeringdb).
  core.String peeringdbFacilityId;

  /// [Output Only] A list of InterconnectLocation.RegionInfo objects, that
  /// describe parameters pertaining to the relation between this
  /// InterconnectLocation and various Google Cloud regions.
  core.List<InterconnectLocationRegionInfo> regionInfos;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of this InterconnectLocation, which can take one
  /// of the following values:
  /// - CLOSED: The InterconnectLocation is closed and is unavailable for
  /// provisioning new Interconnects.
  /// - AVAILABLE: The InterconnectLocation is available for provisioning new
  /// Interconnects.
  /// Possible string values are:
  /// - "AVAILABLE"
  /// - "CLOSED"
  core.String status;

  InterconnectLocation();

  InterconnectLocation.fromJson(core.Map _json) {
    if (_json.containsKey('address')) {
      address = _json['address'] as core.String;
    }
    if (_json.containsKey('availabilityZone')) {
      availabilityZone = _json['availabilityZone'] as core.String;
    }
    if (_json.containsKey('city')) {
      city = _json['city'] as core.String;
    }
    if (_json.containsKey('continent')) {
      continent = _json['continent'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('facilityProvider')) {
      facilityProvider = _json['facilityProvider'] as core.String;
    }
    if (_json.containsKey('facilityProviderFacilityId')) {
      facilityProviderFacilityId =
          _json['facilityProviderFacilityId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peeringdbFacilityId')) {
      peeringdbFacilityId = _json['peeringdbFacilityId'] as core.String;
    }
    if (_json.containsKey('regionInfos')) {
      regionInfos = (_json['regionInfos'] as core.List)
          .map<InterconnectLocationRegionInfo>((value) =>
              InterconnectLocationRegionInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (address != null) {
      _json['address'] = address;
    }
    if (availabilityZone != null) {
      _json['availabilityZone'] = availabilityZone;
    }
    if (city != null) {
      _json['city'] = city;
    }
    if (continent != null) {
      _json['continent'] = continent;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (facilityProvider != null) {
      _json['facilityProvider'] = facilityProvider;
    }
    if (facilityProviderFacilityId != null) {
      _json['facilityProviderFacilityId'] = facilityProviderFacilityId;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (peeringdbFacilityId != null) {
      _json['peeringdbFacilityId'] = peeringdbFacilityId;
    }
    if (regionInfos != null) {
      _json['regionInfos'] =
          regionInfos.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

class InterconnectLocationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  InterconnectLocationListWarningData();

  InterconnectLocationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class InterconnectLocationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<InterconnectLocationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  InterconnectLocationListWarning();

  InterconnectLocationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectLocationListWarningData>((value) =>
              InterconnectLocationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Response to the list request, and contains a list of interconnect locations.
class InterconnectLocationList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InterconnectLocation resources.
  core.List<InterconnectLocation> items;

  /// [Output Only] Type of resource. Always compute#interconnectLocationList
  /// for lists of interconnect locations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  InterconnectLocationListWarning warning;

  InterconnectLocationList();

  InterconnectLocationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InterconnectLocation>((value) => InterconnectLocation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectLocationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Information about any potential InterconnectAttachments between an
/// Interconnect at a specific InterconnectLocation, and a specific Cloud
/// Region.
class InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "LOCAL_REGION"
  /// - "LP_GLOBAL"
  /// - "LP_LOCAL_REGION"
  core.String locationPresence;

  /// URL for the region of this location.
  core.String region;

  InterconnectLocationRegionInfo();

  InterconnectLocationRegionInfo.fromJson(core.Map _json) {
    if (_json.containsKey('expectedRttMs')) {
      expectedRttMs = _json['expectedRttMs'] as core.String;
    }
    if (_json.containsKey('locationPresence')) {
      locationPresence = _json['locationPresence'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (expectedRttMs != null) {
      _json['expectedRttMs'] = expectedRttMs;
    }
    if (locationPresence != null) {
      _json['locationPresence'] = locationPresence;
    }
    if (region != null) {
      _json['region'] = region;
    }
    return _json;
  }
}

/// Description of a planned outage on this Interconnect.
class InterconnectOutageNotification {
  /// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String> affectedCircuits;

  /// A description about the purpose of the outage.
  core.String description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String endTime;

  /// Form this outage is expected to take, which can take one of the following
  /// values:
  /// - OUTAGE: The Interconnect may be completely out of service for some or
  /// all of the specified window.
  /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole
  /// should remain up, but with reduced bandwidth. Note that the versions of
  /// this enum prefixed with "IT_" have been deprecated in favor of the
  /// unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE"
  /// - "IT_PARTIAL_OUTAGE"
  /// - "OUTAGE"
  /// - "PARTIAL_OUTAGE"
  core.String issueType;

  /// Unique identifier for this outage notification.
  core.String name;

  /// The party that generated this notification, which can take the following
  /// value:
  /// - GOOGLE: this notification as generated by Google. Note that the value of
  /// NSRC_GOOGLE has been deprecated in favor of GOOGLE.
  /// Possible string values are:
  /// - "GOOGLE"
  /// - "NSRC_GOOGLE"
  core.String source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String startTime;

  /// State of this notification, which can take one of the following values:
  /// - ACTIVE: This outage notification is active. The event could be in the
  /// past, present, or future. See start_time and end_time for scheduling.
  /// - CANCELLED: The outage associated with this notification was cancelled
  /// before the outage was due to start. Note that the versions of this enum
  /// prefixed with "NS_" have been deprecated in favor of the unprefixed
  /// values.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CANCELLED"
  /// - "COMPLETED"
  /// - "NS_ACTIVE"
  /// - "NS_CANCELED"
  core.String state;

  InterconnectOutageNotification();

  InterconnectOutageNotification.fromJson(core.Map _json) {
    if (_json.containsKey('affectedCircuits')) {
      affectedCircuits = (_json['affectedCircuits'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTime')) {
      endTime = _json['endTime'] as core.String;
    }
    if (_json.containsKey('issueType')) {
      issueType = _json['issueType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (affectedCircuits != null) {
      _json['affectedCircuits'] = affectedCircuits;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (endTime != null) {
      _json['endTime'] = endTime;
    }
    if (issueType != null) {
      _json['issueType'] = issueType;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (source != null) {
      _json['source'] = source;
    }
    if (startTime != null) {
      _json['startTime'] = startTime;
    }
    if (state != null) {
      _json['state'] = state;
    }
    return _json;
  }
}

/// Response for the InterconnectsGetDiagnosticsRequest.
class InterconnectsGetDiagnosticsResponse {
  InterconnectDiagnostics result;

  InterconnectsGetDiagnosticsResponse();

  InterconnectsGetDiagnosticsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = InterconnectDiagnostics.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (result != null) {
      _json['result'] = result.toJson();
    }
    return _json;
  }
}

/// Represents a License resource.
///
/// A License represents billing and aggregate usage data for public and
/// marketplace images.  Caution This resource is intended for use only by
/// third-party partners who are creating Cloud Marketplace images. (==
/// resource_for {$api_version}.licenses ==)
class License {
  /// [Output Only] Deprecated. This field no longer reflects whether a license
  /// charges a usage fee.
  core.bool chargesUseFee;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#license for licenses.
  core.String kind;

  /// [Output Only] The unique code used to attach this license to images,
  /// snapshots, and disks.
  core.String licenseCode;

  /// Name of the resource. The name must be 1-63 characters long and comply
  /// with RFC1035.
  core.String name;
  LicenseResourceRequirements resourceRequirements;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// If false, licenses will not be copied from the source resource when
  /// creating an image from a disk, disk from snapshot, or snapshot from disk.
  core.bool transferable;

  License();

  License.fromJson(core.Map _json) {
    if (_json.containsKey('chargesUseFee')) {
      chargesUseFee = _json['chargesUseFee'] as core.bool;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseCode')) {
      licenseCode = _json['licenseCode'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('resourceRequirements')) {
      resourceRequirements = LicenseResourceRequirements.fromJson(
          _json['resourceRequirements'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('transferable')) {
      transferable = _json['transferable'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (chargesUseFee != null) {
      _json['chargesUseFee'] = chargesUseFee;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (licenseCode != null) {
      _json['licenseCode'] = licenseCode;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (resourceRequirements != null) {
      _json['resourceRequirements'] = resourceRequirements.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (transferable != null) {
      _json['transferable'] = transferable;
    }
    return _json;
  }
}

/// Represents a License Code resource.
///
/// A License Code is a unique identifier used to represent a license resource.
/// Caution This resource is intended for use only by third-party partners who
/// are creating Cloud Marketplace images. (== resource_for
/// {$api_version}.licenseCodes ==)
class LicenseCode {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] Description of this License Code.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#licenseCode for licenses.
  core.String kind;

  /// [Output Only] URL and description aliases of Licenses with the same
  /// License Code.
  core.List<LicenseCodeLicenseAlias> licenseAlias;

  /// [Output Only] Name of the resource. The name is 1-20 characters long and
  /// must be a valid 64 bit integer.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Current state of this License Code.
  /// Possible string values are:
  /// - "DISABLED"
  /// - "ENABLED"
  /// - "RESTRICTED"
  /// - "STATE_UNSPECIFIED"
  /// - "TERMINATED"
  core.String state;

  /// [Output Only] If true, the license will remain attached when creating
  /// images or snapshots from disks. Otherwise, the license is not transferred.
  core.bool transferable;

  LicenseCode();

  LicenseCode.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseAlias')) {
      licenseAlias = (_json['licenseAlias'] as core.List)
          .map<LicenseCodeLicenseAlias>((value) =>
              LicenseCodeLicenseAlias.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('transferable')) {
      transferable = _json['transferable'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (licenseAlias != null) {
      _json['licenseAlias'] =
          licenseAlias.map((value) => value.toJson()).toList();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (state != null) {
      _json['state'] = state;
    }
    if (transferable != null) {
      _json['transferable'] = transferable;
    }
    return _json;
  }
}

class LicenseCodeLicenseAlias {
  /// [Output Only] Description of this License Code.
  core.String description;

  /// [Output Only] URL of license corresponding to this License Code.
  core.String selfLink;

  LicenseCodeLicenseAlias();

  LicenseCodeLicenseAlias.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// Commitment for a particular license resource.
class LicenseResourceCommitment {
  /// The number of licenses purchased.
  core.String amount;

  /// Specifies the core range of the instance for which this license applies.
  core.String coresPerLicense;

  /// Any applicable license URI.
  core.String license;

  LicenseResourceCommitment();

  LicenseResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey('amount')) {
      amount = _json['amount'] as core.String;
    }
    if (_json.containsKey('coresPerLicense')) {
      coresPerLicense = _json['coresPerLicense'] as core.String;
    }
    if (_json.containsKey('license')) {
      license = _json['license'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (amount != null) {
      _json['amount'] = amount;
    }
    if (coresPerLicense != null) {
      _json['coresPerLicense'] = coresPerLicense;
    }
    if (license != null) {
      _json['license'] = license;
    }
    return _json;
  }
}

class LicenseResourceRequirements {
  /// Minimum number of guest cpus required to use the Instance. Enforced at
  /// Instance creation and Instance start.
  core.int minGuestCpuCount;

  /// Minimum memory required to use the Instance. Enforced at Instance creation
  /// and Instance start.
  core.int minMemoryMb;

  LicenseResourceRequirements();

  LicenseResourceRequirements.fromJson(core.Map _json) {
    if (_json.containsKey('minGuestCpuCount')) {
      minGuestCpuCount = _json['minGuestCpuCount'] as core.int;
    }
    if (_json.containsKey('minMemoryMb')) {
      minMemoryMb = _json['minMemoryMb'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (minGuestCpuCount != null) {
      _json['minGuestCpuCount'] = minGuestCpuCount;
    }
    if (minMemoryMb != null) {
      _json['minMemoryMb'] = minMemoryMb;
    }
    return _json;
  }
}

class LicensesListResponseWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  LicensesListResponseWarningData();

  LicensesListResponseWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class LicensesListResponseWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<LicensesListResponseWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  LicensesListResponseWarning();

  LicensesListResponseWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<LicensesListResponseWarningData>((value) =>
              LicensesListResponseWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class LicensesListResponse {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of License resources.
  core.List<License> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  LicensesListResponseWarning warning;

  LicensesListResponse();

  LicensesListResponse.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<License>((value) =>
              License.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = LicensesListResponseWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Specifies what kind of log the caller must write
class LogConfig {
  /// Cloud audit options.
  LogConfigCloudAuditOptions cloudAudit;

  /// Counter options.
  LogConfigCounterOptions counter;

  /// Data access options.
  LogConfigDataAccessOptions dataAccess;

  LogConfig();

  LogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('cloudAudit')) {
      cloudAudit = LogConfigCloudAuditOptions.fromJson(
          _json['cloudAudit'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('counter')) {
      counter = LogConfigCounterOptions.fromJson(
          _json['counter'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('dataAccess')) {
      dataAccess = LogConfigDataAccessOptions.fromJson(
          _json['dataAccess'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cloudAudit != null) {
      _json['cloudAudit'] = cloudAudit.toJson();
    }
    if (counter != null) {
      _json['counter'] = counter.toJson();
    }
    if (dataAccess != null) {
      _json['dataAccess'] = dataAccess.toJson();
    }
    return _json;
  }
}

/// Write a Cloud Audit log
class LogConfigCloudAuditOptions {
  /// Information used by the Cloud Audit Logging pipeline.
  AuthorizationLoggingOptions authorizationLoggingOptions;

  /// The log_name to populate in the Cloud Audit Record.
  /// Possible string values are:
  /// - "ADMIN_ACTIVITY"
  /// - "DATA_ACCESS"
  /// - "UNSPECIFIED_LOG_NAME"
  core.String logName;

  LogConfigCloudAuditOptions();

  LogConfigCloudAuditOptions.fromJson(core.Map _json) {
    if (_json.containsKey('authorizationLoggingOptions')) {
      authorizationLoggingOptions = AuthorizationLoggingOptions.fromJson(
          _json['authorizationLoggingOptions']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('logName')) {
      logName = _json['logName'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (authorizationLoggingOptions != null) {
      _json['authorizationLoggingOptions'] =
          authorizationLoggingOptions.toJson();
    }
    if (logName != null) {
      _json['logName'] = logName;
    }
    return _json;
  }
}

/// Increment a streamz counter with the specified metric and field names.
///
/// Metric names should start with a '/', generally be lowercase-only, and end
/// in "_count". Field names should not contain an initial slash. The actual
/// exported metric names will have "/iam/policy" prepended.
///
/// Field names correspond to IAM request parameters and field values are their
/// respective values.
///
/// Supported field names: - "authority", which is "[token]" if IAMContext.token
/// is present, otherwise the value of IAMContext.authority_selector if present,
/// and otherwise a representation of IAMContext.principal; or -
/// "iam_principal", a representation of IAMContext.principal even if a token or
/// authority selector is present; or - "" (empty string), resulting in a
/// counter with no fields.
///
/// Examples: counter { metric: "/debug_access_count" field: "iam_principal" }
/// ==> increment counter /iam/policy/debug_access_count {iam_principal=[value
/// of IAMContext.principal]}
class LogConfigCounterOptions {
  /// Custom fields.
  core.List<LogConfigCounterOptionsCustomField> customFields;

  /// The field value to attribute.
  core.String field;

  /// The metric to update.
  core.String metric;

  LogConfigCounterOptions();

  LogConfigCounterOptions.fromJson(core.Map _json) {
    if (_json.containsKey('customFields')) {
      customFields = (_json['customFields'] as core.List)
          .map<LogConfigCounterOptionsCustomField>((value) =>
              LogConfigCounterOptionsCustomField.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('field')) {
      field = _json['field'] as core.String;
    }
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (customFields != null) {
      _json['customFields'] =
          customFields.map((value) => value.toJson()).toList();
    }
    if (field != null) {
      _json['field'] = field;
    }
    if (metric != null) {
      _json['metric'] = metric;
    }
    return _json;
  }
}

/// Custom fields. These can be used to create a counter with arbitrary
/// field/value pairs. See: go/rpcsp-custom-fields.
class LogConfigCounterOptionsCustomField {
  /// Name is the field name.
  core.String name;

  /// Value is the field value. It is important that in contrast to the
  /// CounterOptions.field, the value here is a constant that is not derived
  /// from the IAMContext.
  core.String value;

  LogConfigCounterOptionsCustomField();

  LogConfigCounterOptionsCustomField.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Write a Data Access (Gin) log
class LogConfigDataAccessOptions {
  ///
  /// Possible string values are:
  /// - "LOG_FAIL_CLOSED"
  /// - "LOG_MODE_UNSPECIFIED"
  core.String logMode;

  LogConfigDataAccessOptions();

  LogConfigDataAccessOptions.fromJson(core.Map _json) {
    if (_json.containsKey('logMode')) {
      logMode = _json['logMode'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (logMode != null) {
      _json['logMode'] = logMode;
    }
    return _json;
  }
}

class MachineTypeAccelerators {
  /// Number of accelerator cards exposed to the guest.
  core.int guestAcceleratorCount;

  /// The accelerator type resource name, not a full URL, e.g.
  /// 'nvidia-tesla-k80'.
  core.String guestAcceleratorType;

  MachineTypeAccelerators();

  MachineTypeAccelerators.fromJson(core.Map _json) {
    if (_json.containsKey('guestAcceleratorCount')) {
      guestAcceleratorCount = _json['guestAcceleratorCount'] as core.int;
    }
    if (_json.containsKey('guestAcceleratorType')) {
      guestAcceleratorType = _json['guestAcceleratorType'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (guestAcceleratorCount != null) {
      _json['guestAcceleratorCount'] = guestAcceleratorCount;
    }
    if (guestAcceleratorType != null) {
      _json['guestAcceleratorType'] = guestAcceleratorType;
    }
    return _json;
  }
}

class MachineTypeScratchDisks {
  /// Size of the scratch disk, defined in GB.
  core.int diskGb;

  MachineTypeScratchDisks();

  MachineTypeScratchDisks.fromJson(core.Map _json) {
    if (_json.containsKey('diskGb')) {
      diskGb = _json['diskGb'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (diskGb != null) {
      _json['diskGb'] = diskGb;
    }
    return _json;
  }
}

/// Represents a Machine Type resource.
///
/// You can use specific machine types for your VM instances based on
/// performance and pricing requirements. For more information, read Machine
/// Types. (== resource_for {$api_version}.machineTypes ==)
class MachineType {
  /// [Output Only] A list of accelerator configurations assigned to this
  /// machine type.
  core.List<MachineTypeAccelerators> accelerators;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this machine type.
  /// Only applicable if the machine type is unavailable.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The number of virtual CPUs that are available to the
  /// instance.
  core.int guestCpus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Deprecated] This property is deprecated and will never be populated with
  /// any relevant values.
  core.int imageSpaceGb;

  /// [Output Only] Whether this machine type has a shared CPU. See Shared-core
  /// machine types for more information.
  core.bool isSharedCpu;

  /// [Output Only] The type of the resource. Always compute#machineType for
  /// machine types.
  core.String kind;

  /// [Output Only] Maximum persistent disks allowed.
  core.int maximumPersistentDisks;

  /// [Output Only] Maximum total persistent disks size (GB) allowed.
  core.String maximumPersistentDisksSizeGb;

  /// [Output Only] The amount of physical memory available to the instance,
  /// defined in MB.
  core.int memoryMb;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] A list of extended scratch disks assigned to the instance.
  core.List<MachineTypeScratchDisks> scratchDisks;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the machine type resides, such as
  /// us-central1-a.
  core.String zone;

  MachineType();

  MachineType.fromJson(core.Map _json) {
    if (_json.containsKey('accelerators')) {
      accelerators = (_json['accelerators'] as core.List)
          .map<MachineTypeAccelerators>((value) =>
              MachineTypeAccelerators.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('guestCpus')) {
      guestCpus = _json['guestCpus'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('imageSpaceGb')) {
      imageSpaceGb = _json['imageSpaceGb'] as core.int;
    }
    if (_json.containsKey('isSharedCpu')) {
      isSharedCpu = _json['isSharedCpu'] as core.bool;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('maximumPersistentDisks')) {
      maximumPersistentDisks = _json['maximumPersistentDisks'] as core.int;
    }
    if (_json.containsKey('maximumPersistentDisksSizeGb')) {
      maximumPersistentDisksSizeGb =
          _json['maximumPersistentDisksSizeGb'] as core.String;
    }
    if (_json.containsKey('memoryMb')) {
      memoryMb = _json['memoryMb'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('scratchDisks')) {
      scratchDisks = (_json['scratchDisks'] as core.List)
          .map<MachineTypeScratchDisks>((value) =>
              MachineTypeScratchDisks.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (accelerators != null) {
      _json['accelerators'] =
          accelerators.map((value) => value.toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (guestCpus != null) {
      _json['guestCpus'] = guestCpus;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (imageSpaceGb != null) {
      _json['imageSpaceGb'] = imageSpaceGb;
    }
    if (isSharedCpu != null) {
      _json['isSharedCpu'] = isSharedCpu;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (maximumPersistentDisks != null) {
      _json['maximumPersistentDisks'] = maximumPersistentDisks;
    }
    if (maximumPersistentDisksSizeGb != null) {
      _json['maximumPersistentDisksSizeGb'] = maximumPersistentDisksSizeGb;
    }
    if (memoryMb != null) {
      _json['memoryMb'] = memoryMb;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (scratchDisks != null) {
      _json['scratchDisks'] =
          scratchDisks.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class MachineTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeAggregatedListWarningData();

  MachineTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeAggregatedListWarning();

  MachineTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypeAggregatedListWarningData>((value) =>
              MachineTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class MachineTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineTypesScopedList resources.
  core.Map<core.String, MachineTypesScopedList> items;

  /// [Output Only] Type of resource. Always compute#machineTypeAggregatedList
  /// for aggregated lists of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  MachineTypeAggregatedListWarning warning;

  MachineTypeAggregatedList();

  MachineTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              MachineTypesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class MachineTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypeListWarningData();

  MachineTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class MachineTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypeListWarning();

  MachineTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypeListWarningData>((value) =>
              MachineTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of machine types.
class MachineTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of MachineType resources.
  core.List<MachineType> items;

  /// [Output Only] Type of resource. Always compute#machineTypeList for lists
  /// of machine types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  MachineTypeListWarning warning;

  MachineTypeList();

  MachineTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<MachineType>((value) => MachineType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class MachineTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  MachineTypesScopedListWarningData();

  MachineTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the machine types
/// list is empty.
class MachineTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<MachineTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  MachineTypesScopedListWarning();

  MachineTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypesScopedListWarningData>((value) =>
              MachineTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class MachineTypesScopedList {
  /// [Output Only] A list of machine types contained in this scope.
  core.List<MachineType> machineTypes;

  /// [Output Only] An informational warning that appears when the machine types
  /// list is empty.
  MachineTypesScopedListWarning warning;

  MachineTypesScopedList();

  MachineTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('machineTypes')) {
      machineTypes = (_json['machineTypes'] as core.List)
          .map<MachineType>((value) => MachineType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (machineTypes != null) {
      _json['machineTypes'] =
          machineTypes.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A Managed Instance resource.
class ManagedInstance {
  /// [Output Only] The current action that the managed instance group has
  /// scheduled for the instance. Possible values:
  /// - NONE The instance is running, and the managed instance group does not
  /// have any scheduled actions for this instance.
  /// - CREATING The managed instance group is creating this instance. If the
  /// group fails to create this instance, it will try again until it is
  /// successful.
  /// - CREATING_WITHOUT_RETRIES The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased instead.
  /// - RECREATING The managed instance group is recreating this instance.
  /// - DELETING The managed instance group is permanently deleting this
  /// instance.
  /// - ABANDONING The managed instance group is abandoning this instance. The
  /// instance will be removed from the instance group and from any target pools
  /// that are associated with this group.
  /// - RESTARTING The managed instance group is restarting the instance.
  /// - REFRESHING The managed instance group is applying configuration changes
  /// to the instance without stopping it. For example, the group can update the
  /// target pool list for an instance without stopping that instance.
  /// - VERIFYING The managed instance group has created the instance and it is
  /// in the process of being verified.
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String currentAction;

  /// [Output only] The unique identifier for this resource. This field is empty
  /// when instance does not exist.
  core.String id;

  /// [Output Only] The URL of the instance. The URL can exist even if the
  /// instance has not yet been created.
  core.String instance;

  /// [Output Only] Health state of the instance per health-check.
  core.List<ManagedInstanceInstanceHealth> instanceHealth;

  /// [Output Only] The status of the instance. This field is empty when the
  /// instance does not exist.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String instanceStatus;

  /// [Output Only] Information about the last attempt to create or delete the
  /// instance.
  ManagedInstanceLastAttempt lastAttempt;

  /// [Output Only] Preserved state applied from per-instance config for this
  /// instance.
  PreservedState preservedStateFromConfig;

  /// [Output Only] Preserved state generated based on stateful policy for this
  /// instance.
  PreservedState preservedStateFromPolicy;

  /// [Output Only] Intended version of this instance.
  ManagedInstanceVersion version;

  ManagedInstance();

  ManagedInstance.fromJson(core.Map _json) {
    if (_json.containsKey('currentAction')) {
      currentAction = _json['currentAction'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('instanceHealth')) {
      instanceHealth = (_json['instanceHealth'] as core.List)
          .map<ManagedInstanceInstanceHealth>((value) =>
              ManagedInstanceInstanceHealth.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('instanceStatus')) {
      instanceStatus = _json['instanceStatus'] as core.String;
    }
    if (_json.containsKey('lastAttempt')) {
      lastAttempt = ManagedInstanceLastAttempt.fromJson(
          _json['lastAttempt'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preservedStateFromConfig')) {
      preservedStateFromConfig = PreservedState.fromJson(
          _json['preservedStateFromConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preservedStateFromPolicy')) {
      preservedStateFromPolicy = PreservedState.fromJson(
          _json['preservedStateFromPolicy']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('version')) {
      version = ManagedInstanceVersion.fromJson(
          _json['version'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (currentAction != null) {
      _json['currentAction'] = currentAction;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (instanceHealth != null) {
      _json['instanceHealth'] =
          instanceHealth.map((value) => value.toJson()).toList();
    }
    if (instanceStatus != null) {
      _json['instanceStatus'] = instanceStatus;
    }
    if (lastAttempt != null) {
      _json['lastAttempt'] = lastAttempt.toJson();
    }
    if (preservedStateFromConfig != null) {
      _json['preservedStateFromConfig'] = preservedStateFromConfig.toJson();
    }
    if (preservedStateFromPolicy != null) {
      _json['preservedStateFromPolicy'] = preservedStateFromPolicy.toJson();
    }
    if (version != null) {
      _json['version'] = version.toJson();
    }
    return _json;
  }
}

class ManagedInstanceInstanceHealth {
  /// [Output Only] The current detailed instance health state.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "TIMEOUT"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String detailedHealthState;

  /// [Output Only] The URL for the health check that verifies whether the
  /// instance is healthy.
  core.String healthCheck;

  ManagedInstanceInstanceHealth();

  ManagedInstanceInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey('detailedHealthState')) {
      detailedHealthState = _json['detailedHealthState'] as core.String;
    }
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (detailedHealthState != null) {
      _json['detailedHealthState'] = detailedHealthState;
    }
    if (healthCheck != null) {
      _json['healthCheck'] = healthCheck;
    }
    return _json;
  }
}

class ManagedInstanceLastAttemptErrorsErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  ManagedInstanceLastAttemptErrorsErrors();

  ManagedInstanceLastAttemptErrorsErrors.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (location != null) {
      _json['location'] = location;
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// [Output Only] Encountered errors during the last attempt to create or delete
/// the instance.
class ManagedInstanceLastAttemptErrors {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<ManagedInstanceLastAttemptErrorsErrors> errors;

  ManagedInstanceLastAttemptErrors();

  ManagedInstanceLastAttemptErrors.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = (_json['errors'] as core.List)
          .map<ManagedInstanceLastAttemptErrorsErrors>((value) =>
              ManagedInstanceLastAttemptErrorsErrors.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (errors != null) {
      _json['errors'] = errors.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class ManagedInstanceLastAttempt {
  /// [Output Only] Encountered errors during the last attempt to create or
  /// delete the instance.
  ManagedInstanceLastAttemptErrors errors;

  ManagedInstanceLastAttempt();

  ManagedInstanceLastAttempt.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = ManagedInstanceLastAttemptErrors.fromJson(
          _json['errors'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (errors != null) {
      _json['errors'] = errors.toJson();
    }
    return _json;
  }
}

class ManagedInstanceVersion {
  /// [Output Only] The intended template of the instance. This field is empty
  /// when current_action is one of { DELETING, ABANDONING }.
  core.String instanceTemplate;

  /// [Output Only] Name of the version.
  core.String name;

  ManagedInstanceVersion();

  ManagedInstanceVersion.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceTemplate != null) {
      _json['instanceTemplate'] = instanceTemplate;
    }
    if (name != null) {
      _json['name'] = name;
    }
    return _json;
  }
}

class MetadataItems {
  /// Key for the metadata entry. Keys must conform to the following regexp:
  /// [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as
  /// part of a URL in the metadata server. Additionally, to avoid ambiguity,
  /// keys must not conflict with any other metadata keys for the project.
  core.String key;

  /// Value for the metadata entry. These are free-form strings, and only have
  /// meaning as interpreted by the image running in the instance. The only
  /// restriction placed on values is that their size must be less than or equal
  /// to 262144 bytes (256 KiB).
  core.String value;

  MetadataItems();

  MetadataItems.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// A metadata key/value entry.
class Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata, otherwise the
  /// request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve the
  /// resource.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Array of key/value pairs. The total size of all keys and values must be
  /// less than 512 KB.
  core.List<MetadataItems> items;

  /// [Output Only] Type of the resource. Always compute#metadata for metadata.
  core.String kind;

  Metadata();

  Metadata.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<MetadataItems>((value) => MetadataItems.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    return _json;
  }
}

/// Opaque filter criteria used by loadbalancers to restrict routing
/// configuration to a limited set of loadbalancing proxies. Proxies and
/// sidecars involved in loadbalancing would typically present metadata to the
/// loadbalancers which need to match criteria specified here. If a match takes
/// place, the relevant configuration is made available to those proxies.
/// For each metadataFilter in this list, if its filterMatchCriteria is set to
/// MATCH_ANY, at least one of the filterLabels must match the corresponding
/// label provided in the metadata. If its filterMatchCriteria is set to
/// MATCH_ALL, then all of its filterLabels must match with corresponding labels
/// provided in the metadata.
/// An example for using metadataFilters would be: if loadbalancing involves
/// Envoys, they will only receive routing configuration when values in
/// metadataFilters match values supplied in <a
/// href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/base.proto#envoy-api-msg-core-node"
/// Node metadata of their XDS requests to loadbalancers.
class MetadataFilter {
  /// The list of label value pairs that must match labels in the provided
  /// metadata based on filterMatchCriteria
  /// This list must not be empty and can have at the most 64 entries.
  core.List<MetadataFilterLabelMatch> filterLabels;

  /// Specifies how individual filterLabel matches within the list of
  /// filterLabels contribute towards the overall metadataFilter match.
  /// Supported values are:
  /// - MATCH_ANY: At least one of the filterLabels must have a matching label
  /// in the provided metadata.
  /// - MATCH_ALL: All filterLabels must have matching labels in the provided
  /// metadata.
  /// Possible string values are:
  /// - "MATCH_ALL"
  /// - "MATCH_ANY"
  /// - "NOT_SET"
  core.String filterMatchCriteria;

  MetadataFilter();

  MetadataFilter.fromJson(core.Map _json) {
    if (_json.containsKey('filterLabels')) {
      filterLabels = (_json['filterLabels'] as core.List)
          .map<MetadataFilterLabelMatch>((value) =>
              MetadataFilterLabelMatch.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('filterMatchCriteria')) {
      filterMatchCriteria = _json['filterMatchCriteria'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (filterLabels != null) {
      _json['filterLabels'] =
          filterLabels.map((value) => value.toJson()).toList();
    }
    if (filterMatchCriteria != null) {
      _json['filterMatchCriteria'] = filterMatchCriteria;
    }
    return _json;
  }
}

/// MetadataFilter label name value pairs that are expected to match
/// corresponding labels presented as metadata to the loadbalancer.
class MetadataFilterLabelMatch {
  /// Name of metadata label.
  /// The name can have a maximum length of 1024 characters and must be at least
  /// 1 character long.
  core.String name;

  /// The value of the label must match the specified value.
  /// value can have a maximum length of 1024 characters.
  core.String value;

  MetadataFilterLabelMatch();

  MetadataFilterLabelMatch.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// The named port. For example: .
class NamedPort {
  /// The name for this named port. The name must be 1-63 characters long, and
  /// comply with RFC1035.
  core.String name;

  /// The port number, which can be a value between 1 and 65535.
  core.int port;

  NamedPort();

  NamedPort.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    if (port != null) {
      _json['port'] = port;
    }
    return _json;
  }
}

/// Represents a VPC Network resource.
///
/// Networks connect resources to each other and to the internet. For more
/// information, read Virtual Private Cloud (VPC) Network. (== resource_for
/// {$api_version}.networks ==)
class Network {
  /// Deprecated in favor of subnet mode networks. The range of internal
  /// addresses that are legal on this network. This range is a CIDR
  /// specification, for example: 192.168.0.0/16. Provided by the client when
  /// the network is created.
  core.String IPv4Range;

  /// Must be set to create a VPC network. If not set, a legacy network is
  /// created.
  ///
  /// When set to true, the VPC network is created in auto mode. When set to
  /// false, the VPC network is created in custom mode.
  ///
  /// An auto mode VPC network starts with one subnet per region. Each subnet
  /// has a predetermined range as described in Auto mode VPC network IP ranges.
  ///
  /// For custom mode VPC networks, you can add subnets using the subnetworks
  /// insert method.
  core.bool autoCreateSubnetworks;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// [Output Only] The gateway address for default routing out of the network,
  /// selected by GCP.
  core.String gatewayIPv4;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#network for networks.
  core.String kind;

  /// Maximum Transmission Unit in bytes. The minimum value for this field is
  /// 1460 and the maximum value is 1500 bytes.
  core.int mtu;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// [Output Only] A list of network peerings for the resource.
  core.List<NetworkPeering> peerings;

  /// The network-level routing configuration for this network. Used by Cloud
  /// Router to determine what type of network-wide routing behavior to enforce.
  NetworkRoutingConfig routingConfig;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Server-defined fully-qualified URLs for all subnetworks in
  /// this VPC network.
  core.List<core.String> subnetworks;

  Network();

  Network.fromJson(core.Map _json) {
    if (_json.containsKey('IPv4Range')) {
      IPv4Range = _json['IPv4Range'] as core.String;
    }
    if (_json.containsKey('autoCreateSubnetworks')) {
      autoCreateSubnetworks = _json['autoCreateSubnetworks'] as core.bool;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('gatewayIPv4')) {
      gatewayIPv4 = _json['gatewayIPv4'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('mtu')) {
      mtu = _json['mtu'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerings')) {
      peerings = (_json['peerings'] as core.List)
          .map<NetworkPeering>((value) => NetworkPeering.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('routingConfig')) {
      routingConfig = NetworkRoutingConfig.fromJson(
          _json['routingConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (IPv4Range != null) {
      _json['IPv4Range'] = IPv4Range;
    }
    if (autoCreateSubnetworks != null) {
      _json['autoCreateSubnetworks'] = autoCreateSubnetworks;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (gatewayIPv4 != null) {
      _json['gatewayIPv4'] = gatewayIPv4;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (mtu != null) {
      _json['mtu'] = mtu;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (peerings != null) {
      _json['peerings'] = peerings.map((value) => value.toJson()).toList();
    }
    if (routingConfig != null) {
      _json['routingConfig'] = routingConfig.toJson();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (subnetworks != null) {
      _json['subnetworks'] = subnetworks;
    }
    return _json;
  }
}

/// The network endpoint.
class NetworkEndpoint {
  /// Metadata defined as annotations on the network endpoint.
  core.Map<core.String, core.String> annotations;

  /// Optional fully qualified domain name of network endpoint. This can only be
  /// specified when NetworkEndpointGroup.network_endpoint_type is
  /// NON_GCP_FQDN_PORT.
  core.String fqdn;

  /// The name for a specific VM instance that the IP address belongs to. This
  /// is required for network endpoints of type GCE_VM_IP_PORT. The instance
  /// must be in the same zone of network endpoint group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String instance;

  /// Optional IPv4 address of network endpoint. The IP address must belong to a
  /// VM in Compute Engine (either the primary IP or as part of an aliased IP
  /// range). If the IP address is not specified, then the primary IP address
  /// for the VM instance in the network that the network endpoint group belongs
  /// to will be used.
  core.String ipAddress;

  /// Optional port number of network endpoint. If not specified and the
  /// NetworkEndpointGroup.network_endpoint_type is GCE_IP_PORT, the defaultPort
  /// for the network endpoint group will be used.
  core.int port;

  NetworkEndpoint();

  NetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations = (_json['annotations'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('fqdn')) {
      fqdn = _json['fqdn'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (annotations != null) {
      _json['annotations'] = annotations;
    }
    if (fqdn != null) {
      _json['fqdn'] = fqdn;
    }
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    if (port != null) {
      _json['port'] = port;
    }
    return _json;
  }
}

/// Represents a collection of network endpoints.
///
/// A network endpoint group (NEG) defines how a set of endpoints should be
/// reached, whether they are reachable, and where they are located. For more
/// information about using NEGs, see  Setting up internet NEGs,  Setting up
/// zonal NEGs, or  Setting up serverless NEGs. (== resource_for
/// {$api_version}.networkEndpointGroups ==) (== resource_for
/// {$api_version}.globalNetworkEndpointGroups ==) (== resource_for
/// {$api_version}.regionNetworkEndpointGroups ==)
class NetworkEndpointGroup {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String> annotations;

  /// Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
  /// appEngine or cloudFunction may be set.
  NetworkEndpointGroupAppEngine appEngine;

  /// Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
  /// appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudFunction cloudFunction;

  /// Only valid when networkEndpointType is "SERVERLESS". Only one of cloudRun,
  /// appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudRun cloudRun;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// The default port used if the port number is not specified in the network
  /// endpoint.
  core.int defaultPort;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#networkEndpointGroup
  /// for network endpoint group.
  core.String kind;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The URL of the network to which all network endpoints in the NEG belong.
  /// Uses "default" project network if unspecified.
  core.String network;

  /// Type of network endpoints in this network endpoint group. Can be one of
  /// GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
  /// INTERNET_IP_PORT, or SERVERLESS.
  /// Possible string values are:
  /// - "GCE_VM_IP_PORT"
  /// - "INTERNET_FQDN_PORT"
  /// - "INTERNET_IP_PORT"
  /// - "NON_GCP_PRIVATE_IP_PORT"
  /// - "SERVERLESS"
  core.String networkEndpointType;

  /// [Output Only] The URL of the region where the network endpoint group is
  /// located.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output only] Number of network endpoints in the network endpoint group.
  core.int size;

  /// Optional URL of the subnetwork to which all network endpoints in the NEG
  /// belong.
  core.String subnetwork;

  /// [Output Only] The URL of the zone where the network endpoint group is
  /// located.
  core.String zone;

  NetworkEndpointGroup();

  NetworkEndpointGroup.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations = (_json['annotations'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('appEngine')) {
      appEngine = NetworkEndpointGroupAppEngine.fromJson(
          _json['appEngine'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cloudFunction')) {
      cloudFunction = NetworkEndpointGroupCloudFunction.fromJson(
          _json['cloudFunction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cloudRun')) {
      cloudRun = NetworkEndpointGroupCloudRun.fromJson(
          _json['cloudRun'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultPort')) {
      defaultPort = _json['defaultPort'] as core.int;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkEndpointType')) {
      networkEndpointType = _json['networkEndpointType'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (annotations != null) {
      _json['annotations'] = annotations;
    }
    if (appEngine != null) {
      _json['appEngine'] = appEngine.toJson();
    }
    if (cloudFunction != null) {
      _json['cloudFunction'] = cloudFunction.toJson();
    }
    if (cloudRun != null) {
      _json['cloudRun'] = cloudRun.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (defaultPort != null) {
      _json['defaultPort'] = defaultPort;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (networkEndpointType != null) {
      _json['networkEndpointType'] = networkEndpointType;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (size != null) {
      _json['size'] = size;
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class NetworkEndpointGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupAggregatedListWarningData();

  NetworkEndpointGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupAggregatedListWarning();

  NetworkEndpointGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupAggregatedListWarningData>((value) =>
              NetworkEndpointGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointGroupsScopedList resources.
  core.Map<core.String, NetworkEndpointGroupsScopedList> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupAggregatedList for aggregated lists of network
  /// endpoint groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupAggregatedListWarning warning;

  NetworkEndpointGroupAggregatedList();

  NetworkEndpointGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              NetworkEndpointGroupsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Configuration for an App Engine network endpoint group (NEG). The service is
/// optional, may be provided explicitly or in the URL mask. The version is
/// optional and can only be provided explicitly or in the URL mask when service
/// is present.
///
/// Note: App Engine service must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupAppEngine {
  /// Optional serving service.
  ///
  /// The service name must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "default", "my-service".
  core.String service;

  /// A template to parse service and version fields from a request URL. URL
  /// mask allows for routing to multiple App Engine services without having to
  /// create multiple Network Endpoint Groups and backend services.
  ///
  /// For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
  /// "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG
  /// with URL mask "-dot-appname.appspot.com/". The URL mask will parse them to
  /// { service = "foo1", version = "v1" } and { service = "foo1", version =
  /// "v2" } respectively.
  core.String urlMask;

  /// Optional serving version.
  ///
  /// The version must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "v1", "v2".
  core.String version;

  NetworkEndpointGroupAppEngine();

  NetworkEndpointGroupAppEngine.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
    if (_json.containsKey('version')) {
      version = _json['version'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (service != null) {
      _json['service'] = service;
    }
    if (urlMask != null) {
      _json['urlMask'] = urlMask;
    }
    if (version != null) {
      _json['version'] = version;
    }
    return _json;
  }
}

/// Configuration for a Cloud Function network endpoint group (NEG). The
/// function must be provided explicitly or in the URL mask.
///
/// Note: Cloud Function must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupCloudFunction {
  /// A user-defined name of the Cloud Function.
  ///
  /// The function name is case-sensitive and must be 1-63 characters long.
  ///
  /// Example value: "func1".
  core.String function;

  /// A template to parse function field from a request URL. URL mask allows for
  /// routing to multiple Cloud Functions without having to create multiple
  /// Network Endpoint Groups and backend services.
  ///
  /// For example, request URLs "mydomain.com/function1" and
  /// "mydomain.com/function2" can be backed by the same Serverless NEG with URL
  /// mask "/". The URL mask will parse them to { function = "function1" } and {
  /// function = "function2" } respectively.
  core.String urlMask;

  NetworkEndpointGroupCloudFunction();

  NetworkEndpointGroupCloudFunction.fromJson(core.Map _json) {
    if (_json.containsKey('function')) {
      function = _json['function'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (function != null) {
      _json['function'] = function;
    }
    if (urlMask != null) {
      _json['urlMask'] = urlMask;
    }
    return _json;
  }
}

/// Configuration for a Cloud Run network endpoint group (NEG). The service must
/// be provided explicitly or in the URL mask. The tag is optional, may be
/// provided explicitly or in the URL mask.
///
/// Note: Cloud Run service must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupCloudRun {
  /// Cloud Run service is the main resource of Cloud Run.
  ///
  /// The service must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "run-service".
  core.String service;

  /// Optional Cloud Run tag represents the "named-revision" to provide
  /// additional fine-grained traffic routing information.
  ///
  /// The tag must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "revision-0010".
  core.String tag;

  /// A template to parse service and tag fields from a request URL. URL mask
  /// allows for routing to multiple Run services without having to create
  /// multiple network endpoint groups and backend services.
  ///
  /// For example, request URLs "foo1.domain.com/bar1" and
  /// "foo1.domain.com/bar2" can be backed by the same Serverless Network
  /// Endpoint Group (NEG) with URL mask ".domain.com/". The URL mask will parse
  /// them to { service="bar1", tag="foo1" } and { service="bar2", tag="foo2" }
  /// respectively.
  core.String urlMask;

  NetworkEndpointGroupCloudRun();

  NetworkEndpointGroupCloudRun.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('tag')) {
      tag = _json['tag'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (service != null) {
      _json['service'] = service;
    }
    if (tag != null) {
      _json['tag'] = tag;
    }
    if (urlMask != null) {
      _json['urlMask'] = urlMask;
    }
    return _json;
  }
}

class NetworkEndpointGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupListWarningData();

  NetworkEndpointGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupListWarning();

  NetworkEndpointGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupListWarningData>((value) =>
              NetworkEndpointGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointGroup resources.
  core.List<NetworkEndpointGroup> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupList for network endpoint group lists.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupListWarning warning;

  NetworkEndpointGroupList();

  NetworkEndpointGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NetworkEndpointGroup>((value) => NetworkEndpointGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint> networkEndpoints;

  NetworkEndpointGroupsAttachEndpointsRequest();

  NetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkEndpoints != null) {
      _json['networkEndpoints'] =
          networkEndpoints.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class NetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint> networkEndpoints;

  NetworkEndpointGroupsDetachEndpointsRequest();

  NetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkEndpoints != null) {
      _json['networkEndpoints'] =
          networkEndpoints.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class NetworkEndpointGroupsListEndpointsRequest {
  /// Optional query parameter for showing the health status of each network
  /// endpoint. Valid options are SKIP or SHOW. If you don't specify this
  /// parameter, the health status of network endpoints will not be provided.
  /// Possible string values are:
  /// - "SHOW"
  /// - "SKIP"
  core.String healthStatus;

  NetworkEndpointGroupsListEndpointsRequest();

  NetworkEndpointGroupsListEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthStatus')) {
      healthStatus = _json['healthStatus'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthStatus != null) {
      _json['healthStatus'] = healthStatus;
    }
    return _json;
  }
}

class NetworkEndpointGroupsListNetworkEndpointsWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupsListNetworkEndpointsWarningData();

  NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkEndpointGroupsListNetworkEndpointsWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupsListNetworkEndpointsWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupsListNetworkEndpointsWarning();

  NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupsListNetworkEndpointsWarningData>((value) =>
              NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupsListNetworkEndpoints {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NetworkEndpointWithHealthStatus resources.
  core.List<NetworkEndpointWithHealthStatus> items;

  /// [Output Only] The resource type, which is always
  /// compute#networkEndpointGroupsListNetworkEndpoints for the list of network
  /// endpoints in the specified network endpoint group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  NetworkEndpointGroupsListNetworkEndpointsWarning warning;

  NetworkEndpointGroupsListNetworkEndpoints();

  NetworkEndpointGroupsListNetworkEndpoints.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NetworkEndpointWithHealthStatus>((value) =>
              NetworkEndpointWithHealthStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NetworkEndpointGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkEndpointGroupsScopedListWarningData();

  NetworkEndpointGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that replaces the list of network
/// endpoint groups when the list is empty.
class NetworkEndpointGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkEndpointGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkEndpointGroupsScopedListWarning();

  NetworkEndpointGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupsScopedListWarningData>((value) =>
              NetworkEndpointGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NetworkEndpointGroupsScopedList {
  /// [Output Only] The list of network endpoint groups that are contained in
  /// this scope.
  core.List<NetworkEndpointGroup> networkEndpointGroups;

  /// [Output Only] An informational warning that replaces the list of network
  /// endpoint groups when the list is empty.
  NetworkEndpointGroupsScopedListWarning warning;

  NetworkEndpointGroupsScopedList();

  NetworkEndpointGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpointGroups')) {
      networkEndpointGroups = (_json['networkEndpointGroups'] as core.List)
          .map<NetworkEndpointGroup>((value) => NetworkEndpointGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkEndpointGroups != null) {
      _json['networkEndpointGroups'] =
          networkEndpointGroups.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NetworkEndpointWithHealthStatus {
  /// [Output only] The health status of network endpoint;
  core.List<HealthStatusForNetworkEndpoint> healths;

  /// [Output only] The network endpoint;
  NetworkEndpoint networkEndpoint;

  NetworkEndpointWithHealthStatus();

  NetworkEndpointWithHealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey('healths')) {
      healths = (_json['healths'] as core.List)
          .map<HealthStatusForNetworkEndpoint>((value) =>
              HealthStatusForNetworkEndpoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('networkEndpoint')) {
      networkEndpoint = NetworkEndpoint.fromJson(
          _json['networkEndpoint'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healths != null) {
      _json['healths'] = healths.map((value) => value.toJson()).toList();
    }
    if (networkEndpoint != null) {
      _json['networkEndpoint'] = networkEndpoint.toJson();
    }
    return _json;
  }
}

/// A network interface resource attached to an instance.
class NetworkInterface {
  /// An array of configurations for this interface. Currently, only one access
  /// config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs
  /// specified, then this instance will have no external internet access.
  core.List<AccessConfig> accessConfigs;

  /// An array of alias IP ranges for this network interface. You can only
  /// specify this field for network interfaces in VPC networks.
  core.List<AliasIpRange> aliasIpRanges;

  /// Fingerprint hash of contents stored in this network interface. This field
  /// will be ignored when inserting an Instance or adding a NetworkInterface.
  /// An up-to-date fingerprint must be provided in order to update the
  /// NetworkInterface, otherwise the request will fail with error 412
  /// conditionNotMet.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] An IPv6 internal network address for this network interface.
  core.String ipv6Address;

  /// [Output Only] Type of the resource. Always compute#networkInterface for
  /// network interfaces.
  core.String kind;

  /// [Output Only] The name of the network interface, which is generated by the
  /// server. For network devices, these are eth0, eth1, etc.
  core.String name;

  /// URL of the network resource for this instance. When creating an instance,
  /// if neither the network nor the subnetwork is specified, the default
  /// network global/networks/default is used; if the network is not specified
  /// but the subnetwork is specified, the network is inferred.
  ///
  /// If you specify this property, you can specify the network as a full or
  /// partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/networks/network
  /// - projects/project/global/networks/network
  /// - global/networks/default
  core.String network;

  /// An IPv4 internal IP address to assign to the instance for this network
  /// interface. If not specified by the user, an unused internal IP is assigned
  /// by the system.
  core.String networkIP;

  /// The URL of the Subnetwork resource for this instance. If the network
  /// resource is in legacy mode, do not specify this field. If the network is
  /// in auto subnet mode, specifying the subnetwork is optional. If the network
  /// is in custom subnet mode, specifying the subnetwork is required. If you
  /// specify this field, you can specify the subnetwork as a full or partial
  /// URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
  /// - regions/region/subnetworks/subnetwork
  core.String subnetwork;

  NetworkInterface();

  NetworkInterface.fromJson(core.Map _json) {
    if (_json.containsKey('accessConfigs')) {
      accessConfigs = (_json['accessConfigs'] as core.List)
          .map<AccessConfig>((value) => AccessConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('aliasIpRanges')) {
      aliasIpRanges = (_json['aliasIpRanges'] as core.List)
          .map<AliasIpRange>((value) => AliasIpRange.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('ipv6Address')) {
      ipv6Address = _json['ipv6Address'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkIP')) {
      networkIP = _json['networkIP'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (accessConfigs != null) {
      _json['accessConfigs'] =
          accessConfigs.map((value) => value.toJson()).toList();
    }
    if (aliasIpRanges != null) {
      _json['aliasIpRanges'] =
          aliasIpRanges.map((value) => value.toJson()).toList();
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (ipv6Address != null) {
      _json['ipv6Address'] = ipv6Address;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (networkIP != null) {
      _json['networkIP'] = networkIP;
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    return _json;
  }
}

class NetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NetworkListWarningData();

  NetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NetworkListWarning();

  NetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkListWarningData>((value) =>
              NetworkListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of networks.
class NetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Network resources.
  core.List<Network> items;

  /// [Output Only] Type of resource. Always compute#networkList for lists of
  /// networks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NetworkListWarning warning;

  NetworkList();

  NetworkList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Network>((value) =>
              Network.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A network peering attached to a network resource. The message includes the
/// peering name, peer network, peering state, and a flag indicating whether
/// Google Compute Engine should automatically create routes for the peering.
class NetworkPeering {
  /// This field will be deprecated soon. Use the exchange_subnet_routes field
  /// instead. Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks. Currently this field should always
  /// be true since Google Compute Engine will automatically create and manage
  /// subnetwork routes between two networks when peering state is ACTIVE.
  core.bool autoCreateRoutes;

  /// Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks. Currently this field should always
  /// be true since Google Compute Engine will automatically create and manage
  /// subnetwork routes between two networks when peering state is ACTIVE.
  core.bool exchangeSubnetRoutes;

  /// Whether to export the custom routes to peer network.
  core.bool exportCustomRoutes;

  /// Whether subnet routes with public IP range are exported. The default value
  /// is true, all subnet routes are exported. The IPv4 special-use ranges
  /// (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always exported
  /// to peers and are not controlled by this field.
  core.bool exportSubnetRoutesWithPublicIp;

  /// Whether to import the custom routes from peer network.
  core.bool importCustomRoutes;

  /// Whether subnet routes with public IP range are imported. The default value
  /// is false. The IPv4 special-use ranges
  /// (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported
  /// from peers and are not controlled by this field.
  core.bool importSubnetRoutesWithPublicIp;

  /// Name of this peering. Provided by the client when the peering is created.
  /// The name must comply with RFC1035. Specifically, the name must be 1-63
  /// characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`.
  /// The first character must be a lowercase letter, and all the following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash.
  core.String name;

  /// The URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String network;

  /// Maximum Transmission Unit in bytes.
  core.int peerMtu;

  /// [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The
  /// peering is `ACTIVE` when there's a matching configuration in the peer
  /// network.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String state;

  /// [Output Only] Details about the current state of the peering.
  core.String stateDetails;

  NetworkPeering();

  NetworkPeering.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreateRoutes')) {
      autoCreateRoutes = _json['autoCreateRoutes'] as core.bool;
    }
    if (_json.containsKey('exchangeSubnetRoutes')) {
      exchangeSubnetRoutes = _json['exchangeSubnetRoutes'] as core.bool;
    }
    if (_json.containsKey('exportCustomRoutes')) {
      exportCustomRoutes = _json['exportCustomRoutes'] as core.bool;
    }
    if (_json.containsKey('exportSubnetRoutesWithPublicIp')) {
      exportSubnetRoutesWithPublicIp =
          _json['exportSubnetRoutesWithPublicIp'] as core.bool;
    }
    if (_json.containsKey('importCustomRoutes')) {
      importCustomRoutes = _json['importCustomRoutes'] as core.bool;
    }
    if (_json.containsKey('importSubnetRoutesWithPublicIp')) {
      importSubnetRoutesWithPublicIp =
          _json['importSubnetRoutesWithPublicIp'] as core.bool;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('peerMtu')) {
      peerMtu = _json['peerMtu'] as core.int;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('stateDetails')) {
      stateDetails = _json['stateDetails'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoCreateRoutes != null) {
      _json['autoCreateRoutes'] = autoCreateRoutes;
    }
    if (exchangeSubnetRoutes != null) {
      _json['exchangeSubnetRoutes'] = exchangeSubnetRoutes;
    }
    if (exportCustomRoutes != null) {
      _json['exportCustomRoutes'] = exportCustomRoutes;
    }
    if (exportSubnetRoutesWithPublicIp != null) {
      _json['exportSubnetRoutesWithPublicIp'] = exportSubnetRoutesWithPublicIp;
    }
    if (importCustomRoutes != null) {
      _json['importCustomRoutes'] = importCustomRoutes;
    }
    if (importSubnetRoutesWithPublicIp != null) {
      _json['importSubnetRoutesWithPublicIp'] = importSubnetRoutesWithPublicIp;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (peerMtu != null) {
      _json['peerMtu'] = peerMtu;
    }
    if (state != null) {
      _json['state'] = state;
    }
    if (stateDetails != null) {
      _json['stateDetails'] = stateDetails;
    }
    return _json;
  }
}

/// A routing configuration attached to a network resource. The message includes
/// the list of routers associated with the network, and a flag indicating the
/// type of routing behavior to enforce network-wide.
class NetworkRoutingConfig {
  /// The network-wide routing mode to use. If set to REGIONAL, this network's
  /// Cloud Routers will only advertise routes with subnets of this network in
  /// the same region as the router. If set to GLOBAL, this network's Cloud
  /// Routers will advertise routes with all subnets of this network, across
  /// regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String routingMode;

  NetworkRoutingConfig();

  NetworkRoutingConfig.fromJson(core.Map _json) {
    if (_json.containsKey('routingMode')) {
      routingMode = _json['routingMode'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (routingMode != null) {
      _json['routingMode'] = routingMode;
    }
    return _json;
  }
}

class NetworksAddPeeringRequest {
  /// This field will be deprecated soon. Use exchange_subnet_routes in
  /// network_peering instead. Indicates whether full mesh connectivity is
  /// created and managed automatically between peered networks. Currently this
  /// field should always be true since Google Compute Engine will automatically
  /// create and manage subnetwork routes between two networks when peering
  /// state is ACTIVE.
  core.bool autoCreateRoutes;

  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  /// Network peering parameters. In order to specify route policies for peering
  /// using import and export custom routes, you must specify all peering
  /// related parameters (name, peer network, exchange_subnet_routes) in the
  /// network_peering field. The corresponding fields in
  /// NetworksAddPeeringRequest will be deprecated soon.
  NetworkPeering networkPeering;

  /// URL of the peer network. It can be either full URL or partial URL. The
  /// peer network may belong to a different project. If the partial URL does
  /// not contain project, it is assumed that the peer network is in the same
  /// project as the current network.
  core.String peerNetwork;

  NetworksAddPeeringRequest();

  NetworksAddPeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreateRoutes')) {
      autoCreateRoutes = _json['autoCreateRoutes'] as core.bool;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkPeering')) {
      networkPeering = NetworkPeering.fromJson(
          _json['networkPeering'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('peerNetwork')) {
      peerNetwork = _json['peerNetwork'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoCreateRoutes != null) {
      _json['autoCreateRoutes'] = autoCreateRoutes;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (networkPeering != null) {
      _json['networkPeering'] = networkPeering.toJson();
    }
    if (peerNetwork != null) {
      _json['peerNetwork'] = peerNetwork;
    }
    return _json;
  }
}

class NetworksRemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String name;

  NetworksRemovePeeringRequest();

  NetworksRemovePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    return _json;
  }
}

class NetworksUpdatePeeringRequest {
  NetworkPeering networkPeering;

  NetworksUpdatePeeringRequest();

  NetworksUpdatePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkPeering')) {
      networkPeering = NetworkPeering.fromJson(
          _json['networkPeering'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkPeering != null) {
      _json['networkPeering'] = networkPeering.toJson();
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Group resource.
///
/// A sole-tenant node is a physical server that is dedicated to hosting VM
/// instances only for your specific project. Use sole-tenant nodes to keep your
/// instances physically separated from instances in other projects, or to group
/// your instances together on the same host hardware. For more information,
/// read Sole-tenant nodes. (== resource_for {$api_version}.nodeGroups ==)
class NodeGroup {
  /// Specifies how autoscaling should behave.
  NodeGroupAutoscalingPolicy autoscalingPolicy;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeGroup for node
  /// group.
  core.String kind;

  /// Specifies how to handle instances when a node in the group undergoes
  /// maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or
  /// MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more
  /// information, see  Maintenance policies.
  /// Possible string values are:
  /// - "DEFAULT"
  /// - "MAINTENANCE_POLICY_UNSPECIFIED"
  /// - "MIGRATE_WITHIN_NODE_GROUP"
  /// - "RESTART_IN_PLACE"
  core.String maintenancePolicy;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// URL of the node template to create the node group from.
  core.String nodeTemplate;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The total number of nodes in the node group.
  core.int size;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  /// [Output Only] The name of the zone where the node group resides, such as
  /// us-central1-a.
  core.String zone;

  NodeGroup();

  NodeGroup.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalingPolicy')) {
      autoscalingPolicy = NodeGroupAutoscalingPolicy.fromJson(
          _json['autoscalingPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('maintenancePolicy')) {
      maintenancePolicy = _json['maintenancePolicy'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeTemplate')) {
      nodeTemplate = _json['nodeTemplate'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoscalingPolicy != null) {
      _json['autoscalingPolicy'] = autoscalingPolicy.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (maintenancePolicy != null) {
      _json['maintenancePolicy'] = maintenancePolicy;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (nodeTemplate != null) {
      _json['nodeTemplate'] = nodeTemplate;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (size != null) {
      _json['size'] = size;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class NodeGroupAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupAggregatedListWarningData();

  NodeGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupAggregatedListWarning();

  NodeGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupAggregatedListWarningData>((value) =>
              NodeGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeGroupAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeGroupsScopedList resources.
  core.Map<core.String, NodeGroupsScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeGroupAggregatedList for
  /// aggregated lists of node groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  NodeGroupAggregatedListWarning warning;

  NodeGroupAggregatedList();

  NodeGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              NodeGroupsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeGroupAutoscalingPolicy {
  /// The maximum number of nodes that the group should have.
  core.int maxNodes;

  /// The minimum number of nodes that the group should have.
  core.int minNodes;

  /// The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more
  /// information, see  Autoscaler modes.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED"
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_SCALE_OUT"
  core.String mode;

  NodeGroupAutoscalingPolicy();

  NodeGroupAutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('maxNodes')) {
      maxNodes = _json['maxNodes'] as core.int;
    }
    if (_json.containsKey('minNodes')) {
      minNodes = _json['minNodes'] as core.int;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (maxNodes != null) {
      _json['maxNodes'] = maxNodes;
    }
    if (minNodes != null) {
      _json['minNodes'] = minNodes;
    }
    if (mode != null) {
      _json['mode'] = mode;
    }
    return _json;
  }
}

class NodeGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupListWarningData();

  NodeGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupListWarning();

  NodeGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupListWarningData>((value) =>
              NodeGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of nodeGroups.
class NodeGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeGroup resources.
  core.List<NodeGroup> items;

  /// [Output Only] Type of resource.Always compute#nodeGroupList for lists of
  /// node groups.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeGroupListWarning warning;

  NodeGroupList();

  NodeGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeGroup>((value) =>
              NodeGroup.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeGroupNode {
  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String cpuOvercommitType;

  /// Instances scheduled on this node.
  core.List<core.String> instances;

  /// The name of the node.
  core.String name;

  /// The type of this node.
  core.String nodeType;

  /// Binding properties for the physical server.
  ServerBinding serverBinding;

  /// Server ID associated with this node.
  core.String serverId;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "REPAIRING"
  core.String status;

  NodeGroupNode();

  NodeGroupNode.fromJson(core.Map _json) {
    if (_json.containsKey('cpuOvercommitType')) {
      cpuOvercommitType = _json['cpuOvercommitType'] as core.String;
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeType')) {
      nodeType = _json['nodeType'] as core.String;
    }
    if (_json.containsKey('serverBinding')) {
      serverBinding = ServerBinding.fromJson(
          _json['serverBinding'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('serverId')) {
      serverId = _json['serverId'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cpuOvercommitType != null) {
      _json['cpuOvercommitType'] = cpuOvercommitType;
    }
    if (instances != null) {
      _json['instances'] = instances;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (nodeType != null) {
      _json['nodeType'] = nodeType;
    }
    if (serverBinding != null) {
      _json['serverBinding'] = serverBinding.toJson();
    }
    if (serverId != null) {
      _json['serverId'] = serverId;
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

class NodeGroupsAddNodesRequest {
  /// Count of additional nodes to be added to the node group.
  core.int additionalNodeCount;

  NodeGroupsAddNodesRequest();

  NodeGroupsAddNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('additionalNodeCount')) {
      additionalNodeCount = _json['additionalNodeCount'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (additionalNodeCount != null) {
      _json['additionalNodeCount'] = additionalNodeCount;
    }
    return _json;
  }
}

class NodeGroupsDeleteNodesRequest {
  /// Names of the nodes to delete.
  core.List<core.String> nodes;

  NodeGroupsDeleteNodesRequest();

  NodeGroupsDeleteNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('nodes')) {
      nodes = (_json['nodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nodes != null) {
      _json['nodes'] = nodes;
    }
    return _json;
  }
}

class NodeGroupsListNodesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupsListNodesWarningData();

  NodeGroupsListNodesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeGroupsListNodesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupsListNodesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupsListNodesWarning();

  NodeGroupsListNodesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupsListNodesWarningData>((value) =>
              NodeGroupsListNodesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeGroupsListNodes {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Node resources.
  core.List<NodeGroupNode> items;

  /// [Output Only] The resource type, which is always
  /// compute.nodeGroupsListNodes for the list of nodes in the specified node
  /// group.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeGroupsListNodesWarning warning;

  NodeGroupsListNodes();

  NodeGroupsListNodes.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeGroupNode>((value) => NodeGroupNode.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupsListNodesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeGroupsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeGroupsScopedListWarningData();

  NodeGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the nodeGroup list
/// is empty.
class NodeGroupsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeGroupsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeGroupsScopedListWarning();

  NodeGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupsScopedListWarningData>((value) =>
              NodeGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeGroupsScopedList {
  /// [Output Only] A list of node groups contained in this scope.
  core.List<NodeGroup> nodeGroups;

  /// [Output Only] An informational warning that appears when the nodeGroup
  /// list is empty.
  NodeGroupsScopedListWarning warning;

  NodeGroupsScopedList();

  NodeGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeGroups')) {
      nodeGroups = (_json['nodeGroups'] as core.List)
          .map<NodeGroup>((value) =>
              NodeGroup.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nodeGroups != null) {
      _json['nodeGroups'] = nodeGroups.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeGroupsSetNodeTemplateRequest {
  /// Full or partial URL of the node template resource to be updated for this
  /// node group.
  core.String nodeTemplate;

  NodeGroupsSetNodeTemplateRequest();

  NodeGroupsSetNodeTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTemplate')) {
      nodeTemplate = _json['nodeTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nodeTemplate != null) {
      _json['nodeTemplate'] = nodeTemplate;
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Template resource.
///
/// You can use a template to define properties for nodes in a node group. For
/// more information, read Creating node groups and instances. (== resource_for
/// {$api_version}.nodeTemplates ==)
class NodeTemplate {
  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String cpuOvercommitType;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeTemplate for
  /// node templates.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Labels to use for node affinity, which will be used in instance
  /// scheduling.
  core.Map<core.String, core.String> nodeAffinityLabels;

  /// The node type to use for nodes group that are created from this template.
  core.String nodeType;

  /// The flexible properties of the desired node type. Node groups that use
  /// this node template will create nodes of a type that matches these
  /// properties.
  ///
  /// This field is mutually exclusive with the node_type property; you can only
  /// define one or the other, but not both.
  NodeTemplateNodeTypeFlexibility nodeTypeFlexibility;

  /// [Output Only] The name of the region where the node template resides, such
  /// as us-central1.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Sets the binding properties for the physical server. Valid values include:
  /// - [Default] RESTART_NODE_ON_ANY_SERVER: Restarts VMs on any available
  /// physical server
  /// - RESTART_NODE_ON_MINIMAL_SERVER: Restarts VMs on the same physical server
  /// whenever possible
  ///
  /// See Sole-tenant node options for more information.
  ServerBinding serverBinding;

  /// [Output Only] The status of the node template. One of the following
  /// values: CREATING, READY, and DELETING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  /// [Output Only] An optional, human-readable explanation of the status.
  core.String statusMessage;

  NodeTemplate();

  NodeTemplate.fromJson(core.Map _json) {
    if (_json.containsKey('cpuOvercommitType')) {
      cpuOvercommitType = _json['cpuOvercommitType'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeAffinityLabels')) {
      nodeAffinityLabels = (_json['nodeAffinityLabels'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('nodeType')) {
      nodeType = _json['nodeType'] as core.String;
    }
    if (_json.containsKey('nodeTypeFlexibility')) {
      nodeTypeFlexibility = NodeTemplateNodeTypeFlexibility.fromJson(
          _json['nodeTypeFlexibility'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serverBinding')) {
      serverBinding = ServerBinding.fromJson(
          _json['serverBinding'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cpuOvercommitType != null) {
      _json['cpuOvercommitType'] = cpuOvercommitType;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (nodeAffinityLabels != null) {
      _json['nodeAffinityLabels'] = nodeAffinityLabels;
    }
    if (nodeType != null) {
      _json['nodeType'] = nodeType;
    }
    if (nodeTypeFlexibility != null) {
      _json['nodeTypeFlexibility'] = nodeTypeFlexibility.toJson();
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (serverBinding != null) {
      _json['serverBinding'] = serverBinding.toJson();
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (statusMessage != null) {
      _json['statusMessage'] = statusMessage;
    }
    return _json;
  }
}

class NodeTemplateAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplateAggregatedListWarningData();

  NodeTemplateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTemplateAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplateAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplateAggregatedListWarning();

  NodeTemplateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplateAggregatedListWarningData>((value) =>
              NodeTemplateAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeTemplateAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTemplatesScopedList resources.
  core.Map<core.String, NodeTemplatesScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeTemplateAggregatedList
  /// for aggregated lists of node templates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  NodeTemplateAggregatedListWarning warning;

  NodeTemplateAggregatedList();

  NodeTemplateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              NodeTemplatesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplateAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeTemplateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplateListWarningData();

  NodeTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTemplateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplateListWarning();

  NodeTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplateListWarningData>((value) =>
              NodeTemplateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of node templates.
class NodeTemplateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTemplate resources.
  core.List<NodeTemplate> items;

  /// [Output Only] Type of resource.Always compute#nodeTemplateList for lists
  /// of node templates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTemplateListWarning warning;

  NodeTemplateList();

  NodeTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeTemplate>((value) => NodeTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeTemplateNodeTypeFlexibility {
  core.String cpus;
  core.String localSsd;
  core.String memory;

  NodeTemplateNodeTypeFlexibility();

  NodeTemplateNodeTypeFlexibility.fromJson(core.Map _json) {
    if (_json.containsKey('cpus')) {
      cpus = _json['cpus'] as core.String;
    }
    if (_json.containsKey('localSsd')) {
      localSsd = _json['localSsd'] as core.String;
    }
    if (_json.containsKey('memory')) {
      memory = _json['memory'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cpus != null) {
      _json['cpus'] = cpus;
    }
    if (localSsd != null) {
      _json['localSsd'] = localSsd;
    }
    if (memory != null) {
      _json['memory'] = memory;
    }
    return _json;
  }
}

class NodeTemplatesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTemplatesScopedListWarningData();

  NodeTemplatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the node templates
/// list is empty.
class NodeTemplatesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTemplatesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTemplatesScopedListWarning();

  NodeTemplatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplatesScopedListWarningData>((value) =>
              NodeTemplatesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeTemplatesScopedList {
  /// [Output Only] A list of node templates contained in this scope.
  core.List<NodeTemplate> nodeTemplates;

  /// [Output Only] An informational warning that appears when the node
  /// templates list is empty.
  NodeTemplatesScopedListWarning warning;

  NodeTemplatesScopedList();

  NodeTemplatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTemplates')) {
      nodeTemplates = (_json['nodeTemplates'] as core.List)
          .map<NodeTemplate>((value) => NodeTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplatesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nodeTemplates != null) {
      _json['nodeTemplates'] =
          nodeTemplates.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represent a sole-tenant Node Type resource.
///
/// Each node within a node group must have a node type. A node type specifies
/// the total amount of cores and memory for that node. Currently, the only
/// available node type is n1-node-96-624 node type that has 96 vCPUs and 624 GB
/// of memory, available in multiple zones. For more information read Node
/// types. (== resource_for {$api_version}.nodeTypes ==)
class NodeType {
  /// [Output Only] The CPU platform used by this node type.
  core.String cpuPlatform;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this node type.
  DeprecationStatus deprecated;

  /// [Output Only] An optional textual description of the resource.
  core.String description;

  /// [Output Only] The number of virtual CPUs that are available to the node
  /// type.
  core.int guestCpus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The type of the resource. Always compute#nodeType for node
  /// types.
  core.String kind;

  /// [Output Only] Local SSD available to the node type, defined in GB.
  core.int localSsdGb;

  /// [Output Only] The amount of physical memory available to the node type,
  /// defined in MB.
  core.int memoryMb;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The name of the zone where the node type resides, such as
  /// us-central1-a.
  core.String zone;

  NodeType();

  NodeType.fromJson(core.Map _json) {
    if (_json.containsKey('cpuPlatform')) {
      cpuPlatform = _json['cpuPlatform'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('guestCpus')) {
      guestCpus = _json['guestCpus'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('localSsdGb')) {
      localSsdGb = _json['localSsdGb'] as core.int;
    }
    if (_json.containsKey('memoryMb')) {
      memoryMb = _json['memoryMb'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (cpuPlatform != null) {
      _json['cpuPlatform'] = cpuPlatform;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (guestCpus != null) {
      _json['guestCpus'] = guestCpus;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (localSsdGb != null) {
      _json['localSsdGb'] = localSsdGb;
    }
    if (memoryMb != null) {
      _json['memoryMb'] = memoryMb;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class NodeTypeAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypeAggregatedListWarningData();

  NodeTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTypeAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypeAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypeAggregatedListWarning();

  NodeTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypeAggregatedListWarningData>((value) =>
              NodeTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeTypeAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeTypesScopedList resources.
  core.Map<core.String, NodeTypesScopedList> items;

  /// [Output Only] Type of resource.Always compute#nodeTypeAggregatedList for
  /// aggregated lists of node types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  NodeTypeAggregatedListWarning warning;

  NodeTypeAggregatedList();

  NodeTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              NodeTypesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypeListWarningData();

  NodeTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NodeTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypeListWarning();

  NodeTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypeListWarningData>((value) =>
              NodeTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of node types.
class NodeTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NodeType resources.
  core.List<NodeType> items;

  /// [Output Only] Type of resource.Always compute#nodeTypeList for lists of
  /// node types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NodeTypeListWarning warning;

  NodeTypeList();

  NodeTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeType>((value) =>
              NodeType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class NodeTypesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NodeTypesScopedListWarningData();

  NodeTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] An informational warning that appears when the node types list
/// is empty.
class NodeTypesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NodeTypesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NodeTypesScopedListWarning();

  NodeTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypesScopedListWarningData>((value) =>
              NodeTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NodeTypesScopedList {
  /// [Output Only] A list of node types contained in this scope.
  core.List<NodeType> nodeTypes;

  /// [Output Only] An informational warning that appears when the node types
  /// list is empty.
  NodeTypesScopedListWarning warning;

  NodeTypesScopedList();

  NodeTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTypes')) {
      nodeTypes = (_json['nodeTypes'] as core.List)
          .map<NodeType>((value) =>
              NodeType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (nodeTypes != null) {
      _json['nodeTypes'] = nodeTypes.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a notification endpoint.
///
/// A notification endpoint resource defines an endpoint to receive
/// notifications when there are status changes detected by the associated
/// health check service.
///
/// For more information, see  Health checks overview. (== resource_for
/// {$api_version}.notificationEndpoint ==) (== resource_for
/// {$api_version}.regionNotificationEndpoints ==)
class NotificationEndpoint {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Settings of the gRPC notification endpoint including the endpoint URL and
  /// the retry duration.
  NotificationEndpointGrpcSettings grpcSettings;

  /// [Output Only] A unique identifier for this resource type. The server
  /// generates this identifier.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#notificationEndpoint
  /// for notification endpoints.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the notification endpoint resides.
  /// This field applies only to the regional resource. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  NotificationEndpoint();

  NotificationEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('grpcSettings')) {
      grpcSettings = NotificationEndpointGrpcSettings.fromJson(
          _json['grpcSettings'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (grpcSettings != null) {
      _json['grpcSettings'] = grpcSettings.toJson();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// Represents a gRPC setting that describes one gRPC notification endpoint and
/// the retry duration attempting to send notification to this endpoint.
class NotificationEndpointGrpcSettings {
  /// Optional. If specified, this field is used to set the authority header by
  /// the sender of notifications. See
  /// https://tools.ietf.org/html/rfc7540#section-8.1.2.3
  core.String authority;

  /// Endpoint to which gRPC notifications are sent. This must be a valid gRPCLB
  /// DNS name.
  core.String endpoint;

  /// Optional. If specified, this field is used to populate the "name" field in
  /// gRPC requests.
  core.String payloadName;

  /// Optional. This field is used to configure how often to send a full update
  /// of all non-healthy backends. If unspecified, full updates are not sent. If
  /// specified, must be in the range between 600 seconds to 3600 seconds. Nanos
  /// are disallowed.
  Duration resendInterval;

  /// How much time (in seconds) is spent attempting notification retries until
  /// a successful response is received. Default is 30s. Limit is 20m (1200s).
  /// Must be a positive number.
  core.int retryDurationSec;

  NotificationEndpointGrpcSettings();

  NotificationEndpointGrpcSettings.fromJson(core.Map _json) {
    if (_json.containsKey('authority')) {
      authority = _json['authority'] as core.String;
    }
    if (_json.containsKey('endpoint')) {
      endpoint = _json['endpoint'] as core.String;
    }
    if (_json.containsKey('payloadName')) {
      payloadName = _json['payloadName'] as core.String;
    }
    if (_json.containsKey('resendInterval')) {
      resendInterval = Duration.fromJson(
          _json['resendInterval'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryDurationSec')) {
      retryDurationSec = _json['retryDurationSec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (authority != null) {
      _json['authority'] = authority;
    }
    if (endpoint != null) {
      _json['endpoint'] = endpoint;
    }
    if (payloadName != null) {
      _json['payloadName'] = payloadName;
    }
    if (resendInterval != null) {
      _json['resendInterval'] = resendInterval.toJson();
    }
    if (retryDurationSec != null) {
      _json['retryDurationSec'] = retryDurationSec;
    }
    return _json;
  }
}

class NotificationEndpointListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  NotificationEndpointListWarningData();

  NotificationEndpointListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class NotificationEndpointListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<NotificationEndpointListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  NotificationEndpointListWarning();

  NotificationEndpointListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NotificationEndpointListWarningData>((value) =>
              NotificationEndpointListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class NotificationEndpointList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of NotificationEndpoint resources.
  core.List<NotificationEndpoint> items;

  /// [Output Only] Type of the resource. Always compute#notificationEndpoint
  /// for notification endpoints.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  NotificationEndpointListWarning warning;

  NotificationEndpointList();

  NotificationEndpointList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NotificationEndpoint>((value) => NotificationEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NotificationEndpointListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class OperationErrorErrors {
  /// [Output Only] The error type identifier for this error.
  core.String code;

  /// [Output Only] Indicates the field in the request that caused the error.
  /// This property is optional.
  core.String location;

  /// [Output Only] An optional, human-readable error message.
  core.String message;

  OperationErrorErrors();

  OperationErrorErrors.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (location != null) {
      _json['location'] = location;
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// [Output Only] If errors are generated during processing of the operation,
/// this field will be populated.
class OperationError {
  /// [Output Only] The array of errors encountered while processing this
  /// operation.
  core.List<OperationErrorErrors> errors;

  OperationError();

  OperationError.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = (_json['errors'] as core.List)
          .map<OperationErrorErrors>((value) => OperationErrorErrors.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (errors != null) {
      _json['errors'] = errors.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class OperationWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationWarningsData();

  OperationWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

class OperationWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationWarnings();

  OperationWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationWarningsData>((value) => OperationWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Represents an Operation resource.
///
/// Google Compute Engine has three Operation resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/globalOperations) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionOperations) *
/// [Zonal](/compute/docs/reference/rest/{$api_version}/zoneOperations)
///
/// You can use an operation resource to manage asynchronous API requests. For
/// more information, read Handling API responses.
///
/// Operations can be global, regional or zonal.
/// - For global operations, use the `globalOperations` resource.
/// - For regional operations, use the `regionOperations` resource.
/// - For zonal operations, use the `zonalOperations` resource.
///
/// For more information, read  Global, Regional, and Zonal Resources. (==
/// resource_for {$api_version}.globalOperations ==) (== resource_for
/// {$api_version}.regionOperations ==) (== resource_for
/// {$api_version}.zoneOperations ==)
class Operation {
  /// [Output Only] The value of `requestId` if you provided it in the request.
  /// Not present otherwise.
  core.String clientOperationId;

  /// [Deprecated] This field is deprecated.
  core.String creationTimestamp;

  /// [Output Only] A textual description of the operation, which is set when
  /// the operation is created.
  core.String description;

  /// [Output Only] The time that this operation was completed. This value is in
  /// RFC3339 text format.
  core.String endTime;

  /// [Output Only] If errors are generated during processing of the operation,
  /// this field will be populated.
  OperationError error;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// message that was returned, such as `NOT FOUND`.
  core.String httpErrorMessage;

  /// [Output Only] If the operation fails, this field contains the HTTP error
  /// status code that was returned. For example, a `404` means the resource was
  /// not found.
  core.int httpErrorStatusCode;

  /// [Output Only] The unique identifier for the operation. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] The time that this operation was requested. This value is in
  /// RFC3339 text format.
  core.String insertTime;

  /// [Output Only] Type of the resource. Always `compute#operation` for
  /// Operation resources.
  core.String kind;

  /// [Output Only] Name of the operation.
  core.String name;

  /// [Output Only] The type of operation, such as `insert`, `update`, or
  /// `delete`, and so on.
  core.String operationType;

  /// [Output Only] An optional progress indicator that ranges from 0 to 100.
  /// There is no requirement that this be linear or support any granularity of
  /// operations. This should not be used to guess when the operation will be
  /// complete. This number should monotonically increase as the operation
  /// progresses.
  core.int progress;

  /// [Output Only] The URL of the region where the operation resides. Only
  /// applicable when performing regional operations.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The time that this operation was started by the server. This
  /// value is in RFC3339 text format.
  core.String startTime;

  /// [Output Only] The status of the operation, which can be one of the
  /// following: `PENDING`, `RUNNING`, or `DONE`.
  /// Possible string values are:
  /// - "DONE"
  /// - "PENDING"
  /// - "RUNNING"
  core.String status;

  /// [Output Only] An optional textual description of the current status of the
  /// operation.
  core.String statusMessage;

  /// [Output Only] The unique target ID, which identifies a specific
  /// incarnation of the target resource.
  core.String targetId;

  /// [Output Only] The URL of the resource that the operation modifies. For
  /// operations related to creating a snapshot, this points to the persistent
  /// disk that the snapshot was created from.
  core.String targetLink;

  /// [Output Only] User who requested the operation, for example:
  /// `user@example.com`.
  core.String user;

  /// [Output Only] If warning messages are generated during processing of the
  /// operation, this field will be populated.
  core.List<OperationWarnings> warnings;

  /// [Output Only] The URL of the zone where the operation resides. Only
  /// applicable when performing per-zone operations.
  core.String zone;

  Operation();

  Operation.fromJson(core.Map _json) {
    if (_json.containsKey('clientOperationId')) {
      clientOperationId = _json['clientOperationId'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTime')) {
      endTime = _json['endTime'] as core.String;
    }
    if (_json.containsKey('error')) {
      error = OperationError.fromJson(
          _json['error'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpErrorMessage')) {
      httpErrorMessage = _json['httpErrorMessage'] as core.String;
    }
    if (_json.containsKey('httpErrorStatusCode')) {
      httpErrorStatusCode = _json['httpErrorStatusCode'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('insertTime')) {
      insertTime = _json['insertTime'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('operationType')) {
      operationType = _json['operationType'] as core.String;
    }
    if (_json.containsKey('progress')) {
      progress = _json['progress'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
    if (_json.containsKey('targetId')) {
      targetId = _json['targetId'] as core.String;
    }
    if (_json.containsKey('targetLink')) {
      targetLink = _json['targetLink'] as core.String;
    }
    if (_json.containsKey('user')) {
      user = _json['user'] as core.String;
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<OperationWarnings>((value) => OperationWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (clientOperationId != null) {
      _json['clientOperationId'] = clientOperationId;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (endTime != null) {
      _json['endTime'] = endTime;
    }
    if (error != null) {
      _json['error'] = error.toJson();
    }
    if (httpErrorMessage != null) {
      _json['httpErrorMessage'] = httpErrorMessage;
    }
    if (httpErrorStatusCode != null) {
      _json['httpErrorStatusCode'] = httpErrorStatusCode;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (insertTime != null) {
      _json['insertTime'] = insertTime;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (operationType != null) {
      _json['operationType'] = operationType;
    }
    if (progress != null) {
      _json['progress'] = progress;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (startTime != null) {
      _json['startTime'] = startTime;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (statusMessage != null) {
      _json['statusMessage'] = statusMessage;
    }
    if (targetId != null) {
      _json['targetId'] = targetId;
    }
    if (targetLink != null) {
      _json['targetLink'] = targetLink;
    }
    if (user != null) {
      _json['user'] = user;
    }
    if (warnings != null) {
      _json['warnings'] = warnings.map((value) => value.toJson()).toList();
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class OperationAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationAggregatedListWarningData();

  OperationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationAggregatedListWarning();

  OperationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationAggregatedListWarningData>((value) =>
              OperationAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class OperationAggregatedList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A map of scoped operation lists.
  core.Map<core.String, OperationsScopedList> items;

  /// [Output Only] Type of resource. Always `compute#operationAggregatedList`
  /// for aggregated lists of operations.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than `maxResults`, use
  /// the `nextPageToken` as a value for the query parameter `pageToken` in the
  /// next list request. Subsequent list requests will have their own
  /// `nextPageToken` to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  OperationAggregatedListWarning warning;

  OperationAggregatedList();

  OperationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              OperationsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = OperationAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class OperationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationListWarningData();

  OperationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class OperationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationListWarning();

  OperationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationListWarningData>((value) =>
              OperationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Operation resources.
class OperationList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of Operation resources.
  core.List<Operation> items;

  /// [Output Only] Type of resource. Always `compute#operations` for Operations
  /// resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than `maxResults`, use
  /// the `nextPageToken` as a value for the query parameter `pageToken` in the
  /// next list request. Subsequent list requests will have their own
  /// `nextPageToken` to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  OperationListWarning warning;

  OperationList();

  OperationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Operation>((value) =>
              Operation.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = OperationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class OperationsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  OperationsScopedListWarningData();

  OperationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of operations
/// when the list is empty.
class OperationsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<OperationsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  OperationsScopedListWarning();

  OperationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationsScopedListWarningData>((value) =>
              OperationsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class OperationsScopedList {
  /// [Output Only] A list of operations contained in this scope.
  core.List<Operation> operations;

  /// [Output Only] Informational warning which replaces the list of operations
  /// when the list is empty.
  OperationsScopedListWarning warning;

  OperationsScopedList();

  OperationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('operations')) {
      operations = (_json['operations'] as core.List)
          .map<Operation>((value) =>
              Operation.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = OperationsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (operations != null) {
      _json['operations'] = operations.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Settings controlling the eviction of unhealthy hosts from the load balancing
/// pool for the backend service.
class OutlierDetection {
  /// The base time that a host is ejected for. The real ejection time is equal
  /// to the base ejection time multiplied by the number of times the host has
  /// been ejected. Defaults to 30000ms or 30s.
  Duration baseEjectionTime;

  /// Number of errors before a host is ejected from the connection pool. When
  /// the backend host is accessed over HTTP, a 5xx return code qualifies as an
  /// error. Defaults to 5.
  core.int consecutiveErrors;

  /// The number of consecutive gateway failures (502, 503, 504 status or
  /// connection errors that are mapped to one of those status codes) before a
  /// consecutive gateway failure ejection occurs. Defaults to 3.
  core.int consecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive 5xx. This setting can be used to
  /// disable ejection or to ramp it up slowly. Defaults to 0.
  core.int enforcingConsecutiveErrors;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive gateway failures. This setting can
  /// be used to disable ejection or to ramp it up slowly. Defaults to 100.
  core.int enforcingConsecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through success rate statistics. This setting can be
  /// used to disable ejection or to ramp it up slowly. Defaults to 100.
  core.int enforcingSuccessRate;

  /// Time interval between ejection analysis sweeps. This can result in both
  /// new ejections as well as hosts being returned to service. Defaults to 1
  /// second.
  Duration interval;

  /// Maximum percentage of hosts in the load balancing pool for the backend
  /// service that can be ejected. Defaults to 50%.
  core.int maxEjectionPercent;

  /// The number of hosts in a cluster that must have enough request volume to
  /// detect success rate outliers. If the number of hosts is less than this
  /// setting, outlier detection via success rate statistics is not performed
  /// for any host in the cluster. Defaults to 5.
  core.int successRateMinimumHosts;

  /// The minimum number of total requests that must be collected in one
  /// interval (as defined by the interval duration above) to include this host
  /// in success rate based outlier detection. If the volume is lower than this
  /// setting, outlier detection via success rate statistics is not performed
  /// for that host. Defaults to 100.
  core.int successRateRequestVolume;

  /// This factor is used to determine the ejection threshold for success rate
  /// outlier ejection. The ejection threshold is the difference between the
  /// mean success rate, and the product of this factor and the standard
  /// deviation of the mean success rate: mean - (stdev *
  /// success_rate_stdev_factor). This factor is divided by a thousand to get a
  /// double. That is, if the desired factor is 1.9, the runtime value should be
  /// 1900. Defaults to 1900.
  core.int successRateStdevFactor;

  OutlierDetection();

  OutlierDetection.fromJson(core.Map _json) {
    if (_json.containsKey('baseEjectionTime')) {
      baseEjectionTime = Duration.fromJson(
          _json['baseEjectionTime'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('consecutiveErrors')) {
      consecutiveErrors = _json['consecutiveErrors'] as core.int;
    }
    if (_json.containsKey('consecutiveGatewayFailure')) {
      consecutiveGatewayFailure =
          _json['consecutiveGatewayFailure'] as core.int;
    }
    if (_json.containsKey('enforcingConsecutiveErrors')) {
      enforcingConsecutiveErrors =
          _json['enforcingConsecutiveErrors'] as core.int;
    }
    if (_json.containsKey('enforcingConsecutiveGatewayFailure')) {
      enforcingConsecutiveGatewayFailure =
          _json['enforcingConsecutiveGatewayFailure'] as core.int;
    }
    if (_json.containsKey('enforcingSuccessRate')) {
      enforcingSuccessRate = _json['enforcingSuccessRate'] as core.int;
    }
    if (_json.containsKey('interval')) {
      interval = Duration.fromJson(
          _json['interval'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxEjectionPercent')) {
      maxEjectionPercent = _json['maxEjectionPercent'] as core.int;
    }
    if (_json.containsKey('successRateMinimumHosts')) {
      successRateMinimumHosts = _json['successRateMinimumHosts'] as core.int;
    }
    if (_json.containsKey('successRateRequestVolume')) {
      successRateRequestVolume = _json['successRateRequestVolume'] as core.int;
    }
    if (_json.containsKey('successRateStdevFactor')) {
      successRateStdevFactor = _json['successRateStdevFactor'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (baseEjectionTime != null) {
      _json['baseEjectionTime'] = baseEjectionTime.toJson();
    }
    if (consecutiveErrors != null) {
      _json['consecutiveErrors'] = consecutiveErrors;
    }
    if (consecutiveGatewayFailure != null) {
      _json['consecutiveGatewayFailure'] = consecutiveGatewayFailure;
    }
    if (enforcingConsecutiveErrors != null) {
      _json['enforcingConsecutiveErrors'] = enforcingConsecutiveErrors;
    }
    if (enforcingConsecutiveGatewayFailure != null) {
      _json['enforcingConsecutiveGatewayFailure'] =
          enforcingConsecutiveGatewayFailure;
    }
    if (enforcingSuccessRate != null) {
      _json['enforcingSuccessRate'] = enforcingSuccessRate;
    }
    if (interval != null) {
      _json['interval'] = interval.toJson();
    }
    if (maxEjectionPercent != null) {
      _json['maxEjectionPercent'] = maxEjectionPercent;
    }
    if (successRateMinimumHosts != null) {
      _json['successRateMinimumHosts'] = successRateMinimumHosts;
    }
    if (successRateRequestVolume != null) {
      _json['successRateRequestVolume'] = successRateRequestVolume;
    }
    if (successRateStdevFactor != null) {
      _json['successRateStdevFactor'] = successRateStdevFactor;
    }
    return _json;
  }
}

/// Represents a Packet Mirroring resource.
///
/// Packet Mirroring clones the traffic of specified instances in your Virtual
/// Private Cloud (VPC) network and forwards it to a collector destination, such
/// as an instance group of an internal TCP/UDP load balancer, for analysis or
/// examination. For more information about setting up Packet Mirroring, see
/// Using Packet Mirroring. (== resource_for {$api_version}.packetMirrorings ==)
class PacketMirroring {
  /// The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
  /// will be used as collector for mirrored traffic. The specified forwarding
  /// rule must have isMirroringCollector set to true.
  PacketMirroringForwardingRuleInfo collectorIlb;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Indicates whether or not this packet mirroring takes effect. If set to
  /// FALSE, this packet mirroring policy will not be enforced on the network.
  ///
  /// The default is TRUE.
  /// Possible string values are:
  /// - "FALSE"
  /// - "TRUE"
  core.String enable;

  /// Filter for mirrored traffic. If unspecified, all traffic is mirrored.
  PacketMirroringFilter filter;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#packetMirroring for
  /// packet mirrorings.
  core.String kind;

  /// PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a
  /// set of mirrored VM instances, subnetworks and/or tags for which traffic
  /// from/to all VM instances will be mirrored.
  PacketMirroringMirroredResourceInfo mirroredResources;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the mirrored VPC network. Only packets in this network will be
  /// mirrored. All mirrored VMs should have a NIC in the given network. All
  /// mirrored subnetworks should belong to the given network.
  PacketMirroringNetworkInfo network;

  /// The priority of applying this configuration. Priority is used to break
  /// ties in cases where there is more than one matching rule. In the case of
  /// two rules that apply for a given Instance, the one with the
  /// lowest-numbered priority value wins.
  ///
  /// Default value is 1000. Valid range is 0 through 65535.
  core.int priority;

  /// [Output Only] URI of the region where the packetMirroring resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  PacketMirroring();

  PacketMirroring.fromJson(core.Map _json) {
    if (_json.containsKey('collectorIlb')) {
      collectorIlb = PacketMirroringForwardingRuleInfo.fromJson(
          _json['collectorIlb'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.String;
    }
    if (_json.containsKey('filter')) {
      filter = PacketMirroringFilter.fromJson(
          _json['filter'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('mirroredResources')) {
      mirroredResources = PacketMirroringMirroredResourceInfo.fromJson(
          _json['mirroredResources'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = PacketMirroringNetworkInfo.fromJson(
          _json['network'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (collectorIlb != null) {
      _json['collectorIlb'] = collectorIlb.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enable != null) {
      _json['enable'] = enable;
    }
    if (filter != null) {
      _json['filter'] = filter.toJson();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (mirroredResources != null) {
      _json['mirroredResources'] = mirroredResources.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network.toJson();
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

class PacketMirroringAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringAggregatedListWarningData();

  PacketMirroringAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class PacketMirroringAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringAggregatedListWarning();

  PacketMirroringAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringAggregatedListWarningData>((value) =>
              PacketMirroringAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of packetMirrorings.
class PacketMirroringAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of PacketMirroring resources.
  core.Map<core.String, PacketMirroringsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  PacketMirroringAggregatedListWarning warning;

  PacketMirroringAggregatedList();

  PacketMirroringAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              PacketMirroringsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class PacketMirroringFilter {
  /// Protocols that apply as filter on mirrored traffic. If no protocols are
  /// specified, all traffic that matches the specified CIDR ranges is mirrored.
  /// If neither cidrRanges nor IPProtocols is specified, all traffic is
  /// mirrored.
  core.List<core.String> IPProtocols;

  /// IP CIDR ranges that apply as filter on the source (ingress) or destination
  /// (egress) IP in the IP header. Only IPv4 is supported. If no ranges are
  /// specified, all traffic that matches the specified IPProtocols is mirrored.
  /// If neither cidrRanges nor IPProtocols is specified, all traffic is
  /// mirrored.
  core.List<core.String> cidrRanges;

  PacketMirroringFilter();

  PacketMirroringFilter.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocols')) {
      IPProtocols = (_json['IPProtocols'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('cidrRanges')) {
      cidrRanges = (_json['cidrRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (IPProtocols != null) {
      _json['IPProtocols'] = IPProtocols;
    }
    if (cidrRanges != null) {
      _json['cidrRanges'] = cidrRanges;
    }
    return _json;
  }
}

class PacketMirroringForwardingRuleInfo {
  /// [Output Only] Unique identifier for the forwarding rule; defined by the
  /// server.
  core.String canonicalUrl;

  /// Resource URL to the forwarding rule representing the ILB configured as
  /// destination of the mirrored traffic.
  core.String url;

  PacketMirroringForwardingRuleInfo();

  PacketMirroringForwardingRuleInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canonicalUrl != null) {
      _json['canonicalUrl'] = canonicalUrl;
    }
    if (url != null) {
      _json['url'] = url;
    }
    return _json;
  }
}

class PacketMirroringListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringListWarningData();

  PacketMirroringListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class PacketMirroringListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringListWarning();

  PacketMirroringListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringListWarningData>((value) =>
              PacketMirroringListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of PacketMirroring resources.
class PacketMirroringList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of PacketMirroring resources.
  core.List<PacketMirroring> items;

  /// [Output Only] Type of resource. Always compute#packetMirroring for
  /// packetMirrorings.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  PacketMirroringListWarning warning;

  PacketMirroringList();

  PacketMirroringList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PacketMirroring>((value) => PacketMirroring.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfo {
  /// A set of virtual machine instances that are being mirrored. They must live
  /// in zones contained in the same region as this packetMirroring.
  ///
  /// Note that this config will apply only to those network interfaces of the
  /// Instances that belong to the network specified in this packetMirroring.
  ///
  /// You may specify a maximum of 50 Instances.
  core.List<PacketMirroringMirroredResourceInfoInstanceInfo> instances;

  /// A set of subnetworks for which traffic from/to all VM instances will be
  /// mirrored. They must live in the same region as this packetMirroring.
  ///
  /// You may specify a maximum of 5 subnetworks.
  core.List<PacketMirroringMirroredResourceInfoSubnetInfo> subnetworks;

  /// A set of mirrored tags. Traffic from/to all VM instances that have one or
  /// more of these tags will be mirrored.
  core.List<core.String> tags;

  PacketMirroringMirroredResourceInfo();

  PacketMirroringMirroredResourceInfo.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PacketMirroringMirroredResourceInfoInstanceInfo>((value) =>
              PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<PacketMirroringMirroredResourceInfoSubnetInfo>((value) =>
              PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('tags')) {
      tags = (_json['tags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    if (subnetworks != null) {
      _json['subnetworks'] =
          subnetworks.map((value) => value.toJson()).toList();
    }
    if (tags != null) {
      _json['tags'] = tags;
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfoInstanceInfo {
  /// [Output Only] Unique identifier for the instance; defined by the server.
  core.String canonicalUrl;

  /// Resource URL to the virtual machine instance which is being mirrored.
  core.String url;

  PacketMirroringMirroredResourceInfoInstanceInfo();

  PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canonicalUrl != null) {
      _json['canonicalUrl'] = canonicalUrl;
    }
    if (url != null) {
      _json['url'] = url;
    }
    return _json;
  }
}

class PacketMirroringMirroredResourceInfoSubnetInfo {
  /// [Output Only] Unique identifier for the subnetwork; defined by the server.
  core.String canonicalUrl;

  /// Resource URL to the subnetwork for which traffic from/to all VM instances
  /// will be mirrored.
  core.String url;

  PacketMirroringMirroredResourceInfoSubnetInfo();

  PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canonicalUrl != null) {
      _json['canonicalUrl'] = canonicalUrl;
    }
    if (url != null) {
      _json['url'] = url;
    }
    return _json;
  }
}

class PacketMirroringNetworkInfo {
  /// [Output Only] Unique identifier for the network; defined by the server.
  core.String canonicalUrl;

  /// URL of the network resource.
  core.String url;

  PacketMirroringNetworkInfo();

  PacketMirroringNetworkInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (canonicalUrl != null) {
      _json['canonicalUrl'] = canonicalUrl;
    }
    if (url != null) {
      _json['url'] = url;
    }
    return _json;
  }
}

class PacketMirroringsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  PacketMirroringsScopedListWarningData();

  PacketMirroringsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of packetMirrorings when the
/// list is empty.
class PacketMirroringsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<PacketMirroringsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  PacketMirroringsScopedListWarning();

  PacketMirroringsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringsScopedListWarningData>((value) =>
              PacketMirroringsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class PacketMirroringsScopedList {
  /// A list of packetMirrorings contained in this scope.
  core.List<PacketMirroring> packetMirrorings;

  /// Informational warning which replaces the list of packetMirrorings when the
  /// list is empty.
  PacketMirroringsScopedListWarning warning;

  PacketMirroringsScopedList();

  PacketMirroringsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('packetMirrorings')) {
      packetMirrorings = (_json['packetMirrorings'] as core.List)
          .map<PacketMirroring>((value) => PacketMirroring.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (packetMirrorings != null) {
      _json['packetMirrorings'] =
          packetMirrorings.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A matcher for the path portion of the URL. The BackendService from the
/// longest-matched rule will serve the URL. If no rule was matched, the default
/// service will be used.
class PathMatcher {
  /// defaultRouteAction takes effect when none of the  pathRules or routeRules
  /// match. The load balancer performs advanced routing actions like URL
  /// rewrites, header transformations, etc. prior to forwarding the request to
  /// the selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a pathMatcher's defaultRouteAction.
  HttpRouteAction defaultRouteAction;

  /// The full or partial URL to the BackendService resource. This will be used
  /// if none of the pathRules or routeRules defined by this PathMatcher are
  /// matched. For example, the following are all valid URLs to a BackendService
  /// resource:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
  /// - compute/v1/projects/project/global/backendServices/backendService
  /// - global/backendServices/backendService  If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be specified.
  /// Only one of defaultService, defaultUrlRedirect  or
  /// defaultRouteAction.weightedBackendService must be set.
  /// Authorization requires one or more of the following Google IAM permissions
  /// on the specified resource default_service:
  /// - compute.backendBuckets.use
  /// - compute.backendServices.use
  core.String defaultService;

  /// When none of the specified pathRules or routeRules match, the request is
  /// redirected to a URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction defaultUrlRedirect;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// HeaderAction specified here are applied after the matching HttpRouteRule
  /// HeaderAction and before the HeaderAction in the UrlMap
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction headerAction;

  /// The name to which this PathMatcher is referred by the HostRule.
  core.String name;

  /// The list of path rules. Use this list instead of routeRules when routing
  /// based on simple path matching is all that's required. The order by which
  /// path rules are specified does not matter. Matches are always done on the
  /// longest-path-first basis.
  /// For example: a pathRule with a path /a/b/c / *  will match before /a/b / *
  /// irrespective of the order in which those paths appear in this list.
  /// Within a given pathMatcher, only one of pathRules or routeRules must be
  /// set.
  core.List<PathRule> pathRules;

  /// The list of HTTP route rules. Use this list instead of pathRules when
  /// advanced route matching and routing actions are desired. routeRules are
  /// evaluated in order of priority, from the lowest to highest number.
  /// Within a given pathMatcher, you can set only one of pathRules or
  /// routeRules.
  core.List<HttpRouteRule> routeRules;

  PathMatcher();

  PathMatcher.fromJson(core.Map _json) {
    if (_json.containsKey('defaultRouteAction')) {
      defaultRouteAction = HttpRouteAction.fromJson(
          _json['defaultRouteAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('defaultService')) {
      defaultService = _json['defaultService'] as core.String;
    }
    if (_json.containsKey('defaultUrlRedirect')) {
      defaultUrlRedirect = HttpRedirectAction.fromJson(
          _json['defaultUrlRedirect'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('pathRules')) {
      pathRules = (_json['pathRules'] as core.List)
          .map<PathRule>((value) =>
              PathRule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('routeRules')) {
      routeRules = (_json['routeRules'] as core.List)
          .map<HttpRouteRule>((value) => HttpRouteRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (defaultRouteAction != null) {
      _json['defaultRouteAction'] = defaultRouteAction.toJson();
    }
    if (defaultService != null) {
      _json['defaultService'] = defaultService;
    }
    if (defaultUrlRedirect != null) {
      _json['defaultUrlRedirect'] = defaultUrlRedirect.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (headerAction != null) {
      _json['headerAction'] = headerAction.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (pathRules != null) {
      _json['pathRules'] = pathRules.map((value) => value.toJson()).toList();
    }
    if (routeRules != null) {
      _json['routeRules'] = routeRules.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// A path-matching rule for a URL. If matched, will use the specified
/// BackendService to handle the traffic arriving at this URL.
class PathRule {
  /// The list of path patterns to match. Each must start with / and the only
  /// place a * is allowed is at the end following a /. The string fed to the
  /// path matcher does not include any text after the first ? or #, and those
  /// chars are not allowed here.
  core.List<core.String> paths;

  /// In response to a matching path, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc. prior to
  /// forwarding the request to the selected backend. If routeAction specifies
  /// any  weightedBackendServices, service must not be set. Conversely if
  /// service is set, routeAction cannot contain any  weightedBackendServices.
  /// Only one of routeAction or urlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a pathRule's routeAction.
  HttpRouteAction routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched. If routeAction is additionally
  /// specified, advanced routing actions like URL Rewrites, etc. take effect
  /// prior to sending the request to the backend. However, if service is
  /// specified, routeAction cannot contain any weightedBackendService s.
  /// Conversely, if routeAction specifies any  weightedBackendServices, service
  /// must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String service;

  /// When a path pattern is matched, the request is redirected to a URL
  /// specified by urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction urlRedirect;

  PathRule();

  PathRule.fromJson(core.Map _json) {
    if (_json.containsKey('paths')) {
      paths = (_json['paths'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('routeAction')) {
      routeAction = HttpRouteAction.fromJson(
          _json['routeAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlRedirect')) {
      urlRedirect = HttpRedirectAction.fromJson(
          _json['urlRedirect'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (paths != null) {
      _json['paths'] = paths;
    }
    if (routeAction != null) {
      _json['routeAction'] = routeAction.toJson();
    }
    if (service != null) {
      _json['service'] = service;
    }
    if (urlRedirect != null) {
      _json['urlRedirect'] = urlRedirect.toJson();
    }
    return _json;
  }
}

class PerInstanceConfig {
  /// Fingerprint of this per-instance config. This field can be used in
  /// optimistic locking. It is ignored when inserting a per-instance config. An
  /// up-to-date fingerprint must be provided in order to update an existing
  /// per-instance config or the field needs to be unset.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The name of a per-instance config and its corresponding instance. Serves
  /// as a merge key during UpdatePerInstanceConfigs operations, that is, if a
  /// per-instance config with the same name exists then it will be updated,
  /// otherwise a new one will be created for the VM instance with the same
  /// name. An attempt to create a per-instance config for a VM instance that
  /// either doesn't exist or is not part of the group will result in an error.
  core.String name;

  /// The intended preserved state for the given instance. Does not contain
  /// preserved state generated from a stateful policy.
  PreservedState preservedState;

  /// The status of applying this per-instance config on the corresponding
  /// managed instance.
  /// Possible string values are:
  /// - "APPLYING"
  /// - "DELETING"
  /// - "EFFECTIVE"
  /// - "NONE"
  /// - "UNAPPLIED"
  /// - "UNAPPLIED_DELETION"
  core.String status;

  PerInstanceConfig();

  PerInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('preservedState')) {
      preservedState = PreservedState.fromJson(
          _json['preservedState'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (preservedState != null) {
      _json['preservedState'] = preservedState.toJson();
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members` to a single `role`. Members can be user accounts, service
/// accounts, Google groups, and domains (such as G Suite). A `role` is a named
/// list of permissions; each `role` can be an IAM predefined role or a
/// user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the [IAM
/// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin",
/// "members": [ "user:mike@example.com", "group:admins@example.com",
/// "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": [
/// "user:eve@example.com" ], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
/// "BwWWja0YfJA=", "version": 3 }
///
/// **YAML example:**
///
/// bindings: - members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') -
/// etag: BwWWja0YfJA= - version: 3
///
/// For a description of IAM and its features, see the [IAM
/// documentation](https://cloud.google.com/iam/docs/).
class Policy {
  /// Specifies cloud audit logging configuration for this policy.
  core.List<AuditConfig> auditConfigs;

  /// Associates a list of `members` to a `role`. Optionally, may specify a
  /// `condition` that determines how and when the `bindings` are applied. Each
  /// of the `bindings` must contain at least one member.
  core.List<Binding> bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other. It is
  /// strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  core.String etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  core.bool iamOwned;

  /// If more than one rule is specified, the rules are applied in the following
  /// manner: - All matching LOG rules are always applied. - If any
  /// DENY/DENY_WITH_LOG rule matches, permission is denied. Logging will be
  /// applied if one or more matching rule requires logging. - Otherwise, if any
  /// ALLOW/ALLOW_WITH_LOG rule matches, permission is granted. Logging will be
  /// applied if one or more matching rule requires logging. - Otherwise, if no
  /// rule applies, permission is denied.
  core.List<Rule> rules;

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int version;

  Policy();

  Policy.fromJson(core.Map _json) {
    if (_json.containsKey('auditConfigs')) {
      auditConfigs = (_json['auditConfigs'] as core.List)
          .map<AuditConfig>((value) => AuditConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('iamOwned')) {
      iamOwned = _json['iamOwned'] as core.bool;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<Rule>((value) =>
              Rule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('version')) {
      version = _json['version'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (auditConfigs != null) {
      _json['auditConfigs'] =
          auditConfigs.map((value) => value.toJson()).toList();
    }
    if (bindings != null) {
      _json['bindings'] = bindings.map((value) => value.toJson()).toList();
    }
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (iamOwned != null) {
      _json['iamOwned'] = iamOwned;
    }
    if (rules != null) {
      _json['rules'] = rules.map((value) => value.toJson()).toList();
    }
    if (version != null) {
      _json['version'] = version;
    }
    return _json;
  }
}

class PreconfiguredWafSet {
  /// List of entities that are currently supported for WAF rules.
  core.List<WafExpressionSet> expressionSets;

  PreconfiguredWafSet();

  PreconfiguredWafSet.fromJson(core.Map _json) {
    if (_json.containsKey('expressionSets')) {
      expressionSets = (_json['expressionSets'] as core.List)
          .map<WafExpressionSet>((value) => WafExpressionSet.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (expressionSets != null) {
      _json['expressionSets'] =
          expressionSets.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// Preserved state for a given instance.
class PreservedState {
  /// Preserved disks defined for this instance. This map is keyed with the
  /// device names of the disks.
  core.Map<core.String, PreservedStatePreservedDisk> disks;

  /// Preserved metadata defined for this instance.
  core.Map<core.String, core.String> metadata;

  PreservedState();

  PreservedState.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              PreservedStatePreservedDisk.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('metadata')) {
      metadata =
          (_json['metadata'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (disks != null) {
      _json['disks'] =
          disks.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (metadata != null) {
      _json['metadata'] = metadata;
    }
    return _json;
  }
}

class PreservedStatePreservedDisk {
  /// These stateful disks will never be deleted during autohealing, update,
  /// instance recreate operations. This flag is used to configure if the disk
  /// should be deleted after it is no longer used by the group, e.g. when the
  /// given instance or the whole MIG is deleted. Note: disks attached in
  /// READ_ONLY mode cannot be auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String autoDelete;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If
  /// not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String mode;

  /// The URL of the disk resource that is stateful and should be attached to
  /// the VM instance.
  core.String source;

  PreservedStatePreservedDisk();

  PreservedStatePreservedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.String;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoDelete != null) {
      _json['autoDelete'] = autoDelete;
    }
    if (mode != null) {
      _json['mode'] = mode;
    }
    if (source != null) {
      _json['source'] = source;
    }
    return _json;
  }
}

/// Represents a Project resource.
///
/// A project is used to organize resources in a Google Cloud Platform
/// environment. For more information, read about the  Resource Hierarchy. (==
/// resource_for {$api_version}.projects ==)
class Project {
  /// Metadata key/value pairs available to all instances contained in this
  /// project. See Custom metadata for more information.
  Metadata commonInstanceMetadata;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// This signifies the default network tier used for configuring resources of
  /// the project and can only take the following values: PREMIUM, STANDARD.
  /// Initially the default network tier is PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String defaultNetworkTier;

  /// [Output Only] Default service account used by VMs running in this project.
  core.String defaultServiceAccount;

  /// An optional textual description of the resource.
  core.String description;

  /// Restricted features enabled for use on this project.
  core.List<core.String> enabledFeatures;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server. This is not the project ID, and is just a unique ID
  /// used by Compute Engine to identify resources.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#project for projects.
  core.String kind;

  /// The project ID. For example: my-example-project. Use the project ID to
  /// make requests to Compute Engine.
  core.String name;

  /// [Output Only] Quotas assigned to this project.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The naming prefix for daily usage reports and the Google Cloud Storage
  /// bucket where they are stored.
  UsageExportLocation usageExportLocation;

  /// [Output Only] The role this project has in a shared VPC configuration.
  /// Currently, only projects with the host role, which is specified by the
  /// value HOST, are differentiated.
  /// Possible string values are:
  /// - "HOST"
  /// - "UNSPECIFIED_XPN_PROJECT_STATUS"
  core.String xpnProjectStatus;

  Project();

  Project.fromJson(core.Map _json) {
    if (_json.containsKey('commonInstanceMetadata')) {
      commonInstanceMetadata = Metadata.fromJson(_json['commonInstanceMetadata']
          as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultNetworkTier')) {
      defaultNetworkTier = _json['defaultNetworkTier'] as core.String;
    }
    if (_json.containsKey('defaultServiceAccount')) {
      defaultServiceAccount = _json['defaultServiceAccount'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enabledFeatures')) {
      enabledFeatures = (_json['enabledFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('quotas')) {
      quotas = (_json['quotas'] as core.List)
          .map<Quota>((value) =>
              Quota.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('usageExportLocation')) {
      usageExportLocation = UsageExportLocation.fromJson(
          _json['usageExportLocation'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('xpnProjectStatus')) {
      xpnProjectStatus = _json['xpnProjectStatus'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (commonInstanceMetadata != null) {
      _json['commonInstanceMetadata'] = commonInstanceMetadata.toJson();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (defaultNetworkTier != null) {
      _json['defaultNetworkTier'] = defaultNetworkTier;
    }
    if (defaultServiceAccount != null) {
      _json['defaultServiceAccount'] = defaultServiceAccount;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enabledFeatures != null) {
      _json['enabledFeatures'] = enabledFeatures;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (quotas != null) {
      _json['quotas'] = quotas.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (usageExportLocation != null) {
      _json['usageExportLocation'] = usageExportLocation.toJson();
    }
    if (xpnProjectStatus != null) {
      _json['xpnProjectStatus'] = xpnProjectStatus;
    }
    return _json;
  }
}

class ProjectsDisableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsDisableXpnResourceRequest();

  ProjectsDisableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('xpnResource')) {
      xpnResource = XpnResourceId.fromJson(
          _json['xpnResource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (xpnResource != null) {
      _json['xpnResource'] = xpnResource.toJson();
    }
    return _json;
  }
}

class ProjectsEnableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId xpnResource;

  ProjectsEnableXpnResourceRequest();

  ProjectsEnableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('xpnResource')) {
      xpnResource = XpnResourceId.fromJson(
          _json['xpnResource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (xpnResource != null) {
      _json['xpnResource'] = xpnResource.toJson();
    }
    return _json;
  }
}

class ProjectsGetXpnResources {
  /// [Output Only] Type of resource. Always compute#projectsGetXpnResources for
  /// lists of service resources (a.k.a service projects)
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// Service resources (a.k.a service projects) attached to this project as
  /// their shared VPC host.
  core.List<XpnResourceId> resources;

  ProjectsGetXpnResources();

  ProjectsGetXpnResources.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('resources')) {
      resources = (_json['resources'] as core.List)
          .map<XpnResourceId>((value) => XpnResourceId.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (resources != null) {
      _json['resources'] = resources.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects. If not specified, the organization will be
  /// inferred from the project.
  core.String organization;

  ProjectsListXpnHostsRequest();

  ProjectsListXpnHostsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('organization')) {
      organization = _json['organization'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (organization != null) {
      _json['organization'] = organization;
    }
    return _json;
  }
}

class ProjectsSetDefaultNetworkTierRequest {
  /// Default network tier to be set.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String networkTier;

  ProjectsSetDefaultNetworkTierRequest();

  ProjectsSetDefaultNetworkTierRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (networkTier != null) {
      _json['networkTier'] = networkTier;
    }
    return _json;
  }
}

/// A quotas entry.
class Quota {
  /// [Output Only] Quota limit for this metric.
  core.double limit;

  /// [Output Only] Name of the quota metric.
  /// Possible string values are:
  /// - "A2_CPUS"
  /// - "AFFINITY_GROUPS"
  /// - "AUTOSCALERS"
  /// - "BACKEND_BUCKETS"
  /// - "BACKEND_SERVICES"
  /// - "C2_CPUS"
  /// - "COMMITMENTS"
  /// - "COMMITTED_A2_CPUS"
  /// - "COMMITTED_C2_CPUS"
  /// - "COMMITTED_CPUS"
  /// - "COMMITTED_LICENSES"
  /// - "COMMITTED_LOCAL_SSD_TOTAL_GB"
  /// - "COMMITTED_MEMORY_OPTIMIZED_CPUS"
  /// - "COMMITTED_N2D_CPUS"
  /// - "COMMITTED_N2_CPUS"
  /// - "COMMITTED_NVIDIA_A100_GPUS"
  /// - "COMMITTED_NVIDIA_K80_GPUS"
  /// - "COMMITTED_NVIDIA_P100_GPUS"
  /// - "COMMITTED_NVIDIA_P4_GPUS"
  /// - "COMMITTED_NVIDIA_T4_GPUS"
  /// - "COMMITTED_NVIDIA_V100_GPUS"
  /// - "CPUS"
  /// - "CPUS_ALL_REGIONS"
  /// - "DISKS_TOTAL_GB"
  /// - "EXTERNAL_NETWORK_LB_FORWARDING_RULES"
  /// - "EXTERNAL_PROTOCOL_FORWARDING_RULES"
  /// - "EXTERNAL_VPN_GATEWAYS"
  /// - "FIREWALLS"
  /// - "FORWARDING_RULES"
  /// - "GLOBAL_INTERNAL_ADDRESSES"
  /// - "GPUS_ALL_REGIONS"
  /// - "HEALTH_CHECKS"
  /// - "IMAGES"
  /// - "INSTANCES"
  /// - "INSTANCE_GROUPS"
  /// - "INSTANCE_GROUP_MANAGERS"
  /// - "INSTANCE_TEMPLATES"
  /// - "INTERCONNECTS"
  /// - "INTERCONNECT_ATTACHMENTS_PER_REGION"
  /// - "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS"
  /// - "INTERCONNECT_TOTAL_GBPS"
  /// - "INTERNAL_ADDRESSES"
  /// - "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES"
  /// - "IN_PLACE_SNAPSHOTS"
  /// - "IN_USE_ADDRESSES"
  /// - "IN_USE_BACKUP_SCHEDULES"
  /// - "IN_USE_SNAPSHOT_SCHEDULES"
  /// - "LOCAL_SSD_TOTAL_GB"
  /// - "M1_CPUS"
  /// - "M2_CPUS"
  /// - "MACHINE_IMAGES"
  /// - "N2D_CPUS"
  /// - "N2_CPUS"
  /// - "NETWORKS"
  /// - "NETWORK_ENDPOINT_GROUPS"
  /// - "NETWORK_FIREWALL_POLICIES"
  /// - "NODE_GROUPS"
  /// - "NODE_TEMPLATES"
  /// - "NVIDIA_A100_GPUS"
  /// - "NVIDIA_K80_GPUS"
  /// - "NVIDIA_P100_GPUS"
  /// - "NVIDIA_P100_VWS_GPUS"
  /// - "NVIDIA_P4_GPUS"
  /// - "NVIDIA_P4_VWS_GPUS"
  /// - "NVIDIA_T4_GPUS"
  /// - "NVIDIA_T4_VWS_GPUS"
  /// - "NVIDIA_V100_GPUS"
  /// - "PACKET_MIRRORINGS"
  /// - "PREEMPTIBLE_CPUS"
  /// - "PREEMPTIBLE_LOCAL_SSD_GB"
  /// - "PREEMPTIBLE_NVIDIA_A100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_K80_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_V100_GPUS"
  /// - "PUBLIC_ADVERTISED_PREFIXES"
  /// - "PUBLIC_DELEGATED_PREFIXES"
  /// - "REGIONAL_AUTOSCALERS"
  /// - "REGIONAL_INSTANCE_GROUP_MANAGERS"
  /// - "RESERVATIONS"
  /// - "RESOURCE_POLICIES"
  /// - "ROUTERS"
  /// - "ROUTES"
  /// - "SECURITY_POLICIES"
  /// - "SECURITY_POLICY_CEVAL_RULES"
  /// - "SECURITY_POLICY_RULES"
  /// - "SNAPSHOTS"
  /// - "SSD_TOTAL_GB"
  /// - "SSL_CERTIFICATES"
  /// - "STATIC_ADDRESSES"
  /// - "STATIC_BYOIP_ADDRESSES"
  /// - "SUBNETWORKS"
  /// - "TARGET_HTTPS_PROXIES"
  /// - "TARGET_HTTP_PROXIES"
  /// - "TARGET_INSTANCES"
  /// - "TARGET_POOLS"
  /// - "TARGET_SSL_PROXIES"
  /// - "TARGET_TCP_PROXIES"
  /// - "TARGET_VPN_GATEWAYS"
  /// - "URL_MAPS"
  /// - "VPN_GATEWAYS"
  /// - "VPN_TUNNELS"
  core.String metric;

  /// [Output Only] Owning resource. This is the resource on which this quota is
  /// applied.
  core.String owner;

  /// [Output Only] Current usage of this metric.
  core.double usage;

  Quota();

  Quota.fromJson(core.Map _json) {
    if (_json.containsKey('limit')) {
      limit = (_json['limit'] as core.num).toDouble();
    }
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
    if (_json.containsKey('owner')) {
      owner = _json['owner'] as core.String;
    }
    if (_json.containsKey('usage')) {
      usage = (_json['usage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (limit != null) {
      _json['limit'] = limit;
    }
    if (metric != null) {
      _json['metric'] = metric;
    }
    if (owner != null) {
      _json['owner'] = owner;
    }
    if (usage != null) {
      _json['usage'] = usage;
    }
    return _json;
  }
}

/// Represents a reference to a resource.
class Reference {
  /// [Output Only] Type of the resource. Always compute#reference for
  /// references.
  core.String kind;

  /// A description of the reference type with no implied semantics. Possible
  /// values include:
  /// - MEMBER_OF
  core.String referenceType;

  /// URL of the resource which refers to the target.
  core.String referrer;

  /// URL of the resource to which this reference points.
  core.String target;

  Reference();

  Reference.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('referenceType')) {
      referenceType = _json['referenceType'] as core.String;
    }
    if (_json.containsKey('referrer')) {
      referrer = _json['referrer'] as core.String;
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (referenceType != null) {
      _json['referenceType'] = referenceType;
    }
    if (referrer != null) {
      _json['referrer'] = referrer;
    }
    if (target != null) {
      _json['target'] = target;
    }
    return _json;
  }
}

/// Represents a Region resource.
///
/// A region is a geographical area where a resource is located. For more
/// information, read Regions and Zones. (== resource_for {$api_version}.regions
/// ==)
class Region {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this region.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#region for regions.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Quotas assigned to this region.
  core.List<Quota> quotas;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the region, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  /// [Output Only] A list of zones available in this region, in the form of
  /// resource URLs.
  core.List<core.String> zones;

  Region();

  Region.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('quotas')) {
      quotas = (_json['quotas'] as core.List)
          .map<Quota>((value) =>
              Quota.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('zones')) {
      zones = (_json['zones'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (quotas != null) {
      _json['quotas'] = quotas.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (zones != null) {
      _json['zones'] = zones;
    }
    return _json;
  }
}

class RegionAutoscalerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionAutoscalerListWarningData();

  RegionAutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionAutoscalerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionAutoscalerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionAutoscalerListWarning();

  RegionAutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionAutoscalerListWarningData>((value) =>
              RegionAutoscalerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of autoscalers.
class RegionAutoscalerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionAutoscalerListWarning warning;

  RegionAutoscalerList();

  RegionAutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionAutoscalerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RegionDiskTypeListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionDiskTypeListWarningData();

  RegionDiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionDiskTypeListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionDiskTypeListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionDiskTypeListWarning();

  RegionDiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionDiskTypeListWarningData>((value) =>
              RegionDiskTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class RegionDiskTypeList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of DiskType resources.
  core.List<DiskType> items;

  /// [Output Only] Type of resource. Always compute#regionDiskTypeList for
  /// region disk types.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionDiskTypeListWarning warning;

  RegionDiskTypeList();

  RegionDiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionDiskTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RegionDisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  core.List<core.String> resourcePolicies;

  RegionDisksAddResourcePoliciesRequest();

  RegionDisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class RegionDisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String> resourcePolicies;

  RegionDisksRemoveResourcePoliciesRequest();

  RegionDisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] = resourcePolicies;
    }
    return _json;
  }
}

class RegionDisksResizeRequest {
  /// The new size of the regional persistent disk, which is specified in GB.
  core.String sizeGb;

  RegionDisksResizeRequest();

  RegionDisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sizeGb != null) {
      _json['sizeGb'] = sizeGb;
    }
    return _json;
  }
}

class RegionInstanceGroupListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupListWarningData();

  RegionInstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupListWarning();

  RegionInstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupListWarningData>((value) =>
              RegionInstanceGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of InstanceGroup resources.
class RegionInstanceGroupList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupListWarning warning;

  RegionInstanceGroupList();

  RegionInstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.deletePerInstanceConfigs
class RegionInstanceGroupManagerDeleteInstanceConfigReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String> names;

  RegionInstanceGroupManagerDeleteInstanceConfigReq();

  RegionInstanceGroupManagerDeleteInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('names')) {
      names = (_json['names'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (names != null) {
      _json['names'] = names;
    }
    return _json;
  }
}

class RegionInstanceGroupManagerListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupManagerListWarningData();

  RegionInstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupManagerListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupManagerListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupManagerListWarning();

  RegionInstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupManagerListWarningData>((value) =>
              RegionInstanceGroupManagerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of managed instance groups.
class RegionInstanceGroupManagerList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager> items;

  /// [Output Only] The resource type, which is always
  /// compute#instanceGroupManagerList for a list of managed instance groups
  /// that exist in th regional scope.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupManagerListWarning warning;

  RegionInstanceGroupManagerList();

  RegionInstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupManagerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.patchPerInstanceConfigs
class RegionInstanceGroupManagerPatchInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig> perInstanceConfigs;

  RegionInstanceGroupManagerPatchInstanceConfigReq();

  RegionInstanceGroupManagerPatchInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (perInstanceConfigs != null) {
      _json['perInstanceConfigs'] =
          perInstanceConfigs.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.updatePerInstanceConfigs
class RegionInstanceGroupManagerUpdateInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig> perInstanceConfigs;

  RegionInstanceGroupManagerUpdateInstanceConfigReq();

  RegionInstanceGroupManagerUpdateInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (perInstanceConfigs != null) {
      _json['perInstanceConfigs'] =
          perInstanceConfigs.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersAbandonInstancesRequest();

  RegionInstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.applyUpdatesToInstances
class RegionInstanceGroupManagersApplyUpdatesRequest {
  /// The list of URLs of one or more instances for which you want to apply
  /// updates. Each URL can be a full URL or a partial URL, such as
  /// zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the minimum
  /// action is NONE. If your update requires a more disruptive action than you
  /// set with this flag, the necessary action is performed to execute the
  /// update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all.  By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String mostDisruptiveAllowedAction;

  RegionInstanceGroupManagersApplyUpdatesRequest();

  RegionInstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('mostDisruptiveAllowedAction')) {
      mostDisruptiveAllowedAction =
          _json['mostDisruptiveAllowedAction'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    if (minimalAction != null) {
      _json['minimalAction'] = minimalAction;
    }
    if (mostDisruptiveAllowedAction != null) {
      _json['mostDisruptiveAllowedAction'] = mostDisruptiveAllowedAction;
    }
    return _json;
  }
}

/// RegionInstanceGroupManagers.createInstances
class RegionInstanceGroupManagersCreateInstancesRequest {
  /// [Required] List of specifications of per-instance configs.
  core.List<PerInstanceConfig> instances;

  RegionInstanceGroupManagersCreateInstancesRequest();

  RegionInstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersDeleteInstancesRequest();

  RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListErrorsResponse {
  /// [Output Only] The list of errors of the managed instance group.
  core.List<InstanceManagedByIgmError> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  RegionInstanceGroupManagersListErrorsResponse();

  RegionInstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceManagedByIgmError>((value) =>
              InstanceManagedByIgmError.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListInstanceConfigsRespWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData();

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupManagersListInstanceConfigsRespWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupManagersListInstanceConfigsRespWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupManagersListInstanceConfigsRespWarning();

  RegionInstanceGroupManagersListInstanceConfigsRespWarning.fromJson(
      core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupManagersListInstanceConfigsRespWarningData>(
              (value) =>
                  RegionInstanceGroupManagersListInstanceConfigsRespWarningData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListInstanceConfigsResp {
  /// [Output Only] The list of PerInstanceConfig.
  core.List<PerInstanceConfig> items;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupManagersListInstanceConfigsRespWarning warning;

  RegionInstanceGroupManagersListInstanceConfigsResp();

  RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning =
          RegionInstanceGroupManagersListInstanceConfigsRespWarning.fromJson(
              _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupManagersListInstancesResponse {
  /// A list of managed instances.
  core.List<ManagedInstance> managedInstances;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  RegionInstanceGroupManagersListInstancesResponse();

  RegionInstanceGroupManagersListInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('managedInstances')) {
      managedInstances = (_json['managedInstances'] as core.List)
          .map<ManagedInstance>((value) => ManagedInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (managedInstances != null) {
      _json['managedInstances'] =
          managedInstances.map((value) => value.toJson()).toList();
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersRecreateRequest {
  /// The URLs of one or more instances to recreate. This can be a full URL or a
  /// partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
  core.List<core.String> instances;

  RegionInstanceGroupManagersRecreateRequest();

  RegionInstanceGroupManagersRecreateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents. This field is used for optimistic locking when you update the
  /// target pool entries. This field is optional.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added. The target pools automatically apply to all
  /// of the instances in the managed instance group.
  core.List<core.String> targetPools;

  RegionInstanceGroupManagersSetTargetPoolsRequest();

  RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (targetPools != null) {
      _json['targetPools'] = targetPools;
    }
    return _json;
  }
}

class RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String instanceTemplate;

  RegionInstanceGroupManagersSetTemplateRequest();

  RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceTemplate != null) {
      _json['instanceTemplate'] = instanceTemplate;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionInstanceGroupsListInstancesWarningData();

  RegionInstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionInstanceGroupsListInstancesWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionInstanceGroupsListInstancesWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionInstanceGroupsListInstancesWarning();

  RegionInstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupsListInstancesWarningData>((value) =>
              RegionInstanceGroupsListInstancesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstances {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts> items;

  /// The resource type.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionInstanceGroupsListInstancesWarning warning;

  RegionInstanceGroupsListInstances();

  RegionInstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceWithNamedPorts>((value) =>
              InstanceWithNamedPorts.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupsListInstancesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned. Valid options are: 'ALL',
  /// 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String instanceState;

  /// Name of port user is interested in. It is optional. If it is set, only
  /// information about this ports will be returned. If it is not set, all the
  /// named ports will be returned. Always lists all instances.
  core.String portName;

  RegionInstanceGroupsListInstancesRequest();

  RegionInstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceState')) {
      instanceState = _json['instanceState'] as core.String;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceState != null) {
      _json['instanceState'] = instanceState;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    return _json;
  }
}

class RegionInstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort> namedPorts;

  RegionInstanceGroupsSetNamedPortsRequest();

  RegionInstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (namedPorts != null) {
      _json['namedPorts'] = namedPorts.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class RegionListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RegionListWarningData();

  RegionListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RegionListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RegionListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RegionListWarning();

  RegionListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionListWarningData>((value) => RegionListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of region resources.
class RegionList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Region resources.
  core.List<Region> items;

  /// [Output Only] Type of resource. Always compute#regionList for lists of
  /// regions.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RegionListWarning warning;

  RegionList();

  RegionList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Region>((value) =>
              Region.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RegionSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash in order to update or change
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String> labels;

  RegionSetLabelsRequest();

  RegionSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    return _json;
  }
}

class RegionSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  RegionSetPolicyRequest();

  RegionSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bindings != null) {
      _json['bindings'] = bindings.map((value) => value.toJson()).toList();
    }
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (policy != null) {
      _json['policy'] = policy.toJson();
    }
    return _json;
  }
}

class RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource. Currently exactly one SslCertificate resource
  /// must be specified.
  core.List<core.String> sslCertificates;

  RegionTargetHttpsProxiesSetSslCertificatesRequest();

  RegionTargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sslCertificates != null) {
      _json['sslCertificates'] = sslCertificates;
    }
    return _json;
  }
}

class RegionUrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap resource;

  RegionUrlMapsValidateRequest();

  RegionUrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = UrlMap.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resource != null) {
      _json['resource'] = resource.toJson();
    }
    return _json;
  }
}

/// A policy that specifies how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service. Loadbalancer does not wait
/// for responses from the shadow service. Prior to sending traffic to the
/// shadow service, the host / authority header is suffixed with -shadow.
class RequestMirrorPolicy {
  /// The full or partial URL to the BackendService resource being mirrored to.
  core.String backendService;

  RequestMirrorPolicy();

  RequestMirrorPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backendService != null) {
      _json['backendService'] = backendService;
    }
    return _json;
  }
}

/// Represents a reservation resource. A reservation ensures that capacity is
/// held in a specific zone even if the reserved VMs are not running. For more
/// information, read  Reserving zonal resources. (== resource_for
/// {$api_version}.reservations ==)
class Reservation {
  /// [Output Only] Full or partial URL to a parent commitment. This field
  /// displays for reservations that are tied to a commitment.
  core.String commitment;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#reservations for
  /// reservations.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Reservation for instances with specific machine shapes.
  AllocationSpecificSKUReservation specificReservation;

  /// Indicates whether the reservation can be consumed by VMs with affinity for
  /// "any" reservation. If the field is set, then only VMs that target the
  /// reservation by name can consume from this reservation.
  core.bool specificReservationRequired;

  /// [Output Only] The status of the reservation.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "UPDATING"
  core.String status;

  /// Zone in which the reservation resides. A zone must be provided if the
  /// reservation is created within a commitment.
  core.String zone;

  Reservation();

  Reservation.fromJson(core.Map _json) {
    if (_json.containsKey('commitment')) {
      commitment = _json['commitment'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('specificReservation')) {
      specificReservation = AllocationSpecificSKUReservation.fromJson(
          _json['specificReservation'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('specificReservationRequired')) {
      specificReservationRequired =
          _json['specificReservationRequired'] as core.bool;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (commitment != null) {
      _json['commitment'] = commitment;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (specificReservation != null) {
      _json['specificReservation'] = specificReservation.toJson();
    }
    if (specificReservationRequired != null) {
      _json['specificReservationRequired'] = specificReservationRequired;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

/// Specifies the reservations that this instance can consume from.
class ReservationAffinity {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
  /// NO_RESERVATION. See  Consuming reserved instances for examples.
  /// Possible string values are:
  /// - "ANY_RESERVATION"
  /// - "NO_RESERVATION"
  /// - "SPECIFIC_RESERVATION"
  /// - "UNSPECIFIED"
  core.String consumeReservationType;

  /// Corresponds to the label key of a reservation resource. To target a
  /// SPECIFIC_RESERVATION by name, specify googleapis.com/reservation-name as
  /// the key and specify the name of your reservation as its value.
  core.String key;

  /// Corresponds to the label values of a reservation resource.
  core.List<core.String> values;

  ReservationAffinity();

  ReservationAffinity.fromJson(core.Map _json) {
    if (_json.containsKey('consumeReservationType')) {
      consumeReservationType = _json['consumeReservationType'] as core.String;
    }
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (consumeReservationType != null) {
      _json['consumeReservationType'] = consumeReservationType;
    }
    if (key != null) {
      _json['key'] = key;
    }
    if (values != null) {
      _json['values'] = values;
    }
    return _json;
  }
}

class ReservationAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationAggregatedListWarningData();

  ReservationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ReservationAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationAggregatedListWarning();

  ReservationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationAggregatedListWarningData>((value) =>
              ReservationAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of reservations.
class ReservationAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Allocation resources.
  core.Map<core.String, ReservationsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  ReservationAggregatedListWarning warning;

  ReservationAggregatedList();

  ReservationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              ReservationsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ReservationAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class ReservationListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationListWarningData();

  ReservationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ReservationListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationListWarning();

  ReservationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationListWarningData>((value) =>
              ReservationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ReservationList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of Allocation resources.
  core.List<Reservation> items;

  /// [Output Only] Type of resource.Always compute#reservationsList for listsof
  /// reservations
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ReservationListWarning warning;

  ReservationList();

  ReservationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ReservationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class ReservationsResizeRequest {
  /// Number of allocated resources can be resized with minimum = 1 and maximum
  /// = 1000.
  core.String specificSkuCount;

  ReservationsResizeRequest();

  ReservationsResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('specificSkuCount')) {
      specificSkuCount = _json['specificSkuCount'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (specificSkuCount != null) {
      _json['specificSkuCount'] = specificSkuCount;
    }
    return _json;
  }
}

class ReservationsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ReservationsScopedListWarningData();

  ReservationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of reservations when the list
/// is empty.
class ReservationsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ReservationsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ReservationsScopedListWarning();

  ReservationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationsScopedListWarningData>((value) =>
              ReservationsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ReservationsScopedList {
  /// A list of reservations contained in this scope.
  core.List<Reservation> reservations;

  /// Informational warning which replaces the list of reservations when the
  /// list is empty.
  ReservationsScopedListWarning warning;

  ReservationsScopedList();

  ReservationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('reservations')) {
      reservations = (_json['reservations'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ReservationsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (reservations != null) {
      _json['reservations'] =
          reservations.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Commitment for a particular resource (a Commitment is composed of one or
/// more of these).
class ResourceCommitment {
  /// Name of the accelerator type resource. Applicable only when the type is
  /// ACCELERATOR.
  core.String acceleratorType;

  /// The amount of the resource purchased (in a type-dependent unit, such as
  /// bytes). For vCPUs, this can just be an integer. For memory, this must be
  /// provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
  /// memory per every vCPU.
  core.String amount;

  /// Type of resource for which this commitment applies. Possible values are
  /// VCPU and MEMORY
  /// Possible string values are:
  /// - "ACCELERATOR"
  /// - "LOCAL_SSD"
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String type;

  ResourceCommitment();

  ResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorType')) {
      acceleratorType = _json['acceleratorType'] as core.String;
    }
    if (_json.containsKey('amount')) {
      amount = _json['amount'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (acceleratorType != null) {
      _json['acceleratorType'] = acceleratorType;
    }
    if (amount != null) {
      _json['amount'] = amount;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class ResourceGroupReference {
  /// A URI referencing one of the instance groups or network endpoint groups
  /// listed in the backend service.
  core.String group;

  ResourceGroupReference();

  ResourceGroupReference.fromJson(core.Map _json) {
    if (_json.containsKey('group')) {
      group = _json['group'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (group != null) {
      _json['group'] = group;
    }
    return _json;
  }
}

class ResourcePoliciesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePoliciesScopedListWarningData();

  ResourcePoliciesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of resourcePolicies when the
/// list is empty.
class ResourcePoliciesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePoliciesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePoliciesScopedListWarning();

  ResourcePoliciesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePoliciesScopedListWarningData>((value) =>
              ResourcePoliciesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ResourcePoliciesScopedList {
  /// A list of resourcePolicies contained in this scope.
  core.List<ResourcePolicy> resourcePolicies;

  /// Informational warning which replaces the list of resourcePolicies when the
  /// list is empty.
  ResourcePoliciesScopedListWarning warning;

  ResourcePoliciesScopedList();

  ResourcePoliciesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePoliciesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resourcePolicies != null) {
      _json['resourcePolicies'] =
          resourcePolicies.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Resource Policy resource. You can use resource policies to
/// schedule actions for some Compute Engine resources. For example, you can use
/// them to schedule persistent disk snapshots.
///
/// (== resource_for {$api_version}.resourcePolicies ==)
class ResourcePolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;
  core.String description;

  /// Resource policy for instacnes for placement configuration.
  ResourcePolicyGroupPlacementPolicy groupPlacementPolicy;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#resource_policies for
  /// resource policies.
  core.String kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The resource name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;
  core.String region;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// Resource policy for persistent disks for creating snapshots.
  ResourcePolicySnapshotSchedulePolicy snapshotSchedulePolicy;

  /// [Output Only] The status of resource policy creation.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String status;

  ResourcePolicy();

  ResourcePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('groupPlacementPolicy')) {
      groupPlacementPolicy = ResourcePolicyGroupPlacementPolicy.fromJson(
          _json['groupPlacementPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('snapshotSchedulePolicy')) {
      snapshotSchedulePolicy = ResourcePolicySnapshotSchedulePolicy.fromJson(
          _json['snapshotSchedulePolicy']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (groupPlacementPolicy != null) {
      _json['groupPlacementPolicy'] = groupPlacementPolicy.toJson();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (snapshotSchedulePolicy != null) {
      _json['snapshotSchedulePolicy'] = snapshotSchedulePolicy.toJson();
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

class ResourcePolicyAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePolicyAggregatedListWarningData();

  ResourcePolicyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ResourcePolicyAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePolicyAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePolicyAggregatedListWarning();

  ResourcePolicyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePolicyAggregatedListWarningData>((value) =>
              ResourcePolicyAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of resourcePolicies.
class ResourcePolicyAggregatedList {
  core.String etag;

  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of ResourcePolicy resources.
  core.Map<core.String, ResourcePoliciesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  ResourcePolicyAggregatedListWarning warning;

  ResourcePolicyAggregatedList();

  ResourcePolicyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              ResourcePoliciesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePolicyAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Time window specified for daily operations.
class ResourcePolicyDailyCycle {
  /// Defines a schedule with units measured in months. The value determines how
  /// many months pass between the start of each cycle.
  core.int daysInCycle;

  /// [Output only] A predetermined duration for the window, automatically
  /// chosen to be the smallest possible in the given scenario.
  core.String duration;

  /// Start time of the window. This must be in UTC format that resolves to one
  /// of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5
  /// and 08:00 are valid.
  core.String startTime;

  ResourcePolicyDailyCycle();

  ResourcePolicyDailyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('daysInCycle')) {
      daysInCycle = _json['daysInCycle'] as core.int;
    }
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (daysInCycle != null) {
      _json['daysInCycle'] = daysInCycle;
    }
    if (duration != null) {
      _json['duration'] = duration;
    }
    if (startTime != null) {
      _json['startTime'] = startTime;
    }
    return _json;
  }
}

/// A GroupPlacementPolicy specifies resource placement configuration. It
/// specifies the failure bucket separation as well as network locality
class ResourcePolicyGroupPlacementPolicy {
  /// The number of availability domains instances will be spread across. If two
  /// instances are in different availability domain, they will not be put in
  /// the same low latency network
  core.int availabilityDomainCount;

  /// Specifies network collocation
  /// Possible string values are:
  /// - "COLLOCATED"
  /// - "UNSPECIFIED_COLLOCATION"
  core.String collocation;

  /// Number of vms in this placement group
  core.int vmCount;

  ResourcePolicyGroupPlacementPolicy();

  ResourcePolicyGroupPlacementPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('availabilityDomainCount')) {
      availabilityDomainCount = _json['availabilityDomainCount'] as core.int;
    }
    if (_json.containsKey('collocation')) {
      collocation = _json['collocation'] as core.String;
    }
    if (_json.containsKey('vmCount')) {
      vmCount = _json['vmCount'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (availabilityDomainCount != null) {
      _json['availabilityDomainCount'] = availabilityDomainCount;
    }
    if (collocation != null) {
      _json['collocation'] = collocation;
    }
    if (vmCount != null) {
      _json['vmCount'] = vmCount;
    }
    return _json;
  }
}

/// Time window specified for hourly operations.
class ResourcePolicyHourlyCycle {
  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  core.String duration;

  /// Defines a schedule with units measured in hours. The value determines how
  /// many hours pass between the start of each cycle.
  core.int hoursInCycle;

  /// Time within the window to start the operations. It must be in format
  /// "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
  core.String startTime;

  ResourcePolicyHourlyCycle();

  ResourcePolicyHourlyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('hoursInCycle')) {
      hoursInCycle = _json['hoursInCycle'] as core.int;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (duration != null) {
      _json['duration'] = duration;
    }
    if (hoursInCycle != null) {
      _json['hoursInCycle'] = hoursInCycle;
    }
    if (startTime != null) {
      _json['startTime'] = startTime;
    }
    return _json;
  }
}

class ResourcePolicyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ResourcePolicyListWarningData();

  ResourcePolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ResourcePolicyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ResourcePolicyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ResourcePolicyListWarning();

  ResourcePolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePolicyListWarningData>((value) =>
              ResourcePolicyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class ResourcePolicyList {
  core.String etag;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] A list of ResourcePolicy resources.
  core.List<ResourcePolicy> items;

  /// [Output Only] Type of resource.Always compute#resourcePoliciesList for
  /// listsof resourcePolicies
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ResourcePolicyListWarning warning;

  ResourcePolicyList();

  ResourcePolicyList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePolicyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A snapshot schedule policy specifies when and how frequently snapshots are
/// to be created for the target disk. Also specifies how many and how long
/// these scheduled snapshots should be retained.
class ResourcePolicySnapshotSchedulePolicy {
  /// Retention policy applied to snapshots created by this resource policy.
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy retentionPolicy;

  /// A Vm Maintenance Policy specifies what kind of infrastructure maintenance
  /// we are allowed to perform on this VM and when. Schedule that is applied to
  /// disks covered by this policy.
  ResourcePolicySnapshotSchedulePolicySchedule schedule;

  /// Properties with which snapshots are created such as labels, encryption
  /// keys.
  ResourcePolicySnapshotSchedulePolicySnapshotProperties snapshotProperties;

  ResourcePolicySnapshotSchedulePolicy();

  ResourcePolicySnapshotSchedulePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('retentionPolicy')) {
      retentionPolicy =
          ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(
              _json['retentionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('schedule')) {
      schedule = ResourcePolicySnapshotSchedulePolicySchedule.fromJson(
          _json['schedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('snapshotProperties')) {
      snapshotProperties =
          ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
              _json['snapshotProperties']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (retentionPolicy != null) {
      _json['retentionPolicy'] = retentionPolicy.toJson();
    }
    if (schedule != null) {
      _json['schedule'] = schedule.toJson();
    }
    if (snapshotProperties != null) {
      _json['snapshotProperties'] = snapshotProperties.toJson();
    }
    return _json;
  }
}

/// Policy for retention of scheduled snapshots.
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /// Maximum age of the snapshot that is allowed to be kept.
  core.int maxRetentionDays;

  /// Specifies the behavior to apply to scheduled snapshots when the source
  /// disk is deleted.
  /// Possible string values are:
  /// - "APPLY_RETENTION_POLICY"
  /// - "KEEP_AUTO_SNAPSHOTS"
  /// - "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
  core.String onSourceDiskDelete;

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy();

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('maxRetentionDays')) {
      maxRetentionDays = _json['maxRetentionDays'] as core.int;
    }
    if (_json.containsKey('onSourceDiskDelete')) {
      onSourceDiskDelete = _json['onSourceDiskDelete'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (maxRetentionDays != null) {
      _json['maxRetentionDays'] = maxRetentionDays;
    }
    if (onSourceDiskDelete != null) {
      _json['onSourceDiskDelete'] = onSourceDiskDelete;
    }
    return _json;
  }
}

/// A schedule for disks where the schedueled operations are performed.
class ResourcePolicySnapshotSchedulePolicySchedule {
  ResourcePolicyDailyCycle dailySchedule;
  ResourcePolicyHourlyCycle hourlySchedule;
  ResourcePolicyWeeklyCycle weeklySchedule;

  ResourcePolicySnapshotSchedulePolicySchedule();

  ResourcePolicySnapshotSchedulePolicySchedule.fromJson(core.Map _json) {
    if (_json.containsKey('dailySchedule')) {
      dailySchedule = ResourcePolicyDailyCycle.fromJson(
          _json['dailySchedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('hourlySchedule')) {
      hourlySchedule = ResourcePolicyHourlyCycle.fromJson(
          _json['hourlySchedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weeklySchedule')) {
      weeklySchedule = ResourcePolicyWeeklyCycle.fromJson(
          _json['weeklySchedule'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (dailySchedule != null) {
      _json['dailySchedule'] = dailySchedule.toJson();
    }
    if (hourlySchedule != null) {
      _json['hourlySchedule'] = hourlySchedule.toJson();
    }
    if (weeklySchedule != null) {
      _json['weeklySchedule'] = weeklySchedule.toJson();
    }
    return _json;
  }
}

/// Specified snapshot properties for scheduled snapshots created by this
/// policy.
class ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /// Indication to perform a 'guest aware' snapshot.
  core.bool guestFlush;

  /// Labels to apply to scheduled snapshots. These can be later modified by the
  /// setLabels method. Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Cloud Storage bucket storage location of the auto snapshot (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  ResourcePolicySnapshotSchedulePolicySnapshotProperties();

  ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey('guestFlush')) {
      guestFlush = _json['guestFlush'] as core.bool;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (guestFlush != null) {
      _json['guestFlush'] = guestFlush;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (storageLocations != null) {
      _json['storageLocations'] = storageLocations;
    }
    return _json;
  }
}

/// Time window specified for weekly operations.
class ResourcePolicyWeeklyCycle {
  /// Up to 7 intervals/windows, one for each day of the week.
  core.List<ResourcePolicyWeeklyCycleDayOfWeek> dayOfWeeks;

  ResourcePolicyWeeklyCycle();

  ResourcePolicyWeeklyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('dayOfWeeks')) {
      dayOfWeeks = (_json['dayOfWeeks'] as core.List)
          .map<ResourcePolicyWeeklyCycleDayOfWeek>((value) =>
              ResourcePolicyWeeklyCycleDayOfWeek.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (dayOfWeeks != null) {
      _json['dayOfWeeks'] = dayOfWeeks.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class ResourcePolicyWeeklyCycleDayOfWeek {
  /// Defines a schedule that runs on specific days of the week. Specify one or
  /// more days. The following options are available: MONDAY, TUESDAY,
  /// WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
  /// Possible string values are:
  /// - "FRIDAY"
  /// - "INVALID"
  /// - "MONDAY"
  /// - "SATURDAY"
  /// - "SUNDAY"
  /// - "THURSDAY"
  /// - "TUESDAY"
  /// - "WEDNESDAY"
  core.String day;

  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  core.String duration;

  /// Time within the window to start the operations. It must be in format
  /// "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
  core.String startTime;

  ResourcePolicyWeeklyCycleDayOfWeek();

  ResourcePolicyWeeklyCycleDayOfWeek.fromJson(core.Map _json) {
    if (_json.containsKey('day')) {
      day = _json['day'] as core.String;
    }
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (day != null) {
      _json['day'] = day;
    }
    if (duration != null) {
      _json['duration'] = duration;
    }
    if (startTime != null) {
      _json['startTime'] = startTime;
    }
    return _json;
  }
}

class RouteWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteWarningsData();

  RouteWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

class RouteWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteWarnings();

  RouteWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouteWarningsData>((value) => RouteWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Represents a Route resource.
///
/// A route defines a path from VM instances in the VPC network to a specific
/// destination. This destination can be inside or outside the VPC network. For
/// more information, read the Routes overview. (== resource_for
/// {$api_version}.routes ==)
class Route {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this field when you
  /// create the resource.
  core.String description;

  /// The destination range of outgoing packets that this route applies to. Only
  /// IPv4 is supported.
  core.String destRange;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of this resource. Always compute#routes for Route
  /// resources.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a
  /// lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String name;

  /// Fully-qualified URL of the network that this route applies to.
  core.String network;

  /// The URL to a gateway that should handle matching packets. You can only
  /// specify the internet gateway using a full or partial valid URL:
  /// projects/project/global/gateways/default-internet-gateway
  core.String nextHopGateway;

  /// The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
  /// should handle matching packets. You can only specify the forwarding rule
  /// as a partial or full URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
  /// - regions/region/forwardingRules/forwardingRule
  core.String nextHopIlb;

  /// The URL to an instance that should handle matching packets. You can
  /// specify this as a full or partial URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
  core.String nextHopInstance;

  /// The network IP address of an instance that should handle matching packets.
  /// Only IPv4 is supported.
  core.String nextHopIp;

  /// The URL of the local network if it should handle matching packets.
  core.String nextHopNetwork;

  /// [Output Only] The network peering name that should handle matching
  /// packets, which should conform to RFC1035.
  core.String nextHopPeering;

  /// The URL to a VpnTunnel that should handle matching packets.
  core.String nextHopVpnTunnel;

  /// The priority of this route. Priority is used to break ties in cases where
  /// there is more than one matching route of equal prefix length. In cases
  /// where multiple routes have equal prefix length, the one with the
  /// lowest-numbered priority value wins. The default value is `1000`. The
  /// priority value must be from `0` to `65535`, inclusive.
  core.int priority;

  /// [Output Only] Server-defined fully-qualified URL for this resource.
  core.String selfLink;

  /// A list of instance tags to which this route applies.
  core.List<core.String> tags;

  /// [Output Only] If potential misconfigurations are detected for this route,
  /// this field will be populated with warning messages.
  core.List<RouteWarnings> warnings;

  Route();

  Route.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('destRange')) {
      destRange = _json['destRange'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('nextHopGateway')) {
      nextHopGateway = _json['nextHopGateway'] as core.String;
    }
    if (_json.containsKey('nextHopIlb')) {
      nextHopIlb = _json['nextHopIlb'] as core.String;
    }
    if (_json.containsKey('nextHopInstance')) {
      nextHopInstance = _json['nextHopInstance'] as core.String;
    }
    if (_json.containsKey('nextHopIp')) {
      nextHopIp = _json['nextHopIp'] as core.String;
    }
    if (_json.containsKey('nextHopNetwork')) {
      nextHopNetwork = _json['nextHopNetwork'] as core.String;
    }
    if (_json.containsKey('nextHopPeering')) {
      nextHopPeering = _json['nextHopPeering'] as core.String;
    }
    if (_json.containsKey('nextHopVpnTunnel')) {
      nextHopVpnTunnel = _json['nextHopVpnTunnel'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('tags')) {
      tags = (_json['tags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<RouteWarnings>((value) => RouteWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (destRange != null) {
      _json['destRange'] = destRange;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (nextHopGateway != null) {
      _json['nextHopGateway'] = nextHopGateway;
    }
    if (nextHopIlb != null) {
      _json['nextHopIlb'] = nextHopIlb;
    }
    if (nextHopInstance != null) {
      _json['nextHopInstance'] = nextHopInstance;
    }
    if (nextHopIp != null) {
      _json['nextHopIp'] = nextHopIp;
    }
    if (nextHopNetwork != null) {
      _json['nextHopNetwork'] = nextHopNetwork;
    }
    if (nextHopPeering != null) {
      _json['nextHopPeering'] = nextHopPeering;
    }
    if (nextHopVpnTunnel != null) {
      _json['nextHopVpnTunnel'] = nextHopVpnTunnel;
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (tags != null) {
      _json['tags'] = tags;
    }
    if (warnings != null) {
      _json['warnings'] = warnings.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class RouteListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouteListWarningData();

  RouteListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouteListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouteListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouteListWarning();

  RouteListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouteListWarningData>((value) => RouteListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Route resources.
class RouteList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Route resources.
  core.List<Route> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouteListWarning warning;

  RouteList();

  RouteList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RouteListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Cloud Router resource.
///
/// For more information about Cloud Router, read the Cloud Router overview.
class Router {
  /// BGP information specific to this router.
  RouterBgp bgp;

  /// BGP information that must be configured into the routing stack to
  /// establish BGP peering. This information must specify the peer ASN and
  /// either the interface name, IP address, or peer IP address. Please refer to
  /// RFC4273.
  core.List<RouterBgpPeer> bgpPeers;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// Router interfaces. Each interface requires either one linked resource,
  /// (for example, linkedVpnTunnel), or IP address and IP address range (for
  /// example, ipRange), or both.
  core.List<RouterInterface> interfaces;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A list of NAT services created in this router.
  core.List<RouterNat> nats;

  /// URI of the network to which this router belongs.
  core.String network;

  /// [Output Only] URI of the region where the router resides. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  Router();

  Router.fromJson(core.Map _json) {
    if (_json.containsKey('bgp')) {
      bgp = RouterBgp.fromJson(
          _json['bgp'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('bgpPeers')) {
      bgpPeers = (_json['bgpPeers'] as core.List)
          .map<RouterBgpPeer>((value) => RouterBgpPeer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interfaces')) {
      interfaces = (_json['interfaces'] as core.List)
          .map<RouterInterface>((value) => RouterInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nats')) {
      nats = (_json['nats'] as core.List)
          .map<RouterNat>((value) =>
              RouterNat.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bgp != null) {
      _json['bgp'] = bgp.toJson();
    }
    if (bgpPeers != null) {
      _json['bgpPeers'] = bgpPeers.map((value) => value.toJson()).toList();
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (interfaces != null) {
      _json['interfaces'] = interfaces.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (nats != null) {
      _json['nats'] = nats.map((value) => value.toJson()).toList();
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

/// Description-tagged IP ranges for the router to advertise.
class RouterAdvertisedIpRange {
  /// User-specified description for the IP range.
  core.String description;

  /// The IP range to advertise. The value must be a CIDR-formatted string.
  core.String range;

  RouterAdvertisedIpRange();

  RouterAdvertisedIpRange.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('range')) {
      range = _json['range'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (range != null) {
      _json['range'] = range;
    }
    return _json;
  }
}

class RouterAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterAggregatedListWarningData();

  RouterAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterAggregatedListWarning();

  RouterAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouterAggregatedListWarningData>((value) =>
              RouterAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of routers.
class RouterAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.Map<core.String, RoutersScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  RouterAggregatedListWarning warning;

  RouterAggregatedList();

  RouterAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              RoutersScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = RouterAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class RouterBgp {
  /// User-specified flag to indicate which mode to use for advertisement. The
  /// options are DEFAULT or CUSTOM.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode. This
  /// field can only be populated if advertise_mode is CUSTOM and is advertised
  /// to all peers of the router. These groups will be advertised in addition to
  /// any specified prefixes. Leave this field blank to advertise no custom
  /// groups.
  core.List<core.String> advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These IP ranges will be advertised
  /// in addition to any specified groups. Leave this field blank to advertise
  /// no custom IP ranges.
  core.List<RouterAdvertisedIpRange> advertisedIpRanges;

  /// Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN,
  /// either 16-bit or 32-bit. The value will be fixed for this router resource.
  /// All VPN tunnels that link to this router will have the same local ASN.
  core.int asn;

  RouterBgp();

  RouterBgp.fromJson(core.Map _json) {
    if (_json.containsKey('advertiseMode')) {
      advertiseMode = _json['advertiseMode'] as core.String;
    }
    if (_json.containsKey('advertisedGroups')) {
      advertisedGroups = (_json['advertisedGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('advertisedIpRanges')) {
      advertisedIpRanges = (_json['advertisedIpRanges'] as core.List)
          .map<RouterAdvertisedIpRange>((value) =>
              RouterAdvertisedIpRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('asn')) {
      asn = _json['asn'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (advertiseMode != null) {
      _json['advertiseMode'] = advertiseMode;
    }
    if (advertisedGroups != null) {
      _json['advertisedGroups'] = advertisedGroups;
    }
    if (advertisedIpRanges != null) {
      _json['advertisedIpRanges'] =
          advertisedIpRanges.map((value) => value.toJson()).toList();
    }
    if (asn != null) {
      _json['asn'] = asn;
    }
    return _json;
  }
}

class RouterBgpPeer {
  /// User-specified flag to indicate which mode to use for advertisement.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode, which
  /// can take one of the following options:
  /// - ALL_SUBNETS: Advertises all available subnets, including peer VPC
  /// subnets.
  /// - ALL_VPC_SUBNETS: Advertises the router's own VPC subnets.
  /// - ALL_PEER_VPC_SUBNETS: Advertises peer subnets of the router's VPC
  /// network. Note that this field can only be populated if advertise_mode is
  /// CUSTOM and overrides the list defined for the router (in the "bgp"
  /// message). These groups are advertised in addition to any specified
  /// prefixes. Leave this field blank to advertise no custom groups.
  core.List<core.String> advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  /// This field can only be populated if advertise_mode is CUSTOM and overrides
  /// the list defined for the router (in the "bgp" message). These IP ranges
  /// are advertised in addition to any specified groups. Leave this field blank
  /// to advertise no custom IP ranges.
  core.List<RouterAdvertisedIpRange> advertisedIpRanges;

  /// The priority of routes advertised to this BGP peer. Where there is more
  /// than one matching route of maximum length, the routes with the lowest
  /// priority value win.
  core.int advertisedRoutePriority;

  /// Name of the interface the BGP peer is associated with.
  core.String interfaceName;

  /// IP address of the interface inside Google Cloud Platform. Only IPv4 is
  /// supported.
  core.String ipAddress;

  /// [Output Only] The resource that configures and manages this BGP peer.
  /// - MANAGED_BY_USER is the default value and can be managed by you or other
  /// users
  /// - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by
  /// Cloud Interconnect, specifically by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// BGP peer when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String managementType;

  /// Name of this BGP peer. The name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Peer BGP Autonomous System Number (ASN). Each BGP interface may use a
  /// different value.
  core.int peerAsn;

  /// IP address of the BGP interface outside Google Cloud Platform. Only IPv4
  /// is supported.
  core.String peerIpAddress;

  RouterBgpPeer();

  RouterBgpPeer.fromJson(core.Map _json) {
    if (_json.containsKey('advertiseMode')) {
      advertiseMode = _json['advertiseMode'] as core.String;
    }
    if (_json.containsKey('advertisedGroups')) {
      advertisedGroups = (_json['advertisedGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('advertisedIpRanges')) {
      advertisedIpRanges = (_json['advertisedIpRanges'] as core.List)
          .map<RouterAdvertisedIpRange>((value) =>
              RouterAdvertisedIpRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('advertisedRoutePriority')) {
      advertisedRoutePriority = _json['advertisedRoutePriority'] as core.int;
    }
    if (_json.containsKey('interfaceName')) {
      interfaceName = _json['interfaceName'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('managementType')) {
      managementType = _json['managementType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerAsn')) {
      peerAsn = _json['peerAsn'] as core.int;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (advertiseMode != null) {
      _json['advertiseMode'] = advertiseMode;
    }
    if (advertisedGroups != null) {
      _json['advertisedGroups'] = advertisedGroups;
    }
    if (advertisedIpRanges != null) {
      _json['advertisedIpRanges'] =
          advertisedIpRanges.map((value) => value.toJson()).toList();
    }
    if (advertisedRoutePriority != null) {
      _json['advertisedRoutePriority'] = advertisedRoutePriority;
    }
    if (interfaceName != null) {
      _json['interfaceName'] = interfaceName;
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    if (managementType != null) {
      _json['managementType'] = managementType;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (peerAsn != null) {
      _json['peerAsn'] = peerAsn;
    }
    if (peerIpAddress != null) {
      _json['peerIpAddress'] = peerIpAddress;
    }
    return _json;
  }
}

class RouterInterface {
  /// IP address and range of the interface. The IP range must be in the RFC3927
  /// link-local IP address space. The value must be a CIDR-formatted string,
  /// for example: 169.254.0.1/30. NOTE: Do not truncate the address as it
  /// represents the IP address of the interface.
  core.String ipRange;

  /// URI of the linked Interconnect attachment. It must be in the same region
  /// as the router. Each interface can have one linked resource, which can be a
  /// VPN tunnel, an Interconnect attachment, or a virtual machine instance.
  core.String linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel, which must be in the same region as the
  /// router. Each interface can have one linked resource, which can be a VPN
  /// tunnel, an Interconnect attachment, or a virtual machine instance.
  core.String linkedVpnTunnel;

  /// [Output Only] The resource that configures and manages this interface.
  /// - MANAGED_BY_USER is the default value and can be managed directly by
  /// users.
  /// - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by
  /// Cloud Interconnect, specifically, by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// interface when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String managementType;

  /// Name of this interface entry. The name must be 1-63 characters long, and
  /// comply with RFC1035. Specifically, the name must be 1-63 characters long
  /// and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
  /// the first character must be a lowercase letter, and all following
  /// characters must be a dash, lowercase letter, or digit, except the last
  /// character, which cannot be a dash.
  core.String name;

  RouterInterface();

  RouterInterface.fromJson(core.Map _json) {
    if (_json.containsKey('ipRange')) {
      ipRange = _json['ipRange'] as core.String;
    }
    if (_json.containsKey('linkedInterconnectAttachment')) {
      linkedInterconnectAttachment =
          _json['linkedInterconnectAttachment'] as core.String;
    }
    if (_json.containsKey('linkedVpnTunnel')) {
      linkedVpnTunnel = _json['linkedVpnTunnel'] as core.String;
    }
    if (_json.containsKey('managementType')) {
      managementType = _json['managementType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipRange != null) {
      _json['ipRange'] = ipRange;
    }
    if (linkedInterconnectAttachment != null) {
      _json['linkedInterconnectAttachment'] = linkedInterconnectAttachment;
    }
    if (linkedVpnTunnel != null) {
      _json['linkedVpnTunnel'] = linkedVpnTunnel;
    }
    if (managementType != null) {
      _json['managementType'] = managementType;
    }
    if (name != null) {
      _json['name'] = name;
    }
    return _json;
  }
}

class RouterListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RouterListWarningData();

  RouterListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class RouterListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RouterListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RouterListWarning();

  RouterListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouterListWarningData>((value) => RouterListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Router resources.
class RouterList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Router resources.
  core.List<Router> items;

  /// [Output Only] Type of resource. Always compute#router for routers.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  RouterListWarning warning;

  RouterList();

  RouterList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Router>((value) =>
              Router.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RouterListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Nat resource. It enables the VMs within the specified
/// subnetworks to access Internet without external IP addresses. It specifies a
/// list of subnetworks (and the ranges within) that want to use NAT. Customers
/// can also provide the external IPs that would be used for NAT. GCP would
/// auto-allocate ephemeral IPs if no external IPs are provided.
class RouterNat {
  /// A list of URLs of the IP resources to be drained. These IPs must be valid
  /// static external IPs that have been assigned to the NAT. These IPs should
  /// be used for updating/patching a NAT only.
  core.List<core.String> drainNatIps;

  /// Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
  core.int icmpIdleTimeoutSec;

  /// Configure logging on this NAT.
  RouterNatLogConfig logConfig;

  /// Minimum number of ports allocated to a VM from this NAT config. If not
  /// set, a default number of ports is allocated to a VM. This is rounded up to
  /// the nearest power of 2. For example, if the value of this field is 50, at
  /// least 64 ports are allocated to a VM.
  core.int minPortsPerVm;

  /// Unique name of this Nat service. The name must be 1-63 characters long and
  /// comply with RFC1035.
  core.String name;

  /// Specify the NatIpAllocateOption, which can take one of the following
  /// values:
  /// - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When
  /// there are not enough specified Nat IPs, the Nat service fails for new VMs.
  /// - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers
  /// can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be
  /// empty.
  /// Possible string values are:
  /// - "AUTO_ONLY"
  /// - "MANUAL_ONLY"
  core.String natIpAllocateOption;

  /// A list of URLs of the IP resources used for this Nat service. These IP
  /// addresses must be valid static external IP addresses assigned to the
  /// project.
  core.List<core.String> natIps;

  /// Specify the Nat option, which can take one of the following values:
  /// - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork
  /// are allowed to Nat.
  /// - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in
  /// every Subnetwork are allowed to Nat.
  /// - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified
  /// in the field subnetwork below) The default is
  /// SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field
  /// contains ALL_SUBNETWORKS_ALL_IP_RANGES or
  /// ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other
  /// Router.Nat section in any Router for this network in this region.
  /// Possible string values are:
  /// - "ALL_SUBNETWORKS_ALL_IP_RANGES"
  /// - "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES"
  /// - "LIST_OF_SUBNETWORKS"
  core.String sourceSubnetworkIpRangesToNat;

  /// A list of Subnetwork resources whose traffic should be translated by NAT
  /// Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the
  /// SubnetworkIpRangeToNatOption above.
  core.List<RouterNatSubnetworkToNat> subnetworks;

  /// Timeout (in seconds) for TCP established connections. Defaults to 1200s if
  /// not set.
  core.int tcpEstablishedIdleTimeoutSec;

  /// Timeout (in seconds) for TCP transitory connections. Defaults to 30s if
  /// not set.
  core.int tcpTransitoryIdleTimeoutSec;

  /// Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
  core.int udpIdleTimeoutSec;

  RouterNat();

  RouterNat.fromJson(core.Map _json) {
    if (_json.containsKey('drainNatIps')) {
      drainNatIps = (_json['drainNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('icmpIdleTimeoutSec')) {
      icmpIdleTimeoutSec = _json['icmpIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = RouterNatLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minPortsPerVm')) {
      minPortsPerVm = _json['minPortsPerVm'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natIpAllocateOption')) {
      natIpAllocateOption = _json['natIpAllocateOption'] as core.String;
    }
    if (_json.containsKey('natIps')) {
      natIps = (_json['natIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceSubnetworkIpRangesToNat')) {
      sourceSubnetworkIpRangesToNat =
          _json['sourceSubnetworkIpRangesToNat'] as core.String;
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<RouterNatSubnetworkToNat>((value) =>
              RouterNatSubnetworkToNat.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('tcpEstablishedIdleTimeoutSec')) {
      tcpEstablishedIdleTimeoutSec =
          _json['tcpEstablishedIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('tcpTransitoryIdleTimeoutSec')) {
      tcpTransitoryIdleTimeoutSec =
          _json['tcpTransitoryIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('udpIdleTimeoutSec')) {
      udpIdleTimeoutSec = _json['udpIdleTimeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (drainNatIps != null) {
      _json['drainNatIps'] = drainNatIps;
    }
    if (icmpIdleTimeoutSec != null) {
      _json['icmpIdleTimeoutSec'] = icmpIdleTimeoutSec;
    }
    if (logConfig != null) {
      _json['logConfig'] = logConfig.toJson();
    }
    if (minPortsPerVm != null) {
      _json['minPortsPerVm'] = minPortsPerVm;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (natIpAllocateOption != null) {
      _json['natIpAllocateOption'] = natIpAllocateOption;
    }
    if (natIps != null) {
      _json['natIps'] = natIps;
    }
    if (sourceSubnetworkIpRangesToNat != null) {
      _json['sourceSubnetworkIpRangesToNat'] = sourceSubnetworkIpRangesToNat;
    }
    if (subnetworks != null) {
      _json['subnetworks'] =
          subnetworks.map((value) => value.toJson()).toList();
    }
    if (tcpEstablishedIdleTimeoutSec != null) {
      _json['tcpEstablishedIdleTimeoutSec'] = tcpEstablishedIdleTimeoutSec;
    }
    if (tcpTransitoryIdleTimeoutSec != null) {
      _json['tcpTransitoryIdleTimeoutSec'] = tcpTransitoryIdleTimeoutSec;
    }
    if (udpIdleTimeoutSec != null) {
      _json['udpIdleTimeoutSec'] = udpIdleTimeoutSec;
    }
    return _json;
  }
}

/// Configuration of logging on a NAT.
class RouterNatLogConfig {
  /// Indicates whether or not to export logs. This is false by default.
  core.bool enable;

  /// Specify the desired filtering of logs on this NAT. If unspecified, logs
  /// are exported for all connections handled by this NAT. This option can take
  /// one of the following values:
  /// - ERRORS_ONLY: Export logs only for connection failures.
  /// - TRANSLATIONS_ONLY: Export logs only for successful connections.
  /// - ALL: Export logs for all connections, successful and unsuccessful.
  /// Possible string values are:
  /// - "ALL"
  /// - "ERRORS_ONLY"
  /// - "TRANSLATIONS_ONLY"
  core.String filter;

  RouterNatLogConfig();

  RouterNatLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('filter')) {
      filter = _json['filter'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enable != null) {
      _json['enable'] = enable;
    }
    if (filter != null) {
      _json['filter'] = filter;
    }
    return _json;
  }
}

/// Defines the IP ranges that want to use NAT for a subnetwork.
class RouterNatSubnetworkToNat {
  /// URL for the subnetwork resource that will use NAT.
  core.String name;

  /// A list of the secondary ranges of the Subnetwork that are allowed to use
  /// NAT. This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of
  /// the values in source_ip_ranges_to_nat.
  core.List<core.String> secondaryIpRangeNames;

  /// Specify the options for NAT ranges in the Subnetwork. All options of a
  /// single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only
  /// valid option with multiple values is: ["PRIMARY_IP_RANGE",
  /// "LIST_OF_SECONDARY_IP_RANGES"] Default: [ALL_IP_RANGES]
  core.List<core.String> sourceIpRangesToNat;

  RouterNatSubnetworkToNat();

  RouterNatSubnetworkToNat.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('secondaryIpRangeNames')) {
      secondaryIpRangeNames = (_json['secondaryIpRangeNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceIpRangesToNat')) {
      sourceIpRangesToNat = (_json['sourceIpRangesToNat'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (name != null) {
      _json['name'] = name;
    }
    if (secondaryIpRangeNames != null) {
      _json['secondaryIpRangeNames'] = secondaryIpRangeNames;
    }
    if (sourceIpRangesToNat != null) {
      _json['sourceIpRangesToNat'] = sourceIpRangesToNat;
    }
    return _json;
  }
}

class RouterStatus {
  /// Best routes for this router's network.
  core.List<Route> bestRoutes;

  /// Best routes learned by this router.
  core.List<Route> bestRoutesForRouter;
  core.List<RouterStatusBgpPeerStatus> bgpPeerStatus;
  core.List<RouterStatusNatStatus> natStatus;

  /// URI of the network to which this router belongs.
  core.String network;

  RouterStatus();

  RouterStatus.fromJson(core.Map _json) {
    if (_json.containsKey('bestRoutes')) {
      bestRoutes = (_json['bestRoutes'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bestRoutesForRouter')) {
      bestRoutesForRouter = (_json['bestRoutesForRouter'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bgpPeerStatus')) {
      bgpPeerStatus = (_json['bgpPeerStatus'] as core.List)
          .map<RouterStatusBgpPeerStatus>((value) =>
              RouterStatusBgpPeerStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('natStatus')) {
      natStatus = (_json['natStatus'] as core.List)
          .map<RouterStatusNatStatus>((value) => RouterStatusNatStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bestRoutes != null) {
      _json['bestRoutes'] = bestRoutes.map((value) => value.toJson()).toList();
    }
    if (bestRoutesForRouter != null) {
      _json['bestRoutesForRouter'] =
          bestRoutesForRouter.map((value) => value.toJson()).toList();
    }
    if (bgpPeerStatus != null) {
      _json['bgpPeerStatus'] =
          bgpPeerStatus.map((value) => value.toJson()).toList();
    }
    if (natStatus != null) {
      _json['natStatus'] = natStatus.map((value) => value.toJson()).toList();
    }
    if (network != null) {
      _json['network'] = network;
    }
    return _json;
  }
}

class RouterStatusBgpPeerStatus {
  /// Routes that were advertised to the remote BGP peer
  core.List<Route> advertisedRoutes;

  /// IP address of the local BGP interface.
  core.String ipAddress;

  /// URL of the VPN tunnel that this BGP peer controls.
  core.String linkedVpnTunnel;

  /// Name of this BGP peer. Unique within the Routers resource.
  core.String name;

  /// Number of routes learned from the remote BGP Peer.
  core.int numLearnedRoutes;

  /// IP address of the remote BGP interface.
  core.String peerIpAddress;

  /// BGP state as specified in RFC1771.
  core.String state;

  /// Status of the BGP peer: {UP, DOWN}
  /// Possible string values are:
  /// - "DOWN"
  /// - "UNKNOWN"
  /// - "UP"
  core.String status;

  /// Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23
  /// hours, 59 minutes, 59 seconds
  core.String uptime;

  /// Time this session has been up, in seconds. Format: 145
  core.String uptimeSeconds;

  RouterStatusBgpPeerStatus();

  RouterStatusBgpPeerStatus.fromJson(core.Map _json) {
    if (_json.containsKey('advertisedRoutes')) {
      advertisedRoutes = (_json['advertisedRoutes'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('linkedVpnTunnel')) {
      linkedVpnTunnel = _json['linkedVpnTunnel'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('numLearnedRoutes')) {
      numLearnedRoutes = _json['numLearnedRoutes'] as core.int;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('uptime')) {
      uptime = _json['uptime'] as core.String;
    }
    if (_json.containsKey('uptimeSeconds')) {
      uptimeSeconds = _json['uptimeSeconds'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (advertisedRoutes != null) {
      _json['advertisedRoutes'] =
          advertisedRoutes.map((value) => value.toJson()).toList();
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    if (linkedVpnTunnel != null) {
      _json['linkedVpnTunnel'] = linkedVpnTunnel;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (numLearnedRoutes != null) {
      _json['numLearnedRoutes'] = numLearnedRoutes;
    }
    if (peerIpAddress != null) {
      _json['peerIpAddress'] = peerIpAddress;
    }
    if (state != null) {
      _json['state'] = state;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (uptime != null) {
      _json['uptime'] = uptime;
    }
    if (uptimeSeconds != null) {
      _json['uptimeSeconds'] = uptimeSeconds;
    }
    return _json;
  }
}

/// Status of a NAT contained in this router.
class RouterStatusNatStatus {
  /// A list of IPs auto-allocated for NAT. Example: ["1.1.1.1", "129.2.16.89"]
  core.List<core.String> autoAllocatedNatIps;

  /// A list of IPs auto-allocated for NAT that are in drain mode. Example:
  /// ["1.1.1.1", "179.12.26.133"].
  core.List<core.String> drainAutoAllocatedNatIps;

  /// A list of IPs user-allocated for NAT that are in drain mode. Example:
  /// ["1.1.1.1", "179.12.26.133"].
  core.List<core.String> drainUserAllocatedNatIps;

  /// The number of extra IPs to allocate. This will be greater than 0 only if
  /// user-specified IPs are NOT enough to allow all configured VMs to use NAT.
  /// This value is meaningful only when auto-allocation of NAT IPs is *not*
  /// used.
  core.int minExtraNatIpsNeeded;

  /// Unique name of this NAT.
  core.String name;

  /// Number of VM endpoints (i.e., Nics) that can use NAT.
  core.int numVmEndpointsWithNatMappings;

  /// A list of fully qualified URLs of reserved IP address resources.
  core.List<core.String> userAllocatedNatIpResources;

  /// A list of IPs user-allocated for NAT. They will be raw IP strings like
  /// "179.12.26.133".
  core.List<core.String> userAllocatedNatIps;

  RouterStatusNatStatus();

  RouterStatusNatStatus.fromJson(core.Map _json) {
    if (_json.containsKey('autoAllocatedNatIps')) {
      autoAllocatedNatIps = (_json['autoAllocatedNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('drainAutoAllocatedNatIps')) {
      drainAutoAllocatedNatIps =
          (_json['drainAutoAllocatedNatIps'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('drainUserAllocatedNatIps')) {
      drainUserAllocatedNatIps =
          (_json['drainUserAllocatedNatIps'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('minExtraNatIpsNeeded')) {
      minExtraNatIpsNeeded = _json['minExtraNatIpsNeeded'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('numVmEndpointsWithNatMappings')) {
      numVmEndpointsWithNatMappings =
          _json['numVmEndpointsWithNatMappings'] as core.int;
    }
    if (_json.containsKey('userAllocatedNatIpResources')) {
      userAllocatedNatIpResources =
          (_json['userAllocatedNatIpResources'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('userAllocatedNatIps')) {
      userAllocatedNatIps = (_json['userAllocatedNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoAllocatedNatIps != null) {
      _json['autoAllocatedNatIps'] = autoAllocatedNatIps;
    }
    if (drainAutoAllocatedNatIps != null) {
      _json['drainAutoAllocatedNatIps'] = drainAutoAllocatedNatIps;
    }
    if (drainUserAllocatedNatIps != null) {
      _json['drainUserAllocatedNatIps'] = drainUserAllocatedNatIps;
    }
    if (minExtraNatIpsNeeded != null) {
      _json['minExtraNatIpsNeeded'] = minExtraNatIpsNeeded;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (numVmEndpointsWithNatMappings != null) {
      _json['numVmEndpointsWithNatMappings'] = numVmEndpointsWithNatMappings;
    }
    if (userAllocatedNatIpResources != null) {
      _json['userAllocatedNatIpResources'] = userAllocatedNatIpResources;
    }
    if (userAllocatedNatIps != null) {
      _json['userAllocatedNatIps'] = userAllocatedNatIps;
    }
    return _json;
  }
}

class RouterStatusResponse {
  /// Type of resource.
  core.String kind;
  RouterStatus result;

  RouterStatusResponse();

  RouterStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('result')) {
      result = RouterStatus.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (result != null) {
      _json['result'] = result.toJson();
    }
    return _json;
  }
}

class RoutersPreviewResponse {
  /// Preview of given router.
  Router resource;

  RoutersPreviewResponse();

  RoutersPreviewResponse.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = Router.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resource != null) {
      _json['resource'] = resource.toJson();
    }
    return _json;
  }
}

class RoutersScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  RoutersScopedListWarningData();

  RoutersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of routers when the list is
/// empty.
class RoutersScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<RoutersScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  RoutersScopedListWarning();

  RoutersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RoutersScopedListWarningData>((value) =>
              RoutersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class RoutersScopedList {
  /// A list of routers contained in this scope.
  core.List<Router> routers;

  /// Informational warning which replaces the list of routers when the list is
  /// empty.
  RoutersScopedListWarning warning;

  RoutersScopedList();

  RoutersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('routers')) {
      routers = (_json['routers'] as core.List)
          .map<Router>((value) =>
              Router.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = RoutersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (routers != null) {
      _json['routers'] = routers.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A rule to be applied in a Policy.
class Rule {
  /// Required
  /// Possible string values are:
  /// - "ALLOW"
  /// - "ALLOW_WITH_LOG"
  /// - "DENY"
  /// - "DENY_WITH_LOG"
  /// - "LOG"
  /// - "NO_ACTION"
  core.String action;

  /// Additional restrictions that must be met. All conditions must pass for the
  /// rule to match.
  core.List<Condition> conditions;

  /// Human-readable description of the rule.
  core.String description;

  /// If one or more 'in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.
  core.List<core.String> ins;

  /// The config returned to callers of tech.iam.IAM.CheckPolicy for any entries
  /// that match the LOG action.
  core.List<LogConfig> logConfigs;

  /// If one or more 'not_in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in none of the entries.
  core.List<core.String> notIns;

  /// A permission is a string of form '..' (e.g., 'storage.buckets.list'). A
  /// value of '*' matches all permissions, and a verb part of '*' (e.g.,
  /// 'storage.buckets.*') matches all verbs.
  core.List<core.String> permissions;

  Rule();

  Rule.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('conditions')) {
      conditions = (_json['conditions'] as core.List)
          .map<Condition>((value) =>
              Condition.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('ins')) {
      ins = (_json['ins'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('logConfigs')) {
      logConfigs = (_json['logConfigs'] as core.List)
          .map<LogConfig>((value) =>
              LogConfig.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('notIns')) {
      notIns = (_json['notIns'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (action != null) {
      _json['action'] = action;
    }
    if (conditions != null) {
      _json['conditions'] = conditions.map((value) => value.toJson()).toList();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (ins != null) {
      _json['ins'] = ins;
    }
    if (logConfigs != null) {
      _json['logConfigs'] = logConfigs.map((value) => value.toJson()).toList();
    }
    if (notIns != null) {
      _json['notIns'] = notIns;
    }
    if (permissions != null) {
      _json['permissions'] = permissions;
    }
    return _json;
  }
}

class SSLHealthCheck {
  /// The TCP port number for the health check request. The default value is
  /// 443. Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, SSL health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the SSL connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  SSLHealthCheck();

  SSLHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('request')) {
      request = _json['request'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (request != null) {
      _json['request'] = request;
    }
    if (response != null) {
      _json['response'] = response;
    }
    return _json;
  }
}

/// Sets the scheduling options for an Instance. NextID: 13
class Scheduling {
  /// Specifies whether the instance should be automatically restarted if it is
  /// terminated by Compute Engine (not terminated by a user). You can only set
  /// the automatic restart option for standard instances. Preemptible instances
  /// cannot be automatically restarted.
  ///
  /// By default, this is set to true so an instance is automatically restarted
  /// if it is terminated by Compute Engine.
  core.bool automaticRestart;

  /// The minimum number of virtual CPUs this instance will consume when running
  /// on a sole-tenant node.
  core.int minNodeCpus;

  /// A set of node affinity and anti-affinity configurations. Refer to
  /// Configuring node affinity for more information. Overrides
  /// reservationAffinity.
  core.List<SchedulingNodeAffinity> nodeAffinities;

  /// Defines the maintenance behavior for this instance. For standard
  /// instances, the default behavior is MIGRATE. For preemptible instances, the
  /// default and only possible behavior is TERMINATE. For more information, see
  /// Setting Instance Scheduling Options.
  /// Possible string values are:
  /// - "MIGRATE"
  /// - "TERMINATE"
  core.String onHostMaintenance;

  /// Defines whether the instance is preemptible. This can only be set during
  /// instance creation or while the instance is stopped and therefore, in a
  /// `TERMINATED` state. See Instance Life Cycle for more information on the
  /// possible instance states.
  core.bool preemptible;

  Scheduling();

  Scheduling.fromJson(core.Map _json) {
    if (_json.containsKey('automaticRestart')) {
      automaticRestart = _json['automaticRestart'] as core.bool;
    }
    if (_json.containsKey('minNodeCpus')) {
      minNodeCpus = _json['minNodeCpus'] as core.int;
    }
    if (_json.containsKey('nodeAffinities')) {
      nodeAffinities = (_json['nodeAffinities'] as core.List)
          .map<SchedulingNodeAffinity>((value) =>
              SchedulingNodeAffinity.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('onHostMaintenance')) {
      onHostMaintenance = _json['onHostMaintenance'] as core.String;
    }
    if (_json.containsKey('preemptible')) {
      preemptible = _json['preemptible'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (automaticRestart != null) {
      _json['automaticRestart'] = automaticRestart;
    }
    if (minNodeCpus != null) {
      _json['minNodeCpus'] = minNodeCpus;
    }
    if (nodeAffinities != null) {
      _json['nodeAffinities'] =
          nodeAffinities.map((value) => value.toJson()).toList();
    }
    if (onHostMaintenance != null) {
      _json['onHostMaintenance'] = onHostMaintenance;
    }
    if (preemptible != null) {
      _json['preemptible'] = preemptible;
    }
    return _json;
  }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled.
class SchedulingNodeAffinity {
  /// Corresponds to the label key of Node resource.
  core.String key;

  /// Defines the operation of node selection. Valid operators are IN for
  /// affinity and NOT_IN for anti-affinity.
  /// Possible string values are:
  /// - "IN"
  /// - "NOT_IN"
  /// - "OPERATOR_UNSPECIFIED"
  core.String operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String> values;

  SchedulingNodeAffinity();

  SchedulingNodeAffinity.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('operator')) {
      operator = _json['operator'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (operator != null) {
      _json['operator'] = operator;
    }
    if (values != null) {
      _json['values'] = values;
    }
    return _json;
  }
}

/// An instance's screenshot.
class Screenshot {
  /// [Output Only] The Base64-encoded screenshot data.
  core.String contents;

  /// [Output Only] Type of the resource. Always compute#screenshot for the
  /// screenshots.
  core.String kind;

  Screenshot();

  Screenshot.fromJson(core.Map _json) {
    if (_json.containsKey('contents')) {
      contents = _json['contents'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (contents != null) {
      _json['contents'] = contents;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    return _json;
  }
}

class SecurityPoliciesListPreconfiguredExpressionSetsResponse {
  SecurityPoliciesWafConfig preconfiguredExpressionSets;

  SecurityPoliciesListPreconfiguredExpressionSetsResponse();

  SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
      core.Map _json) {
    if (_json.containsKey('preconfiguredExpressionSets')) {
      preconfiguredExpressionSets = SecurityPoliciesWafConfig.fromJson(
          _json['preconfiguredExpressionSets']
              as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (preconfiguredExpressionSets != null) {
      _json['preconfiguredExpressionSets'] =
          preconfiguredExpressionSets.toJson();
    }
    return _json;
  }
}

class SecurityPoliciesWafConfig {
  PreconfiguredWafSet wafRules;

  SecurityPoliciesWafConfig();

  SecurityPoliciesWafConfig.fromJson(core.Map _json) {
    if (_json.containsKey('wafRules')) {
      wafRules = PreconfiguredWafSet.fromJson(
          _json['wafRules'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (wafRules != null) {
      _json['wafRules'] = wafRules.toJson();
    }
    return _json;
  }
}

/// Represents a Cloud Armor Security Policy resource.
///
/// Only external backend services that use load balancers can reference a
/// Security Policy. For more information, read  Cloud Armor Security Policy
/// Concepts. (== resource_for {$api_version}.securityPolicies ==)
class SecurityPolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking. The fingerprint
  /// is initially generated by Compute Engine and changes after every request
  /// to modify or update metadata. You must always provide an up-to-date
  /// fingerprint hash in order to update or change metadata, otherwise the
  /// request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make get() request to the security policy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output only] Type of the resource. Always compute#securityPolicyfor
  /// security policies
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A list of rules that belong to this policy. There must always be a default
  /// rule (rule with priority 2147483647 and match "*"). If no rules are
  /// provided when creating a security policy, a default rule with action
  /// "allow" will be added.
  core.List<SecurityPolicyRule> rules;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  SecurityPolicy();

  SecurityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<SecurityPolicyRule>((value) => SecurityPolicyRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (rules != null) {
      _json['rules'] = rules.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    return _json;
  }
}

class SecurityPolicyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SecurityPolicyListWarningData();

  SecurityPolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SecurityPolicyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SecurityPolicyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SecurityPolicyListWarning();

  SecurityPolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SecurityPolicyListWarningData>((value) =>
              SecurityPolicyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SecurityPolicyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SecurityPolicy resources.
  core.List<SecurityPolicy> items;

  /// [Output Only] Type of resource. Always compute#securityPolicyList for
  /// listsof securityPolicies
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Informational warning message.
  SecurityPolicyListWarning warning;

  SecurityPolicyList();

  SecurityPolicyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SecurityPolicy>((value) => SecurityPolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SecurityPolicyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SecurityPolicyReference {
  core.String securityPolicy;

  SecurityPolicyReference();

  SecurityPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey('securityPolicy')) {
      securityPolicy = _json['securityPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (securityPolicy != null) {
      _json['securityPolicy'] = securityPolicy;
    }
    return _json;
  }
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class SecurityPolicyRule {
  /// The Action to preform when the client connection triggers the rule. Can
  /// currently be either "allow" or "deny()" where valid values for status are
  /// 403, 404, and 502.
  core.String action;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output only] Type of the resource. Always compute#securityPolicyRule for
  /// security policy rules
  core.String kind;

  /// A match condition that incoming traffic is evaluated against. If it
  /// evaluates to true, the corresponding 'action' is enforced.
  SecurityPolicyRuleMatcher match;

  /// If set to true, the specified action is not enforced.
  core.bool preview;

  /// An integer indicating the priority of a rule in the list. The priority
  /// must be a positive value between 0 and 2147483647. Rules are evaluated
  /// from highest to lowest priority where 0 is the highest priority and
  /// 2147483647 is the lowest prority.
  core.int priority;

  SecurityPolicyRule();

  SecurityPolicyRule.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('match')) {
      match = SecurityPolicyRuleMatcher.fromJson(
          _json['match'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preview')) {
      preview = _json['preview'] as core.bool;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (action != null) {
      _json['action'] = action;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (match != null) {
      _json['match'] = match.toJson();
    }
    if (preview != null) {
      _json['preview'] = preview;
    }
    if (priority != null) {
      _json['priority'] = priority;
    }
    return _json;
  }
}

/// Represents a match condition that incoming traffic is evaluated against.
/// Exactly one field must be specified.
class SecurityPolicyRuleMatcher {
  /// The configuration options available when specifying versioned_expr. This
  /// field must be specified if versioned_expr is specified and cannot be
  /// specified if versioned_expr is not specified.
  SecurityPolicyRuleMatcherConfig config;

  /// User defined CEVAL expression. A CEVAL expression is used to specify match
  /// criteria such as origin.ip, source.region_code and contents in the request
  /// header.
  Expr expr;

  /// Preconfigured versioned expression. If this field is specified, config
  /// must also be specified. Available preconfigured expressions along with
  /// their requirements are: SRC_IPS_V1 - must specify the corresponding
  /// src_ip_range field in config.
  /// Possible string values are:
  /// - "SRC_IPS_V1"
  core.String versionedExpr;

  SecurityPolicyRuleMatcher();

  SecurityPolicyRuleMatcher.fromJson(core.Map _json) {
    if (_json.containsKey('config')) {
      config = SecurityPolicyRuleMatcherConfig.fromJson(
          _json['config'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('expr')) {
      expr =
          Expr.fromJson(_json['expr'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versionedExpr')) {
      versionedExpr = _json['versionedExpr'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (config != null) {
      _json['config'] = config.toJson();
    }
    if (expr != null) {
      _json['expr'] = expr.toJson();
    }
    if (versionedExpr != null) {
      _json['versionedExpr'] = versionedExpr;
    }
    return _json;
  }
}

class SecurityPolicyRuleMatcherConfig {
  /// CIDR IP address range. Maximum number of src_ip_ranges allowed is 10.
  core.List<core.String> srcIpRanges;

  SecurityPolicyRuleMatcherConfig();

  SecurityPolicyRuleMatcherConfig.fromJson(core.Map _json) {
    if (_json.containsKey('srcIpRanges')) {
      srcIpRanges = (_json['srcIpRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (srcIpRanges != null) {
      _json['srcIpRanges'] = srcIpRanges;
    }
    return _json;
  }
}

/// An instance's serial console output.
class SerialPortOutput {
  /// [Output Only] The contents of the console output.
  core.String contents;

  /// [Output Only] Type of the resource. Always compute#serialPortOutput for
  /// serial port output.
  core.String kind;

  /// [Output Only] The position of the next byte of content, regardless of
  /// whether the content exists, following the output returned in the
  /// `contents` property. Use this value in the next request as the start
  /// parameter.
  core.String next;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// The starting byte position of the output that was returned. This should
  /// match the start parameter sent with the request. If the serial console
  /// output exceeds the size of the buffer (1 MB), older output is overwritten
  /// by newer content. The output start value will indicate the byte position
  /// of the output that was returned, which might be different than the `start`
  /// value that was specified in the request.
  core.String start;

  SerialPortOutput();

  SerialPortOutput.fromJson(core.Map _json) {
    if (_json.containsKey('contents')) {
      contents = _json['contents'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('next')) {
      next = _json['next'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('start')) {
      start = _json['start'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (contents != null) {
      _json['contents'] = contents;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (next != null) {
      _json['next'] = next;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (start != null) {
      _json['start'] = start;
    }
    return _json;
  }
}

class ServerBinding {
  ///
  /// Possible string values are:
  /// - "RESTART_NODE_ON_ANY_SERVER"
  /// - "RESTART_NODE_ON_MINIMAL_SERVERS"
  /// - "SERVER_BINDING_TYPE_UNSPECIFIED"
  core.String type;

  ServerBinding();

  ServerBinding.fromJson(core.Map _json) {
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

/// A service account.
class ServiceAccount {
  /// Email address of the service account.
  core.String email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String> scopes;

  ServiceAccount();

  ServiceAccount.fromJson(core.Map _json) {
    if (_json.containsKey('email')) {
      email = _json['email'] as core.String;
    }
    if (_json.containsKey('scopes')) {
      scopes = (_json['scopes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (email != null) {
      _json['email'] = email;
    }
    if (scopes != null) {
      _json['scopes'] = scopes;
    }
    return _json;
  }
}

/// A set of Shielded Instance options.
class ShieldedInstanceConfig {
  /// Defines whether the instance has integrity monitoring enabled. Enabled by
  /// default.
  core.bool enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled. Disabled by default.
  core.bool enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled. Enabled by default.
  core.bool enableVtpm;

  ShieldedInstanceConfig();

  ShieldedInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enableIntegrityMonitoring')) {
      enableIntegrityMonitoring =
          _json['enableIntegrityMonitoring'] as core.bool;
    }
    if (_json.containsKey('enableSecureBoot')) {
      enableSecureBoot = _json['enableSecureBoot'] as core.bool;
    }
    if (_json.containsKey('enableVtpm')) {
      enableVtpm = _json['enableVtpm'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (enableIntegrityMonitoring != null) {
      _json['enableIntegrityMonitoring'] = enableIntegrityMonitoring;
    }
    if (enableSecureBoot != null) {
      _json['enableSecureBoot'] = enableSecureBoot;
    }
    if (enableVtpm != null) {
      _json['enableVtpm'] = enableVtpm;
    }
    return _json;
  }
}

/// A shielded Instance identity entry.
class ShieldedInstanceIdentity {
  /// An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry encryptionKey;

  /// [Output Only] Type of the resource. Always
  /// compute#shieldedInstanceIdentity for shielded Instance identity entry.
  core.String kind;

  /// An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry signingKey;

  ShieldedInstanceIdentity();

  ShieldedInstanceIdentity.fromJson(core.Map _json) {
    if (_json.containsKey('encryptionKey')) {
      encryptionKey = ShieldedInstanceIdentityEntry.fromJson(
          _json['encryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('signingKey')) {
      signingKey = ShieldedInstanceIdentityEntry.fromJson(
          _json['signingKey'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (encryptionKey != null) {
      _json['encryptionKey'] = encryptionKey.toJson();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (signingKey != null) {
      _json['signingKey'] = signingKey.toJson();
    }
    return _json;
  }
}

/// A Shielded Instance Identity Entry.
class ShieldedInstanceIdentityEntry {
  /// A PEM-encoded X.509 certificate. This field can be empty.
  core.String ekCert;

  /// A PEM-encoded public key.
  core.String ekPub;

  ShieldedInstanceIdentityEntry();

  ShieldedInstanceIdentityEntry.fromJson(core.Map _json) {
    if (_json.containsKey('ekCert')) {
      ekCert = _json['ekCert'] as core.String;
    }
    if (_json.containsKey('ekPub')) {
      ekPub = _json['ekPub'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ekCert != null) {
      _json['ekCert'] = ekCert;
    }
    if (ekPub != null) {
      _json['ekPub'] = ekPub;
    }
    return _json;
  }
}

/// The policy describes the baseline against which Instance boot integrity is
/// measured.
class ShieldedInstanceIntegrityPolicy {
  /// Updates the integrity policy baseline using the measurements from the VM
  /// instance's most recent boot.
  core.bool updateAutoLearnPolicy;

  ShieldedInstanceIntegrityPolicy();

  ShieldedInstanceIntegrityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('updateAutoLearnPolicy')) {
      updateAutoLearnPolicy = _json['updateAutoLearnPolicy'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (updateAutoLearnPolicy != null) {
      _json['updateAutoLearnPolicy'] = updateAutoLearnPolicy;
    }
    return _json;
  }
}

/// Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
class SignedUrlKey {
  /// Name of the key. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String keyName;

  /// 128-bit key value used for signing the URL. The key value must be a valid
  /// RFC 4648 Section 5 base64url encoded string.
  core.String keyValue;

  SignedUrlKey();

  SignedUrlKey.fromJson(core.Map _json) {
    if (_json.containsKey('keyName')) {
      keyName = _json['keyName'] as core.String;
    }
    if (_json.containsKey('keyValue')) {
      keyValue = _json['keyValue'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (keyName != null) {
      _json['keyName'] = keyName;
    }
    if (keyValue != null) {
      _json['keyValue'] = keyValue;
    }
    return _json;
  }
}

/// Represents a Persistent Disk Snapshot resource.
///
/// You can use snapshots to back up data on a regular interval. For more
/// information, read  Creating persistent disk snapshots. (== resource_for
/// {$api_version}.snapshots ==)
class Snapshot {
  /// [Output Only] Set to true if snapshots are automatically created by
  /// applying resource policy on the target disk.
  core.bool autoCreated;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Size of the source disk, specified in GB.
  core.String diskSizeGb;

  /// [Output Only] Number of bytes downloaded to restore a snapshot to a disk.
  core.String downloadBytes;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#snapshot for Snapshot
  /// resources.
  core.String kind;

  /// A fingerprint for the labels being applied to this snapshot, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// snapshot.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this snapshot. These can be later modified by the
  /// setLabels method. Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// [Output Only] Integer license codes indicating which licenses are attached
  /// to this snapshot.
  core.List<core.String> licenseCodes;

  /// [Output Only] A list of public visible licenses that apply to this
  /// snapshot. This can be because the original image had licenses attached
  /// (such as a Windows image).
  core.List<core.String> licenses;

  /// Name of the resource; provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Encrypts the snapshot using a customer-supplied encryption key.
  ///
  /// After you encrypt a snapshot using a customer-supplied key, you must
  /// provide the same key if you use the snapshot later. For example, you must
  /// provide the encryption key when you create a disk from the encrypted
  /// snapshot in a future request.
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// snapshot.
  ///
  /// If you do not provide an encryption key when creating the snapshot, then
  /// the snapshot will be encrypted using an automatically generated key and
  /// you do not need to provide a key to use the snapshot later.
  CustomerEncryptionKey snapshotEncryptionKey;

  /// The source disk used to create this snapshot.
  core.String sourceDisk;

  /// The customer-supplied encryption key of the source disk. Required if the
  /// source disk is protected by a customer-supplied encryption key.
  CustomerEncryptionKey sourceDiskEncryptionKey;

  /// [Output Only] The ID value of the disk used to create this snapshot. This
  /// value may be used to determine whether the snapshot was taken from the
  /// current or a previous instance of a given disk name.
  core.String sourceDiskId;

  /// [Output Only] The status of the snapshot. This can be CREATING, DELETING,
  /// FAILED, READY, or UPLOADING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "UPLOADING"
  core.String status;

  /// [Output Only] A size of the storage used by the snapshot. As snapshots
  /// share storage, this number is expected to change with snapshot
  /// creation/deletion.
  core.String storageBytes;

  /// [Output Only] An indicator whether storageBytes is in a stable state or it
  /// is being adjusted as a result of shared storage reallocation. This status
  /// can either be UPDATING, meaning the size of the snapshot is being updated,
  /// or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String storageBytesStatus;

  /// Cloud Storage bucket storage location of the snapshot (regional or
  /// multi-regional).
  core.List<core.String> storageLocations;

  Snapshot();

  Snapshot.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreated')) {
      autoCreated = _json['autoCreated'] as core.bool;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('downloadBytes')) {
      downloadBytes = _json['downloadBytes'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('snapshotEncryptionKey')) {
      snapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['snapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskEncryptionKey')) {
      sourceDiskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceDiskEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('storageBytes')) {
      storageBytes = _json['storageBytes'] as core.String;
    }
    if (_json.containsKey('storageBytesStatus')) {
      storageBytesStatus = _json['storageBytesStatus'] as core.String;
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoCreated != null) {
      _json['autoCreated'] = autoCreated;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (diskSizeGb != null) {
      _json['diskSizeGb'] = diskSizeGb;
    }
    if (downloadBytes != null) {
      _json['downloadBytes'] = downloadBytes;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (licenseCodes != null) {
      _json['licenseCodes'] = licenseCodes;
    }
    if (licenses != null) {
      _json['licenses'] = licenses;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (snapshotEncryptionKey != null) {
      _json['snapshotEncryptionKey'] = snapshotEncryptionKey.toJson();
    }
    if (sourceDisk != null) {
      _json['sourceDisk'] = sourceDisk;
    }
    if (sourceDiskEncryptionKey != null) {
      _json['sourceDiskEncryptionKey'] = sourceDiskEncryptionKey.toJson();
    }
    if (sourceDiskId != null) {
      _json['sourceDiskId'] = sourceDiskId;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (storageBytes != null) {
      _json['storageBytes'] = storageBytes;
    }
    if (storageBytesStatus != null) {
      _json['storageBytesStatus'] = storageBytesStatus;
    }
    if (storageLocations != null) {
      _json['storageLocations'] = storageLocations;
    }
    return _json;
  }
}

class SnapshotListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SnapshotListWarningData();

  SnapshotListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SnapshotListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SnapshotListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SnapshotListWarning();

  SnapshotListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SnapshotListWarningData>((value) =>
              SnapshotListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Snapshot resources.
class SnapshotList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Snapshot resources.
  core.List<Snapshot> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SnapshotListWarning warning;

  SnapshotList();

  SnapshotList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Snapshot>((value) =>
              Snapshot.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SnapshotListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// A specification of the parameters to use when creating the instance template
/// from a source instance.
class SourceInstanceParams {
  /// Attached disks configuration. If not provided, defaults are applied: For
  /// boot disk and any other R/W disks, new custom images will be created from
  /// each disk. For read-only disks, they will be attached in read-only mode.
  /// Local SSD disks will be created as blank volumes.
  core.List<DiskInstantiationConfig> diskConfigs;

  SourceInstanceParams();

  SourceInstanceParams.fromJson(core.Map _json) {
    if (_json.containsKey('diskConfigs')) {
      diskConfigs = (_json['diskConfigs'] as core.List)
          .map<DiskInstantiationConfig>((value) =>
              DiskInstantiationConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (diskConfigs != null) {
      _json['diskConfigs'] =
          diskConfigs.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// Represents an SSL Certificate resource.
///
/// Google Compute Engine has two SSL Certificate resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/sslCertificates) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionSslCertificates)
///
///
///
/// The sslCertificates are used by:
/// - external HTTPS load balancers
/// - SSL proxy load balancers
///
/// The regionSslCertificates are used by internal HTTPS load balancers.
///
/// Optionally, certificate file contents that you upload can contain a set of
/// up to five PEM-encoded certificates. The API call creates an object
/// (sslCertificate) that holds this data. You can use SSL keys and certificates
/// to secure connections to a load balancer. For more information, read
/// Creating and using SSL certificates, SSL certificates quotas and limits, and
/// Troubleshooting SSL certificates. (== resource_for
/// {$api_version}.sslCertificates ==) (== resource_for
/// {$api_version}.regionSslCertificates ==)
class SslCertificate {
  /// A value read into memory from a certificate file. The certificate file
  /// must be in PEM format. The certificate chain must be no greater than 5
  /// certs long. The chain must include at least one intermediate cert.
  core.String certificate;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Expire time of the certificate. RFC3339
  core.String expireTime;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#sslCertificate for SSL
  /// certificates.
  core.String kind;

  /// Configuration and status of a managed SSL certificate.
  SslCertificateManagedSslCertificate managed;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// A value read into memory from a write-only private key file. The private
  /// key file must be in PEM format. For security, only insert requests include
  /// this field.
  core.String privateKey;

  /// [Output Only] URL of the region where the regional SSL Certificate
  /// resides. This field is not applicable to global SSL Certificate.
  core.String region;

  /// [Output only] Server-defined URL for the resource.
  core.String selfLink;

  /// Configuration and status of a self-managed SSL certificate.
  SslCertificateSelfManagedSslCertificate selfManaged;

  /// [Output Only] Domains associated with the certificate via Subject
  /// Alternative Name.
  core.List<core.String> subjectAlternativeNames;

  /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or
  /// "MANAGED". If not specified, the certificate is self-managed and the
  /// fields certificate and private_key are used.
  /// Possible string values are:
  /// - "MANAGED"
  /// - "SELF_MANAGED"
  /// - "TYPE_UNSPECIFIED"
  core.String type;

  SslCertificate();

  SslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('certificate')) {
      certificate = _json['certificate'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expireTime')) {
      expireTime = _json['expireTime'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('managed')) {
      managed = SslCertificateManagedSslCertificate.fromJson(
          _json['managed'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('privateKey')) {
      privateKey = _json['privateKey'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('selfManaged')) {
      selfManaged = SslCertificateSelfManagedSslCertificate.fromJson(
          _json['selfManaged'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('subjectAlternativeNames')) {
      subjectAlternativeNames = (_json['subjectAlternativeNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (certificate != null) {
      _json['certificate'] = certificate;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (expireTime != null) {
      _json['expireTime'] = expireTime;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (managed != null) {
      _json['managed'] = managed.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (privateKey != null) {
      _json['privateKey'] = privateKey;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (selfManaged != null) {
      _json['selfManaged'] = selfManaged.toJson();
    }
    if (subjectAlternativeNames != null) {
      _json['subjectAlternativeNames'] = subjectAlternativeNames;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

class SslCertificateAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificateAggregatedListWarningData();

  SslCertificateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslCertificateAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificateAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificateAggregatedListWarning();

  SslCertificateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificateAggregatedListWarningData>((value) =>
              SslCertificateAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SslCertificateAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslCertificatesScopedList resources.
  core.Map<core.String, SslCertificatesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#sslCertificateAggregatedList for lists of SSL Certificates.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  SslCertificateAggregatedListWarning warning;

  SslCertificateAggregatedList();

  SslCertificateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              SslCertificatesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificateAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SslCertificateListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificateListWarningData();

  SslCertificateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslCertificateListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificateListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificateListWarning();

  SslCertificateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificateListWarningData>((value) =>
              SslCertificateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of SslCertificate resources.
class SslCertificateList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslCertificate resources.
  core.List<SslCertificate> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslCertificateListWarning warning;

  SslCertificateList();

  SslCertificateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SslCertificate>((value) => SslCertificate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Configuration and status of a managed SSL certificate.
class SslCertificateManagedSslCertificate {
  /// [Output only] Detailed statuses of the domains specified for managed
  /// certificate resource.
  core.Map<core.String, core.String> domainStatus;

  /// The domains for which a managed SSL certificate will be generated.
  /// Currently only single-domain certs are supported.
  core.List<core.String> domains;

  /// [Output only] Status of the managed certificate resource.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
  /// - "PROVISIONING"
  /// - "PROVISIONING_FAILED"
  /// - "PROVISIONING_FAILED_PERMANENTLY"
  /// - "RENEWAL_FAILED"
  core.String status;

  SslCertificateManagedSslCertificate();

  SslCertificateManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('domainStatus')) {
      domainStatus = (_json['domainStatus'] as core.Map)
          .cast<core.String, core.String>()
          .map(
            (key, item) => core.MapEntry(
              key,
              item as core.String,
            ),
          );
    }
    if (_json.containsKey('domains')) {
      domains = (_json['domains'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (domainStatus != null) {
      _json['domainStatus'] = domainStatus;
    }
    if (domains != null) {
      _json['domains'] = domains;
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

/// Configuration and status of a self-managed SSL certificate.
class SslCertificateSelfManagedSslCertificate {
  /// A local certificate file. The certificate must be in PEM format. The
  /// certificate chain must be no greater than 5 certs long. The chain must
  /// include at least one intermediate cert.
  core.String certificate;

  /// A write-only private key in PEM format. Only insert requests will include
  /// this field.
  core.String privateKey;

  SslCertificateSelfManagedSslCertificate();

  SslCertificateSelfManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('certificate')) {
      certificate = _json['certificate'] as core.String;
    }
    if (_json.containsKey('privateKey')) {
      privateKey = _json['privateKey'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (certificate != null) {
      _json['certificate'] = certificate;
    }
    if (privateKey != null) {
      _json['privateKey'] = privateKey;
    }
    return _json;
  }
}

class SslCertificatesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslCertificatesScopedListWarningData();

  SslCertificatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class SslCertificatesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslCertificatesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslCertificatesScopedListWarning();

  SslCertificatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificatesScopedListWarningData>((value) =>
              SslCertificatesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SslCertificatesScopedList {
  /// List of SslCertificates contained in this scope.
  core.List<SslCertificate> sslCertificates;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  SslCertificatesScopedListWarning warning;

  SslCertificatesScopedList();

  SslCertificatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<SslCertificate>((value) => SslCertificate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificatesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sslCertificates != null) {
      _json['sslCertificates'] =
          sslCertificates.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SslPoliciesListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslPoliciesListWarningData();

  SslPoliciesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SslPoliciesListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslPoliciesListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslPoliciesListWarning();

  SslPoliciesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslPoliciesListWarningData>((value) =>
              SslPoliciesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SslPoliciesList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SslPolicy resources.
  core.List<SslPolicy> items;

  /// [Output Only] Type of the resource. Always compute#sslPoliciesList for
  /// lists of sslPolicies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SslPoliciesListWarning warning;

  SslPoliciesList();

  SslPoliciesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SslPolicy>((value) =>
              SslPolicy.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SslPoliciesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SslPoliciesListAvailableFeaturesResponse {
  core.List<core.String> features;

  SslPoliciesListAvailableFeaturesResponse();

  SslPoliciesListAvailableFeaturesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('features')) {
      features = (_json['features'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (features != null) {
      _json['features'] = features;
    }
    return _json;
  }
}

class SslPolicyWarningsData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SslPolicyWarningsData();

  SslPolicyWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

class SslPolicyWarnings {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SslPolicyWarningsData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SslPolicyWarnings();

  SslPolicyWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslPolicyWarningsData>((value) => SslPolicyWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Represents a Cloud Armor Security Policy resource.
///
/// Only external backend services used by HTTP or HTTPS load balancers can
/// reference a Security Policy. For more information, read read  Cloud Armor
/// Security Policy Concepts. (== resource_for {$api_version}.sslPolicies ==)
class SslPolicy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// A list of features enabled when the selected profile is CUSTOM. The
  /// - method returns the set of features that can be specified in this list.
  /// This field must be empty if the profile is not CUSTOM.
  core.List<core.String> customFeatures;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The list of features enabled in the SSL policy.
  core.List<core.String> enabledFeatures;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a SslPolicy. An up-to-date fingerprint must be
  /// provided in order to update the SslPolicy, otherwise the request will fail
  /// with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// SslPolicy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output only] Type of the resource. Always compute#sslPolicyfor SSL
  /// policies.
  core.String kind;

  /// The minimum version of SSL protocol that can be used by the clients to
  /// establish a connection with the load balancer. This can be one of TLS_1_0,
  /// TLS_1_1, TLS_1_2.
  /// Possible string values are:
  /// - "TLS_1_0"
  /// - "TLS_1_1"
  /// - "TLS_1_2"
  core.String minTlsVersion;

  /// Name of the resource. The name must be 1-63 characters long, and comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the
  /// first character must be a lowercase letter, and all following characters
  /// must be a dash, lowercase letter, or digit, except the last character,
  /// which cannot be a dash.
  core.String name;

  /// Profile specifies the set of SSL features that can be used by the load
  /// balancer when negotiating SSL with clients. This can be one of COMPATIBLE,
  /// MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to
  /// enable must be specified in the customFeatures field.
  /// Possible string values are:
  /// - "COMPATIBLE"
  /// - "CUSTOM"
  /// - "MODERN"
  /// - "RESTRICTED"
  core.String profile;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] If potential misconfigurations are detected for this SSL
  /// policy, this field will be populated with warning messages.
  core.List<SslPolicyWarnings> warnings;

  SslPolicy();

  SslPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customFeatures')) {
      customFeatures = (_json['customFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enabledFeatures')) {
      enabledFeatures = (_json['enabledFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('minTlsVersion')) {
      minTlsVersion = _json['minTlsVersion'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('profile')) {
      profile = _json['profile'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<SslPolicyWarnings>((value) => SslPolicyWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (customFeatures != null) {
      _json['customFeatures'] = customFeatures;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enabledFeatures != null) {
      _json['enabledFeatures'] = enabledFeatures;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (minTlsVersion != null) {
      _json['minTlsVersion'] = minTlsVersion;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (profile != null) {
      _json['profile'] = profile;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warnings != null) {
      _json['warnings'] = warnings.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class SslPolicyReference {
  /// URL of the SSL policy resource. Set this to empty string to clear any
  /// existing SSL policy associated with the target proxy resource.
  core.String sslPolicy;

  SslPolicyReference();

  SslPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sslPolicy != null) {
      _json['sslPolicy'] = sslPolicy;
    }
    return _json;
  }
}

class StatefulPolicy {
  StatefulPolicyPreservedState preservedState;

  StatefulPolicy();

  StatefulPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('preservedState')) {
      preservedState = StatefulPolicyPreservedState.fromJson(
          _json['preservedState'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (preservedState != null) {
      _json['preservedState'] = preservedState.toJson();
    }
    return _json;
  }
}

/// Configuration of preserved resources.
class StatefulPolicyPreservedState {
  /// Disks created on the instances that will be preserved on instance delete,
  /// update, etc. This map is keyed with the device names of the disks.
  core.Map<core.String, StatefulPolicyPreservedStateDiskDevice> disks;

  StatefulPolicyPreservedState();

  StatefulPolicyPreservedState.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              StatefulPolicyPreservedStateDiskDevice.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (disks != null) {
      _json['disks'] =
          disks.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    return _json;
  }
}

class StatefulPolicyPreservedStateDiskDevice {
  /// These stateful disks will never be deleted during autohealing, update or
  /// VM instance recreate operations. This flag is used to configure if the
  /// disk should be deleted after it is no longer used by the group, e.g. when
  /// the given instance or the whole group is deleted. Note: disks attached in
  /// READ_ONLY mode cannot be auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String autoDelete;

  StatefulPolicyPreservedStateDiskDevice();

  StatefulPolicyPreservedStateDiskDevice.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (autoDelete != null) {
      _json['autoDelete'] = autoDelete;
    }
    return _json;
  }
}

/// Represents a Subnetwork resource.
///
/// A subnetwork (also known as a subnet) is a logical partition of a Virtual
/// Private Cloud network with one primary IP range and zero or more secondary
/// IP ranges. For more information, read  Virtual Private Cloud (VPC) Network.
/// (== resource_for {$api_version}.subnetworks ==)
class Subnetwork {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource. This field can be set only at resource creation time.
  core.String description;

  /// Whether to enable flow logging for this subnetwork. If this field is not
  /// explicitly set, it will not appear in get listings. If not set the default
  /// behavior is to disable flow logging. This field isn't supported with the
  /// purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
  core.bool enableFlowLogs;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a Subnetwork. An up-to-date fingerprint must be
  /// provided in order to update the Subnetwork, otherwise the request will
  /// fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// Subnetwork.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The gateway address for default routes to reach destination
  /// addresses outside this subnetwork.
  core.String gatewayAddress;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// The range of internal addresses that are owned by this subnetwork. Provide
  /// this property when you create the subnetwork. For example, 10.0.0.0/8 or
  /// 100.64.0.0/10. Ranges must be unique and non-overlapping within a network.
  /// Only IPv4 is supported. This field is set at resource creation time. This
  /// may be a RFC 1918 IP range, or a privately routed, non-RFC 1918 IP range,
  /// not belonging to Google. The range can be expanded after creation using
  /// expandIpCidrRange.
  core.String ipCidrRange;

  /// [Output Only] The range of internal IPv6 addresses that are owned by this
  /// subnetwork.
  core.String ipv6CidrRange;

  /// [Output Only] Type of the resource. Always compute#subnetwork for
  /// Subnetwork resources.
  core.String kind;

  /// This field denotes the VPC flow logging options for this subnetwork. If
  /// logging is enabled, logs are exported to Cloud Logging.
  SubnetworkLogConfig logConfig;

  /// The name of the resource, provided by the client when initially creating
  /// the resource. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String name;

  /// The URL of the network to which this subnetwork belongs, provided by the
  /// client when initially creating the subnetwork. Only networks that are in
  /// the distributed mode can have subnetworks. This field can be set only at
  /// resource creation time.
  core.String network;

  /// Whether the VMs in this subnet can access Google services without assigned
  /// external IP addresses. This field can be both set at resource creation
  /// time and updated using setPrivateIpGoogleAccess.
  core.bool privateIpGoogleAccess;

  /// The private IPv6 google access type for the VMs in this subnet. This is an
  /// expanded field of enablePrivateV6Access. If both fields are set,
  /// privateIpv6GoogleAccess will take priority.
  ///
  /// This field can be both set at resource creation time and updated using
  /// patch.
  /// Possible string values are:
  /// - "DISABLE_GOOGLE_ACCESS"
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  core.String privateIpv6GoogleAccess;

  /// The purpose of the resource. This field can be either PRIVATE_RFC_1918 or
  /// INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to
  /// INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is reserved
  /// for Internal HTTP(S) Load Balancing. If unspecified, the purpose defaults
  /// to PRIVATE_RFC_1918. The enableFlowLogs field isn't supported with the
  /// purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
  /// Possible string values are:
  /// - "INTERNAL_HTTPS_LOAD_BALANCER"
  /// - "PRIVATE"
  /// - "PRIVATE_RFC_1918"
  core.String purpose;

  /// URL of the region where the Subnetwork resides. This field can be set only
  /// at resource creation time.
  core.String region;

  /// The role of subnetwork. Currently, this field is only used when purpose =
  /// INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
  /// ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
  /// Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
  /// ACTIVE or is currently draining. This field can be updated with a patch
  /// request.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "BACKUP"
  core.String role;

  /// An array of configurations for secondary IP ranges for VM instances
  /// contained in this subnetwork. The primary IP of such VM must belong to the
  /// primary ipCidrRange of the subnetwork. The alias IPs may belong to either
  /// primary or secondary ranges. This field can be updated with a patch
  /// request.
  core.List<SubnetworkSecondaryRange> secondaryIpRanges;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The state of the subnetwork, which can be one of READY or
  /// DRAINING. A subnetwork that is READY is ready to be used. The state of
  /// DRAINING is only applicable to subnetworks that have the purpose set to
  /// INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load
  /// balancer are being drained. A subnetwork that is draining cannot be used
  /// or modified until it reaches a status of READY.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "READY"
  core.String state;

  Subnetwork();

  Subnetwork.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableFlowLogs')) {
      enableFlowLogs = _json['enableFlowLogs'] as core.bool;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('gatewayAddress')) {
      gatewayAddress = _json['gatewayAddress'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('ipv6CidrRange')) {
      ipv6CidrRange = _json['ipv6CidrRange'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = SubnetworkLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('privateIpGoogleAccess')) {
      privateIpGoogleAccess = _json['privateIpGoogleAccess'] as core.bool;
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('purpose')) {
      purpose = _json['purpose'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('role')) {
      role = _json['role'] as core.String;
    }
    if (_json.containsKey('secondaryIpRanges')) {
      secondaryIpRanges = (_json['secondaryIpRanges'] as core.List)
          .map<SubnetworkSecondaryRange>((value) =>
              SubnetworkSecondaryRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (enableFlowLogs != null) {
      _json['enableFlowLogs'] = enableFlowLogs;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (gatewayAddress != null) {
      _json['gatewayAddress'] = gatewayAddress;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    if (ipv6CidrRange != null) {
      _json['ipv6CidrRange'] = ipv6CidrRange;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (logConfig != null) {
      _json['logConfig'] = logConfig.toJson();
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (privateIpGoogleAccess != null) {
      _json['privateIpGoogleAccess'] = privateIpGoogleAccess;
    }
    if (privateIpv6GoogleAccess != null) {
      _json['privateIpv6GoogleAccess'] = privateIpv6GoogleAccess;
    }
    if (purpose != null) {
      _json['purpose'] = purpose;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (role != null) {
      _json['role'] = role;
    }
    if (secondaryIpRanges != null) {
      _json['secondaryIpRanges'] =
          secondaryIpRanges.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (state != null) {
      _json['state'] = state;
    }
    return _json;
  }
}

class SubnetworkAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkAggregatedListWarningData();

  SubnetworkAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkAggregatedListWarning();

  SubnetworkAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworkAggregatedListWarningData>((value) =>
              SubnetworkAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SubnetworkAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of SubnetworksScopedList resources.
  core.Map<core.String, SubnetworksScopedList> items;

  /// [Output Only] Type of resource. Always compute#subnetworkAggregatedList
  /// for aggregated lists of subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  SubnetworkAggregatedListWarning warning;

  SubnetworkAggregatedList();

  SubnetworkAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              SubnetworksScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworkAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SubnetworkListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworkListWarningData();

  SubnetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class SubnetworkListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworkListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworkListWarning();

  SubnetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworkListWarningData>((value) =>
              SubnetworkListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of Subnetwork resources.
class SubnetworkList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Subnetwork resources.
  core.List<Subnetwork> items;

  /// [Output Only] Type of resource. Always compute#subnetworkList for lists of
  /// subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  SubnetworkListWarning warning;

  SubnetworkList();

  SubnetworkList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Subnetwork>((value) =>
              Subnetwork.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworkListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// The available logging options for this subnetwork.
class SubnetworkLogConfig {
  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  /// Toggles the aggregation interval for collecting flow logs. Increasing the
  /// interval time will reduce the amount of generated flow logs for long
  /// lasting connections. Default is an interval of 5 seconds per connection.
  /// Possible string values are:
  /// - "INTERVAL_10_MIN"
  /// - "INTERVAL_15_MIN"
  /// - "INTERVAL_1_MIN"
  /// - "INTERVAL_30_SEC"
  /// - "INTERVAL_5_MIN"
  /// - "INTERVAL_5_SEC"
  core.String aggregationInterval;

  /// Whether to enable flow logging for this subnetwork. If this field is not
  /// explicitly set, it will not appear in get listings. If not set the default
  /// behavior is to disable flow logging.
  core.bool enable;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  /// Export filter used to define which VPC flow logs should be logged.
  core.String filterExpr;

  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  /// The value of the field must be in [0, 1]. Set the sampling rate of VPC
  /// flow logs within the subnetwork where 1.0 means all collected logs are
  /// reported and 0.0 means no logs are reported. Default is 0.5, which means
  /// half of all collected logs are reported.
  core.double flowSampling;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  /// Configures whether all, none or a subset of metadata fields should be
  /// added to the reported VPC flow logs. Default is INCLUDE_ALL_METADATA.
  /// Possible string values are:
  /// - "CUSTOM_METADATA"
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String metadata;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled and
  /// "metadata" was set to CUSTOM_METADATA.
  core.List<core.String> metadataFields;

  SubnetworkLogConfig();

  SubnetworkLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('aggregationInterval')) {
      aggregationInterval = _json['aggregationInterval'] as core.String;
    }
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('filterExpr')) {
      filterExpr = _json['filterExpr'] as core.String;
    }
    if (_json.containsKey('flowSampling')) {
      flowSampling = (_json['flowSampling'] as core.num).toDouble();
    }
    if (_json.containsKey('metadata')) {
      metadata = _json['metadata'] as core.String;
    }
    if (_json.containsKey('metadataFields')) {
      metadataFields = (_json['metadataFields'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (aggregationInterval != null) {
      _json['aggregationInterval'] = aggregationInterval;
    }
    if (enable != null) {
      _json['enable'] = enable;
    }
    if (filterExpr != null) {
      _json['filterExpr'] = filterExpr;
    }
    if (flowSampling != null) {
      _json['flowSampling'] = flowSampling;
    }
    if (metadata != null) {
      _json['metadata'] = metadata;
    }
    if (metadataFields != null) {
      _json['metadataFields'] = metadataFields;
    }
    return _json;
  }
}

/// Represents a secondary IP range of a subnetwork.
class SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported. This may be a RFC 1918 IP range, or a
  /// privately, non-RFC 1918 IP range, not belonging to Google.
  core.String ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance. The name must be 1-63 characters long,
  /// and comply with RFC1035. The name must be unique within the subnetwork.
  core.String rangeName;

  SubnetworkSecondaryRange();

  SubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('rangeName')) {
      rangeName = _json['rangeName'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    if (rangeName != null) {
      _json['rangeName'] = rangeName;
    }
    return _json;
  }
}

class SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork. This range should be disjoint from other subnetworks
  /// within this network. This range can only be larger than (i.e. a superset
  /// of) the range previously defined before the update.
  core.String ipCidrRange;

  SubnetworksExpandIpCidrRangeRequest();

  SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    return _json;
  }
}

class SubnetworksScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  SubnetworksScopedListWarningData();

  SubnetworksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// An informational warning that appears when the list of addresses is empty.
class SubnetworksScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<SubnetworksScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  SubnetworksScopedListWarning();

  SubnetworksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworksScopedListWarningData>((value) =>
              SubnetworksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class SubnetworksScopedList {
  /// A list of subnetworks contained in this scope.
  core.List<Subnetwork> subnetworks;

  /// An informational warning that appears when the list of addresses is empty.
  SubnetworksScopedListWarning warning;

  SubnetworksScopedList();

  SubnetworksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<Subnetwork>((value) =>
              Subnetwork.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (subnetworks != null) {
      _json['subnetworks'] =
          subnetworks.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool privateIpGoogleAccess;

  SubnetworksSetPrivateIpGoogleAccessRequest();

  SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map _json) {
    if (_json.containsKey('privateIpGoogleAccess')) {
      privateIpGoogleAccess = _json['privateIpGoogleAccess'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (privateIpGoogleAccess != null) {
      _json['privateIpGoogleAccess'] = privateIpGoogleAccess;
    }
    return _json;
  }
}

class TCPHealthCheck {
  /// The TCP port number for the health check request. The default value is 80.
  /// Valid values are 1 through 65535.
  core.int port;

  /// Port name as defined in InstanceGroup#NamedPort#name. If both port and
  /// port_name are defined, port takes precedence.
  core.String portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking. For other backends, the port
  /// or named port specified in the Backend Service is used for health
  /// checking.
  ///
  ///
  /// If not specified, TCP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// The application data to send once the TCP connection has been established
  /// (default value is empty). If both request and response are empty, the
  /// connection establishment alone will indicate health. The request data can
  /// only be ASCII.
  core.String request;

  /// The bytes to match against the beginning of the response data. If left
  /// empty (the default value), any response will indicate health. The response
  /// data can only be ASCII.
  core.String response;

  TCPHealthCheck();

  TCPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('request')) {
      request = _json['request'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (port != null) {
      _json['port'] = port;
    }
    if (portName != null) {
      _json['portName'] = portName;
    }
    if (portSpecification != null) {
      _json['portSpecification'] = portSpecification;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (request != null) {
      _json['request'] = request;
    }
    if (response != null) {
      _json['response'] = response;
    }
    return _json;
  }
}

/// A set of instance tags.
class Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the tags' contents and used for optimistic locking. The fingerprint is
  /// initially generated by Compute Engine and changes after every request to
  /// modify or update tags. You must always provide an up-to-date fingerprint
  /// hash in order to update or change tags.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// An array of tags. Each tag must be 1-63 characters long, and comply with
  /// RFC1035.
  core.List<core.String> items;

  Tags();

  Tags.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (items != null) {
      _json['items'] = items;
    }
    return _json;
  }
}

/// Represents a Target gRPC Proxy resource.
///
/// A target gRPC proxy is a component of load balancers intended for load
/// balancing gRPC traffic. Global forwarding rules reference a target gRPC
/// proxy. The Target gRPC Proxy references a URL map which specifies how
/// traffic routes to gRPC backend services. (== resource_for
/// {$api_version}.targetGrpcProxies ==)
class TargetGrpcProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a TargetGrpcProxy. An up-to-date fingerprint must
  /// be provided in order to patch/update the TargetGrpcProxy; otherwise, the
  /// request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve the TargetGrpcProxy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource type. The server
  /// generates this identifier.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetGrpcProxy for
  /// target grpc proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Server-defined URL with id for the resource.
  core.String selfLinkWithId;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService. The protocol field in the BackendService must be set to
  /// GRPC.
  core.String urlMap;

  /// If true, indicates that the BackendServices referenced by the urlMap may
  /// be accessed by gRPC applications without using a sidecar proxy. This will
  /// enable configuration checks on urlMap and its referenced BackendServices
  /// to not allow unsupported features. A gRPC application must use "xds:///"
  /// scheme in the target URI of the service it is connecting to. If false,
  /// indicates that the BackendServices referenced by the urlMap will be
  /// accessed by gRPC applications via a sidecar proxy. In this case, a gRPC
  /// application must not use "xds:///" scheme in the target URI of the service
  /// it is connecting to
  core.bool validateForProxyless;

  TargetGrpcProxy();

  TargetGrpcProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('selfLinkWithId')) {
      selfLinkWithId = _json['selfLinkWithId'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
    if (_json.containsKey('validateForProxyless')) {
      validateForProxyless = _json['validateForProxyless'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (selfLinkWithId != null) {
      _json['selfLinkWithId'] = selfLinkWithId;
    }
    if (urlMap != null) {
      _json['urlMap'] = urlMap;
    }
    if (validateForProxyless != null) {
      _json['validateForProxyless'] = validateForProxyless;
    }
    return _json;
  }
}

class TargetGrpcProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetGrpcProxyListWarningData();

  TargetGrpcProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetGrpcProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetGrpcProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetGrpcProxyListWarning();

  TargetGrpcProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetGrpcProxyListWarningData>((value) =>
              TargetGrpcProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetGrpcProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetGrpcProxy resources.
  core.List<TargetGrpcProxy> items;

  /// [Output Only] Type of the resource. Always compute#targetGrpcProxy for
  /// target grpc proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetGrpcProxyListWarning warning;

  TargetGrpcProxyList();

  TargetGrpcProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetGrpcProxy>((value) => TargetGrpcProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetGrpcProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetHttpProxiesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpProxiesScopedListWarningData();

  TargetHttpProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpProxiesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpProxiesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpProxiesScopedListWarning();

  TargetHttpProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpProxiesScopedListWarningData>((value) =>
              TargetHttpProxiesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetHttpProxiesScopedList {
  /// A list of TargetHttpProxies contained in this scope.
  core.List<TargetHttpProxy> targetHttpProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpProxiesScopedListWarning warning;

  TargetHttpProxiesScopedList();

  TargetHttpProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetHttpProxies')) {
      targetHttpProxies = (_json['targetHttpProxies'] as core.List)
          .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpProxiesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (targetHttpProxies != null) {
      _json['targetHttpProxies'] =
          targetHttpProxies.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Target HTTP Proxy resource.
///
/// Google Compute Engine has two Target HTTP Proxy resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/targetHttpProxies) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionTargetHttpProxies)
///
/// A target HTTP proxy is a component of GCP HTTP load balancers.
///
/// * targetHttpProxies are used by external HTTP load balancers and Traffic
/// Director. * regionTargetHttpProxies are used by internal HTTP load
/// balancers.
///
/// Forwarding rules reference a target HTTP proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpProxies ==)
class TargetHttpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a TargetHttpProxy. An up-to-date fingerprint must
  /// be provided in order to patch/update the TargetHttpProxy; otherwise, the
  /// request will fail with error 412 conditionNotMet. To see the latest
  /// fingerprint, make a get() request to retrieve the TargetHttpProxy.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpProxy for target
  /// HTTP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the regional Target HTTP Proxy
  /// resides. This field is not applicable to global Target HTTP Proxies.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  core.String urlMap;

  TargetHttpProxy();

  TargetHttpProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (urlMap != null) {
      _json['urlMap'] = urlMap;
    }
    return _json;
  }
}

class TargetHttpProxyAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpProxiesScopedList resources.
  core.Map<core.String, TargetHttpProxiesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#targetHttpProxyAggregatedList for lists of Target HTTP Proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  TargetHttpProxyAggregatedList();

  TargetHttpProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              TargetHttpProxiesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    return _json;
  }
}

class TargetHttpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpProxyListWarningData();

  TargetHttpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpProxyListWarning();

  TargetHttpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpProxyListWarningData>((value) =>
              TargetHttpProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// A list of TargetHttpProxy resources.
class TargetHttpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpProxy resources.
  core.List<TargetHttpProxy> items;

  /// Type of resource. Always compute#targetHttpProxyList for lists of target
  /// HTTP proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpProxyListWarning warning;

  TargetHttpProxyList();

  TargetHttpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetHttpsProxiesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxiesScopedListWarningData();

  TargetHttpsProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpsProxiesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxiesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxiesScopedListWarning();

  TargetHttpsProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxiesScopedListWarningData>((value) =>
              TargetHttpsProxiesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetHttpsProxiesScopedList {
  /// A list of TargetHttpsProxies contained in this scope.
  core.List<TargetHttpsProxy> targetHttpsProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpsProxiesScopedListWarning warning;

  TargetHttpsProxiesScopedList();

  TargetHttpsProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetHttpsProxies')) {
      targetHttpsProxies = (_json['targetHttpsProxies'] as core.List)
          .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxiesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (targetHttpsProxies != null) {
      _json['targetHttpsProxies'] =
          targetHttpsProxies.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetHttpsProxiesSetQuicOverrideRequest {
  /// QUIC policy for the TargetHttpsProxy resource.
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String quicOverride;

  TargetHttpsProxiesSetQuicOverrideRequest();

  TargetHttpsProxiesSetQuicOverrideRequest.fromJson(core.Map _json) {
    if (_json.containsKey('quicOverride')) {
      quicOverride = _json['quicOverride'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (quicOverride != null) {
      _json['quicOverride'] = quicOverride;
    }
    return _json;
  }
}

class TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource. Currently exactly one SslCertificate resource
  /// must be specified.
  core.List<core.String> sslCertificates;

  TargetHttpsProxiesSetSslCertificatesRequest();

  TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sslCertificates != null) {
      _json['sslCertificates'] = sslCertificates;
    }
    return _json;
  }
}

/// Represents a Target HTTPS Proxy resource.
///
/// Google Compute Engine has two Target HTTPS Proxy resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/targetHttpsProxies) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionTargetHttpsProxies)
///
/// A target HTTPS proxy is a component of GCP HTTPS load balancers.
///
/// * targetHttpsProxies are used by external HTTPS load balancers. *
/// regionTargetHttpsProxies are used by internal HTTPS load balancers.
///
/// Forwarding rules reference a target HTTPS proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpsProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpsProxies ==)
class TargetHttpsProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetHttpsProxy for target
  /// HTTPS proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the QUIC override policy for this TargetHttpsProxy resource.
  /// This setting determines whether the load balancer attempts to negotiate
  /// QUIC with clients. You can specify NONE, ENABLE, or DISABLE.
  /// - When quic-override is set to NONE, Google manages whether QUIC is used.
  /// - When quic-override is set to ENABLE, the load balancer uses QUIC when
  /// possible.
  /// - When quic-override is set to DISABLE, the load balancer doesn't use
  /// QUIC.
  /// - If the quic-override flag is not specified, NONE is implied.
  /// -
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String quicOverride;

  /// [Output Only] URL of the region where the regional TargetHttpsProxy
  /// resides. This field is not applicable to global TargetHttpsProxies.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// between users and the load balancer. At least one SSL certificate must be
  /// specified. Currently, you may specify up to 15 SSL certificates.
  core.List<core.String> sslCertificates;

  /// URL of SslPolicy resource that will be associated with the
  /// TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource has
  /// no SSL policy configured.
  core.String sslPolicy;

  /// A fully-qualified or valid partial URL to the UrlMap resource that defines
  /// the mapping from URL to the BackendService. For example, the following are
  /// all valid URLs for specifying a URL map:
  /// -
  /// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
  /// - projects/project/global/urlMaps/url-map
  /// - global/urlMaps/url-map
  core.String urlMap;

  TargetHttpsProxy();

  TargetHttpsProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('quicOverride')) {
      quicOverride = _json['quicOverride'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (quicOverride != null) {
      _json['quicOverride'] = quicOverride;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sslCertificates != null) {
      _json['sslCertificates'] = sslCertificates;
    }
    if (sslPolicy != null) {
      _json['sslPolicy'] = sslPolicy;
    }
    if (urlMap != null) {
      _json['urlMap'] = urlMap;
    }
    return _json;
  }
}

class TargetHttpsProxyAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxyAggregatedListWarningData();

  TargetHttpsProxyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpsProxyAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxyAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxyAggregatedListWarning();

  TargetHttpsProxyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxyAggregatedListWarningData>((value) =>
              TargetHttpsProxyAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetHttpsProxyAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpsProxiesScopedList resources.
  core.Map<core.String, TargetHttpsProxiesScopedList> items;

  /// [Output Only] Type of resource. Always
  /// compute#targetHttpsProxyAggregatedList for lists of Target HTTP Proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  TargetHttpsProxyAggregatedListWarning warning;

  TargetHttpsProxyAggregatedList();

  TargetHttpsProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              TargetHttpsProxiesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxyAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetHttpsProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetHttpsProxyListWarningData();

  TargetHttpsProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetHttpsProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetHttpsProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetHttpsProxyListWarning();

  TargetHttpsProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxyListWarningData>((value) =>
              TargetHttpsProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetHttpsProxy resources.
class TargetHttpsProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetHttpsProxy resources.
  core.List<TargetHttpsProxy> items;

  /// Type of resource. Always compute#targetHttpsProxyList for lists of target
  /// HTTPS proxies.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetHttpsProxyListWarning warning;

  TargetHttpsProxyList();

  TargetHttpsProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Target Instance resource.
///
/// You can use a target instance to handle traffic for one or more forwarding
/// rules, which is ideal for forwarding protocol traffic that is managed by a
/// single source. For example, ESP, AH, TCP, or UDP. For more information, read
/// Target instances. (== resource_for {$api_version}.targetInstances ==)
class TargetInstance {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance. When creating a target instance, you can provide the
  /// fully-qualified URL or a valid partial URL to the desired virtual machine.
  /// For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String instance;

  /// [Output Only] The type of the resource. Always compute#targetInstance for
  /// target instances.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// NAT option controlling how IPs are NAT'ed to the instance. Currently only
  /// NO_NAT (default value) is supported.
  /// Possible string values are:
  /// - "NO_NAT"
  core.String natPolicy;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] URL of the zone where the target instance resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String zone;

  TargetInstance();

  TargetInstance.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natPolicy')) {
      natPolicy = _json['natPolicy'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (instance != null) {
      _json['instance'] = instance;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (natPolicy != null) {
      _json['natPolicy'] = natPolicy;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (zone != null) {
      _json['zone'] = zone;
    }
    return _json;
  }
}

class TargetInstanceAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceAggregatedListWarningData();

  TargetInstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceAggregatedListWarning();

  TargetInstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstanceAggregatedListWarningData>((value) =>
              TargetInstanceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetInstanceAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.Map<core.String, TargetInstancesScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  TargetInstanceAggregatedListWarning warning;

  TargetInstanceAggregatedList();

  TargetInstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              TargetInstancesScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstanceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetInstanceListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstanceListWarningData();

  TargetInstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetInstanceListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstanceListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstanceListWarning();

  TargetInstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstanceListWarningData>((value) =>
              TargetInstanceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetInstance resources.
class TargetInstanceList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetInstance resources.
  core.List<TargetInstance> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetInstanceListWarning warning;

  TargetInstanceList();

  TargetInstanceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetInstance>((value) => TargetInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstanceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetInstancesScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetInstancesScopedListWarningData();

  TargetInstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetInstancesScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetInstancesScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetInstancesScopedListWarning();

  TargetInstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstancesScopedListWarningData>((value) =>
              TargetInstancesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetInstancesScopedList {
  /// A list of target instances contained in this scope.
  core.List<TargetInstance> targetInstances;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetInstancesScopedListWarning warning;

  TargetInstancesScopedList();

  TargetInstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetInstances')) {
      targetInstances = (_json['targetInstances'] as core.List)
          .map<TargetInstance>((value) => TargetInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstancesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (targetInstances != null) {
      _json['targetInstances'] =
          targetInstances.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Target Pool resource.
///
/// Target pools are used for network TCP/UDP load balancing. A target pool
/// references member instances, an associated legacy HttpHealthCheck resource,
/// and, optionally, a backup target pool. For more information, read Using
/// target pools. (== resource_for {$api_version}.targetPools ==)
class TargetPool {
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between [0, 1].
  ///
  /// backupPool and failoverRatio together define the fallback behavior of the
  /// primary target pool: if the ratio of the healthy instances in the primary
  /// pool is at or below failoverRatio, traffic arriving at the load-balanced
  /// IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio and backupPool are not set, or all the
  /// instances in the backup pool are unhealthy, the traffic will be directed
  /// back to the primary pool in the "force" mode, where traffic will be spread
  /// to the healthy instances with the best effort, or to all instances when no
  /// instance is healthy.
  core.String backupPool;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool). The value of the field must be in [0, 1].
  ///
  /// If set, backupPool must also be set. They together define the fallback
  /// behavior of the primary target pool: if the ratio of the healthy instances
  /// in the primary pool is at or below this number, traffic arriving at the
  /// load-balanced IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio is not set or all the instances in the backup
  /// pool are unhealthy, the traffic will be directed back to the primary pool
  /// in the "force" mode, where traffic will be spread to the healthy instances
  /// with the best effort, or to all instances when no instance is healthy.
  core.double failoverRatio;

  /// The URL of the HttpHealthCheck resource. A member instance in this pool is
  /// considered healthy if and only if the health checks pass. An empty list
  /// means all member instances will be considered healthy at all times. Only
  /// legacy HttpHealthChecks are supported. Only one health check may be
  /// specified.
  core.List<core.String> healthChecks;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool. They must live in zones contained in the same region as this pool.
  core.List<core.String> instances;

  /// [Output Only] Type of the resource. Always compute#targetPool for target
  /// pools.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// [Output Only] URL of the region where the target pool resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Session affinity option, must be one of the following values:
  /// NONE: Connections from the same client IP may go to any instance in the
  /// pool.
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy.
  /// CLIENT_IP_PROTO: Connections from the same client IP with the same IP
  /// protocol will go to the same instance in the pool while that instance
  /// remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String sessionAffinity;

  TargetPool();

  TargetPool.fromJson(core.Map _json) {
    if (_json.containsKey('backupPool')) {
      backupPool = _json['backupPool'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('failoverRatio')) {
      failoverRatio = (_json['failoverRatio'] as core.num).toDouble();
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sessionAffinity')) {
      sessionAffinity = _json['sessionAffinity'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backupPool != null) {
      _json['backupPool'] = backupPool;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (failoverRatio != null) {
      _json['failoverRatio'] = failoverRatio;
    }
    if (healthChecks != null) {
      _json['healthChecks'] = healthChecks;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (instances != null) {
      _json['instances'] = instances;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sessionAffinity != null) {
      _json['sessionAffinity'] = sessionAffinity;
    }
    return _json;
  }
}

class TargetPoolAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolAggregatedListWarningData();

  TargetPoolAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolAggregatedListWarning();

  TargetPoolAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolAggregatedListWarningData>((value) =>
              TargetPoolAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetPoolAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.Map<core.String, TargetPoolsScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetPoolAggregatedList
  /// for aggregated lists of target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  TargetPoolAggregatedListWarning warning;

  TargetPoolAggregatedList();

  TargetPoolAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              TargetPoolsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetPoolInstanceHealth {
  core.List<HealthStatus> healthStatus;

  /// [Output Only] Type of resource. Always compute#targetPoolInstanceHealth
  /// when checking the health of an instance.
  core.String kind;

  TargetPoolInstanceHealth();

  TargetPoolInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey('healthStatus')) {
      healthStatus = (_json['healthStatus'] as core.List)
          .map<HealthStatus>((value) => HealthStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthStatus != null) {
      _json['healthStatus'] =
          healthStatus.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    return _json;
  }
}

class TargetPoolListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolListWarningData();

  TargetPoolListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetPoolListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolListWarning();

  TargetPoolListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolListWarningData>((value) =>
              TargetPoolListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetPool resources.
class TargetPoolList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetPool resources.
  core.List<TargetPool> items;

  /// [Output Only] Type of resource. Always compute#targetPoolList for lists of
  /// target pools.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetPoolListWarning warning;

  TargetPoolList();

  TargetPoolList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetPool>((value) =>
              TargetPool.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetPoolsAddHealthCheckRequest {
  /// The HttpHealthCheck to add to the target pool.
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsAddHealthCheckRequest();

  TargetPoolsAddHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheckReference>((value) => HealthCheckReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthChecks != null) {
      _json['healthChecks'] =
          healthChecks.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsAddInstanceRequest {
  /// A full or partial URL to an instance to add to this target pool. This can
  /// be a full or partial URL. For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project-id/zones/zone/instances/instance-name
  /// - projects/project-id/zones/zone/instances/instance-name
  /// - zones/zone/instances/instance-name
  core.List<InstanceReference> instances;

  TargetPoolsAddInstanceRequest();

  TargetPoolsAddInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveHealthCheckRequest {
  /// Health check URL to be removed. This can be a full or valid partial URL.
  /// For example, the following are valid URLs:
  /// -
  /// https://www.googleapis.com/compute/beta/projects/project/global/httpHealthChecks/health-check
  /// - projects/project/global/httpHealthChecks/health-check
  /// - global/httpHealthChecks/health-check
  core.List<HealthCheckReference> healthChecks;

  TargetPoolsRemoveHealthCheckRequest();

  TargetPoolsRemoveHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheckReference>((value) => HealthCheckReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (healthChecks != null) {
      _json['healthChecks'] =
          healthChecks.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsRemoveInstanceRequest {
  /// URLs of the instances to be removed from target pool.
  core.List<InstanceReference> instances;

  TargetPoolsRemoveInstanceRequest();

  TargetPoolsRemoveInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instances != null) {
      _json['instances'] = instances.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class TargetPoolsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetPoolsScopedListWarningData();

  TargetPoolsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetPoolsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetPoolsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetPoolsScopedListWarning();

  TargetPoolsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolsScopedListWarningData>((value) =>
              TargetPoolsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetPoolsScopedList {
  /// A list of target pools contained in this scope.
  core.List<TargetPool> targetPools;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetPoolsScopedListWarning warning;

  TargetPoolsScopedList();

  TargetPoolsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<TargetPool>((value) =>
              TargetPool.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (targetPools != null) {
      _json['targetPools'] =
          targetPools.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetReference {
  core.String target;

  TargetReference();

  TargetReference.fromJson(core.Map _json) {
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (target != null) {
      _json['target'] = target;
    }
    return _json;
  }
}

class TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String service;

  TargetSslProxiesSetBackendServiceRequest();

  TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (service != null) {
      _json['service'] = service;
    }
    return _json;
  }
}

class TargetSslProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetSslProxiesSetProxyHeaderRequest();

  TargetSslProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    return _json;
  }
}

class TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy. Currently exactly one ssl certificate must be specified.
  core.List<core.String> sslCertificates;

  TargetSslProxiesSetSslCertificatesRequest();

  TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (sslCertificates != null) {
      _json['sslCertificates'] = sslCertificates;
    }
    return _json;
  }
}

/// Represents a Target SSL Proxy resource.
///
/// A target SSL proxy is a component of a SSL Proxy load balancer. Global
/// forwarding rules reference a target SSL proxy, and the target proxy then
/// references an external backend service. For more information, read Using
/// Target Proxies. (== resource_for {$api_version}.targetSslProxies ==)
class TargetSslProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetSslProxy for
  /// target SSL proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends. At least one SSL certificate must be specified. Currently,
  /// you may specify up to 15 SSL certificates.
  core.List<core.String> sslCertificates;

  /// URL of SslPolicy resource that will be associated with the TargetSslProxy
  /// resource. If not set, the TargetSslProxy resource will not have any SSL
  /// policy configured.
  core.String sslPolicy;

  TargetSslProxy();

  TargetSslProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (service != null) {
      _json['service'] = service;
    }
    if (sslCertificates != null) {
      _json['sslCertificates'] = sslCertificates;
    }
    if (sslPolicy != null) {
      _json['sslPolicy'] = sslPolicy;
    }
    return _json;
  }
}

class TargetSslProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetSslProxyListWarningData();

  TargetSslProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetSslProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetSslProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetSslProxyListWarning();

  TargetSslProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetSslProxyListWarningData>((value) =>
              TargetSslProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetSslProxy resources.
class TargetSslProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetSslProxy resources.
  core.List<TargetSslProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetSslProxyListWarning warning;

  TargetSslProxyList();

  TargetSslProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetSslProxy>((value) => TargetSslProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetSslProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String service;

  TargetTcpProxiesSetBackendServiceRequest();

  TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (service != null) {
      _json['service'] = service;
    }
    return _json;
  }
}

class TargetTcpProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  TargetTcpProxiesSetProxyHeaderRequest();

  TargetTcpProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    return _json;
  }
}

/// Represents a Target TCP Proxy resource.
///
/// A target TCP proxy is a component of a TCP Proxy load balancer. Global
/// forwarding rules reference target TCP proxy, and the target proxy then
/// references an external backend service. For more information, read TCP Proxy
/// Load Balancing overview. (== resource_for {$api_version}.targetTcpProxies
/// ==)
class TargetTcpProxy {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#targetTcpProxy for
  /// target TCP proxies.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1. The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String proxyHeader;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// URL to the BackendService resource.
  core.String service;

  TargetTcpProxy();

  TargetTcpProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (proxyHeader != null) {
      _json['proxyHeader'] = proxyHeader;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (service != null) {
      _json['service'] = service;
    }
    return _json;
  }
}

class TargetTcpProxyListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetTcpProxyListWarningData();

  TargetTcpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetTcpProxyListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetTcpProxyListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetTcpProxyListWarning();

  TargetTcpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetTcpProxyListWarningData>((value) =>
              TargetTcpProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetTcpProxy resources.
class TargetTcpProxyList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetTcpProxy resources.
  core.List<TargetTcpProxy> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetTcpProxyListWarning warning;

  TargetTcpProxyList();

  TargetTcpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetTcpProxy>((value) => TargetTcpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetTcpProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Target VPN Gateway resource.
///
/// The target VPN gateway resource represents a Classic Cloud VPN gateway. For
/// more information, read the the Cloud VPN Overview. (== resource_for
/// {$api_version}.targetVpnGateways ==)
class TargetVpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] A list of URLs to the ForwardingRule resources.
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated with a VPN gateway.
  core.List<core.String> forwardingRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network to which this VPN gateway is attached. Provided by the
  /// client when the VPN gateway is created.
  core.String network;

  /// [Output Only] URL of the region where the target VPN gateway resides. You
  /// must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] The status of the VPN gateway, which can be one of the
  /// following: CREATING, READY, FAILED, or DELETING.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String status;

  /// [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are
  /// created using the compute.vpntunnels.insert method and associated with a
  /// VPN gateway.
  core.List<core.String> tunnels;

  TargetVpnGateway();

  TargetVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('forwardingRules')) {
      forwardingRules = (_json['forwardingRules'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('tunnels')) {
      tunnels = (_json['tunnels'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (forwardingRules != null) {
      _json['forwardingRules'] = forwardingRules;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (tunnels != null) {
      _json['tunnels'] = tunnels;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayAggregatedListWarningData();

  TargetVpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayAggregatedListWarning();

  TargetVpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewayAggregatedListWarningData>((value) =>
              TargetVpnGatewayAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetVpnGatewayAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.Map<core.String, TargetVpnGatewaysScopedList> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayAggregatedListWarning warning;

  TargetVpnGatewayAggregatedList();

  TargetVpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              TargetVpnGatewaysScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewayAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetVpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewayListWarningData();

  TargetVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class TargetVpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewayListWarning();

  TargetVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewayListWarningData>((value) =>
              TargetVpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of TargetVpnGateway resources.
class TargetVpnGatewayList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of TargetVpnGateway resources.
  core.List<TargetVpnGateway> items;

  /// [Output Only] Type of resource. Always compute#targetVpnGateway for target
  /// VPN gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  TargetVpnGatewayListWarning warning;

  TargetVpnGatewayList();

  TargetVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  TargetVpnGatewaysScopedListWarningData();

  TargetVpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class TargetVpnGatewaysScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<TargetVpnGatewaysScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  TargetVpnGatewaysScopedListWarning();

  TargetVpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewaysScopedListWarningData>((value) =>
              TargetVpnGatewaysScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class TargetVpnGatewaysScopedList {
  /// [Output Only] A list of target VPN gateways contained in this scope.
  core.List<TargetVpnGateway> targetVpnGateways;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  TargetVpnGatewaysScopedListWarning warning;

  TargetVpnGatewaysScopedList();

  TargetVpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetVpnGateways')) {
      targetVpnGateways = (_json['targetVpnGateways'] as core.List)
          .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewaysScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (targetVpnGateways != null) {
      _json['targetVpnGateways'] =
          targetVpnGateways.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class TestFailure {
  /// BackendService or BackendBucket returned by load balancer.
  core.String actualService;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  core.String expectedService;

  /// Host portion of the URL.
  core.String host;

  /// Path portion including query parameters in the URL.
  core.String path;

  TestFailure();

  TestFailure.fromJson(core.Map _json) {
    if (_json.containsKey('actualService')) {
      actualService = _json['actualService'] as core.String;
    }
    if (_json.containsKey('expectedService')) {
      expectedService = _json['expectedService'] as core.String;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (actualService != null) {
      _json['actualService'] = actualService;
    }
    if (expectedService != null) {
      _json['expectedService'] = expectedService;
    }
    if (host != null) {
      _json['host'] = host;
    }
    if (path != null) {
      _json['path'] = path;
    }
    return _json;
  }
}

class TestPermissionsRequest {
  /// The set of permissions to check for the 'resource'. Permissions with
  /// wildcards (such as '*' or 'storage.*') are not allowed.
  core.List<core.String> permissions;

  TestPermissionsRequest();

  TestPermissionsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (permissions != null) {
      _json['permissions'] = permissions;
    }
    return _json;
  }
}

class TestPermissionsResponse {
  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  core.List<core.String> permissions;

  TestPermissionsResponse();

  TestPermissionsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (permissions != null) {
      _json['permissions'] = permissions;
    }
    return _json;
  }
}

/// Represents a URL Map resource.
///
/// Google Compute Engine has two URL Map resources:
///
/// * [Global](/compute/docs/reference/rest/{$api_version}/urlMaps) *
/// [Regional](/compute/docs/reference/rest/{$api_version}/regionUrlMaps)
///
/// A URL map resource is a component of certain types of GCP load balancers and
/// Traffic Director.
///
/// * urlMaps are used by external HTTP(S) load balancers and Traffic Director.
/// * regionUrlMaps are used by internal HTTP(S) load balancers.
///
/// For a list of supported URL map features by load balancer type, see the
/// Load balancing features: Routing and traffic management table.
///
/// For a list of supported URL map features for Traffic Director, see the
/// Traffic Director features: Routing and traffic management table.
///
/// This resource defines mappings from host names and URL paths to either a
/// backend service or a backend bucket.
///
/// To use the global urlMaps resource, the backend service must have a
/// loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the
/// regionUrlMaps resource, the backend service must have a loadBalancingScheme
/// of INTERNAL_MANAGED. For more information, read URL Map Concepts.
class UrlMap {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// defaultRouteAction takes effect when none of the  hostRules match. The
  /// load balancer performs advanced routing actions like URL rewrites, header
  /// transformations, etc. prior to forwarding the request to the selected
  /// backend. If defaultRouteAction specifies any weightedBackendServices,
  /// defaultService must not be set. Conversely if defaultService is set,
  /// defaultRouteAction cannot contain any  weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within defaultRouteAction.
  /// defaultRouteAction has no effect when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  HttpRouteAction defaultRouteAction;

  /// The full or partial URL of the defaultService resource to which traffic is
  /// directed if none of the hostRules match. If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified.
  /// Only one of defaultService, defaultUrlRedirect  or
  /// defaultRouteAction.weightedBackendService must be set.
  /// defaultService has no effect when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  core.String defaultService;

  /// When none of the specified hostRules match, the request is redirected to a
  /// URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction defaultUrlRedirect;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// Fingerprint of this resource. A hash of the contents stored in this
  /// object. This field is used in optimistic locking. This field will be
  /// ignored when inserting a UrlMap. An up-to-date fingerprint must be
  /// provided in order to update the UrlMap, otherwise the request will fail
  /// with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a UrlMap.
  core.String fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here take effect after headerAction specified
  /// under pathMatcher.
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction headerAction;

  /// The list of HostRules to use against the URL.
  core.List<HostRule> hostRules;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#urlMaps for url maps.
  core.String kind;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// The list of named PathMatchers to use against the URL.
  core.List<PathMatcher> pathMatchers;

  /// [Output Only] URL of the region where the regional URL map resides. This
  /// field is not applicable to global URL maps. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// The list of expected URL mapping tests. Request to update this UrlMap will
  /// succeed only if all of the test cases pass. You can specify a maximum of
  /// 100 tests per UrlMap.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.List<UrlMapTest> tests;

  UrlMap();

  UrlMap.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultRouteAction')) {
      defaultRouteAction = HttpRouteAction.fromJson(
          _json['defaultRouteAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('defaultService')) {
      defaultService = _json['defaultService'] as core.String;
    }
    if (_json.containsKey('defaultUrlRedirect')) {
      defaultUrlRedirect = HttpRedirectAction.fromJson(
          _json['defaultUrlRedirect'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('hostRules')) {
      hostRules = (_json['hostRules'] as core.List)
          .map<HostRule>((value) =>
              HostRule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('pathMatchers')) {
      pathMatchers = (_json['pathMatchers'] as core.List)
          .map<PathMatcher>((value) => PathMatcher.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('tests')) {
      tests = (_json['tests'] as core.List)
          .map<UrlMapTest>((value) =>
              UrlMapTest.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (defaultRouteAction != null) {
      _json['defaultRouteAction'] = defaultRouteAction.toJson();
    }
    if (defaultService != null) {
      _json['defaultService'] = defaultService;
    }
    if (defaultUrlRedirect != null) {
      _json['defaultUrlRedirect'] = defaultUrlRedirect.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (fingerprint != null) {
      _json['fingerprint'] = fingerprint;
    }
    if (headerAction != null) {
      _json['headerAction'] = headerAction.toJson();
    }
    if (hostRules != null) {
      _json['hostRules'] = hostRules.map((value) => value.toJson()).toList();
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (pathMatchers != null) {
      _json['pathMatchers'] =
          pathMatchers.map((value) => value.toJson()).toList();
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (tests != null) {
      _json['tests'] = tests.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class UrlMapListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapListWarningData();

  UrlMapListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UrlMapListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapListWarning();

  UrlMapListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapListWarningData>((value) => UrlMapListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of UrlMap resources.
class UrlMapList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of UrlMap resources.
  core.List<UrlMap> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UrlMapListWarning warning;

  UrlMapList();

  UrlMapList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<UrlMap>((value) =>
              UrlMap.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class UrlMapReference {
  core.String urlMap;

  UrlMapReference();

  UrlMapReference.fromJson(core.Map _json) {
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (urlMap != null) {
      _json['urlMap'] = urlMap;
    }
    return _json;
  }
}

/// Message for the expected URL mappings.
class UrlMapTest {
  /// Description of this test case.
  core.String description;

  /// Host portion of the URL. If headers contains a host header, then host must
  /// also match the header value.
  core.String host;

  /// Path portion of the URL.
  core.String path;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  /// service cannot be set if expectedRedirectResponseCode is set.
  core.String service;

  UrlMapTest();

  UrlMapTest.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (description != null) {
      _json['description'] = description;
    }
    if (host != null) {
      _json['host'] = host;
    }
    if (path != null) {
      _json['path'] = path;
    }
    if (service != null) {
      _json['service'] = service;
    }
    return _json;
  }
}

/// Message representing the validation result for a UrlMap.
class UrlMapValidationResult {
  core.List<core.String> loadErrors;

  /// Whether the given UrlMap can be successfully loaded. If false,
  /// 'loadErrors' indicates the reasons.
  core.bool loadSucceeded;
  core.List<TestFailure> testFailures;

  /// If successfully loaded, this field indicates whether the test passed. If
  /// false, 'testFailures's indicate the reason of failure.
  core.bool testPassed;

  UrlMapValidationResult();

  UrlMapValidationResult.fromJson(core.Map _json) {
    if (_json.containsKey('loadErrors')) {
      loadErrors = (_json['loadErrors'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('loadSucceeded')) {
      loadSucceeded = _json['loadSucceeded'] as core.bool;
    }
    if (_json.containsKey('testFailures')) {
      testFailures = (_json['testFailures'] as core.List)
          .map<TestFailure>((value) => TestFailure.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('testPassed')) {
      testPassed = _json['testPassed'] as core.bool;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (loadErrors != null) {
      _json['loadErrors'] = loadErrors;
    }
    if (loadSucceeded != null) {
      _json['loadSucceeded'] = loadSucceeded;
    }
    if (testFailures != null) {
      _json['testFailures'] =
          testFailures.map((value) => value.toJson()).toList();
    }
    if (testPassed != null) {
      _json['testPassed'] = testPassed;
    }
    return _json;
  }
}

class UrlMapsAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapsAggregatedListWarningData();

  UrlMapsAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UrlMapsAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapsAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapsAggregatedListWarning();

  UrlMapsAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapsAggregatedListWarningData>((value) =>
              UrlMapsAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class UrlMapsAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of UrlMapsScopedList resources.
  core.Map<core.String, UrlMapsScopedList> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  UrlMapsAggregatedListWarning warning;

  UrlMapsAggregatedList();

  UrlMapsAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              UrlMapsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapsAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class UrlMapsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UrlMapsScopedListWarningData();

  UrlMapsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class UrlMapsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UrlMapsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UrlMapsScopedListWarning();

  UrlMapsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapsScopedListWarningData>((value) =>
              UrlMapsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class UrlMapsScopedList {
  /// A list of UrlMaps contained in this scope.
  core.List<UrlMap> urlMaps;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  UrlMapsScopedListWarning warning;

  UrlMapsScopedList();

  UrlMapsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('urlMaps')) {
      urlMaps = (_json['urlMaps'] as core.List)
          .map<UrlMap>((value) =>
              UrlMap.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (urlMaps != null) {
      _json['urlMaps'] = urlMaps.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class UrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap resource;

  UrlMapsValidateRequest();

  UrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = UrlMap.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (resource != null) {
      _json['resource'] = resource.toJson();
    }
    return _json;
  }
}

class UrlMapsValidateResponse {
  UrlMapValidationResult result;

  UrlMapsValidateResponse();

  UrlMapsValidateResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = UrlMapValidationResult.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (result != null) {
      _json['result'] = result.toJson();
    }
    return _json;
  }
}

/// The spec for modifying the path before sending the request to the matched
/// backend service.
class UrlRewrite {
  /// Prior to forwarding the request to the selected service, the request's
  /// host header is replaced with contents of hostRewrite.
  /// The value must be between 1 and 255 characters.
  core.String hostRewrite;

  /// Prior to forwarding the request to the selected backend service, the
  /// matching portion of the request's path is replaced by pathPrefixRewrite.
  /// The value must be between 1 and 1024 characters.
  core.String pathPrefixRewrite;

  UrlRewrite();

  UrlRewrite.fromJson(core.Map _json) {
    if (_json.containsKey('hostRewrite')) {
      hostRewrite = _json['hostRewrite'] as core.String;
    }
    if (_json.containsKey('pathPrefixRewrite')) {
      pathPrefixRewrite = _json['pathPrefixRewrite'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (hostRewrite != null) {
      _json['hostRewrite'] = hostRewrite;
    }
    if (pathPrefixRewrite != null) {
      _json['pathPrefixRewrite'] = pathPrefixRewrite;
    }
    return _json;
  }
}

/// Subnetwork which the current user has compute.subnetworks.use permission on.
class UsableSubnetwork {
  /// The range of internal addresses that are owned by this subnetwork.
  core.String ipCidrRange;

  /// Network URL.
  core.String network;

  /// Secondary IP ranges.
  core.List<UsableSubnetworkSecondaryRange> secondaryIpRanges;

  /// Subnetwork URL.
  core.String subnetwork;

  UsableSubnetwork();

  UsableSubnetwork.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('secondaryIpRanges')) {
      secondaryIpRanges = (_json['secondaryIpRanges'] as core.List)
          .map<UsableSubnetworkSecondaryRange>((value) =>
              UsableSubnetworkSecondaryRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (secondaryIpRanges != null) {
      _json['secondaryIpRanges'] =
          secondaryIpRanges.map((value) => value.toJson()).toList();
    }
    if (subnetwork != null) {
      _json['subnetwork'] = subnetwork;
    }
    return _json;
  }
}

/// Secondary IP range of a usable subnetwork.
class UsableSubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  core.String ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance. The name must be 1-63 characters long,
  /// and comply with RFC1035. The name must be unique within the subnetwork.
  core.String rangeName;

  UsableSubnetworkSecondaryRange();

  UsableSubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('rangeName')) {
      rangeName = _json['rangeName'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (ipCidrRange != null) {
      _json['ipCidrRange'] = ipCidrRange;
    }
    if (rangeName != null) {
      _json['rangeName'] = rangeName;
    }
    return _json;
  }
}

class UsableSubnetworksAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  UsableSubnetworksAggregatedListWarningData();

  UsableSubnetworksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class UsableSubnetworksAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<UsableSubnetworksAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  UsableSubnetworksAggregatedListWarning();

  UsableSubnetworksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UsableSubnetworksAggregatedListWarningData>((value) =>
              UsableSubnetworksAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class UsableSubnetworksAggregatedList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output] A list of usable subnetwork URLs.
  core.List<UsableSubnetwork> items;

  /// [Output Only] Type of resource. Always
  /// compute#usableSubnetworksAggregatedList for aggregated lists of usable
  /// subnetworks.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  UsableSubnetworksAggregatedListWarning warning;

  UsableSubnetworksAggregatedList();

  UsableSubnetworksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<UsableSubnetwork>((value) => UsableSubnetwork.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = UsableSubnetworksAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// The location in Cloud Storage and naming method of the daily usage report.
/// Contains bucket_name and report_name prefix.
class UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored. The Google Service Account is granted write access to
  /// this bucket. This can either be the bucket name by itself, such as
  /// example-bucket, or the bucket name with gs:// or
  /// https://storage.googleapis.com/ in front of it, such as
  /// gs://example-bucket.
  core.String bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName. If not supplied, defaults to usage. The report is stored as a
  /// CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the
  /// day of the usage according to Pacific Time. If you supply a prefix, it
  /// should conform to Cloud Storage object naming conventions.
  core.String reportNamePrefix;

  UsageExportLocation();

  UsageExportLocation.fromJson(core.Map _json) {
    if (_json.containsKey('bucketName')) {
      bucketName = _json['bucketName'] as core.String;
    }
    if (_json.containsKey('reportNamePrefix')) {
      reportNamePrefix = _json['reportNamePrefix'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bucketName != null) {
      _json['bucketName'] = bucketName;
    }
    if (reportNamePrefix != null) {
      _json['reportNamePrefix'] = reportNamePrefix;
    }
    return _json;
  }
}

/// Contain information of Nat mapping for a VM endpoint (i.e., NIC).
class VmEndpointNatMappings {
  /// Name of the VM instance which the endpoint belongs to
  core.String instanceName;
  core.List<VmEndpointNatMappingsInterfaceNatMappings> interfaceNatMappings;

  VmEndpointNatMappings();

  VmEndpointNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey('instanceName')) {
      instanceName = _json['instanceName'] as core.String;
    }
    if (_json.containsKey('interfaceNatMappings')) {
      interfaceNatMappings = (_json['interfaceNatMappings'] as core.List)
          .map<VmEndpointNatMappingsInterfaceNatMappings>((value) =>
              VmEndpointNatMappingsInterfaceNatMappings.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (instanceName != null) {
      _json['instanceName'] = instanceName;
    }
    if (interfaceNatMappings != null) {
      _json['interfaceNatMappings'] =
          interfaceNatMappings.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// Contain information of Nat mapping for an interface of this endpoint.
class VmEndpointNatMappingsInterfaceNatMappings {
  /// List of all drain IP:port-range mappings assigned to this interface. These
  /// ranges are inclusive, that is, both the first and the last ports can be
  /// used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
  core.List<core.String> drainNatIpPortRanges;

  /// A list of all IP:port-range mappings assigned to this interface. These
  /// ranges are inclusive, that is, both the first and the last ports can be
  /// used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
  core.List<core.String> natIpPortRanges;

  /// Total number of drain ports across all NAT IPs allocated to this
  /// interface. It equals to the aggregated port number in the field
  /// drain_nat_ip_port_ranges.
  core.int numTotalDrainNatPorts;

  /// Total number of ports across all NAT IPs allocated to this interface. It
  /// equals to the aggregated port number in the field nat_ip_port_ranges.
  core.int numTotalNatPorts;

  /// Alias IP range for this interface endpoint. It will be a private (RFC
  /// 1918) IP range. Examples: "10.33.4.55/32", or "192.168.5.0/24".
  core.String sourceAliasIpRange;

  /// Primary IP of the VM for this NIC.
  core.String sourceVirtualIp;

  VmEndpointNatMappingsInterfaceNatMappings();

  VmEndpointNatMappingsInterfaceNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey('drainNatIpPortRanges')) {
      drainNatIpPortRanges = (_json['drainNatIpPortRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('natIpPortRanges')) {
      natIpPortRanges = (_json['natIpPortRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('numTotalDrainNatPorts')) {
      numTotalDrainNatPorts = _json['numTotalDrainNatPorts'] as core.int;
    }
    if (_json.containsKey('numTotalNatPorts')) {
      numTotalNatPorts = _json['numTotalNatPorts'] as core.int;
    }
    if (_json.containsKey('sourceAliasIpRange')) {
      sourceAliasIpRange = _json['sourceAliasIpRange'] as core.String;
    }
    if (_json.containsKey('sourceVirtualIp')) {
      sourceVirtualIp = _json['sourceVirtualIp'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (drainNatIpPortRanges != null) {
      _json['drainNatIpPortRanges'] = drainNatIpPortRanges;
    }
    if (natIpPortRanges != null) {
      _json['natIpPortRanges'] = natIpPortRanges;
    }
    if (numTotalDrainNatPorts != null) {
      _json['numTotalDrainNatPorts'] = numTotalDrainNatPorts;
    }
    if (numTotalNatPorts != null) {
      _json['numTotalNatPorts'] = numTotalNatPorts;
    }
    if (sourceAliasIpRange != null) {
      _json['sourceAliasIpRange'] = sourceAliasIpRange;
    }
    if (sourceVirtualIp != null) {
      _json['sourceVirtualIp'] = sourceVirtualIp;
    }
    return _json;
  }
}

class VmEndpointNatMappingsListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VmEndpointNatMappingsListWarningData();

  VmEndpointNatMappingsListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VmEndpointNatMappingsListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VmEndpointNatMappingsListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VmEndpointNatMappingsListWarning();

  VmEndpointNatMappingsListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VmEndpointNatMappingsListWarningData>((value) =>
              VmEndpointNatMappingsListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of VmEndpointNatMappings.
class VmEndpointNatMappingsList {
  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#vmEndpointNatMappingsList
  /// for lists of Nat mappings of VM endpoints.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] A list of Nat mapping information of VM endpoints.
  core.List<VmEndpointNatMappings> result;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VmEndpointNatMappingsListWarning warning;

  VmEndpointNatMappingsList();

  VmEndpointNatMappingsList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('result')) {
      result = (_json['result'] as core.List)
          .map<VmEndpointNatMappings>((value) => VmEndpointNatMappings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VmEndpointNatMappingsListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (result != null) {
      _json['result'] = result.map((value) => value.toJson()).toList();
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a HA VPN gateway.
///
/// HA VPN is a high-availability (HA) Cloud VPN solution that lets you securely
/// connect your on-premises network to your Google Cloud Virtual Private Cloud
/// network through an IPsec VPN connection in a single region. For more
/// information about Cloud HA VPN solutions, see  Cloud VPN topologies . (==
/// resource_for {$api_version}.vpnGateways ==)
class VpnGateway {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// A fingerprint for the labels being applied to this VpnGateway, which is
  /// essentially a hash of the labels set used for optimistic locking. The
  /// fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// VpnGateway.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource. These can only be added or modified by the
  /// setLabels method. Each label key/value pair must comply with RFC1035.
  /// Label values may be empty.
  core.Map<core.String, core.String> labels;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the network to which this VPN gateway is attached. Provided by the
  /// client when the VPN gateway is created.
  core.String network;

  /// [Output Only] URL of the region where the VPN gateway resides.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// A list of interfaces on this VPN gateway.
  core.List<VpnGatewayVpnGatewayInterface> vpnInterfaces;

  VpnGateway();

  VpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('vpnInterfaces')) {
      vpnInterfaces = (_json['vpnInterfaces'] as core.List)
          .map<VpnGatewayVpnGatewayInterface>((value) =>
              VpnGatewayVpnGatewayInterface.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (network != null) {
      _json['network'] = network;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (vpnInterfaces != null) {
      _json['vpnInterfaces'] =
          vpnInterfaces.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

class VpnGatewayAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewayAggregatedListWarningData();

  VpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnGatewayAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewayAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewayAggregatedListWarning();

  VpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewayAggregatedListWarningData>((value) =>
              VpnGatewayAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class VpnGatewayAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnGateway resources.
  core.Map<core.String, VpnGatewaysScopedList> items;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  VpnGatewayAggregatedListWarning warning;

  VpnGatewayAggregatedList();

  VpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              VpnGatewaysScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewayAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class VpnGatewayListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewayListWarningData();

  VpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnGatewayListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewayListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewayListWarning();

  VpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewayListWarningData>((value) =>
              VpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of VpnGateway resources.
class VpnGatewayList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnGateway resources.
  core.List<VpnGateway> items;

  /// [Output Only] Type of resource. Always compute#vpnGateway for VPN
  /// gateways.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnGatewayListWarning warning;

  VpnGatewayList();

  VpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<VpnGateway>((value) =>
              VpnGateway.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class VpnGatewayStatus {
  /// List of VPN connection for this VpnGateway.
  core.List<VpnGatewayStatusVpnConnection> vpnConnections;

  VpnGatewayStatus();

  VpnGatewayStatus.fromJson(core.Map _json) {
    if (_json.containsKey('vpnConnections')) {
      vpnConnections = (_json['vpnConnections'] as core.List)
          .map<VpnGatewayStatusVpnConnection>((value) =>
              VpnGatewayStatusVpnConnection.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (vpnConnections != null) {
      _json['vpnConnections'] =
          vpnConnections.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// Describes the high availability requirement state for the VPN connection
/// between this Cloud VPN gateway and a peer gateway.
class VpnGatewayStatusHighAvailabilityRequirementState {
  /// Indicates the high availability requirement state for the VPN connection.
  /// Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
  /// Possible string values are:
  /// - "CONNECTION_REDUNDANCY_MET"
  /// - "CONNECTION_REDUNDANCY_NOT_MET"
  core.String state;

  /// Indicates the reason why the VPN connection does not meet the high
  /// availability redundancy criteria/requirement. Valid values is
  /// INCOMPLETE_TUNNELS_COVERAGE.
  /// Possible string values are:
  /// - "INCOMPLETE_TUNNELS_COVERAGE"
  core.String unsatisfiedReason;

  VpnGatewayStatusHighAvailabilityRequirementState();

  VpnGatewayStatusHighAvailabilityRequirementState.fromJson(core.Map _json) {
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('unsatisfiedReason')) {
      unsatisfiedReason = _json['unsatisfiedReason'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (state != null) {
      _json['state'] = state;
    }
    if (unsatisfiedReason != null) {
      _json['unsatisfiedReason'] = unsatisfiedReason;
    }
    return _json;
  }
}

/// Contains some information about a VPN tunnel.
class VpnGatewayStatusTunnel {
  /// The VPN gateway interface this VPN tunnel is associated with.
  core.int localGatewayInterface;

  /// The peer gateway interface this VPN tunnel is connected to, the peer
  /// gateway could either be an external VPN gateway or GCP VPN gateway.
  core.int peerGatewayInterface;

  /// URL reference to the VPN tunnel.
  core.String tunnelUrl;

  VpnGatewayStatusTunnel();

  VpnGatewayStatusTunnel.fromJson(core.Map _json) {
    if (_json.containsKey('localGatewayInterface')) {
      localGatewayInterface = _json['localGatewayInterface'] as core.int;
    }
    if (_json.containsKey('peerGatewayInterface')) {
      peerGatewayInterface = _json['peerGatewayInterface'] as core.int;
    }
    if (_json.containsKey('tunnelUrl')) {
      tunnelUrl = _json['tunnelUrl'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (localGatewayInterface != null) {
      _json['localGatewayInterface'] = localGatewayInterface;
    }
    if (peerGatewayInterface != null) {
      _json['peerGatewayInterface'] = peerGatewayInterface;
    }
    if (tunnelUrl != null) {
      _json['tunnelUrl'] = tunnelUrl;
    }
    return _json;
  }
}

/// A VPN connection contains all VPN tunnels connected from this VpnGateway to
/// the same peer gateway. The peer gateway could either be a external VPN
/// gateway or GCP VPN gateway.
class VpnGatewayStatusVpnConnection {
  /// URL reference to the peer external VPN gateways to which the VPN tunnels
  /// in this VPN connection are connected. This field is mutually exclusive
  /// with peer_gcp_gateway.
  core.String peerExternalGateway;

  /// URL reference to the peer side VPN gateways to which the VPN tunnels in
  /// this VPN connection are connected. This field is mutually exclusive with
  /// peer_gcp_gateway.
  core.String peerGcpGateway;

  /// HighAvailabilityRequirementState for the VPN connection.
  VpnGatewayStatusHighAvailabilityRequirementState state;

  /// List of VPN tunnels that are in this VPN connection.
  core.List<VpnGatewayStatusTunnel> tunnels;

  VpnGatewayStatusVpnConnection();

  VpnGatewayStatusVpnConnection.fromJson(core.Map _json) {
    if (_json.containsKey('peerExternalGateway')) {
      peerExternalGateway = _json['peerExternalGateway'] as core.String;
    }
    if (_json.containsKey('peerGcpGateway')) {
      peerGcpGateway = _json['peerGcpGateway'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = VpnGatewayStatusHighAvailabilityRequirementState.fromJson(
          _json['state'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tunnels')) {
      tunnels = (_json['tunnels'] as core.List)
          .map<VpnGatewayStatusTunnel>((value) =>
              VpnGatewayStatusTunnel.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (peerExternalGateway != null) {
      _json['peerExternalGateway'] = peerExternalGateway;
    }
    if (peerGcpGateway != null) {
      _json['peerGcpGateway'] = peerGcpGateway;
    }
    if (state != null) {
      _json['state'] = state.toJson();
    }
    if (tunnels != null) {
      _json['tunnels'] = tunnels.map((value) => value.toJson()).toList();
    }
    return _json;
  }
}

/// A VPN gateway interface.
class VpnGatewayVpnGatewayInterface {
  /// The numeric ID of this VPN gateway interface.
  core.int id;

  /// [Output Only] The external IP address for this VPN gateway interface.
  core.String ipAddress;

  VpnGatewayVpnGatewayInterface();

  VpnGatewayVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.int;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (ipAddress != null) {
      _json['ipAddress'] = ipAddress;
    }
    return _json;
  }
}

class VpnGatewaysGetStatusResponse {
  VpnGatewayStatus result;

  VpnGatewaysGetStatusResponse();

  VpnGatewaysGetStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = VpnGatewayStatus.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (result != null) {
      _json['result'] = result.toJson();
    }
    return _json;
  }
}

class VpnGatewaysScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnGatewaysScopedListWarningData();

  VpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning which replaces the list of addresses
/// when the list is empty.
class VpnGatewaysScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnGatewaysScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnGatewaysScopedListWarning();

  VpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewaysScopedListWarningData>((value) =>
              VpnGatewaysScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class VpnGatewaysScopedList {
  /// [Output Only] A list of VPN gateways contained in this scope.
  core.List<VpnGateway> vpnGateways;

  /// [Output Only] Informational warning which replaces the list of addresses
  /// when the list is empty.
  VpnGatewaysScopedListWarning warning;

  VpnGatewaysScopedList();

  VpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('vpnGateways')) {
      vpnGateways = (_json['vpnGateways'] as core.List)
          .map<VpnGateway>((value) =>
              VpnGateway.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewaysScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (vpnGateways != null) {
      _json['vpnGateways'] =
          vpnGateways.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Represents a Cloud VPN Tunnel resource.
///
/// For more information about VPN, read the  the Cloud VPN Overview. (==
/// resource_for {$api_version}.vpnTunnels ==)
class VpnTunnel {
  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// An optional description of this resource. Provide this property when you
  /// create the resource.
  core.String description;

  /// [Output Only] Detailed status message for the VPN tunnel.
  core.String detailedStatus;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// IKE protocol version to use when establishing the VPN tunnel with the peer
  /// VPN gateway. Acceptable IKE versions are 1 or 2. The default version is 2.
  core.int ikeVersion;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// Local traffic selector to use when establishing the VPN tunnel with the
  /// peer VPN gateway. The value should be a CIDR formatted string, for
  /// example: 192.168.0.0/16. The ranges must be disjoint. Only IPv4 is
  /// supported.
  core.List<core.String> localTrafficSelector;

  /// Name of the resource. Provided by the client when the resource is created.
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String name;

  /// URL of the peer side external VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created. This
  /// field is exclusive with the field peerGcpGateway.
  core.String peerExternalGateway;

  /// The interface ID of the external VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created.
  core.int peerExternalGatewayInterface;

  /// URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
  /// connected. Provided by the client when the VPN tunnel is created. This
  /// field can be used when creating highly available VPN from VPC network to
  /// VPC network, the field is exclusive with the field peerExternalGateway. If
  /// provided, the VPN tunnel will automatically use the same
  /// vpnGatewayInterface ID in the peer GCP VPN gateway.
  core.String peerGcpGateway;

  /// IP address of the peer VPN gateway. Only IPv4 is supported.
  core.String peerIp;

  /// [Output Only] URL of the region where the VPN tunnel resides. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  core.String region;

  /// Remote traffic selectors to use when establishing the VPN tunnel with the
  /// peer VPN gateway. The value should be a CIDR formatted string, for
  /// example: 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is
  /// supported.
  core.List<core.String> remoteTrafficSelector;

  /// URL of the router resource to be used for dynamic routing.
  core.String router;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// Shared secret used to set the secure session between the Cloud VPN gateway
  /// and the peer VPN gateway.
  core.String sharedSecret;

  /// Hash of the shared secret.
  core.String sharedSecretHash;

  /// [Output Only] The status of the VPN tunnel, which can be one of the
  /// following:
  /// - PROVISIONING: Resource is being allocated for the VPN tunnel.
  /// - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from
  /// the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route
  /// resources are needed to setup the VPN tunnel.
  /// - FIRST_HANDSHAKE: Successful first handshake with the peer VPN.
  /// - ESTABLISHED: Secure session is successfully established with the peer
  /// VPN.
  /// - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS
  /// - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret).
  /// - NEGOTIATION_FAILURE: Handshake failed.
  /// - DEPROVISIONING: Resources are being deallocated for the VPN tunnel.
  /// - FAILED: Tunnel creation has failed and the tunnel is not ready to be
  /// used.
  /// - NO_INCOMING_PACKETS: No incoming packets from peer.
  /// - REJECTED: Tunnel configuration was rejected, can be result of being
  /// blacklisted.
  /// - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all
  /// required resources.
  /// - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for
  /// Classic VPN tunnels or the project is in frozen state.
  /// - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably
  /// behind NAT.
  /// - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an
  /// HA-VPN tunnel.
  /// Possible string values are:
  /// - "ALLOCATING_RESOURCES"
  /// - "AUTHORIZATION_ERROR"
  /// - "DEPROVISIONING"
  /// - "ESTABLISHED"
  /// - "FAILED"
  /// - "FIRST_HANDSHAKE"
  /// - "NEGOTIATION_FAILURE"
  /// - "NETWORK_ERROR"
  /// - "NO_INCOMING_PACKETS"
  /// - "PROVISIONING"
  /// - "REJECTED"
  /// - "STOPPED"
  /// - "WAITING_FOR_FULL_CONFIG"
  core.String status;

  /// URL of the Target VPN gateway with which this VPN tunnel is associated.
  /// Provided by the client when the VPN tunnel is created.
  core.String targetVpnGateway;

  /// URL of the VPN gateway with which this VPN tunnel is associated. Provided
  /// by the client when the VPN tunnel is created. This must be used (instead
  /// of target_vpn_gateway) if a High Availability VPN gateway resource is
  /// created.
  core.String vpnGateway;

  /// The interface ID of the VPN gateway with which this VPN tunnel is
  /// associated.
  core.int vpnGatewayInterface;

  VpnTunnel();

  VpnTunnel.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('detailedStatus')) {
      detailedStatus = _json['detailedStatus'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ikeVersion')) {
      ikeVersion = _json['ikeVersion'] as core.int;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('localTrafficSelector')) {
      localTrafficSelector = (_json['localTrafficSelector'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerExternalGateway')) {
      peerExternalGateway = _json['peerExternalGateway'] as core.String;
    }
    if (_json.containsKey('peerExternalGatewayInterface')) {
      peerExternalGatewayInterface =
          _json['peerExternalGatewayInterface'] as core.int;
    }
    if (_json.containsKey('peerGcpGateway')) {
      peerGcpGateway = _json['peerGcpGateway'] as core.String;
    }
    if (_json.containsKey('peerIp')) {
      peerIp = _json['peerIp'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('remoteTrafficSelector')) {
      remoteTrafficSelector = (_json['remoteTrafficSelector'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('router')) {
      router = _json['router'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sharedSecret')) {
      sharedSecret = _json['sharedSecret'] as core.String;
    }
    if (_json.containsKey('sharedSecretHash')) {
      sharedSecretHash = _json['sharedSecretHash'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('targetVpnGateway')) {
      targetVpnGateway = _json['targetVpnGateway'] as core.String;
    }
    if (_json.containsKey('vpnGateway')) {
      vpnGateway = _json['vpnGateway'] as core.String;
    }
    if (_json.containsKey('vpnGatewayInterface')) {
      vpnGatewayInterface = _json['vpnGatewayInterface'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (detailedStatus != null) {
      _json['detailedStatus'] = detailedStatus;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (ikeVersion != null) {
      _json['ikeVersion'] = ikeVersion;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (localTrafficSelector != null) {
      _json['localTrafficSelector'] = localTrafficSelector;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (peerExternalGateway != null) {
      _json['peerExternalGateway'] = peerExternalGateway;
    }
    if (peerExternalGatewayInterface != null) {
      _json['peerExternalGatewayInterface'] = peerExternalGatewayInterface;
    }
    if (peerGcpGateway != null) {
      _json['peerGcpGateway'] = peerGcpGateway;
    }
    if (peerIp != null) {
      _json['peerIp'] = peerIp;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (remoteTrafficSelector != null) {
      _json['remoteTrafficSelector'] = remoteTrafficSelector;
    }
    if (router != null) {
      _json['router'] = router;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (sharedSecret != null) {
      _json['sharedSecret'] = sharedSecret;
    }
    if (sharedSecretHash != null) {
      _json['sharedSecretHash'] = sharedSecretHash;
    }
    if (status != null) {
      _json['status'] = status;
    }
    if (targetVpnGateway != null) {
      _json['targetVpnGateway'] = targetVpnGateway;
    }
    if (vpnGateway != null) {
      _json['vpnGateway'] = vpnGateway;
    }
    if (vpnGatewayInterface != null) {
      _json['vpnGatewayInterface'] = vpnGatewayInterface;
    }
    return _json;
  }
}

class VpnTunnelAggregatedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelAggregatedListWarningData();

  VpnTunnelAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelAggregatedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelAggregatedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelAggregatedListWarning();

  VpnTunnelAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelAggregatedListWarningData>((value) =>
              VpnTunnelAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class VpnTunnelAggregatedList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnelsScopedList resources.
  core.Map<core.String, VpnTunnelsScopedList> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Unreachable resources.
  core.List<core.String> unreachables;

  /// [Output Only] Informational warning message.
  VpnTunnelAggregatedListWarning warning;

  VpnTunnelAggregatedList();

  VpnTunnelAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map).cast<core.String, core.Map>().map(
            (key, item) => core.MapEntry(
              key,
              VpnTunnelsScopedList.fromJson(
                  item as core.Map<core.String, core.dynamic>),
            ),
          );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] =
          items.map((key, item) => core.MapEntry(key, item.toJson()));
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (unreachables != null) {
      _json['unreachables'] = unreachables;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class VpnTunnelListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelListWarningData();

  VpnTunnelListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class VpnTunnelListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelListWarning();

  VpnTunnelListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelListWarningData>((value) =>
              VpnTunnelListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of VpnTunnel resources.
class VpnTunnelList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of VpnTunnel resources.
  core.List<VpnTunnel> items;

  /// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  VpnTunnelListWarning warning;

  VpnTunnelList();

  VpnTunnelList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<VpnTunnel>((value) =>
              VpnTunnel.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class VpnTunnelsScopedListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  VpnTunnelsScopedListWarningData();

  VpnTunnelsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class VpnTunnelsScopedListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<VpnTunnelsScopedListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  VpnTunnelsScopedListWarning();

  VpnTunnelsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelsScopedListWarningData>((value) =>
              VpnTunnelsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class VpnTunnelsScopedList {
  /// A list of VPN tunnels contained in this scope.
  core.List<VpnTunnel> vpnTunnels;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  VpnTunnelsScopedListWarning warning;

  VpnTunnelsScopedList();

  VpnTunnelsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('vpnTunnels')) {
      vpnTunnels = (_json['vpnTunnels'] as core.List)
          .map<VpnTunnel>((value) =>
              VpnTunnel.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (vpnTunnels != null) {
      _json['vpnTunnels'] = vpnTunnels.map((value) => value.toJson()).toList();
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class WafExpressionSet {
  /// A list of alternate IDs. The format should be: - E.g. XSS-stable Generic
  /// suffix like "stable" is particularly useful if a policy likes to avail
  /// newer set of expressions without having to change the policy. A given
  /// alias name can't be used for more than one entity set.
  core.List<core.String> aliases;

  /// List of available expressions.
  core.List<WafExpressionSetExpression> expressions;

  /// Google specified expression set ID. The format should be: - E.g.
  /// XSS-20170329
  core.String id;

  WafExpressionSet();

  WafExpressionSet.fromJson(core.Map _json) {
    if (_json.containsKey('aliases')) {
      aliases = (_json['aliases'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('expressions')) {
      expressions = (_json['expressions'] as core.List)
          .map<WafExpressionSetExpression>((value) =>
              WafExpressionSetExpression.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (aliases != null) {
      _json['aliases'] = aliases;
    }
    if (expressions != null) {
      _json['expressions'] =
          expressions.map((value) => value.toJson()).toList();
    }
    if (id != null) {
      _json['id'] = id;
    }
    return _json;
  }
}

class WafExpressionSetExpression {
  /// Expression ID should uniquely identify the origin of the expression. E.g.
  /// owasp-crs-v020901-id973337 identifies Owasp core rule set version 2.9.1
  /// rule id 973337. The ID could be used to determine the individual attack
  /// definition that has been detected. It could also be used to exclude it
  /// from the policy in case of false positive.
  core.String id;

  WafExpressionSetExpression();

  WafExpressionSetExpression.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    return _json;
  }
}

/// In contrast to a single BackendService in  HttpRouteAction to which all
/// matching traffic is directed to, WeightedBackendService allows traffic to be
/// split across multiple BackendServices. The volume of traffic for each
/// BackendService is proportional to the weight specified in each
/// WeightedBackendService
class WeightedBackendService {
  /// The full or partial URL to the default BackendService resource. Before
  /// forwarding the request to backendService, the loadbalancer applies any
  /// relevant headerActions specified as part of this backendServiceWeight.
  core.String backendService;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// headerAction specified here take effect before headerAction in the
  /// enclosing HttpRouteRule, PathMatcher and UrlMap.
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction headerAction;

  /// Specifies the fraction of traffic sent to backendService, computed as
  /// weight / (sum of all weightedBackendService weights in routeAction) .
  /// The selection of a backend service is determined only for new traffic.
  /// Once a user's request has been directed to a backendService, subsequent
  /// requests will be sent to the same backendService as determined by the
  /// BackendService's session affinity policy.
  /// The value must be between 0 and 1000
  core.int weight;

  WeightedBackendService();

  WeightedBackendService.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weight')) {
      weight = _json['weight'] as core.int;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (backendService != null) {
      _json['backendService'] = backendService;
    }
    if (headerAction != null) {
      _json['headerAction'] = headerAction.toJson();
    }
    if (weight != null) {
      _json['weight'] = weight;
    }
    return _json;
  }
}

class XpnHostListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  XpnHostListWarningData();

  XpnHostListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class XpnHostListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<XpnHostListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  XpnHostListWarning();

  XpnHostListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<XpnHostListWarningData>((value) =>
              XpnHostListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

class XpnHostList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// [Output Only] A list of shared VPC host project URLs.
  core.List<Project> items;

  /// [Output Only] Type of resource. Always compute#xpnHostList for lists of
  /// shared VPC hosts.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  XpnHostListWarning warning;

  XpnHostList();

  XpnHostList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Project>((value) =>
              Project.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = XpnHostListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

/// Service resource (a.k.a service project) ID.
class XpnResourceId {
  /// The ID of the service resource. In the case of projects, this field
  /// supports project id (e.g., my-project-123) and project number (e.g.
  /// 12345678).
  core.String id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String type;

  XpnResourceId();

  XpnResourceId.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (type != null) {
      _json['type'] = type;
    }
    return _json;
  }
}

/// Represents a Zone resource.
///
/// A zone is a deployment area. These deployment areas are subsets of a region.
/// For example the zone us-east1-a is located in the us-east1 region. For more
/// information, read Regions and Zones. (== resource_for {$api_version}.zones
/// ==)
class Zone {
  /// [Output Only] Available cpu/platform selections for the zone.
  core.List<core.String> availableCpuPlatforms;

  /// [Output Only] Creation timestamp in RFC3339 text format.
  core.String creationTimestamp;

  /// [Output Only] The deprecation status associated with this zone.
  DeprecationStatus deprecated;

  /// [Output Only] Textual description of the resource.
  core.String description;

  /// [Output Only] The unique identifier for the resource. This identifier is
  /// defined by the server.
  core.String id;

  /// [Output Only] Type of the resource. Always compute#zone for zones.
  core.String kind;

  /// [Output Only] Name of the resource.
  core.String name;

  /// [Output Only] Full URL reference to the region which hosts the zone.
  core.String region;

  /// [Output Only] Server-defined URL for the resource.
  core.String selfLink;

  /// [Output Only] Status of the zone, either UP or DOWN.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String status;

  Zone();

  Zone.fromJson(core.Map _json) {
    if (_json.containsKey('availableCpuPlatforms')) {
      availableCpuPlatforms = (_json['availableCpuPlatforms'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (availableCpuPlatforms != null) {
      _json['availableCpuPlatforms'] = availableCpuPlatforms;
    }
    if (creationTimestamp != null) {
      _json['creationTimestamp'] = creationTimestamp;
    }
    if (deprecated != null) {
      _json['deprecated'] = deprecated.toJson();
    }
    if (description != null) {
      _json['description'] = description;
    }
    if (id != null) {
      _json['id'] = id;
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (name != null) {
      _json['name'] = name;
    }
    if (region != null) {
      _json['region'] = region;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (status != null) {
      _json['status'] = status;
    }
    return _json;
  }
}

class ZoneListWarningData {
  /// [Output Only] A key that provides more detail on the warning being
  /// returned. For example, for warnings where there are no results in a list
  /// request for a particular zone, this key might be scope and the key value
  /// might be the zone name. Other examples might be a key indicating a
  /// deprecated resource and a suggested replacement, or a warning about
  /// invalid network settings (for example, if an instance attempts to perform
  /// IP forwarding but is not enabled for IP forwarding).
  core.String key;

  /// [Output Only] A warning data value corresponding to the key.
  core.String value;

  ZoneListWarningData();

  ZoneListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (key != null) {
      _json['key'] = key;
    }
    if (value != null) {
      _json['value'] = value;
    }
    return _json;
  }
}

/// [Output Only] Informational warning message.
class ZoneListWarning {
  /// [Output Only] A warning code, if applicable. For example, Compute Engine
  /// returns NO_RESULTS_ON_PAGE if there are no results in the response.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String code;

  /// [Output Only] Metadata about this warning in key: value format. For
  /// example:
  /// "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  core.List<ZoneListWarningData> data;

  /// [Output Only] A human-readable description of the warning code.
  core.String message;

  ZoneListWarning();

  ZoneListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ZoneListWarningData>((value) => ZoneListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (code != null) {
      _json['code'] = code;
    }
    if (data != null) {
      _json['data'] = data.map((value) => value.toJson()).toList();
    }
    if (message != null) {
      _json['message'] = message;
    }
    return _json;
  }
}

/// Contains a list of zone resources.
class ZoneList {
  /// [Output Only] Unique identifier for the resource; defined by the server.
  core.String id;

  /// A list of Zone resources.
  core.List<Zone> items;

  /// Type of resource.
  core.String kind;

  /// [Output Only] This token allows you to get the next page of results for
  /// list requests. If the number of results is larger than maxResults, use the
  /// nextPageToken as a value for the query parameter pageToken in the next
  /// list request. Subsequent list requests will have their own nextPageToken
  /// to continue paging through the results.
  core.String nextPageToken;

  /// [Output Only] Server-defined URL for this resource.
  core.String selfLink;

  /// [Output Only] Informational warning message.
  ZoneListWarning warning;

  ZoneList();

  ZoneList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Zone>((value) =>
              Zone.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ZoneListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (id != null) {
      _json['id'] = id;
    }
    if (items != null) {
      _json['items'] = items.map((value) => value.toJson()).toList();
    }
    if (kind != null) {
      _json['kind'] = kind;
    }
    if (nextPageToken != null) {
      _json['nextPageToken'] = nextPageToken;
    }
    if (selfLink != null) {
      _json['selfLink'] = selfLink;
    }
    if (warning != null) {
      _json['warning'] = warning.toJson();
    }
    return _json;
  }
}

class ZoneSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts. The fingerprint is initially generated by Compute Engine
  /// and changes after every request to modify or update labels. You must
  /// always provide an up-to-date fingerprint hash in order to update or change
  /// labels. Make a get() request to the resource to get the latest
  /// fingerprint.
  core.String labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String> labels;

  ZoneSetLabelsRequest();

  ZoneSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels =
          (_json['labels'] as core.Map).cast<core.String, core.String>().map(
                (key, item) => core.MapEntry(
                  key,
                  item as core.String,
                ),
              );
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (labelFingerprint != null) {
      _json['labelFingerprint'] = labelFingerprint;
    }
    if (labels != null) {
      _json['labels'] = labels;
    }
    return _json;
  }
}

class ZoneSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format. Deprecated.
  /// Use 'policy' to specify bindings.
  core.List<Binding> bindings;

  /// Flatten Policy to create a backward compatible wire-format. Deprecated.
  /// Use 'policy' to specify the etag.
  core.String etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is in general a
  /// valid policy but certain services (like Projects) might reject them.
  Policy policy;

  ZoneSetPolicyRequest();

  ZoneSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.Object> toJson() {
    final _json = <core.String, core.Object>{};
    if (bindings != null) {
      _json['bindings'] = bindings.map((value) => value.toJson()).toList();
    }
    if (etag != null) {
      _json['etag'] = etag;
    }
    if (policy != null) {
      _json['policy'] = policy.toJson();
    }
    return _json;
  }
}
